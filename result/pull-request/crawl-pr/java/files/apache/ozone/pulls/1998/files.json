[
  {
    "sha": "fbf921a02df6d48ad2e3b0756dd7e57a0b8d18f7",
    "filename": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java",
    "status": "modified",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -31,6 +31,7 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.Queue;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.apache.hadoop.ozone.common.Storage;\n@@ -50,6 +51,8 @@\n \n   private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n   protected boolean isDone = false;\n+  private Callable<Boolean> injectTestFunction;\n+  private UpgradeTestInjectionPoints testInjectionPoint;\n \n   public BasicUpgradeFinalizer(V versionManager) {\n     this.versionManager = versionManager;\n@@ -303,4 +306,26 @@ private void logAndThrow(Exception e, String msg, ResultCodes resultCode)\n     LOG.error(msg, e);\n     throw new UpgradeException(msg, e, resultCode);\n   }\n+\n+  @Override\n+  public void configureTestInjectionFunction(\n+      UpgradeTestInjectionPoints pointIndex,\n+      Callable<Boolean> injectedTestFunction) {\n+    injectTestFunction = injectedTestFunction;\n+    testInjectionPoint = pointIndex;\n+  }\n+\n+  @Override\n+  public Boolean injectTestFunctionAtThisPoint(\n+      UpgradeTestInjectionPoints pointIndex) throws Exception {\n+    if ((testInjectionPoint != null) &&\n+        (pointIndex.getValue() == testInjectionPoint.getValue())) {\n+      if (injectTestFunction != null) {\n+        if (injectTestFunction.call()) {\n+          throw new UpgradeTestInjectionAbort();\n+        }\n+      }\n+    }\n+    return false;\n+  }\n }"
  },
  {
    "sha": "16004c418b5edd304cf9dc0301a886b9b1ee5738",
    "filename": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/UpgradeFinalizer.java",
    "status": "modified",
    "additions": 42,
    "deletions": 1,
    "changes": 43,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/UpgradeFinalizer.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/UpgradeFinalizer.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/UpgradeFinalizer.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -27,6 +27,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.concurrent.Callable;\n \n /**\n  * Interface to define the upgrade finalizer implementations.\n@@ -43,6 +44,28 @@\n @InterfaceStability.Evolving\n public interface UpgradeFinalizer<T> {\n \n+  enum UpgradeTestInjectionPoints {\n+    BeforePreFinalizeUpgrade(1),\n+    AfterPreFinalizeUpgrade(2),\n+    BeforeCompleteFinalization(3),\n+    AfterCompleteFinalization(4),\n+    AfterPostFinalizeUpgrade(5);\n+\n+    private int val;\n+    UpgradeTestInjectionPoints(int value) {\n+      val = value;\n+    }\n+\n+    public int getValue() {\n+      return val;\n+    }\n+  }\n+\n+  class UpgradeTestInjectionAbort extends Exception {\n+    public UpgradeTestInjectionAbort() {\n+    }\n+  }\n+\n   Logger LOG = LoggerFactory.getLogger(UpgradeFinalizer.class);\n \n   /**\n@@ -63,7 +86,7 @@\n     STARTING_FINALIZATION,\n     FINALIZATION_IN_PROGRESS,\n     FINALIZATION_DONE,\n-    FINALIZATION_REQUIRED\n+    FINALIZATION_REQUIRED,\n   }\n \n   /**\n@@ -167,4 +190,22 @@ StatusAndMessages finalize(String upgradeClientID, T service)\n   StatusAndMessages reportStatus(String upgradeClientId, boolean takeover)\n       throws IOException;\n \n+  /**\n+   * Interface to inject arbitrary failures for stress testing.\n+   * @param InjectTestFunction function that will be called\n+   *        code execution reached injectTestFunctionAtThisPoint() location.\n+   * @param pointIndex code execution point for a given thread.\n+   */\n+  void configureTestInjectionFunction(UpgradeTestInjectionPoints pointIndex,\n+                                      Callable<Boolean> injectTestFunction);\n+\n+  /**\n+   * Interface to inject error at a given point in an upgrade thread.\n+   * @param pointIndex TestFunction Injection point in an upgrade thread.\n+   * @return \"true\" if the calling thread should not continue with further\n+   *          upgrade processing, \"false\" otherwise.\n+   */\n+  Boolean injectTestFunctionAtThisPoint(UpgradeTestInjectionPoints pointIndex)\n+      throws Exception;\n+\n }"
  },
  {
    "sha": "6c2965b24c8d722928afac8e3418521ee5071dd0",
    "filename": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/DatanodeStateMachine.java",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/DatanodeStateMachine.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/DatanodeStateMachine.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/DatanodeStateMachine.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -62,6 +62,7 @@\n import org.apache.hadoop.ozone.container.upgrade.DataNodeUpgradeFinalizer;\n import org.apache.hadoop.ozone.container.upgrade.DatanodeMetadataFeatures;\n import org.apache.hadoop.ozone.protocol.commands.SCMCommand;\n+import org.apache.hadoop.ozone.upgrade.UpgradeFinalizer;\n import org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.StatusAndMessages;\n import org.apache.hadoop.util.JvmPauseMonitor;\n import org.apache.hadoop.util.Time;\n@@ -604,7 +605,7 @@ public DatanodeLayoutStorage getLayoutStorage() {\n   }\n \n   @VisibleForTesting\n-  public boolean canFinalizeDataNode() {\n+  private boolean canFinalizeDataNode() {\n     // Lets be sure that we do not have any open container before we return\n     // from here. This function should be called in its own finalizer thread\n     // context.\n@@ -616,6 +617,8 @@ public boolean canFinalizeDataNode() {\n       case OPEN:\n       case CLOSING:\n       case UNHEALTHY:\n+        LOG.warn(\"FinalizeUpgrade : Waiting for container to close, current \" +\n+            \"state is: {}\", ctr.getContainerState());\n         return false;\n       default:\n         continue;\n@@ -645,4 +648,7 @@ public StatusAndMessages queryUpgradeStatus()\n     return upgradeFinalizer.reportStatus(datanodeDetails.getUuidString(),\n         false);\n   }\n+  public UpgradeFinalizer<DatanodeStateMachine> getUpgradeFinalizer() {\n+    return  upgradeFinalizer;\n+  }\n }"
  },
  {
    "sha": "be58cc3d2f432622c17292ee1fb57ee4cfa0ddd1",
    "filename": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/upgrade/DataNodeUpgradeFinalizer.java",
    "status": "modified",
    "additions": 28,
    "deletions": 5,
    "changes": 33,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/upgrade/DataNodeUpgradeFinalizer.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/upgrade/DataNodeUpgradeFinalizer.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/upgrade/DataNodeUpgradeFinalizer.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -18,9 +18,13 @@\n \n package org.apache.hadoop.ozone.container.upgrade;\n \n-import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPostFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPreFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforeCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforePreFinalizeUpgrade;\n \n import java.io.IOException;\n import java.util.Optional;\n@@ -31,12 +35,16 @@\n import org.apache.hadoop.ozone.container.common.statemachine.DatanodeStateMachine;\n import org.apache.hadoop.ozone.upgrade.BasicUpgradeFinalizer;\n import org.apache.hadoop.ozone.upgrade.LayoutFeature;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * UpgradeFinalizer for the DataNode.\n  */\n public class DataNodeUpgradeFinalizer extends\n     BasicUpgradeFinalizer<DatanodeStateMachine, HDDSLayoutVersionManager> {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(DataNodeUpgradeFinalizer.class);\n \n   public DataNodeUpgradeFinalizer(HDDSLayoutVersionManager versionManager,\n                                   String optionalClientID) {\n@@ -53,7 +61,12 @@ public StatusAndMessages finalize(String upgradeClientID,\n     if (response.status() != FINALIZATION_REQUIRED) {\n       return response;\n     }\n-    new Worker(dsm).call();\n+    try {\n+      new Worker(dsm).call();\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      throw new IOException(e.getMessage());\n+    }\n     return STARTING_MSG;\n   }\n \n@@ -70,13 +83,15 @@ public StatusAndMessages finalize(String upgradeClientID,\n     }\n \n     @Override\n-    public Void call() throws IOException {\n+    public Void call() throws Exception {\n+      injectTestFunctionAtThisPoint(BeforePreFinalizeUpgrade);\n       if(!datanodeStateMachine.preFinalizeUpgrade()) {\n-      // datanode is not yet ready to finalize.\n+      // DataNode is not yet ready to finalize.\n       // Reset the Finalization state.\n         versionManager.setUpgradeState(FINALIZATION_REQUIRED);\n         return null;\n       }\n+      injectTestFunctionAtThisPoint(AfterPreFinalizeUpgrade);\n       try {\n         emitStartingMsg();\n         versionManager.setUpgradeState(FINALIZATION_IN_PROGRESS);\n@@ -95,14 +110,22 @@ public Void call() throws IOException {\n               datanodeStateMachine.getLayoutStorage());\n           versionManager.finalized(f);\n         }\n+        injectTestFunctionAtThisPoint(BeforeCompleteFinalization);\n         versionManager.completeFinalization();\n+        injectTestFunctionAtThisPoint(AfterCompleteFinalization);\n         datanodeStateMachine.postFinalizeUpgrade();\n+        injectTestFunctionAtThisPoint(AfterPostFinalizeUpgrade);\n         emitFinishedMsg();\n         return null;\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        if (versionManager.needsFinalization()) {\n+          versionManager.setUpgradeState(FINALIZATION_REQUIRED);\n+        }\n       } finally {\n-        versionManager.setUpgradeState(FINALIZATION_DONE);\n         isDone = true;\n       }\n+      return null;\n     }\n   }\n "
  },
  {
    "sha": "f62dfebf39c54593a536bc8ee5805ddea94dd19f",
    "filename": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/BackgroundPipelineCreator.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/BackgroundPipelineCreator.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/BackgroundPipelineCreator.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/BackgroundPipelineCreator.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -117,6 +117,7 @@ private void createPipelines() {\n     // TODO: #CLUTIL Different replication factor may need to be supported\n \n     if(pausePipelineCreation.get()) {\n+      LOG.info(\"Pipeline Creation is paused.\");\n       return;\n     }\n     HddsProtos.ReplicationType type = HddsProtos.ReplicationType.valueOf("
  },
  {
    "sha": "31cd33a413fb7a071c3171c2db5d620db6a596d9",
    "filename": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -1322,4 +1322,8 @@ public StatusAndMessages queryUpgradeFinalizationProgress(\n   ) throws IOException {\n     return upgradeFinalizer.reportStatus(upgradeClientID, takeover);\n   }\n+\n+  public UpgradeFinalizer<StorageContainerManager> getUpgradeFinalizer() {\n+    return  upgradeFinalizer;\n+  }\n }"
  },
  {
    "sha": "cafeeaef9561ea1c8749f20feb87e89449f9b382",
    "filename": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/upgrade/SCMUpgradeFinalizer.java",
    "status": "modified",
    "additions": 24,
    "deletions": 4,
    "changes": 28,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/upgrade/SCMUpgradeFinalizer.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/upgrade/SCMUpgradeFinalizer.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/upgrade/SCMUpgradeFinalizer.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -18,9 +18,13 @@\n \n package org.apache.hadoop.hdds.scm.server.upgrade;\n \n-import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPostFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPreFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforeCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforePreFinalizeUpgrade;\n \n import java.io.IOException;\n import java.util.Optional;\n@@ -51,7 +55,12 @@ public StatusAndMessages finalize(String upgradeClientID,\n     if (response.status() != FINALIZATION_REQUIRED) {\n       return response;\n     }\n-    new Worker(scm).call();\n+    try {\n+      new Worker(scm).call();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+      throw new IOException(e.getMessage());\n+    }\n     return STARTING_MSG;\n   }\n \n@@ -68,7 +77,7 @@ public StatusAndMessages finalize(String upgradeClientID,\n     }\n \n     @Override\n-    public Void call() throws IOException {\n+    public Void call() throws IOException, InterruptedException {\n       try {\n         emitStartingMsg();\n         versionManager.setUpgradeState(FINALIZATION_IN_PROGRESS);\n@@ -81,7 +90,10 @@ public Void call() throws IOException {\n             \"during Upgrade.\";\n         msg += \"\\n  New pipelines creation will remain frozen until Upgrade \" +\n             \"is finalized.\";\n+\n+        injectTestFunctionAtThisPoint(BeforePreFinalizeUpgrade);\n         storageContainerManager.preFinalizeUpgrade();\n+        injectTestFunctionAtThisPoint(AfterPreFinalizeUpgrade);\n         logAndEmit(msg);\n \n         for (HDDSLayoutFeature f : versionManager.unfinalizedFeatures()) {\n@@ -93,14 +105,22 @@ public Void call() throws IOException {\n               storageContainerManager.getScmStorageConfig());\n           versionManager.finalized(f);\n         }\n+        injectTestFunctionAtThisPoint(BeforeCompleteFinalization);\n         versionManager.completeFinalization();\n+        injectTestFunctionAtThisPoint(AfterCompleteFinalization);\n         storageContainerManager.postFinalizeUpgrade();\n+        injectTestFunctionAtThisPoint(AfterPostFinalizeUpgrade);\n         emitFinishedMsg();\n         return null;\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        if (versionManager.needsFinalization()) {\n+          versionManager.setUpgradeState(FINALIZATION_REQUIRED);\n+        }\n       } finally {\n-        versionManager.setUpgradeState(FINALIZATION_DONE);\n         isDone = true;\n       }\n+      return null;\n     }\n   }\n "
  },
  {
    "sha": "02274b4eaabbbb8494037bfe8054f8eacb6167b2",
    "filename": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/hdds/upgrade/TestHDDSUpgrade.java",
    "status": "modified",
    "additions": 705,
    "deletions": 35,
    "changes": 740,
    "blob_url": "https://github.com/apache/ozone/blob/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/hdds/upgrade/TestHDDSUpgrade.java",
    "raw_url": "https://github.com/apache/ozone/raw/f67b44d2696be2c15f0941ebce6d93833b9ed8d4/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/hdds/upgrade/TestHDDSUpgrade.java",
    "contents_url": "https://api.github.com/repos/apache/ozone/contents/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/hdds/upgrade/TestHDDSUpgrade.java?ref=f67b44d2696be2c15f0941ebce6d93833b9ed8d4",
    "patch": "@@ -18,6 +18,8 @@\n \n package org.apache.hadoop.hdds.upgrade;\n \n+import static java.lang.Thread.sleep;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.apache.hadoop.hdds.HddsConfigKeys.HDDS_PIPELINE_REPORT_INTERVAL;\n import static org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerDataProto.State.CLOSED;\n import static org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerDataProto.State.QUASI_CLOSED;\n@@ -28,15 +30,27 @@\n import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_DATANODE_PIPELINE_LIMIT;\n import static org.apache.hadoop.hdds.scm.pipeline.Pipeline.PipelineState.OPEN;\n import static org.apache.hadoop.hdds.upgrade.HDDSLayoutFeature.INITIAL_VERSION;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.ALREADY_FINALIZED;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.STARTING_FINALIZATION;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPostFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.AfterPreFinalizeUpgrade;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforeCompleteFinalization;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints.BeforePreFinalizeUpgrade;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Set;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n \n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos;\n@@ -46,6 +60,7 @@\n import org.apache.hadoop.hdds.scm.XceiverClientSpi;\n import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.exceptions.SCMException;\n import org.apache.hadoop.hdds.scm.node.states.NodeNotFoundException;\n import org.apache.hadoop.hdds.scm.pipeline.Pipeline;\n import org.apache.hadoop.hdds.scm.pipeline.PipelineID;\n@@ -54,9 +69,15 @@\n import org.apache.hadoop.hdds.scm.storage.ContainerProtocolCalls;\n import org.apache.hadoop.ozone.HddsDatanodeService;\n import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n import org.apache.hadoop.ozone.container.common.interfaces.Container;\n import org.apache.hadoop.ozone.container.common.statemachine.DatanodeStateMachine;\n import org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.StatusAndMessages;\n+import org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.UpgradeTestInjectionPoints;\n+import org.apache.hadoop.security.authentication.client.AuthenticationException;\n import org.apache.hadoop.test.GenericTestUtils;\n import org.apache.hadoop.test.LambdaTestUtils;\n import org.junit.After;\n@@ -74,10 +95,10 @@\n public class TestHDDSUpgrade {\n \n   /**\n-    * Set a timeout for each test.\n-    */\n+   * Set a timeout for each test.\n+   */\n   @Rule\n-  public Timeout timeout = new Timeout(300000);\n+  public Timeout timeout = new Timeout(11000000);\n   private static final Logger LOG =\n       LoggerFactory.getLogger(TestHDDSUpgrade.class);\n   private static final int NUM_DATA_NODES = 3;\n@@ -87,7 +108,6 @@\n   private StorageContainerManager scm;\n   private ContainerManager scmContainerManager;\n   private PipelineManager scmPipelineManager;\n-  private Pipeline ratisPipeline1;\n   private final int numContainersCreated = 1;\n   private HDDSLayoutVersionManager scmVersionManager;\n \n@@ -97,38 +117,75 @@\n    * @throws IOException\n    */\n   @Before\n+  public void setUp() throws Exception {\n+    init();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    shutdown();\n+  }\n+\n   public void init() throws Exception {\n     conf = new OzoneConfiguration();\n     conf.setTimeDuration(HDDS_PIPELINE_REPORT_INTERVAL, 1000,\n-            TimeUnit.MILLISECONDS);\n+        TimeUnit.MILLISECONDS);\n     conf.set(OZONE_DATANODE_PIPELINE_LIMIT, \"1\");\n     cluster = MiniOzoneCluster.newBuilder(conf)\n         .setNumDatanodes(NUM_DATA_NODES)\n         // allow only one FACTOR THREE pipeline.\n         .setTotalPipelineNumLimit(NUM_DATA_NODES + 1)\n-        .setHbInterval(1000)\n-        .setHbProcessorInterval(1000)\n+        .setHbInterval(500)\n+        .setHbProcessorInterval(500)\n         .setScmLayoutVersion(INITIAL_VERSION.layoutVersion())\n         .setDnLayoutVersion(INITIAL_VERSION.layoutVersion())\n         .build();\n     cluster.waitForClusterToBeReady();\n-    scm = cluster.getStorageContainerManager();\n-    scmContainerManager = scm.getContainerManager();\n-    scmPipelineManager = scm.getPipelineManager();\n-    scmVersionManager = scm.getLayoutVersionManager();\n-\n+    loadSCMState();\n   }\n \n   /**\n    * Shutdown MiniDFSCluster.\n    */\n-  @After\n   public void shutdown() {\n     if (cluster != null) {\n       cluster.shutdown();\n     }\n   }\n \n+  /*\n+   * Some tests repeatedly modify the cluster. Helper function to reload the\n+   * latest SCM state.\n+   */\n+  private void loadSCMState(){\n+    scm = cluster.getStorageContainerManager();\n+    scmContainerManager = scm.getContainerManager();\n+    scmPipelineManager = scm.getPipelineManager();\n+    scmVersionManager = scm.getLayoutVersionManager();\n+  }\n+\n+\n+  /*\n+   * helper function to create a Key.\n+   */\n+  private void createKey() throws IOException {\n+    final String uniqueId = \"testhddsupgrade\";\n+    OzoneClient client = OzoneClientFactory.getRpcClient(conf);\n+    ObjectStore objectStore = client.getObjectStore();\n+    objectStore.createVolume(uniqueId);\n+    objectStore.getVolume(uniqueId).createBucket(uniqueId);\n+    OzoneOutputStream key =\n+        objectStore.getVolume(uniqueId).getBucket(uniqueId)\n+            .createKey(uniqueId, 1024, ReplicationType.RATIS,\n+                ReplicationFactor.THREE, new HashMap<>());\n+    key.write(uniqueId.getBytes(UTF_8));\n+    key.flush();\n+    key.close();\n+  }\n+\n+  /*\n+   * Helper function to test Pre-Upgrade conditions on the SCM\n+   */\n   private void testPreUpgradeConditionsSCM() {\n     Assert.assertEquals(INITIAL_VERSION.layoutVersion(),\n         scmVersionManager.getMetadataLayoutVersion());\n@@ -137,28 +194,38 @@ private void testPreUpgradeConditionsSCM() {\n     }\n   }\n \n+  /*\n+   * Helper function to test Post-Upgrade conditions on the SCM\n+   */\n   private void testPostUpgradeConditionsSCM() {\n+    loadSCMState();\n     Assert.assertEquals(scmVersionManager.getSoftwareLayoutVersion(),\n         scmVersionManager.getMetadataLayoutVersion());\n     Assert.assertTrue(scmVersionManager.getMetadataLayoutVersion() >= 1);\n     int countContainers = 0;\n     for (ContainerInfo ci : scmContainerManager.getContainers()) {\n       HddsProtos.LifeCycleState ciState = ci.getState();\n+      LOG.info(\"testPostUpgradeConditionsSCM: container state is {}\",\n+          ciState.name());\n       Assert.assertTrue((ciState == HddsProtos.LifeCycleState.CLOSED) ||\n           (ciState == HddsProtos.LifeCycleState.CLOSING) ||\n+          (ciState == HddsProtos.LifeCycleState.DELETING) ||\n+          (ciState == HddsProtos.LifeCycleState.DELETED) ||\n           (ciState == HddsProtos.LifeCycleState.QUASI_CLOSED));\n       countContainers++;\n     }\n-    Assert.assertEquals(numContainersCreated, countContainers);\n+    Assert.assertTrue(countContainers >= numContainersCreated);\n   }\n \n+  /*\n+   * Helper function to test Pre-Upgrade conditions on all the DataNodes.\n+   */\n   private void testPreUpgradeConditionsDataNodes() {\n     for (HddsDatanodeService dataNode : cluster.getHddsDatanodes()) {\n       DatanodeStateMachine dsm = dataNode.getDatanodeStateMachine();\n       HDDSLayoutVersionManager dnVersionManager =\n           dsm.getLayoutVersionManager();\n       Assert.assertEquals(0, dnVersionManager.getMetadataLayoutVersion());\n-\n     }\n \n     int countContainers = 0;\n@@ -176,22 +243,25 @@ private void testPreUpgradeConditionsDataNodes() {\n     Assert.assertTrue(countContainers >= 1);\n   }\n \n-\n+  /*\n+   * Helper function to test Post-Upgrade conditions on all the DataNodes.\n+   */\n   private void testPostUpgradeConditionsDataNodes() {\n     try {\n       GenericTestUtils.waitFor(() -> {\n         for (HddsDatanodeService dataNode : cluster.getHddsDatanodes()) {\n           DatanodeStateMachine dsm = dataNode.getDatanodeStateMachine();\n           try {\n-            if (dsm.queryUpgradeStatus().status() != FINALIZATION_DONE) {\n+            if ((dsm.queryUpgradeStatus().status() != FINALIZATION_DONE) &&\n+                (dsm.queryUpgradeStatus().status() != ALREADY_FINALIZED)) {\n               return false;\n             }\n           } catch (IOException e) {\n             return false;\n           }\n         }\n         return true;\n-      }, 2000, 20000);\n+      }, 500, 60000);\n     } catch (TimeoutException | InterruptedException e) {\n       Assert.fail(\"Timeout waiting for Upgrade to complete on Data Nodes.\");\n     }\n@@ -217,8 +287,11 @@ private void testPostUpgradeConditionsDataNodes() {\n     Assert.assertTrue(countContainers >= 1);\n   }\n \n+  /*\n+   * Helper function to test that we can create new pipelines Post-Upgrade.\n+   */\n   private void testPostUpgradePipelineCreation() throws IOException {\n-    ratisPipeline1 = scmPipelineManager.createPipeline(RATIS, THREE);\n+    Pipeline ratisPipeline1 = scmPipelineManager.createPipeline(RATIS, THREE);\n     scmPipelineManager.openPipeline(ratisPipeline1.getId());\n     Assert.assertEquals(0,\n         scmPipelineManager.getNumberOfContainers(ratisPipeline1.getId()));\n@@ -228,12 +301,22 @@ private void testPostUpgradePipelineCreation() throws IOException {\n     Assert.assertEquals(pid, ratisPipeline1.getId());\n   }\n \n-  private void testDataNodesStateOnSCM(NodeState state) {\n+  /*\n+   * Helper function to test DataNode state on the SCM. Note that due to\n+   * timing constraints, sometime the node-state can transition to the next\n+   * state. This function expects the DataNode to be in NodeState \"state\" or\n+   * \"alternateState\". Some tests can enforce a unique NodeState test by\n+   * setting \"alternateState = null\".\n+   */\n+  private void testDataNodesStateOnSCM(NodeState state,\n+                                       NodeState alternateState) {\n     int countNodes = 0;\n-    for (DatanodeDetails dn : scm.getScmNodeManager().getAllNodes()){\n+    for (DatanodeDetails dn : scm.getScmNodeManager().getAllNodes()) {\n       try {\n-        Assert.assertEquals(state,\n-            scm.getScmNodeManager().getNodeStatus(dn).getHealth());\n+        NodeState dnState =\n+            scm.getScmNodeManager().getNodeStatus(dn).getHealth();\n+        Assert.assertTrue((dnState == state) ||\n+            (alternateState == null ? false : dnState == alternateState));\n       } catch (NodeNotFoundException e) {\n         e.printStackTrace();\n         Assert.fail(\"Node not found\");\n@@ -243,31 +326,43 @@ private void testDataNodesStateOnSCM(NodeState state) {\n     Assert.assertEquals(NUM_DATA_NODES, countNodes);\n   }\n \n+  /*\n+   * Helper function to wait for Pipeline creation.\n+   */\n   private void waitForPipelineCreated() throws Exception {\n-    LambdaTestUtils.await(10000, 2000, () -> {\n+    LambdaTestUtils.await(10000, 500, () -> {\n       List<Pipeline> pipelines =\n           scmPipelineManager.getPipelines(RATIS, THREE, OPEN);\n       return pipelines.size() == 1;\n     });\n   }\n \n-  @Test\n-  public void testFinalizationFromInitialVersionToLatestVersion()\n-      throws Exception {\n-\n-    waitForPipelineCreated();\n-\n-    // we will create CONTAINERS_CREATED_FOR_TESTING number of containers.\n+  /*\n+   * Helper function for container creation.\n+   */\n+  private void createTestContainers() throws IOException {\n     XceiverClientManager xceiverClientManager = new XceiverClientManager(conf);\n     ContainerInfo ci1 = scmContainerManager.allocateContainer(\n         RATIS, THREE, \"Owner1\");\n-    ratisPipeline1 = scmPipelineManager.getPipeline(ci1.getPipelineID());\n+    Pipeline ratisPipeline1 =\n+        scmPipelineManager.getPipeline(ci1.getPipelineID());\n     scmPipelineManager.openPipeline(ratisPipeline1.getId());\n     XceiverClientSpi client1 =\n         xceiverClientManager.acquireClient(ratisPipeline1);\n     ContainerProtocolCalls.createContainer(client1,\n         ci1.getContainerID(), null);\n     xceiverClientManager.releaseClient(client1, false);\n+  }\n+\n+  /*\n+   * Happy Path Test Case.\n+   */\n+  @Test\n+  public void testFinalizationFromInitialVersionToLatestVersion()\n+      throws Exception {\n+\n+    waitForPipelineCreated();\n+    createTestContainers();\n \n     // Test the Pre-Upgrade conditions on SCM as well as DataNodes.\n     testPreUpgradeConditionsSCM();\n@@ -286,15 +381,15 @@ public void testFinalizationFromInitialVersionToLatestVersion()\n     testPostUpgradeConditionsSCM();\n \n     // All datanodes on the SCM should have moved to HEALTHY-READONLY state.\n-    testDataNodesStateOnSCM(HEALTHY_READONLY);\n+    testDataNodesStateOnSCM(HEALTHY_READONLY, HEALTHY);\n \n     // Verify the SCM has driven all the DataNodes through Layout Upgrade.\n     testPostUpgradeConditionsDataNodes();\n \n     // Need to wait for post finalization heartbeat from DNs.\n-    LambdaTestUtils.await(30000, 5000, () -> {\n+    LambdaTestUtils.await(30000, 1000, () -> {\n       try {\n-        testDataNodesStateOnSCM(HEALTHY);\n+        testDataNodesStateOnSCM(HEALTHY, null);\n       } catch (Throwable ex) {\n         LOG.info(ex.getMessage());\n         return false;\n@@ -305,4 +400,579 @@ public void testFinalizationFromInitialVersionToLatestVersion()\n     // Verify that new pipeline can be created with upgraded datanodes.\n     testPostUpgradePipelineCreation();\n   }\n+\n+  /*\n+   * All the subsequent tests here are failure cases. Some of the tests below\n+   * could simultaneously fail one or more nodes at specific execution points\n+   * and in different thread contexts.\n+   * Upgrade path key execution points are defined in\n+   * UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+\n+  /*\n+   * Helper function to inject SCM failure and a SCM restart at a given\n+   * execution point during SCM-Upgrade.\n+   *\n+   * Injects Failure in  : SCM\n+   * Executing-Thread-Context : SCM-Upgrade\n+   */\n+  private Boolean injectSCMFailureDuringSCMUpgrade()\n+      throws InterruptedException, TimeoutException, AuthenticationException,\n+      IOException {\n+    // For some tests this could get called in a different thread context.\n+    // We need to guard concurrent updates to the cluster.\n+    synchronized(cluster) {\n+      cluster.restartStorageContainerManager(true);\n+      loadSCMState();\n+    }\n+    // The ongoing current SCM Upgrade is getting aborted at this point. We\n+    // need to schedule a new SCM Upgrade on a different thread context.\n+    Thread t = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          loadSCMState();\n+          scm.finalizeUpgrade(\"xyz\");\n+        } catch (IOException e) {\n+          e.printStackTrace();\n+          Assert.fail(e.getMessage());\n+        }\n+      }\n+    });\n+    t.start();\n+    return true;\n+  }\n+\n+  /*\n+   * Helper function to inject DataNode failures and DataNode restarts at a\n+   * given execution point during SCM-Upgrade. Please note that it fails all\n+   * the DataNodes in the cluster and is part of test cases that simulate\n+   * multi-node failure at specific code-execution points during SCM Upgrade.\n+   * Please note that this helper function should be called in the thread\n+   * context of an SCM-Upgrade only. The return value has a significance that\n+   * it does not abort the currently ongoing SCM upgrade. because this\n+   * failure injection does not fail the SCM node and only impacts datanodes,\n+   *  we do not need to schedule another scm-finalize-upgrade here.\n+   *\n+   * Injects Failure in  : All the DataNodes\n+   * Executing-Thread-Context : SCM-Upgrade\n+   */\n+  private Boolean injectDataNodeFailureDuringSCMUpgrade() {\n+    try {\n+      // Work on a Copy of current set of DataNodes to avoid\n+      // running into tricky situations.\n+      List<HddsDatanodeService> currentDataNodes =\n+          new ArrayList<>(cluster.getHddsDatanodes());\n+      for (HddsDatanodeService ds: currentDataNodes) {\n+        DatanodeDetails dn = ds.getDatanodeDetails();\n+        cluster.restartHddsDatanode(dn, false);\n+      }\n+      cluster.waitForClusterToBeReady();\n+    } catch (Exception e) {\n+      LOG.info(\"DataNode Restarts Failed!\");\n+      Assert.fail(e.getMessage());\n+    }\n+    loadSCMState();\n+    // returning false from injection function, continues currently ongoing\n+    // SCM-Upgrade-Finalization.\n+    return false;\n+  }\n+\n+  /*\n+   * Helper function to inject a DataNode failure and restart for a specific\n+   * DataNode. This injection function can target a specific DataNode and\n+   * thus facilitates getting called in the upgrade-finalization thread context\n+   * of that specific DataNode.\n+   *\n+   * Injects Failure in  : Given DataNodes\n+   * Executing-Thread-Context : the same DataNode that we are failing here.\n+   */\n+  private Thread injectDataNodeFailureDuringDataNodeUpgrade(\n+      DatanodeDetails dn) {\n+    Thread t = null;\n+    try {\n+      // Schedule the DataNode restart on a separate thread context\n+      // otherwise DataNode restart will hang. Also any cluster modification\n+      // needs to be guarded since it could get modified in multiple independent\n+      // threads.\n+      t = new Thread(new Runnable() {\n+        @Override\n+        public void run() {\n+          try {\n+            synchronized (cluster) {\n+              cluster.restartHddsDatanode(dn, true);\n+            }\n+          } catch (Exception e) {\n+            e.printStackTrace();\n+            Assert.fail(e.getMessage());\n+          }\n+        }\n+      });\n+    } catch (Exception e) {\n+      LOG.info(\"DataNode Restart Failed!\");\n+      Assert.fail(e.getMessage());\n+    }\n+    return t;\n+  }\n+\n+  /*\n+   * Helper function to inject coordinated failures and restarts across\n+   * all the DataNode as well as SCM. This can help create targeted test cases\n+   * to inject such comprehensive failures in SCM-Upgrade-Context as well as\n+   * DataNode-Upgrade-Context.\n+   *\n+   * Injects Failure in  : SCM as well as ALL the DataNodes.\n+   * Executing-Thread-Context : Either the SCM-Upgrade-Finalizer or the\n+   *                            DataNode-Upgrade-Finalizer.\n+   */\n+  private Thread injectSCMAndDataNodeFailureTogetherAtTheSameTime()\n+      throws InterruptedException, TimeoutException, AuthenticationException,\n+      IOException {\n+    // This needs to happen in a separate thread context otherwise\n+    // DataNode restart will hang.\n+    return new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          // Since we are modifying cluster in an independent thread context,\n+          // we synchronize access to it to avoid concurrent modification\n+          // exception.\n+          synchronized (cluster) {\n+            // Work on a Copy of current set of DataNodes to avoid\n+            // running into tricky situations.\n+            List<HddsDatanodeService> currentDataNodes =\n+                new ArrayList<>(cluster.getHddsDatanodes());\n+            for (HddsDatanodeService ds: currentDataNodes) {\n+              DatanodeDetails dn = ds.getDatanodeDetails();\n+              cluster.restartHddsDatanode(dn, false);\n+            }\n+            cluster.restartStorageContainerManager(false);\n+            cluster.waitForClusterToBeReady();\n+          }\n+        } catch (Exception e) {\n+          e.printStackTrace();\n+          Assert.fail(e.getMessage());\n+        }\n+      }\n+    });\n+  }\n+\n+  /*\n+   * We have various test cases to target single-node or multi-node failures\n+   * below.\n+   **/\n+\n+  /*\n+   * One node(SCM) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test SCM failure During SCM Upgrade before execution point\n+   * \"PreFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testScmFailuresBeforeScmPreFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        BeforePreFinalizeUpgrade,\n+        () -> {\n+          return injectSCMFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * One node(SCM) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test SCM failure During SCM Upgrade after execution point\n+   * \"PreFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testScmFailuresAfterScmPreFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterPreFinalizeUpgrade,\n+        () -> {\n+          return injectSCMFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * One node(SCM) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test SCM failure During SCM Upgrade before execution point\n+   * \"CompleteFinalization\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testScmFailuresBeforeScmCompleteFinalization()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        BeforeCompleteFinalization,\n+        () -> {\n+          return injectSCMFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * One node(SCM) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test SCM failure During SCM Upgrade after execution point\n+   * \"CompleteFinalization\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testScmFailuresAfterScmCompleteFinalization()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterCompleteFinalization,\n+        () -> {\n+          return injectSCMFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * One node(SCM) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test SCM failure During SCM Upgrade after execution point\n+   * \"PostFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testScmFailuresAfterScmPostFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterPostFinalizeUpgrade,\n+        () -> {\n+          return injectSCMFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Multi node(all DataNodes) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test all DataNode failures During SCM Upgrade before execution point\n+   * \"PreFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testAllDataNodeFailuresBeforeScmPreFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        BeforePreFinalizeUpgrade,\n+        () -> {\n+          return injectDataNodeFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Multi node(all DataNodes) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test all DataNode failures During SCM Upgrade before execution point\n+   * \"PreFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testAllDataNodeFailuresAfterScmPreFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterPreFinalizeUpgrade,\n+        () -> {\n+          return injectDataNodeFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Multi node(all DataNodes) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test all DataNode failures During SCM Upgrade before execution point\n+   * \"CompleteFinalization\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testAllDataNodeFailuresBeforeScmCompleteFinalization()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        BeforeCompleteFinalization,\n+        () -> {\n+          return injectDataNodeFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Multi node(all DataNodes) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test all DataNode failures During SCM Upgrade after execution point\n+   * \"CompleteFinalization\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testAllDataNodeFailuresAfterScmCompleteFinalization()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterCompleteFinalization,\n+        () -> {\n+          return injectDataNodeFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Multi node(all DataNodes) failure case:\n+   * Thread-Context : SCM-Upgrade\n+   *\n+   * Test all DataNode failures During SCM Upgrade after execution point\n+   * \"PostFinalizeUpgrade\". All meaningful Upgrade execution points\n+   * are defined in UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testAllDataNodeFailuresAfterScmPostFinalizeUpgrade()\n+      throws Exception {\n+    scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+        AfterPostFinalizeUpgrade,\n+        () -> {\n+          return injectDataNodeFailureDuringSCMUpgrade();\n+        });\n+    testFinalizationWithFailuerInjectionHelper(null);\n+  }\n+\n+  /*\n+   * Single node(targeted DataNode) failure case:\n+   * Thread-Context : DataNode-Upgrade.\n+   *\n+   * Fail the same DataNode that is going through Upgrade-processing at a\n+   * specific code execution point. This test covers all the meaningful\n+   * Upgrade execution points as defined in\n+   * UpgradeFinalizer:UpgradeTestInjectionPoints.\n+   */\n+  @Test\n+  public void testDataNodeFailuresDuringDataNodeUpgrade()\n+      throws Exception {\n+    for (UpgradeTestInjectionPoints injectionPoint:\n+        UpgradeTestInjectionPoints.values()) {\n+      // Configure a given data node to fail itself when it's\n+      // corresponding Upgrade-Finalizer reaches a specific point in it's\n+      // execution.\n+      HddsDatanodeService ds = cluster.getHddsDatanodes().get(1);\n+      Thread failureInjectionThread =\n+          injectDataNodeFailureDuringDataNodeUpgrade(ds.getDatanodeDetails());\n+      ds.getDatanodeStateMachine().getUpgradeFinalizer()\n+          .configureTestInjectionFunction(\n+              injectionPoint, () -> {\n+                failureInjectionThread.start();\n+                return true;\n+              });\n+      testFinalizationWithFailuerInjectionHelper(failureInjectionThread);\n+      synchronized (cluster) {\n+        shutdown();\n+        init();\n+      }\n+      LOG.info(\"testDataNodeFailuresDuringDataNodeUpgrade: Failure Injection \" +\n+          \"Point {} passed.\", injectionPoint.name());\n+    }\n+  }\n+\n+  /*\n+   * Two nodes(SCM and a targeted DataNode) combination failure case:\n+   * Thread-Contexts :\n+   *          DataNode failure in its own DataNode-Upgrade-Context .\n+   *          SCM failure in its own SCM-Upgrade-Context .\n+   *\n+   * Fail the same DataNode that is going through its own Upgrade-processing\n+   * at a specific code execution point. Also fail the SCM when SCM is going\n+   * through upgrade-finalization. This test covers all the combinations of\n+   * SCM-Upgrade-execution points and DataNode-Upgrade-execution points.\n+   */\n+  @Test\n+  public void testAllPossibleDataNodeFailuresAndSCMFailures()\n+      throws Exception {\n+    // Configure a given data node to restart itself when it's\n+    // corresponding Upgrade-Finalizer reaches a specific point in it's\n+    // execution.\n+    for (UpgradeTestInjectionPoints scmInjectionPoint :\n+        UpgradeTestInjectionPoints.values()) {\n+      scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+          scmInjectionPoint,\n+          () -> {\n+            return injectSCMFailureDuringSCMUpgrade();\n+          });\n+      for (UpgradeTestInjectionPoints datanodeInjectionPoint :\n+          UpgradeTestInjectionPoints.values()) {\n+        HddsDatanodeService ds = cluster.getHddsDatanodes().get(1);\n+        Thread dataNodefailureInjectionThread =\n+            injectDataNodeFailureDuringDataNodeUpgrade(ds.getDatanodeDetails());\n+        ds.getDatanodeStateMachine().getUpgradeFinalizer()\n+            .configureTestInjectionFunction(\n+                datanodeInjectionPoint, () -> {\n+                  dataNodefailureInjectionThread.start();\n+                  return true;\n+                });\n+        testFinalizationWithFailuerInjectionHelper(\n+            dataNodefailureInjectionThread);\n+        synchronized (cluster) {\n+          shutdown();\n+          init();\n+        }\n+        LOG.info(\"testAllPossibleDataNodeFailuresAndSCMFailures: \" +\n+            \"DataNode-Failure-Injection-Point={} with \" +\n+            \"Scm-FailureInjection-Point={} passed.\",\n+            datanodeInjectionPoint.name(), scmInjectionPoint.name());\n+      }\n+    }\n+  }\n+\n+  /*\n+   * Two nodes(SCM and a targeted DataNode together at the same time)\n+   * combination failure case:\n+   * Thread-Contexts :\n+   *          SCM-Upgrade-Finalizer-Context\n+   *\n+   * Fail the DataNode and the SCM together when the SCM is going\n+   * through upgrade. This test covers all the combinations of\n+   * SCM-Upgrade-execution points.\n+   */\n+  @Test\n+  public void testDataNodeAndSCMFailuresTogetherDuringSCMUpgrade()\n+      throws Exception {\n+    for (UpgradeTestInjectionPoints injectionPoint :\n+        UpgradeTestInjectionPoints.values()) {\n+      Thread helpingFailureInjectionThread =\n+          injectSCMAndDataNodeFailureTogetherAtTheSameTime();\n+      scm.getUpgradeFinalizer().configureTestInjectionFunction(\n+          injectionPoint, () -> {\n+            helpingFailureInjectionThread.start();\n+            return true;\n+          });\n+      testFinalizationWithFailuerInjectionHelper(helpingFailureInjectionThread);\n+      synchronized (cluster) {\n+        shutdown();\n+        init();\n+      }\n+      LOG.info(\"testDataNodeAndSCMFailuresTogetherDuringSCMUpgrade: Failure \" +\n+          \"Injection Point {} passed.\", injectionPoint.name());\n+    }\n+  }\n+\n+  /*\n+   * Two nodes(SCM and a targeted DataNode together at the same time)\n+   * combination failure case:\n+   * Thread-Contexts :\n+   *          DataNode-Upgrade-Finalizer-Context.\n+   *\n+   * Fail the DataNode and the SCM together when the DataNode is going\n+   * through upgrade. This test covers all the combinations of\n+   * DataNode-Upgrade-execution points.\n+   */\n+  @Test\n+  public void testDataNodeAndSCMFailuresTogetherDuringDataNodeUpgrade()\n+      throws Exception {\n+    for (UpgradeTestInjectionPoints injectionPoint :\n+        UpgradeTestInjectionPoints.values()) {\n+      Thread helpingFailureInjectionThread =\n+          injectSCMAndDataNodeFailureTogetherAtTheSameTime();\n+      HddsDatanodeService ds = cluster.getHddsDatanodes().get(1);\n+      ds.getDatanodeStateMachine().getUpgradeFinalizer()\n+          .configureTestInjectionFunction(\n+              injectionPoint, () -> {\n+                helpingFailureInjectionThread.start();\n+                return true;\n+              });\n+      testFinalizationWithFailuerInjectionHelper(helpingFailureInjectionThread);\n+      synchronized (cluster) {\n+        shutdown();\n+        init();\n+      }\n+      LOG.info(\"testDataNodeAndSCMFailuresTogetherDuringDataNodeUpgrade: \" +\n+          \"Failure Injection Point {} passed.\", injectionPoint.name());\n+    }\n+  }\n+\n+  public void testFinalizationWithFailuerInjectionHelper(\n+      Thread failureInjectionThread) throws Exception {\n+\n+    waitForPipelineCreated();\n+    createTestContainers();\n+    createKey();\n+\n+    // Test the Pre-Upgrade conditions on SCM as well as DataNodes.\n+    testPreUpgradeConditionsSCM();\n+    testPreUpgradeConditionsDataNodes();\n+\n+    // Trigger Finalization on the SCM\n+    StatusAndMessages status = scm.finalizeUpgrade(\"xyz\");\n+    Assert.assertEquals(STARTING_FINALIZATION, status.status());\n+\n+    // Make sure that any outstanding thread created by failure injection\n+    // has completed its job.\n+    if (failureInjectionThread != null) {\n+      failureInjectionThread.join();\n+    }\n+\n+    // Wait for the Finalization to complete on the SCM.\n+    // Failure injection could have restarted the SCM and it could be in\n+    // ALREADY_FINALIZED state as well.\n+    while ((status.status() != FINALIZATION_DONE) &&\n+        (status.status() != ALREADY_FINALIZED)) {\n+      loadSCMState();\n+      status = scm.queryUpgradeFinalizationProgress(\"xyz\", true);\n+      if (status.status() == FINALIZATION_REQUIRED) {\n+        status = scm.finalizeUpgrade(\"xyz\");\n+      }\n+    }\n+\n+    // Verify Post-Upgrade conditions on the SCM.\n+    // With failure injection\n+    testPostUpgradeConditionsSCM();\n+\n+    // All datanodes on the SCM should have moved to HEALTHY-READONLY state.\n+    // Due to timing constraint also allow a \"HEALTHY\" state.\n+    loadSCMState();\n+    testDataNodesStateOnSCM(HEALTHY_READONLY, HEALTHY);\n+\n+    // Need to wait for post finalization heartbeat from DNs.\n+    LambdaTestUtils.await(600000, 500, () -> {\n+      try {\n+        loadSCMState();\n+        testDataNodesStateOnSCM(HEALTHY, null);\n+        sleep(100);\n+      } catch (Throwable ex) {\n+        LOG.info(ex.getMessage());\n+        return false;\n+      }\n+      return true;\n+    });\n+\n+    // Verify the SCM has driven all the DataNodes through Layout Upgrade.\n+    testPostUpgradeConditionsDataNodes();\n+\n+    // Verify that new pipeline can be created with upgraded datanodes.\n+    try {\n+      testPostUpgradePipelineCreation();\n+    } catch(SCMException e) {\n+      // If pipeline creation fails, make sure that there is a valid reason\n+      // for this i.e. all datanodes are already part of some pipeline.\n+      for (HddsDatanodeService dataNode : cluster.getHddsDatanodes()) {\n+        DatanodeStateMachine dsm = dataNode.getDatanodeStateMachine();\n+        Set<PipelineID> pipelines =\n+            scm.getScmNodeManager().getPipelines(dsm.getDatanodeDetails());\n+        Assert.assertTrue(pipelines != null);\n+      }\n+    }\n+  }\n }"
  }
]
