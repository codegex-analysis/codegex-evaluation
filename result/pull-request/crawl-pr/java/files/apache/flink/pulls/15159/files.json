[
  {
    "sha": "7e10cd11b2a6d0de1e6a4aa66b00298fc3fe468e",
    "filename": "docs/layouts/shortcodes/generated/all_jobmanager_section.html",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/all_jobmanager_section.html",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/all_jobmanager_section.html",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/docs/layouts/shortcodes/generated/all_jobmanager_section.html?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -14,11 +14,17 @@\n             <td>Integer</td>\n             <td>Configure the minimum increase in parallelism for a job to scale up.</td>\n         </tr>\n+        <tr>\n+            <td><h5>jobmanager.adaptive-scheduler.resource-stabilization-timeout</h5></td>\n+            <td style=\"word-wrap: break-word;\">10 s</td>\n+            <td>Duration</td>\n+            <td>The resource stabilization timeout defines the time the JobManager will wait if fewer than the required resources are available, but sufficient resources for execution are there. Once this timeout has passed, the job will start executing with the available resources, or fail, if the resources are not sufficient. The timeout starts as soon as there are sufficient resources available for execution.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to 0, so that jobs are starting immediately with the available resources.</td>\n+        </tr>\n         <tr>\n             <td><h5>jobmanager.adaptive-scheduler.resource-wait-timeout</h5></td>\n             <td style=\"word-wrap: break-word;\">10 s</td>\n             <td>Duration</td>\n-            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).</td>\n+            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).<br />Setting a negative duration will disable the resource timeout: The JobManager will wait indefinitely for resources to appear.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to a negative value to disable the resource timeout.</td>\n         </tr>\n         <tr>\n             <td><h5>jobmanager.archive.fs.dir</h5></td>"
  },
  {
    "sha": "ee680543afa7e06d72cd22c5df27e5e3baf1297f",
    "filename": "docs/layouts/shortcodes/generated/expert_scheduling_section.html",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/expert_scheduling_section.html",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/expert_scheduling_section.html",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/docs/layouts/shortcodes/generated/expert_scheduling_section.html?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -20,11 +20,17 @@\n             <td>Integer</td>\n             <td>Configure the minimum increase in parallelism for a job to scale up.</td>\n         </tr>\n+        <tr>\n+            <td><h5>jobmanager.adaptive-scheduler.resource-stabilization-timeout</h5></td>\n+            <td style=\"word-wrap: break-word;\">10 s</td>\n+            <td>Duration</td>\n+            <td>The resource stabilization timeout defines the time the JobManager will wait if fewer than the required resources are available, but sufficient resources for execution are there. Once this timeout has passed, the job will start executing with the available resources, or fail, if the resources are not sufficient. The timeout starts as soon as there are sufficient resources available for execution.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to 0, so that jobs are starting immediately with the available resources.</td>\n+        </tr>\n         <tr>\n             <td><h5>jobmanager.adaptive-scheduler.resource-wait-timeout</h5></td>\n             <td style=\"word-wrap: break-word;\">10 s</td>\n             <td>Duration</td>\n-            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).</td>\n+            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).<br />Setting a negative duration will disable the resource timeout: The JobManager will wait indefinitely for resources to appear.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to a negative value to disable the resource timeout.</td>\n         </tr>\n         <tr>\n             <td><h5>scheduler-mode</h5></td>"
  },
  {
    "sha": "321bbd5dffed9f6f45733e76ddc6bdfb8c665719",
    "filename": "docs/layouts/shortcodes/generated/job_manager_configuration.html",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/job_manager_configuration.html",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/job_manager_configuration.html",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/docs/layouts/shortcodes/generated/job_manager_configuration.html?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -14,11 +14,17 @@\n             <td>Integer</td>\n             <td>Configure the minimum increase in parallelism for a job to scale up.</td>\n         </tr>\n+        <tr>\n+            <td><h5>jobmanager.adaptive-scheduler.resource-stabilization-timeout</h5></td>\n+            <td style=\"word-wrap: break-word;\">10 s</td>\n+            <td>Duration</td>\n+            <td>The resource stabilization timeout defines the time the JobManager will wait if fewer than the required resources are available, but sufficient resources for execution are there. Once this timeout has passed, the job will start executing with the available resources, or fail, if the resources are not sufficient. The timeout starts as soon as there are sufficient resources available for execution.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to 0, so that jobs are starting immediately with the available resources.</td>\n+        </tr>\n         <tr>\n             <td><h5>jobmanager.adaptive-scheduler.resource-wait-timeout</h5></td>\n             <td style=\"word-wrap: break-word;\">10 s</td>\n             <td>Duration</td>\n-            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).</td>\n+            <td>The maximum time the JobManager will wait to acquire all required resources after a job submission or restart. Once elapsed it will try to run the job with a lower parallelism, or fail if the minimum amount of resources could not be acquired.<br />Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).<br />Setting a negative duration will disable the resource timeout: The JobManager will wait indefinitely for resources to appear.<br />If <span markdown=\"span\">`scheduler-mode`</span> is configured to <span markdown=\"span\">`REACTIVE`</span>, this configuration value will default to a negative value to disable the resource timeout.</td>\n         </tr>\n         <tr>\n             <td><h5>jobmanager.archive.fs.dir</h5></td>"
  },
  {
    "sha": "571ca883c16b24d0ec5aa7b5f16af3324088a6c7",
    "filename": "docs/layouts/shortcodes/generated/table_config_configuration.html",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/table_config_configuration.html",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/docs/layouts/shortcodes/generated/table_config_configuration.html",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/docs/layouts/shortcodes/generated/table_config_configuration.html?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -30,7 +30,7 @@\n             <td><h5>table.planner</h5><br> <span class=\"label label-primary\">Batch</span> <span class=\"label label-primary\">Streaming</span></td>\n             <td style=\"word-wrap: break-word;\">BLINK</td>\n             <td><p>Enum</p>Possible values: [BLINK, OLD]</td>\n-            <td>Use either 'blink' planner or 'old' planner. Default is blink planner. For TableEnvironment, this option is used to construct a TableEnvironment, but this option can't be changed after that. However, there is no such limitation for SQL Client. Note: The old planner will be removed in Flink 1.14, so this option will become obsolete.</td>\n+            <td>Use either 'blink' planner or 'old' planner. Default is blink planner. For TableEnvironment, this option is used to construct a TableEnvironment, but this option can't be changed after that. However there is no such limitation for SQL Client.</td>\n         </tr>\n         <tr>\n             <td><h5>table.sql-dialect</h5><br> <span class=\"label label-primary\">Batch</span> <span class=\"label label-primary\">Streaming</span></td>"
  },
  {
    "sha": "737e18eae34d65c10ee27aa9005d0752650c6332",
    "filename": "flink-core/src/main/java/org/apache/flink/configuration/JobManagerOptions.java",
    "status": "modified",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-core/src/main/java/org/apache/flink/configuration/JobManagerOptions.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-core/src/main/java/org/apache/flink/configuration/JobManagerOptions.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-core/src/main/java/org/apache/flink/configuration/JobManagerOptions.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -411,6 +411,35 @@\n                                     .text(\n                                             \"Increasing this value will make the cluster more resilient against temporary resources shortages (e.g., there is more time for a failed TaskManager to be restarted), \"\n                                                     + \"while decreasing this value reduces downtime of a job (provided that enough slots are available to still run the job).\")\n+                                    .linebreak()\n+                                    .text(\n+                                            \"Setting a negative duration will disable the resource timeout: The JobManager will wait indefinitely for resources to appear.\")\n+                                    .linebreak()\n+                                    .text(\n+                                            \"If %s is configured to %s, this configuration value will default to a negative value to disable the resource timeout.\",\n+                                            code(SCHEDULER_MODE.key()),\n+                                            code(SchedulerExecutionMode.REACTIVE.name()))\n+                                    .build());\n+\n+    @Documentation.Section({\n+        Documentation.Sections.EXPERT_SCHEDULING,\n+        Documentation.Sections.ALL_JOB_MANAGER\n+    })\n+    public static final ConfigOption<Duration> RESOURCE_STABILIZATION_TIMEOUT =\n+            key(\"jobmanager.adaptive-scheduler.resource-stabilization-timeout\")\n+                    .durationType()\n+                    .defaultValue(RESOURCE_WAIT_TIMEOUT.defaultValue())\n+                    .withDescription(\n+                            Description.builder()\n+                                    .text(\n+                                            \"The resource stabilization timeout defines the time the JobManager will wait \"\n+                                                    + \"if fewer than the required resources are available, but sufficient resources for execution are there. \"\n+                                                    + \"Once this timeout has passed, the job will start executing with the available resources, or fail, if the resources are not sufficient. The timeout starts as soon as there are sufficient resources available for execution.\")\n+                                    .linebreak()\n+                                    .text(\n+                                            \"If %s is configured to %s, this configuration value will default to 0, so that jobs are starting immediately with the available resources.\",\n+                                            code(SCHEDULER_MODE.key()),\n+                                            code(SchedulerExecutionMode.REACTIVE.name()))\n                                     .build());\n \n     /**"
  },
  {
    "sha": "dfb6043b86fe5836ba8841f31315c184739a43bc",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactory.java",
    "status": "modified",
    "additions": 38,
    "deletions": 1,
    "changes": 39,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactory.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactory.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactory.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -22,8 +22,10 @@\n import org.apache.flink.api.common.JobID;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.ClusterOptions;\n+import org.apache.flink.configuration.ConfigOption;\n import org.apache.flink.configuration.Configuration;\n import org.apache.flink.configuration.JobManagerOptions;\n+import org.apache.flink.configuration.SchedulerExecutionMode;\n import org.apache.flink.runtime.akka.AkkaUtils;\n import org.apache.flink.runtime.blob.BlobWriter;\n import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;\n@@ -49,6 +51,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.time.Duration;\n import java.util.concurrent.ScheduledExecutorService;\n \n /** Default {@link SlotPoolServiceSchedulerFactory} implementation. */\n@@ -167,7 +170,8 @@ public static DefaultSlotPoolServiceSchedulerFactory fromConfiguration(\n                                     batchSlotTimeout);\n                     break;\n                 case Adaptive:\n-                    schedulerNGFactory = new AdaptiveSchedulerFactory();\n+                    schedulerNGFactory =\n+                            getAdaptiveSchedulerFactoryFromConfiguration(configuration);\n                     slotPoolServiceFactory =\n                             new DeclarativeSlotPoolServiceFactory(\n                                     SystemClock.getInstance(), slotIdleTimeout, rpcTimeout);\n@@ -193,4 +197,37 @@ public static DefaultSlotPoolServiceSchedulerFactory fromConfiguration(\n         return new DefaultSlotPoolServiceSchedulerFactory(\n                 slotPoolServiceFactory, schedulerNGFactory);\n     }\n+\n+    private static AdaptiveSchedulerFactory getAdaptiveSchedulerFactoryFromConfiguration(\n+            Configuration configuration) {\n+        Duration initialResourceAllocationTimeout =\n+                returnValueOrReplaceDefaultIfReactiveMode(\n+                        configuration,\n+                        JobManagerOptions.RESOURCE_WAIT_TIMEOUT,\n+                        Duration.ofMillis(-1));\n+        Duration resourceStabilizationTimeout =\n+                returnValueOrReplaceDefaultIfReactiveMode(\n+                        configuration,\n+                        JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT,\n+                        Duration.ZERO);\n+\n+        return new AdaptiveSchedulerFactory(\n+                initialResourceAllocationTimeout, resourceStabilizationTimeout);\n+    }\n+\n+    @VisibleForTesting\n+    protected static <T> T returnValueOrReplaceDefaultIfReactiveMode(\n+            Configuration configuration, ConfigOption<T> option, T replacement) {\n+        return configuration\n+                .getOptional(option)\n+                .orElseGet(\n+                        () -> {\n+                            if (configuration.get(JobManagerOptions.SCHEDULER_MODE)\n+                                    == SchedulerExecutionMode.REACTIVE) {\n+                                return replacement;\n+                            } else {\n+                                return option.defaultValue();\n+                            }\n+                        });\n+    }\n }"
  },
  {
    "sha": "c3fa96f92f9857cd61c4ab7f85bd338fceb2a849",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
    "status": "modified",
    "additions": 22,
    "deletions": 5,
    "changes": 27,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -23,7 +23,6 @@\n import org.apache.flink.api.common.JobStatus;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n-import org.apache.flink.configuration.JobManagerOptions;\n import org.apache.flink.metrics.Gauge;\n import org.apache.flink.queryablestate.KvStateID;\n import org.apache.flink.runtime.JobException;\n@@ -190,7 +189,9 @@\n \n     private final ScaleUpController scaleUpController;\n \n-    private final Duration resourceTimeout;\n+    private final Duration initialResourceAllocationTimeout;\n+\n+    private final Duration resourceStabilizationTimeout;\n \n     private State state = new Created(this, LOG);\n \n@@ -210,6 +211,8 @@ public AdaptiveScheduler(\n             ClassLoader userCodeClassLoader,\n             CheckpointRecoveryFactory checkpointRecoveryFactory,\n             Time rpcTimeout,\n+            Duration initialResourceAllocationTimeout,\n+            Duration resourceStabilizationTimeout,\n             BlobWriter blobWriter,\n             JobManagerJobMetricGroup jobManagerJobMetricGroup,\n             ShuffleMaster<?> shuffleMaster,\n@@ -263,7 +266,9 @@ public AdaptiveScheduler(\n \n         this.scaleUpController = new ReactiveScaleUpController(configuration);\n \n-        this.resourceTimeout = configuration.get(JobManagerOptions.RESOURCE_WAIT_TIMEOUT);\n+        this.initialResourceAllocationTimeout = initialResourceAllocationTimeout;\n+\n+        this.resourceStabilizationTimeout = resourceStabilizationTimeout;\n \n         registerMetrics();\n     }\n@@ -556,7 +561,7 @@ public void deliverOperatorEventToCoordinator(\n     // ----------------------------------------------------------------\n \n     @Override\n-    public boolean hasEnoughResources(ResourceCounter desiredResources) {\n+    public boolean hasDesiredResources(ResourceCounter desiredResources) {\n         final Collection<? extends SlotInfo> allSlots =\n                 declarativeSlotPool.getFreeSlotsInformation();\n         ResourceCounter outstandingResources = desiredResources;\n@@ -577,6 +582,13 @@ public boolean hasEnoughResources(ResourceCounter desiredResources) {\n         return outstandingResources.isEmpty();\n     }\n \n+    @Override\n+    public boolean hasSufficientResources() {\n+        return slotAllocator\n+                .determineParallelism(jobInformation, declarativeSlotPool.getAllSlotsInformation())\n+                .isPresent();\n+    }\n+\n     private <T extends VertexParallelism>\n             ParallelismAndResourceAssignments determineParallelismAndAssignResources(\n                     SlotAllocator<T> slotAllocator) throws JobExecutionException {\n@@ -721,7 +733,12 @@ public void goToWaitingForResources() {\n         declarativeSlotPool.setResourceRequirements(desiredResources);\n \n         transitionToState(\n-                new WaitingForResources.Factory(this, LOG, desiredResources, this.resourceTimeout));\n+                new WaitingForResources.Factory(\n+                        this,\n+                        LOG,\n+                        desiredResources,\n+                        this.initialResourceAllocationTimeout,\n+                        this.resourceStabilizationTimeout));\n     }\n \n     private ResourceCounter calculateDesiredResources() {"
  },
  {
    "sha": "ea28d35d2d650c5d8f2243a2780d903a4ae20cd4",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java",
    "status": "modified",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -40,11 +40,22 @@\n \n import org.slf4j.Logger;\n \n+import java.time.Duration;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ScheduledExecutorService;\n \n /** Factory for the adaptive scheduler. */\n public class AdaptiveSchedulerFactory implements SchedulerNGFactory {\n+\n+    private final Duration initialResourceAllocationTimeout;\n+    private final Duration resourceStabilizationTimeout;\n+\n+    public AdaptiveSchedulerFactory(\n+            Duration initialResourceAllocationTimeout, Duration resourceStabilizationTimeout) {\n+        this.initialResourceAllocationTimeout = initialResourceAllocationTimeout;\n+        this.resourceStabilizationTimeout = resourceStabilizationTimeout;\n+    }\n+\n     @Override\n     public SchedulerNG createInstance(\n             Logger log,\n@@ -97,6 +108,8 @@ public SchedulerNG createInstance(\n                 userCodeLoader,\n                 checkpointRecoveryFactory,\n                 rpcTimeout,\n+                initialResourceAllocationTimeout,\n+                resourceStabilizationTimeout,\n                 blobWriter,\n                 jobManagerJobMetricGroup,\n                 shuffleMaster,"
  },
  {
    "sha": "1c5736b46c1f60177bb9a5efbb04ad5d9756349d",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResources.java",
    "status": "modified",
    "additions": 70,
    "deletions": 11,
    "changes": 81,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResources.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResources.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResources.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -18,7 +18,9 @@\n \n package org.apache.flink.runtime.scheduler.adaptive;\n \n+import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Deadline;\n import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;\n import org.apache.flink.runtime.executiongraph.ExecutionGraph;\n import org.apache.flink.runtime.util.ResourceCounter;\n@@ -41,20 +43,35 @@\n \n     private final ResourceCounter desiredResources;\n \n+    /** If set, there's an ongoing deadline waiting for a resource stabilization. */\n+    @Nullable private Deadline resourceStabilizationDeadline;\n+\n+    private final Duration resourceStabilizationTimeout;\n+\n     WaitingForResources(\n             Context context,\n             Logger log,\n             ResourceCounter desiredResources,\n-            Duration resourceTimeout) {\n+            Duration initialResourceAllocationTimeout,\n+            Duration resourceStabilizationTimeout) {\n         this.context = Preconditions.checkNotNull(context);\n         this.log = Preconditions.checkNotNull(log);\n         this.desiredResources = Preconditions.checkNotNull(desiredResources);\n+        this.resourceStabilizationTimeout =\n+                Preconditions.checkNotNull(resourceStabilizationTimeout);\n+        Preconditions.checkNotNull(initialResourceAllocationTimeout);\n+\n         Preconditions.checkArgument(\n                 !desiredResources.isEmpty(), \"Desired resources must not be empty\");\n \n+        Preconditions.checkArgument(\n+                !resourceStabilizationTimeout.isNegative(),\n+                \"Resource stabilization timeout must not be negative\");\n+\n         // since state transitions are not allowed in state constructors, schedule calls for later.\n-        context.runIfState(\n-                this, this::resourceTimeout, Preconditions.checkNotNull(resourceTimeout));\n+        if (!initialResourceAllocationTimeout.isNegative()) {\n+            context.runIfState(this, this::resourceTimeout, initialResourceAllocationTimeout);\n+        }\n         context.runIfState(this, this::notifyNewResourcesAvailable, Duration.ZERO);\n     }\n \n@@ -90,13 +107,40 @@ public Logger getLogger() {\n \n     @Override\n     public void notifyNewResourcesAvailable() {\n-        if (context.hasEnoughResources(desiredResources)) {\n+        checkDesiredOrSufficientResourcesAvailable();\n+    }\n+\n+    private void checkDesiredOrSufficientResourcesAvailable() {\n+        if (context.hasDesiredResources(desiredResources)) {\n             createExecutionGraphWithAvailableResources();\n+            return;\n         }\n+\n+        if (context.hasSufficientResources()) {\n+            Deadline deadline = initializeOrGetResourceStabilizationDeadline();\n+            if (deadline.isOverdue()) {\n+                createExecutionGraphWithAvailableResources();\n+            } else {\n+                // schedule next resource check\n+                context.runIfState(\n+                        this,\n+                        this::checkDesiredOrSufficientResourcesAvailable,\n+                        deadline.timeLeft());\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    protected Deadline initializeOrGetResourceStabilizationDeadline() {\n+        if (resourceStabilizationDeadline == null) {\n+            resourceStabilizationDeadline = Deadline.fromNow(resourceStabilizationTimeout);\n+        }\n+        return resourceStabilizationDeadline;\n     }\n \n     private void resourceTimeout() {\n-        log.debug(\"Resource timeout triggered: Creating ExecutionGraph with available resources.\");\n+        log.debug(\n+                \"Initial resource allocation timeout triggered: Creating ExecutionGraph with available resources.\");\n         createExecutionGraphWithAvailableResources();\n     }\n \n@@ -145,12 +189,19 @@ ArchivedExecutionGraph getArchivedExecutionGraph(\n                 JobStatus jobStatus, @Nullable Throwable cause);\n \n         /**\n-         * Checks whether we have enough resources to fulfill the desired resources.\n+         * Checks whether we have the desired resources.\n          *\n          * @param desiredResources desiredResources describing the desired resources\n          * @return {@code true} if we have enough resources; otherwise {@code false}\n          */\n-        boolean hasEnoughResources(ResourceCounter desiredResources);\n+        boolean hasDesiredResources(ResourceCounter desiredResources);\n+\n+        /**\n+         * Checks if we currently have sufficient resources for executing the job.\n+         *\n+         * @return {@code true} if we have sufficient resources; otherwise {@code false}\n+         */\n+        boolean hasSufficientResources();\n \n         /**\n          * Creates an {@link ExecutionGraph} with the available resources.\n@@ -176,25 +227,33 @@ ArchivedExecutionGraph getArchivedExecutionGraph(\n         private final Context context;\n         private final Logger log;\n         private final ResourceCounter desiredResources;\n-        private final Duration resourceTimeout;\n+        private final Duration initialResourceAllocationTimeout;\n+        private final Duration resourceStabilizationTimeout;\n \n         public Factory(\n                 Context context,\n                 Logger log,\n                 ResourceCounter desiredResources,\n-                Duration resourceTimeout) {\n+                Duration initialResourceAllocationTimeout,\n+                Duration resourceStabilizationTimeout) {\n             this.context = context;\n             this.log = log;\n             this.desiredResources = desiredResources;\n-            this.resourceTimeout = resourceTimeout;\n+            this.initialResourceAllocationTimeout = initialResourceAllocationTimeout;\n+            this.resourceStabilizationTimeout = resourceStabilizationTimeout;\n         }\n \n         public Class<WaitingForResources> getStateClass() {\n             return WaitingForResources.class;\n         }\n \n         public WaitingForResources getState() {\n-            return new WaitingForResources(context, log, desiredResources, resourceTimeout);\n+            return new WaitingForResources(\n+                    context,\n+                    log,\n+                    desiredResources,\n+                    initialResourceAllocationTimeout,\n+                    resourceStabilizationTimeout);\n         }\n     }\n }"
  },
  {
    "sha": "4f6434fa94bce7a1059337682592fc69cecd2a09",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactoryTest.java",
    "status": "modified",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactoryTest.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactoryTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultSlotPoolServiceSchedulerFactoryTest.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -29,6 +29,8 @@\n \n import org.junit.Test;\n \n+import java.time.Duration;\n+\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertThat;\n@@ -71,4 +73,32 @@ public void testAdaptiveSchedulerForReactiveMode() {\n                 defaultSlotPoolServiceSchedulerFactory.getSchedulerType(),\n                 is(JobManagerOptions.SchedulerType.Adaptive));\n     }\n+\n+    @Test\n+    public void testReturnValueOrReplaceDefaultIfReactiveModeReturnsDefault() {\n+        Configuration emptyConfiguration = new Configuration();\n+\n+        Duration result =\n+                DefaultSlotPoolServiceSchedulerFactory.returnValueOrReplaceDefaultIfReactiveMode(\n+                        emptyConfiguration,\n+                        JobManagerOptions.RESOURCE_WAIT_TIMEOUT,\n+                        Duration.ofMillis(-1));\n+\n+        assertThat(result, is(JobManagerOptions.RESOURCE_WAIT_TIMEOUT.defaultValue()));\n+    }\n+\n+    @Test\n+    public void testReturnValueOrReplaceDefaultIfReactiveModeGetsReplaced() {\n+        Configuration reactiveConfiguration = new Configuration();\n+        reactiveConfiguration.set(\n+                JobManagerOptions.SCHEDULER_MODE, SchedulerExecutionMode.REACTIVE);\n+\n+        Duration result =\n+                DefaultSlotPoolServiceSchedulerFactory.returnValueOrReplaceDefaultIfReactiveMode(\n+                        reactiveConfiguration,\n+                        JobManagerOptions.RESOURCE_WAIT_TIMEOUT,\n+                        Duration.ofMillis(-1));\n+\n+        assertThat(result, is(Duration.ofMillis(-1)));\n+    }\n }"
  },
  {
    "sha": "e705c3b2b0d2a88a5e4f4f93d001dd823518c334",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -19,6 +19,7 @@\n \n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.configuration.JobManagerOptions;\n import org.apache.flink.runtime.blob.BlobWriter;\n import org.apache.flink.runtime.blob.VoidBlobWriter;\n import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;\n@@ -181,6 +182,8 @@ public AdaptiveScheduler build() throws Exception {\n                 userCodeLoader,\n                 checkpointRecoveryFactory,\n                 rpcTimeout,\n+                jobMasterConfiguration.get(JobManagerOptions.RESOURCE_WAIT_TIMEOUT),\n+                jobMasterConfiguration.get(JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT),\n                 blobWriter,\n                 jobManagerJobMetricGroup,\n                 shuffleMaster,"
  },
  {
    "sha": "05a54a503c49dde44dd46be5a62963d47908e1c8",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -171,7 +171,7 @@ public void testHasEnoughResourcesReturnsFalseIfUnsatisfied() throws Exception {\n         final ResourceCounter resourceRequirement =\n                 ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1);\n \n-        assertThat(scheduler.hasEnoughResources(resourceRequirement), is(false));\n+        assertThat(scheduler.hasDesiredResources(resourceRequirement), is(false));\n     }\n \n     @Test\n@@ -194,7 +194,7 @@ public void testHasEnoughResourcesReturnsTrueIfSatisfied() throws Exception {\n         offerSlots(\n                 declarativeSlotPool, createSlotOffersForResourceRequirements(resourceRequirement));\n \n-        assertThat(scheduler.hasEnoughResources(resourceRequirement), is(true));\n+        assertThat(scheduler.hasDesiredResources(resourceRequirement), is(true));\n     }\n \n     @Test\n@@ -220,7 +220,7 @@ public void testHasEnoughResourcesUsesUnmatchedSlotsAsUnknown() throws Exception\n \n         offerSlots(declarativeSlotPool, createSlotOffersForResourceRequirements(providedResources));\n \n-        assertThat(scheduler.hasEnoughResources(requiredResources), is(true));\n+        assertThat(scheduler.hasDesiredResources(requiredResources), is(true));\n     }\n \n     @Test"
  },
  {
    "sha": "9a279d05bc8c1a79647f9fbed767d3a1301ecab9",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StateValidator.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StateValidator.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StateValidator.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StateValidator.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -83,6 +83,6 @@ public final void expectNoStateTransition() {\n                         fail(\n                                 \"No consumer has been set for \"\n                                         + stateName\n-                                        + \". Unexpected state transition\");\n+                                        + \". Unexpected state transition (duplicate?)\");\n     }\n }"
  },
  {
    "sha": "f3e4bc0a724a2dc3cd1253a3b9e883560ae1aaac",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResourcesTest.java",
    "status": "modified",
    "additions": 211,
    "deletions": 27,
    "changes": 238,
    "blob_url": "https://github.com/apache/flink/blob/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResourcesTest.java",
    "raw_url": "https://github.com/apache/flink/raw/57d9b95fac95a649bd8295c294b77aeee5df12fc/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResourcesTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/WaitingForResourcesTest.java?ref=57d9b95fac95a649bd8295c294b77aeee5df12fc",
    "patch": "@@ -19,6 +19,7 @@\n package org.apache.flink.runtime.scheduler.adaptive;\n \n import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Deadline;\n import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;\n import org.apache.flink.runtime.executiongraph.ErrorInfo;\n@@ -31,18 +32,19 @@\n import org.apache.flink.util.function.SupplierWithException;\n \n import org.junit.Test;\n+import org.slf4j.Logger;\n \n import javax.annotation.Nullable;\n \n import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n \n import static org.hamcrest.CoreMatchers.is;\n import static org.hamcrest.CoreMatchers.notNullValue;\n-import static org.hamcrest.Matchers.greaterThan;\n import static org.junit.Assert.assertThat;\n import static org.junit.Assert.assertTrue;\n \n@@ -51,15 +53,18 @@\n     private static final ResourceCounter RESOURCE_COUNTER =\n             ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1);\n \n+    private static final Duration STABILIZATION_TIMEOUT = Duration.ofSeconds(1);\n+\n     /** WaitingForResources is transitioning to Executing if there are enough resources. */\n     @Test\n     public void testTransitionToExecuting() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> true);\n+            ctx.setHasDesiredResources(() -> true);\n \n             ctx.setExpectExecuting(assertNonNull());\n \n-            new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+            new WaitingForResources(\n+                    ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n             // run delayed actions\n             for (ScheduledRunnable scheduledRunnable : ctx.getScheduledRunnables()) {\n                 scheduledRunnable.runAction();\n@@ -73,7 +78,7 @@ public void testTransitionToExecuting() throws Exception {\n     @Test\n     public void testTransitionToFinishedOnExecutionGraphInitializationFailure() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> true);\n+            ctx.setHasDesiredResources(() -> true);\n             ctx.setCreateExecutionGraphWithAvailableResources(\n                     () -> {\n                         throw new RuntimeException(\"Test exception\");\n@@ -84,7 +89,8 @@ public void testTransitionToFinishedOnExecutionGraphInitializationFailure() thro\n                         assertThat(archivedExecutionGraph.getState(), is(JobStatus.FAILED));\n                     }));\n \n-            new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+            new WaitingForResources(\n+                    ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n \n             // run delayed actions\n             for (ScheduledRunnable scheduledRunnable : ctx.getScheduledRunnables()) {\n@@ -98,9 +104,10 @@ public void testTransitionToFinishedOnExecutionGraphInitializationFailure() thro\n     @Test\n     public void testNotEnoughResources() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false);\n+            ctx.setHasDesiredResources(() -> false);\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n \n             // we expect no state transition.\n             wfr.notifyNewResourcesAvailable();\n@@ -110,41 +117,187 @@ public void testNotEnoughResources() throws Exception {\n     @Test\n     public void testNotifyNewResourcesAvailable() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false); // initially, not enough resources\n+            ctx.setHasDesiredResources(() -> false); // initially, not enough resources\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n-            ctx.setHasEnoughResources(() -> true); // make resources available\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n+            ctx.setHasDesiredResources(() -> true); // make resources available\n             ctx.setExpectExecuting(assertNonNull());\n             wfr.notifyNewResourcesAvailable(); // .. and notify\n         }\n     }\n \n     @Test\n-    public void testResourceTimeout() throws Exception {\n+    public void testSchedulingWithSufficientResourcesAndNoStabilizationTimeout() throws Exception {\n+        try (MockContext ctx = new MockContext()) {\n+\n+            Duration noStabilizationTimeout = Duration.ofMillis(0);\n+            WaitingForResources wfr =\n+                    new WaitingForResources(\n+                            ctx,\n+                            log,\n+                            RESOURCE_COUNTER,\n+                            Duration.ofSeconds(1000),\n+                            noStabilizationTimeout);\n+\n+            ctx.setHasDesiredResources(() -> false);\n+            ctx.setHasSufficientResources(() -> true);\n+            ctx.setExpectExecuting(assertNonNull());\n+            wfr.notifyNewResourcesAvailable();\n+        }\n+    }\n+\n+    @Test\n+    public void testNoSchedulingIfStabilizationTimeoutIsConfigured() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false);\n+\n+            Duration stabilizationTimeout = Duration.ofMillis(50000);\n+\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+                    new WaitingForResources(\n+                            ctx,\n+                            log,\n+                            RESOURCE_COUNTER,\n+                            Duration.ofSeconds(1000),\n+                            stabilizationTimeout);\n+\n+            ctx.setHasDesiredResources(() -> false);\n+            ctx.setHasSufficientResources(() -> true);\n+            wfr.notifyNewResourcesAvailable();\n+            // we are not triggering the scheduled tasks, to simulate a long stabilization timeout\n+\n+            assertThat(ctx.hasStateTransition(), is(false));\n+        }\n+    }\n+\n+    @Test\n+    public void testSchedulingIfStabilizationTimeoutIsConfigured() throws Exception {\n+        try (MockContext ctx = new MockContext()) {\n+\n+            Duration initialResourceTimeout = Duration.ofMillis(120948);\n+            Duration stabilizationTimeout = Duration.ofMillis(50000);\n+\n+            TestingWaitingForResources wfr =\n+                    new TestingWaitingForResources(\n+                            ctx,\n+                            log,\n+                            RESOURCE_COUNTER,\n+                            initialResourceTimeout,\n+                            stabilizationTimeout);\n+\n+            // not enough resources available\n+            ctx.setHasDesiredResources(() -> false);\n+            ctx.setHasSufficientResources(() -> false);\n+\n+            assertNoStateTransitionsAfterExecutingRunnables(ctx, wfr);\n+\n+            // sufficient resources available\n+            ctx.setHasDesiredResources(() -> false);\n+            ctx.setHasSufficientResources(() -> true);\n+            wfr.setTestDeadline(Deadline.fromNow(Duration.ofDays(600)));\n \n             ctx.setExpectExecuting(assertNonNull());\n+            // start countdown\n+            wfr.notifyNewResourcesAvailable();\n+\n+            assertNoStateTransitionsAfterExecutingRunnables(ctx, wfr);\n+\n+            // advance time to now\n+            wfr.setTestDeadline(Deadline.now());\n \n-            // immediately execute all scheduled runnables\n-            assertThat(ctx.getScheduledRunnables().size(), greaterThan(0));\n+            // execute all runnables and trigger expected state transition\n             for (ScheduledRunnable scheduledRunnable : ctx.getScheduledRunnables()) {\n-                if (scheduledRunnable.getExpectedState() == wfr) {\n+                if (scheduledRunnable.getExpectedState() == wfr\n+                        && !scheduledRunnable.getDelay().equals(initialResourceTimeout)\n+                        && !scheduledRunnable.getDelay().equals(Duration.ZERO)) {\n                     scheduledRunnable.runAction();\n                 }\n             }\n         }\n     }\n \n+    private static void assertNoStateTransitionsAfterExecutingRunnables(\n+            MockContext ctx, WaitingForResources wfr) {\n+        Iterator<ScheduledRunnable> runnableIterator = ctx.getScheduledRunnables().iterator();\n+        while (runnableIterator.hasNext()) {\n+            ScheduledRunnable scheduledRunnable = runnableIterator.next();\n+            if (scheduledRunnable.getExpectedState() == wfr\n+                    && scheduledRunnable.getDeadline().isOverdue()) {\n+                scheduledRunnable.runAction();\n+                runnableIterator.remove();\n+            }\n+        }\n+        assertThat(ctx.hasStateTransition, is(false));\n+    }\n+\n+    private static class TestingWaitingForResources extends WaitingForResources {\n+\n+        private Deadline testDeadline;\n+\n+        TestingWaitingForResources(\n+                Context context,\n+                Logger log,\n+                ResourceCounter desiredResources,\n+                Duration initialResourceAllocationTimeout,\n+                Duration resourceStabilizationTimeout) {\n+            super(\n+                    context,\n+                    log,\n+                    desiredResources,\n+                    initialResourceAllocationTimeout,\n+                    resourceStabilizationTimeout);\n+        }\n+\n+        @Override\n+        protected Deadline initializeOrGetResourceStabilizationDeadline() {\n+            return testDeadline;\n+        }\n+\n+        public void setTestDeadline(Deadline testDeadline) {\n+            this.testDeadline = testDeadline;\n+        }\n+    }\n+\n+    @Test\n+    public void testNoStateTransitionOnNoResourceTimeout() throws Exception {\n+        try (MockContext ctx = new MockContext()) {\n+            ctx.setHasDesiredResources(() -> false);\n+            WaitingForResources wfr =\n+                    new WaitingForResources(\n+                            ctx,\n+                            log,\n+                            RESOURCE_COUNTER,\n+                            Duration.ofMillis(-1),\n+                            STABILIZATION_TIMEOUT);\n+\n+            executeAllScheduledRunnables(ctx, wfr);\n+\n+            assertThat(ctx.hasStateTransition(), is(false));\n+        }\n+    }\n+\n+    @Test\n+    public void testStateTransitionOnResourceTimeout() throws Exception {\n+        try (MockContext ctx = new MockContext()) {\n+            ctx.setHasDesiredResources(() -> false);\n+            WaitingForResources wfr =\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n+\n+            ctx.setExpectExecuting(assertNonNull());\n+\n+            executeAllScheduledRunnables(ctx, wfr);\n+        }\n+    }\n+\n     @Test\n     public void testTransitionToFinishedOnGlobalFailure() throws Exception {\n         final String testExceptionString = \"This is a test exception\";\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false);\n+            ctx.setHasDesiredResources(() -> false);\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n \n             ctx.setExpectFinished(\n                     archivedExecutionGraph -> {\n@@ -164,9 +317,10 @@ public void testTransitionToFinishedOnGlobalFailure() throws Exception {\n     @Test\n     public void testCancel() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false);\n+            ctx.setHasDesiredResources(() -> false);\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n \n             ctx.setExpectFinished(\n                     (archivedExecutionGraph -> {\n@@ -179,9 +333,10 @@ public void testCancel() throws Exception {\n     @Test\n     public void testSuspend() throws Exception {\n         try (MockContext ctx = new MockContext()) {\n-            ctx.setHasEnoughResources(() -> false);\n+            ctx.setHasDesiredResources(() -> false);\n             WaitingForResources wfr =\n-                    new WaitingForResources(ctx, log, RESOURCE_COUNTER, Duration.ZERO);\n+                    new WaitingForResources(\n+                            ctx, log, RESOURCE_COUNTER, Duration.ZERO, STABILIZATION_TIMEOUT);\n \n             ctx.setExpectFinished(\n                     (archivedExecutionGraph -> {\n@@ -193,14 +348,24 @@ public void testSuspend() throws Exception {\n         }\n     }\n \n+    private void executeAllScheduledRunnables(MockContext ctx, WaitingForResources expectedState) {\n+        for (ScheduledRunnable scheduledRunnable : ctx.getScheduledRunnables()) {\n+            if (scheduledRunnable.getExpectedState() == expectedState) {\n+                scheduledRunnable.runAction();\n+            }\n+        }\n+    }\n+\n     private static class MockContext implements WaitingForResources.Context, AutoCloseable {\n \n         private final StateValidator<ExecutionGraph> executingStateValidator =\n                 new StateValidator<>(\"executing\");\n         private final StateValidator<ArchivedExecutionGraph> finishedStateValidator =\n                 new StateValidator<>(\"finished\");\n \n-        private Supplier<Boolean> hasEnoughResourcesSupplier = () -> false;\n+        private Supplier<Boolean> hasDesiredResourcesSupplier = () -> false;\n+        private Supplier<Boolean> hasSufficientResourcesSupplier = () -> false;\n+\n         private SupplierWithException<ExecutionGraph, FlinkException>\n                 createExecutionGraphWithAvailableResources =\n                         () -> TestingDefaultExecutionGraphBuilder.newBuilder().build();\n@@ -211,8 +376,12 @@ public void testSuspend() throws Exception {\n             return scheduledRunnables;\n         }\n \n-        public void setHasEnoughResources(Supplier<Boolean> sup) {\n-            hasEnoughResourcesSupplier = sup;\n+        public void setHasDesiredResources(Supplier<Boolean> sup) {\n+            hasDesiredResourcesSupplier = sup;\n+        }\n+\n+        public void setHasSufficientResources(Supplier<Boolean> sup) {\n+            hasSufficientResourcesSupplier = sup;\n         }\n \n         public void setCreateExecutionGraphWithAvailableResources(\n@@ -244,8 +413,13 @@ public ArchivedExecutionGraph getArchivedExecutionGraph(\n         }\n \n         @Override\n-        public boolean hasEnoughResources(ResourceCounter desiredResources) {\n-            return hasEnoughResourcesSupplier.get();\n+        public boolean hasDesiredResources(ResourceCounter desiredResources) {\n+            return hasDesiredResourcesSupplier.get();\n+        }\n+\n+        @Override\n+        public boolean hasSufficientResources() {\n+            return hasSufficientResourcesSupplier.get();\n         }\n \n         @Override\n@@ -279,11 +453,13 @@ public boolean hasStateTransition() {\n         private final Runnable action;\n         private final State expectedState;\n         private final Duration delay;\n+        private final Deadline deadline;\n \n         private ScheduledRunnable(State expectedState, Runnable action, Duration delay) {\n             this.expectedState = expectedState;\n             this.action = action;\n             this.delay = delay;\n+            this.deadline = Deadline.fromNow(delay);\n         }\n \n         public void runAction() {\n@@ -293,6 +469,14 @@ public void runAction() {\n         public State getExpectedState() {\n             return expectedState;\n         }\n+\n+        public Duration getDelay() {\n+            return delay;\n+        }\n+\n+        public Deadline getDeadline() {\n+            return deadline;\n+        }\n     }\n \n     static <T> Consumer<T> assertNonNull() {"
  }
]
