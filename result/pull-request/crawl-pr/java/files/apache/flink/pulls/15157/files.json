[
  {
    "sha": "29a4bd50f748eb1f82b9ff61b49ee422f43f0d84",
    "filename": "flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/AdaptivePollingRecordPublisher.java",
    "status": "modified",
    "additions": 8,
    "deletions": 34,
    "changes": 42,
    "blob_url": "https://github.com/apache/flink/blob/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/AdaptivePollingRecordPublisher.java",
    "raw_url": "https://github.com/apache/flink/raw/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/AdaptivePollingRecordPublisher.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/AdaptivePollingRecordPublisher.java?ref=a932fc2f5948ac184d5de4d9e610ff91b101493d",
    "patch": "@@ -26,9 +26,9 @@\n import org.apache.flink.streaming.connectors.kinesis.proxy.KinesisProxyInterface;\n \n /**\n- * An adaptive record publisher to add a dynamic loop delay and batch read size for {@link\n- * PollingRecordPublisher}. Kinesis Streams have quotas on the transactions per second, and\n- * throughout. This class attempts to balance quotas and mitigate back off errors.\n+ * An adaptive record publisher to add a dynamic batch read size for {@link PollingRecordPublisher}.\n+ * Kinesis Streams have quotas on the transactions per second, and throughout. This class attempts\n+ * to balance quotas and mitigate back off errors.\n  */\n @Internal\n public class AdaptivePollingRecordPublisher extends PollingRecordPublisher {\n@@ -44,8 +44,6 @@\n \n     private int maxNumberOfRecordsPerFetch;\n \n-    private final long fetchIntervalMillis;\n-\n     private final PollingRecordPublisherMetricsReporter metricsReporter;\n \n     AdaptivePollingRecordPublisher(\n@@ -64,7 +62,6 @@\n                 maxNumberOfRecordsPerFetch,\n                 fetchIntervalMillis);\n         this.maxNumberOfRecordsPerFetch = maxNumberOfRecordsPerFetch;\n-        this.fetchIntervalMillis = fetchIntervalMillis;\n         this.metricsReporter = metricsReporter;\n     }\n \n@@ -81,42 +78,19 @@ public RecordPublisherRunResult run(final RecordBatchConsumer consumer)\n                         },\n                         maxNumberOfRecordsPerFetch);\n \n-        long adjustmentEndTimeNanos =\n-                adjustRunLoopFrequency(processingStartTimeNanos, System.nanoTime());\n-        long runLoopTimeNanos = adjustmentEndTimeNanos - processingStartTimeNanos;\n+        long endTimeNanos = System.nanoTime();\n+        long runLoopTimeNanos = endTimeNanos - processingStartTimeNanos;\n+\n         maxNumberOfRecordsPerFetch =\n                 adaptRecordsToRead(\n                         runLoopTimeNanos,\n                         lastRecordBatchSize,\n                         lastRecordBatchSizeInBytes,\n                         maxNumberOfRecordsPerFetch);\n-        processingStartTimeNanos = adjustmentEndTimeNanos;\n-        metricsReporter.setRunLoopTimeNanos(runLoopTimeNanos);\n \n-        return result;\n-    }\n+        processingStartTimeNanos = endTimeNanos;\n \n-    /**\n-     * Adjusts loop timing to match target frequency if specified.\n-     *\n-     * @param processingStartTimeNanos The start time of the run loop \"work\"\n-     * @param processingEndTimeNanos The end time of the run loop \"work\"\n-     * @return The System.nanoTime() after the sleep (if any)\n-     * @throws InterruptedException\n-     */\n-    private long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)\n-            throws InterruptedException {\n-        long endTimeNanos = processingEndTimeNanos;\n-        if (fetchIntervalMillis != 0) {\n-            long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos;\n-            long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000);\n-            if (sleepTimeMillis > 0) {\n-                Thread.sleep(sleepTimeMillis);\n-                endTimeNanos = System.nanoTime();\n-                metricsReporter.setSleepTimeMillis(sleepTimeMillis);\n-            }\n-        }\n-        return endTimeNanos;\n+        return result;\n     }\n \n     /**"
  },
  {
    "sha": "70e48a4ab5cb179c9e44defe1b539a70d7243d9b",
    "filename": "flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java",
    "status": "modified",
    "additions": 40,
    "deletions": 8,
    "changes": 48,
    "blob_url": "https://github.com/apache/flink/blob/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java",
    "raw_url": "https://github.com/apache/flink/raw/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java?ref=a932fc2f5948ac184d5de4d9e610ff91b101493d",
    "patch": "@@ -60,7 +60,9 @@\n \n     private final int maxNumberOfRecordsPerFetch;\n \n-    private final long expiredIteratorBackoffMillis;\n+    private final long fetchIntervalMillis;\n+\n+    private long processingStartTimeNanos = System.nanoTime();\n \n     /**\n      * A Polling implementation of {@link RecordPublisher} that polls kinesis for records. The\n@@ -71,25 +73,24 @@\n      * @param metricsReporter a metric reporter used to output metrics\n      * @param kinesisProxy the proxy used to communicate with kinesis\n      * @param maxNumberOfRecordsPerFetch the maximum number of records to retrieve per batch\n-     * @param expiredIteratorBackoffMillis the duration to sleep in the event of an {@link\n-     *     ExpiredIteratorException}\n+     * @param fetchIntervalMillis the target interval between each GetRecords invocation\n      */\n     PollingRecordPublisher(\n             final StartingPosition startingPosition,\n             final StreamShardHandle subscribedShard,\n             final PollingRecordPublisherMetricsReporter metricsReporter,\n             final KinesisProxyInterface kinesisProxy,\n             final int maxNumberOfRecordsPerFetch,\n-            final long expiredIteratorBackoffMillis)\n+            final long fetchIntervalMillis)\n             throws InterruptedException {\n         this.nextStartingPosition = Preconditions.checkNotNull(startingPosition);\n         this.subscribedShard = Preconditions.checkNotNull(subscribedShard);\n         this.metricsReporter = Preconditions.checkNotNull(metricsReporter);\n         this.kinesisProxy = Preconditions.checkNotNull(kinesisProxy);\n         this.maxNumberOfRecordsPerFetch = maxNumberOfRecordsPerFetch;\n-        this.expiredIteratorBackoffMillis = expiredIteratorBackoffMillis;\n+        this.fetchIntervalMillis = fetchIntervalMillis;\n \n-        Preconditions.checkArgument(expiredIteratorBackoffMillis >= 0);\n+        Preconditions.checkArgument(fetchIntervalMillis >= 0);\n         Preconditions.checkArgument(maxNumberOfRecordsPerFetch > 0);\n \n         this.nextShardItr = getShardIterator();\n@@ -118,6 +119,14 @@ public RecordPublisherRunResult run(final RecordBatchConsumer consumer, int maxN\n \n         nextStartingPosition = getNextStartingPosition(latestSequenceNumber);\n         nextShardItr = result.getNextShardIterator();\n+\n+        long adjustmentEndTimeNanos =\n+                adjustRunLoopFrequency(processingStartTimeNanos, System.nanoTime());\n+        long runLoopTimeNanos = adjustmentEndTimeNanos - processingStartTimeNanos;\n+\n+        processingStartTimeNanos = adjustmentEndTimeNanos;\n+        metricsReporter.setRunLoopTimeNanos(runLoopTimeNanos);\n+\n         return nextShardItr == null ? COMPLETE : INCOMPLETE;\n     }\n \n@@ -168,8 +177,8 @@ private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords)\n \n                 // sleep for the fetch interval before the next getRecords attempt with the\n                 // refreshed iterator\n-                if (expiredIteratorBackoffMillis != 0) {\n-                    Thread.sleep(expiredIteratorBackoffMillis);\n+                if (fetchIntervalMillis != 0) {\n+                    Thread.sleep(fetchIntervalMillis);\n                 }\n             }\n         }\n@@ -188,4 +197,27 @@ private String getShardIterator() throws InterruptedException {\n                 nextStartingPosition.getShardIteratorType().toString(),\n                 nextStartingPosition.getStartingMarker());\n     }\n+\n+    /**\n+     * Adjusts loop timing to match target frequency if specified.\n+     *\n+     * @param processingStartTimeNanos The start time of the run loop \"work\"\n+     * @param processingEndTimeNanos The end time of the run loop \"work\"\n+     * @return The System.nanoTime() after the sleep (if any)\n+     * @throws InterruptedException\n+     */\n+    private long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)\n+            throws InterruptedException {\n+        long endTimeNanos = processingEndTimeNanos;\n+        if (fetchIntervalMillis != 0) {\n+            long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos;\n+            long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000);\n+            if (sleepTimeMillis > 0) {\n+                Thread.sleep(sleepTimeMillis);\n+                endTimeNanos = System.nanoTime();\n+                metricsReporter.setSleepTimeMillis(sleepTimeMillis);\n+            }\n+        }\n+        return endTimeNanos;\n+    }\n }"
  },
  {
    "sha": "aadcc17cdda793e6d02bcb24724a1a6b6660b8cb",
    "filename": "flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisherTest.java",
    "status": "modified",
    "additions": 27,
    "deletions": 2,
    "changes": 29,
    "blob_url": "https://github.com/apache/flink/blob/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisherTest.java",
    "raw_url": "https://github.com/apache/flink/raw/a932fc2f5948ac184d5de4d9e610ff91b101493d/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisherTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisherTest.java?ref=a932fc2f5948ac184d5de4d9e610ff91b101493d",
    "patch": "@@ -34,6 +34,7 @@\n import static org.apache.flink.streaming.connectors.kinesis.model.SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM;\n import static org.apache.flink.streaming.connectors.kinesis.testutils.FakeKinesisBehavioursFactory.totalNumOfRecordsAfterNumOfGetRecordsCalls;\n import static org.junit.Assert.assertEquals;\n+import static org.mockito.AdditionalMatchers.gt;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n@@ -43,6 +44,8 @@\n /** Tests for {@link PollingRecordPublisher}. */\n public class PollingRecordPublisherTest {\n \n+    private static final long FETCH_INTERVAL_MILLIS = 500L;\n+\n     @Rule public ExpectedException thrown = ExpectedException.none();\n \n     @Test\n@@ -58,6 +61,21 @@ public void testRunPublishesRecordsToConsumer() throws Exception {\n         assertEquals(100L, consumer.getRecordBatches().get(0).getMillisBehindLatest(), 0);\n     }\n \n+    @Test\n+    public void testRunEmitsRunLoopTimeNanos() throws Exception {\n+        PollingRecordPublisherMetricsReporter metricsReporter =\n+                spy(new PollingRecordPublisherMetricsReporter(mock(MetricGroup.class)));\n+\n+        KinesisProxyInterface fakeKinesis = totalNumOfRecordsAfterNumOfGetRecordsCalls(5, 5, 100);\n+        PollingRecordPublisher recordPublisher =\n+                createPollingRecordPublisher(fakeKinesis, metricsReporter);\n+\n+        recordPublisher.run(new TestConsumer());\n+\n+        // Expect that the run loop took at least FETCH_INTERVAL_MILLIS in nanos\n+        verify(metricsReporter).setRunLoopTimeNanos(gt(FETCH_INTERVAL_MILLIS * 1000));\n+    }\n+\n     @Test\n     public void testRunReturnsCompleteWhenShardExpires() throws Exception {\n         // There are 2 batches available in the stream\n@@ -136,12 +154,19 @@ PollingRecordPublisher createPollingRecordPublisher(final KinesisProxyInterface\n         PollingRecordPublisherMetricsReporter metricsReporter =\n                 new PollingRecordPublisherMetricsReporter(mock(MetricGroup.class));\n \n+        return createPollingRecordPublisher(kinesis, metricsReporter);\n+    }\n+\n+    PollingRecordPublisher createPollingRecordPublisher(\n+            final KinesisProxyInterface kinesis,\n+            final PollingRecordPublisherMetricsReporter metricGroupReporter)\n+            throws Exception {\n         return new PollingRecordPublisher(\n                 StartingPosition.restartFromSequenceNumber(SENTINEL_EARLIEST_SEQUENCE_NUM.get()),\n                 TestUtils.createDummyStreamShardHandle(),\n-                metricsReporter,\n+                metricGroupReporter,\n                 kinesis,\n                 10000,\n-                500L);\n+                FETCH_INTERVAL_MILLIS);\n     }\n }"
  }
]
