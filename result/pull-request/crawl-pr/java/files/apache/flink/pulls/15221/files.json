[
  {
    "sha": "89641b1922b820b48ec722a430c4c13ba78d945a",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/execution/ExecutionState.java",
    "status": "modified",
    "additions": 8,
    "deletions": 5,
    "changes": 13,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/execution/ExecutionState.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/execution/ExecutionState.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/execution/ExecutionState.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -23,17 +23,17 @@\n  * the state {@code CREATED} and switch states according to this diagram:\n  *\n  * <pre>{@code\n- *  CREATED  -> SCHEDULED -> DEPLOYING -> RUNNING -> FINISHED\n- *     |            |            |          |\n- *     |            |            |   +------+\n- *     |            |            V   V\n+ *  CREATED  -> SCHEDULED -> DEPLOYING -> RECOVERING -> RUNNING -> FINISHED\n+ *     |            |            |          |              |\n+ *     |            |            |    +-----+--------------+\n+ *     |            |            V    V\n  *     |            |         CANCELLING -----+----> CANCELED\n  *     |            |                         |\n  *     |            +-------------------------+\n  *     |\n  *     |                                   ... -> FAILED\n  *     V\n- * RECONCILING  -> RUNNING | FINISHED | CANCELED | FAILED\n+ * RECONCILING  -> RECOVERING | RUNNING | FINISHED | CANCELED | FAILED\n  *\n  * }</pre>\n  *\n@@ -52,6 +52,9 @@\n \n     DEPLOYING,\n \n+    /** Restoring last possible valid state of the task if it has it. */\n+    RECOVERING,\n+\n     RUNNING,\n \n     /**"
  },
  {
    "sha": "65ed77fb01b488889f99baf7b835692fc7336b85",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java",
    "status": "modified",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -291,4 +291,16 @@ public void dispatchOperatorEvent(OperatorID operator, SerializedValue<OperatorE\n         throw new UnsupportedOperationException(\n                 \"dispatchOperatorEvent not supported by \" + getClass().getName());\n     }\n+\n+    /**\n+     * This method can be called before {@link #invoke()} to restore an invokable object for the\n+     * last valid state, if it has it.\n+     *\n+     * <p>Every implementation determinate what should be restored by itself. (nothing happens by\n+     * default).\n+     *\n+     * @throws Exception Tasks may forward their exceptions for the TaskManager to handle through\n+     *     failure/recovery.\n+     */\n+    public void restore() throws Exception {}\n }"
  },
  {
    "sha": "68d07d17f28778985c20363f8b65ec72140949ea",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java",
    "status": "modified",
    "additions": 14,
    "deletions": 2,
    "changes": 16,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -737,9 +737,21 @@ private void doRun() {\n             // by the time we switched to running.\n             this.invokable = invokable;\n \n-            // switch to the RUNNING state, if that fails, we have been canceled/failed in the\n+            // switch to the RECOVERING state, if that fails, we have been canceled/failed in the\n             // meantime\n-            if (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\n+            if (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RECOVERING)) {\n+                throw new CancelTaskException();\n+            }\n+\n+            FlinkSecurityManager.monitorUserSystemExitForCurrentThread();\n+            try {\n+                // Restore invokable data to the last valid state\n+                invokable.restore();\n+            } finally {\n+                FlinkSecurityManager.unmonitorUserSystemExitForCurrentThread();\n+            }\n+\n+            if (!transitionState(ExecutionState.RECOVERING, ExecutionState.RUNNING)) {\n                 throw new CancelTaskException();\n             }\n "
  },
  {
    "sha": "8aac3640c98980e2e22880e3bbd9221277f09b8d",
    "filename": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java",
    "status": "modified",
    "additions": 79,
    "deletions": 43,
    "changes": 122,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -44,6 +44,7 @@\n import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n import org.apache.flink.runtime.io.network.api.writer.SingleRecordWriter;\n import org.apache.flink.runtime.io.network.partition.ChannelStateHolder;\n+import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;\n import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n import org.apache.flink.runtime.jobgraph.OperatorID;\n import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n@@ -81,6 +82,7 @@\n import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxDefaultAction.Suspension;\n import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxExecutorFactory;\n import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxProcessor;\n+import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxProcessor.SuspendableMailboxLoop;\n import org.apache.flink.streaming.runtime.tasks.mailbox.TaskMailbox;\n import org.apache.flink.streaming.runtime.tasks.mailbox.TaskMailboxImpl;\n import org.apache.flink.util.ExceptionUtils;\n@@ -212,6 +214,9 @@\n      */\n     private volatile boolean isRunning;\n \n+    /** Flag to mark that the state of current task was restored successfully. */\n+    private volatile boolean restored;\n+\n     /** Flag to mark this task as canceled. */\n     private volatile boolean canceled;\n \n@@ -517,7 +522,8 @@ protected Counter setupNumRecordsInCounter(StreamOperator streamOperator) {\n         }\n     }\n \n-    protected void beforeInvoke() throws Exception {\n+    @Override\n+    public void restore() throws Exception {\n         disposedOperators = false;\n         LOG.debug(\"Initializing {}.\", getName());\n \n@@ -528,70 +534,94 @@ protected void beforeInvoke() throws Exception {\n         init();\n \n         // save the work of reloading state, etc, if the task is already canceled\n-        if (canceled) {\n-            throw new CancelTaskException();\n-        }\n+        ensureNotCanceled();\n \n         // -------- Invoke --------\n         LOG.debug(\"Invoking {}\", getName());\n \n+        SuspendableMailboxLoop suspendableLoop = mailboxProcessor.getSuspendableLoop();\n+\n         // we need to make sure that any triggers scheduled in open() cannot be\n         // executed before all operators are opened\n-        actionExecutor.runThrowing(\n-                () -> {\n-                    SequentialChannelStateReader reader =\n-                            getEnvironment()\n-                                    .getTaskStateManager()\n-                                    .getSequentialChannelStateReader();\n-                    reader.readOutputData(\n-                            getEnvironment().getAllWriters(),\n-                            !configuration.isGraphContainingLoops());\n-\n-                    operatorChain.initializeStateAndOpenOperators(\n-                            createStreamTaskStateInitializer());\n-\n-                    channelIOExecutor.execute(\n-                            () -> {\n-                                try {\n-                                    reader.readInputData(getEnvironment().getAllInputGates());\n-                                } catch (Exception e) {\n-                                    asyncExceptionHandler.handleAsyncException(\n-                                            \"Unable to read channel state\", e);\n-                                }\n-                            });\n+        CompletableFuture<Void> allGatesRecoveredFuture =\n+                actionExecutor.call(\n+                        () -> {\n+                            SequentialChannelStateReader reader =\n+                                    getEnvironment()\n+                                            .getTaskStateManager()\n+                                            .getSequentialChannelStateReader();\n+                            reader.readOutputData(\n+                                    getEnvironment().getAllWriters(),\n+                                    !configuration.isGraphContainingLoops());\n+\n+                            operatorChain.initializeStateAndOpenOperators(\n+                                    createStreamTaskStateInitializer());\n+\n+                            return restoreInputGatesStateAsync(suspendableLoop, reader);\n+                        });\n+\n+        // Run mailbox until all gates will be recovered.\n+        while (isMailboxLoopRunning() && !allGatesRecoveredFuture.isDone()) {\n+            suspendableLoop.run();\n+        }\n \n-                    for (InputGate inputGate : getEnvironment().getAllInputGates()) {\n-                        inputGate\n-                                .getStateConsumedFuture()\n-                                .thenRun(\n-                                        () ->\n-                                                mainMailboxExecutor.execute(\n-                                                        inputGate::requestPartitions,\n-                                                        \"Input gate request partitions\"));\n+        ensureNotCanceled();\n+\n+        if (!allGatesRecoveredFuture.isDone()) {\n+            throw new Exception(\"Mailbox loop interrupted before recovery was finished.\");\n+        }\n+\n+        restored = true;\n+    }\n+\n+    private CompletableFuture<Void> restoreInputGatesStateAsync(\n+            SuspendableMailboxLoop suspendableLoop, SequentialChannelStateReader reader) {\n+        IndexedInputGate[] inputGates = getEnvironment().getAllInputGates();\n+        channelIOExecutor.execute(\n+                () -> {\n+                    try {\n+                        reader.readInputData(inputGates);\n+                    } catch (Exception e) {\n+                        asyncExceptionHandler.handleAsyncException(\n+                                \"Unable to read channel state\", e);\n                     }\n                 });\n \n-        isRunning = true;\n+        List<CompletableFuture<?>> recoveredFutures = new ArrayList<>(inputGates.length);\n+        for (InputGate inputGate : inputGates) {\n+            recoveredFutures.add(inputGate.getStateConsumedFuture());\n+\n+            inputGate\n+                    .getStateConsumedFuture()\n+                    .thenRun(\n+                            () ->\n+                                    mainMailboxExecutor.execute(\n+                                            inputGate::requestPartitions,\n+                                            \"Input gate request partitions\"));\n+        }\n+\n+        return CompletableFuture.allOf(recoveredFutures.toArray(new CompletableFuture[0]))\n+                .thenRun(suspendableLoop::suspend);\n     }\n \n     @Override\n     public final void invoke() throws Exception {\n-        try {\n-            beforeInvoke();\n+        if (!restored) {\n+            throw new Exception(\"Could not perform the task because the state wasn't restored.\");\n+        }\n \n+        try {\n             // final check to exit early before starting to run\n-            if (canceled) {\n-                throw new CancelTaskException();\n-            }\n+            ensureNotCanceled();\n+\n+            isRunning = true;\n \n             // let the task do its work\n             runMailboxLoop();\n \n             // if this left the run() method cleanly despite the fact that this was canceled,\n             // make sure the \"clean shutdown\" is not attempted\n-            if (canceled) {\n-                throw new CancelTaskException();\n-            }\n+            ensureNotCanceled();\n \n             afterInvoke();\n         } catch (Throwable invokeException) {\n@@ -610,6 +640,12 @@ public final void invoke() throws Exception {\n         cleanUpInvoke();\n     }\n \n+    private void ensureNotCanceled() {\n+        if (canceled) {\n+            throw new CancelTaskException();\n+        }\n+    }\n+\n     @VisibleForTesting\n     public boolean runMailboxStep() throws Exception {\n         return mailboxProcessor.runMailboxStep();"
  },
  {
    "sha": "f70a4bbb6072d274ab9861d73f76ddb5cf7ae6ad",
    "filename": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java",
    "status": "modified",
    "additions": 59,
    "deletions": 7,
    "changes": 66,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -79,9 +79,19 @@\n      */\n     protected final MailboxDefaultAction mailboxDefaultAction;\n \n-    /** Control flag to terminate the mailbox loop. Must only be accessed from mailbox thread. */\n+    /**\n+     * Control flag to terminate the mailbox loop. Once it was terminated could not be restarted\n+     * again. Must only be accessed from mailbox thread.\n+     */\n     private boolean mailboxLoopRunning;\n \n+    /**\n+     * Control flag to terminate the current mailbox loop. This allows to interrupt the suspendable\n+     * loop even if not all actions were completed. This flag can be restarted as many times as\n+     * {@link #mailboxLoopRunning} is active. Must only be accessed from mailbox thread.\n+     */\n+    private boolean suspendableMailboxLoopRunning;\n+\n     /**\n      * Remembers a currently active suspension of the default action. Serves as flag to indicate a\n      * suspended default action (suspended if not-null) and to reuse the object as return value in\n@@ -170,8 +180,24 @@ public void drain() throws Exception {\n         }\n     }\n \n+    /** Provide the API for management of the mailbox loop which can be suspended. */\n+    public SuspendableMailboxLoop getSuspendableLoop() {\n+        return new SuspendableMailboxLoop();\n+    }\n+\n     /** Runs the mailbox processing loop. This is where the main work is done. */\n     public void runMailboxLoop() throws Exception {\n+        // Do the work until all actions completed and ignore the interruption.\n+        while (isMailboxLoopRunning()) {\n+            runSuspendableMailboxLoop();\n+        }\n+    }\n+\n+    /**\n+     * Runs the mailbox processing loop which can be suspended and then continued on one more call.\n+     */\n+    private void runSuspendableMailboxLoop() throws Exception {\n+        suspendableMailboxLoopRunning = isMailboxLoopRunning();\n \n         final TaskMailbox localMailbox = mailbox;\n \n@@ -183,10 +209,10 @@ public void runMailboxLoop() throws Exception {\n \n         final MailboxController defaultActionContext = new MailboxController(this);\n \n-        while (isMailboxLoopRunning()) {\n+        while (isSuspendableMailboxLoopRunning()) {\n             // The blocking `processMail` call will not return until default action is available.\n             processMail(localMailbox, false);\n-            if (isMailboxLoopRunning()) {\n+            if (isSuspendableMailboxLoopRunning()) {\n                 mailboxDefaultAction.runDefaultAction(\n                         defaultActionContext); // lock is acquired inside default action as needed\n             }\n@@ -200,10 +226,12 @@ public void runMailboxLoop() throws Exception {\n      */\n     @VisibleForTesting\n     public boolean runMailboxStep() throws Exception {\n+        suspendableMailboxLoopRunning = isMailboxLoopRunning();\n+\n         if (processMail(mailbox, true)) {\n             return true;\n         }\n-        if (!isDefaultActionUnavailable() && isMailboxLoopRunning()) {\n+        if (!isDefaultActionUnavailable() && isSuspendableMailboxLoopRunning()) {\n             mailboxDefaultAction.runDefaultAction(new MailboxController(this));\n             return true;\n         }\n@@ -245,13 +273,18 @@ public void reportThrowable(Throwable throwable) {\n      * performed.\n      */\n     public void allActionsCompleted() {\n+        sendPoisonMail(() -> suspendableMailboxLoopRunning = mailboxLoopRunning = false);\n+    }\n+\n+    /** Send mail in first priority for internal needs. */\n+    private void sendPoisonMail(RunnableWithException mail) {\n         mailbox.runExclusively(\n                 () -> {\n                     // keep state check and poison mail enqueuing atomic, such that no intermediate\n                     // #close may cause a\n                     // MailboxStateException in #sendPriorityMail.\n                     if (mailbox.getState() == TaskMailbox.State.OPEN) {\n-                        sendControlMail(() -> mailboxLoopRunning = false, \"poison mail\");\n+                        sendControlMail(mail, \"poison mail\");\n                     }\n                 });\n     }\n@@ -305,7 +338,7 @@ private boolean processMail(TaskMailbox mailbox, boolean singleStep) throws Exce\n     private boolean processMailsWhenDefaultActionUnavailable() throws Exception {\n         boolean processedSomething = false;\n         Optional<Mail> maybeMail;\n-        while (isDefaultActionUnavailable() && isMailboxLoopRunning()) {\n+        while (isDefaultActionUnavailable() && isSuspendableMailboxLoopRunning()) {\n             maybeMail = mailbox.tryTake(MIN_PRIORITY);\n             if (!maybeMail.isPresent()) {\n                 maybeMail = Optional.of(mailbox.take(MIN_PRIORITY));\n@@ -322,7 +355,8 @@ private boolean processMailsNonBlocking(boolean singleStep) throws Exception {\n         long processedMails = 0;\n         Optional<Mail> maybeMail;\n \n-        while (isMailboxLoopRunning() && (maybeMail = mailbox.tryTakeFromBatch()).isPresent()) {\n+        while (isSuspendableMailboxLoopRunning()\n+                && (maybeMail = mailbox.tryTakeFromBatch()).isPresent()) {\n             if (processedMails++ == 0) {\n                 maybePauseIdleTimer();\n             }\n@@ -381,6 +415,10 @@ public boolean isMailboxLoopRunning() {\n         return mailboxLoopRunning;\n     }\n \n+    private boolean isSuspendableMailboxLoopRunning() {\n+        return suspendableMailboxLoopRunning;\n+    }\n+\n     @VisibleForTesting\n     public boolean hasMail() {\n         return mailbox.hasMail();\n@@ -457,4 +495,18 @@ private void resumeInternal() {\n             }\n         }\n     }\n+\n+    /** Isolated API for providing an opportunity to run the mailbox loop which can be suspended. */\n+    public final class SuspendableMailboxLoop {\n+\n+        /** Runs the mailbox loop which can be suspended by {@link #suspend()}. */\n+        public void run() throws Exception {\n+            runSuspendableMailboxLoop();\n+        }\n+\n+        /** Suspend the running of the loop which was started by {@link #run()}. */\n+        public void suspend() {\n+            sendPoisonMail(() -> suspendableMailboxLoopRunning = false);\n+        }\n+    }\n }"
  },
  {
    "sha": "d70bfb18953d2b28c4d425792fde0fcfe0e85ad4",
    "filename": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarnessBuilder.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/flink/blob/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarnessBuilder.java",
    "raw_url": "https://github.com/apache/flink/raw/6a5cd4a070363effea250079225e29a0aaaa92b6/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarnessBuilder.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarnessBuilder.java?ref=6a5cd4a070363effea250079225e29a0aaaa92b6",
    "patch": "@@ -163,7 +163,7 @@ public StreamTaskMailboxTestHarnessBuilder(\n         streamMockEnvironment.setTaskMetricGroup(taskMetricGroup);\n \n         StreamTask<OUT, ?> task = taskFactory.apply(streamMockEnvironment);\n-        task.beforeInvoke();\n+        task.restore();\n \n         return new StreamTaskMailboxTestHarness<>(\n                 task, outputList, inputGates, streamMockEnvironment);"
  }
]
