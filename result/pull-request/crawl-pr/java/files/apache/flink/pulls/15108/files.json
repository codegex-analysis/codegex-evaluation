[
  {
    "sha": "aab1c7ad91c4825e85b94c3c8323c916f59b227f",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -444,7 +444,7 @@ public void onFatalError(Throwable exception) {\n         ClusterEntryPointExceptionUtils.tryEnrichClusterEntryPointError(exception);\n         LOG.error(\"Fatal error occurred in the cluster entrypoint.\", exception);\n \n-        System.exit(RUNTIME_FAILURE_RETURN_CODE);\n+        FlinkSecurityManager.forceProcessExit(RUNTIME_FAILURE_RETURN_CODE);\n     }\n \n     // --------------------------------------------------"
  },
  {
    "sha": "d543c45b2e4bb8b000636b4831037cecc77753e9",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/security/FlinkSecurityManager.java",
    "status": "modified",
    "additions": 29,
    "deletions": 31,
    "changes": 60,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/security/FlinkSecurityManager.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/security/FlinkSecurityManager.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/security/FlinkSecurityManager.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -28,10 +28,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import javax.annotation.Nullable;\n-\n import java.security.Permission;\n-import java.util.function.Consumer;\n \n /**\n  * {@code FlinkSecurityManager} to control certain behaviors that can be captured by Java system\n@@ -58,23 +55,21 @@\n     private final ThreadLocal<Boolean> monitorUserSystemExit = new InheritableThreadLocal<>();\n     private final ClusterOptions.UserSystemExitMode userSystemExitMode;\n \n-    /** The behavior to execute when the JVM exists. */\n-    private final Consumer<Integer> onExitBehavior;\n+    private final boolean haltOnSystemExit;\n \n     @VisibleForTesting\n     FlinkSecurityManager(\n-            ClusterOptions.UserSystemExitMode userSystemExitMode,\n-            @Nullable Consumer<Integer> onExitBehavior) {\n-        this(userSystemExitMode, onExitBehavior, System.getSecurityManager());\n+            ClusterOptions.UserSystemExitMode userSystemExitMode, boolean haltOnSystemExit) {\n+        this(userSystemExitMode, haltOnSystemExit, System.getSecurityManager());\n     }\n \n     @VisibleForTesting\n     FlinkSecurityManager(\n             ClusterOptions.UserSystemExitMode userSystemExitMode,\n-            @Nullable Consumer<Integer> onExitBehavior,\n+            boolean haltOnSystemExit,\n             SecurityManager originalSecurityManager) {\n         this.userSystemExitMode = Preconditions.checkNotNull(userSystemExitMode);\n-        this.onExitBehavior = onExitBehavior;\n+        this.haltOnSystemExit = haltOnSystemExit;\n         this.originalSecurityManager = originalSecurityManager;\n     }\n \n@@ -100,22 +95,13 @@ static FlinkSecurityManager fromConfiguration(Configuration configuration) {\n         if (userSystemExitMode == ClusterOptions.UserSystemExitMode.DISABLED && !haltOnSystemExit) {\n             return null;\n         }\n-        Consumer<Integer> onExitBehavior = null;\n-        // If halt on system exit is configured, registers a custom SecurityManager which converts\n-        // graceful exists calls using {@code System#exit} into forceful exit calls using\n-        // {@code Runtime#halt}. The latter does not perform a clean shutdown using the registered\n-        // shutdown hooks. This may be configured to prevent deadlocks with Java 8 and the G1\n-        // garbage collection, see https://issues.apache.org/jira/browse/FLINK-16510.\n-        if (haltOnSystemExit) {\n-            onExitBehavior = status -> Runtime.getRuntime().halt(status);\n-        }\n         LOG.info(\n                 \"FlinkSecurityManager is created with {} user system exit mode and {} exit\",\n                 userSystemExitMode,\n                 haltOnSystemExit ? \"forceful\" : \"graceful\");\n         // Add more configuration parameters that need user security manager (currently only for\n         // system exit).\n-        return new FlinkSecurityManager(userSystemExitMode, onExitBehavior);\n+        return new FlinkSecurityManager(userSystemExitMode, haltOnSystemExit);\n     }\n \n     public static void setFromConfiguration(Configuration configuration) {\n@@ -142,14 +128,14 @@ public static void setFromConfiguration(Configuration configuration) {\n     }\n \n     public static void monitorUserSystemExitForCurrentThread() {\n-        if (FlinkSecurityManager.flinkSecurityManager != null) {\n-            FlinkSecurityManager.flinkSecurityManager.monitorUserSystemExit();\n+        if (flinkSecurityManager != null) {\n+            flinkSecurityManager.monitorUserSystemExit();\n         }\n     }\n \n     public static void unmonitorUserSystemExitForCurrentThread() {\n-        if (FlinkSecurityManager.flinkSecurityManager != null) {\n-            FlinkSecurityManager.flinkSecurityManager.unmonitorUserSystemExit();\n+        if (flinkSecurityManager != null) {\n+            flinkSecurityManager.unmonitorUserSystemExit();\n         }\n     }\n \n@@ -193,13 +179,10 @@ public void checkExit(int status) {\n         if (originalSecurityManager != null) {\n             originalSecurityManager.checkExit(status);\n         }\n-        // At this point, exit is determined. Invoke exit handler if defined, otherwise check ended.\n-        if (onExitBehavior != null) {\n-            // Unset ourselves to allow exiting.\n-            System.setSecurityManager(null);\n-            // Execute the desired behavior, e.g. forceful exit instead of proceeding with\n-            // System.exit().\n-            onExitBehavior.accept(status);\n+        // At this point, exit is determined. Halt if defined, otherwise check ended, JVM will call\n+        // System.exit\n+        if (haltOnSystemExit) {\n+            Runtime.getRuntime().halt(status);\n         }\n     }\n \n@@ -217,4 +200,19 @@ void unmonitorUserSystemExit() {\n     boolean userSystemExitMonitored() {\n         return Boolean.TRUE.equals(monitorUserSystemExit.get());\n     }\n+\n+    /**\n+     * Use this method to circumvent the configured {@link FlinkSecurityManager} behavior, ensuring\n+     * that the current JVM process will always stop via System.exit() or\n+     * Runtime.getRuntime().halt().\n+     */\n+    public static void forceProcessExit(int exitCode) {\n+        // Unset ourselves to allow exiting in any case.\n+        System.setSecurityManager(null);\n+        if (flinkSecurityManager != null && flinkSecurityManager.haltOnSystemExit) {\n+            Runtime.getRuntime().halt(exitCode);\n+        } else {\n+            System.exit(exitCode);\n+        }\n+    }\n }"
  },
  {
    "sha": "384842776b4ad5e4e6d1d7c69753aa9e478f07ae",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -332,7 +332,7 @@ public void onFatalError(Throwable exception) {\n     }\n \n     private void terminateJVM() {\n-        System.exit(FAILURE_EXIT_CODE);\n+        FlinkSecurityManager.forceProcessExit(FAILURE_EXIT_CODE);\n     }\n \n     // --------------------------------------------------------------------------------------------"
  },
  {
    "sha": "130ef8910beb41b062f28bbe3e1f0a3434b96a95",
    "filename": "flink-runtime/src/main/java/org/apache/flink/runtime/util/FatalExitExceptionHandler.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/util/FatalExitExceptionHandler.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/main/java/org/apache/flink/runtime/util/FatalExitExceptionHandler.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/main/java/org/apache/flink/runtime/util/FatalExitExceptionHandler.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -18,6 +18,8 @@\n \n package org.apache.flink.runtime.util;\n \n+import org.apache.flink.runtime.security.FlinkSecurityManager;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -43,7 +45,7 @@ public void uncaughtException(Thread t, Throwable e) {\n                     t.getName(),\n                     e);\n         } finally {\n-            System.exit(EXIT_CODE);\n+            FlinkSecurityManager.forceProcessExit(EXIT_CODE);\n         }\n     }\n }"
  },
  {
    "sha": "dcc693ee7386ca17e4785bfe1e31e76848423753",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/security/FlinkSecurityManagerTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 43,
    "changes": 50,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/security/FlinkSecurityManagerTest.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/security/FlinkSecurityManagerTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/security/FlinkSecurityManagerTest.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -26,15 +26,13 @@\n import org.apache.flink.util.TestLogger;\n \n import org.junit.After;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n \n import java.security.Permission;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import static org.apache.flink.core.testutils.CommonTestUtils.assertThrows;\n import static org.hamcrest.Matchers.is;\n@@ -64,15 +62,15 @@ public void tearDown() {\n     @Test(expected = UserSystemExitException.class)\n     public void testThrowUserExit() {\n         FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, null);\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, false);\n         flinkSecurityManager.monitorUserSystemExit();\n         flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n     }\n \n     @Test\n     public void testToggleUserExit() {\n         FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, null);\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, false);\n         flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n         flinkSecurityManager.monitorUserSystemExit();\n         try {\n@@ -87,7 +85,7 @@ public void testToggleUserExit() {\n     @Test\n     public void testPerThreadThrowUserExit() throws Exception {\n         FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, null);\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, false);\n         ExecutorService executorService = Executors.newSingleThreadExecutor();\n         // Async thread test before enabling monitoring ensures it does not throw while prestarting\n         // worker thread, which is to be unmonitored and tested after enabling monitoring enabled.\n@@ -111,7 +109,7 @@ public void testPerThreadThrowUserExit() throws Exception {\n     @Test\n     public void testInheritedThrowUserExit() throws Exception {\n         FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, null);\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, false);\n         flinkSecurityManager.monitorUserSystemExit();\n         try {\n             flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n@@ -140,39 +138,7 @@ public void testLogUserExit() {\n         // Log mode enables monitor but only logging allowing exit, hence not expecting exception.\n         // NOTE - Do not specifically test warning logging.\n         FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.LOG, null);\n-        flinkSecurityManager.monitorUserSystemExit();\n-        flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n-    }\n-\n-    @Test\n-    public void testExitHandlerTriggered() {\n-        AtomicInteger exitStatus = new AtomicInteger(0);\n-        FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(\n-                        ClusterOptions.UserSystemExitMode.DISABLED, exitStatus::set);\n-        flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n-        assertThat(exitStatus.get(), is(TEST_EXIT_CODE));\n-    }\n-\n-    @Test\n-    public void testExitHandlerTriggeredWithExistingSecurityManager() {\n-        TestExitSecurityManager existingSecurityManager = new TestExitSecurityManager();\n-        System.setSecurityManager(existingSecurityManager);\n-        AtomicInteger customExitExecuted = new AtomicInteger(0);\n-        FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(\n-                        ClusterOptions.UserSystemExitMode.DISABLED, customExitExecuted::set);\n-\n-        flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n-        assertThat(existingSecurityManager.getExitStatus(), is(TEST_EXIT_CODE));\n-        assertThat(customExitExecuted.get(), is(TEST_EXIT_CODE));\n-    }\n-\n-    @Test(expected = UserSystemExitException.class)\n-    public void testExitBehaviorUnchangeOnThrowingUserExit() {\n-        FlinkSecurityManager flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.THROW, status -> fail());\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.LOG, false);\n         flinkSecurityManager.monitorUserSystemExit();\n         flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n     }\n@@ -240,7 +206,7 @@ public void testThrowConfiguration() {\n         // since currently\n         // there is only one option to have a valid security manager, so test with constructor).\n         flinkSecurityManager =\n-                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.DISABLED, null);\n+                new FlinkSecurityManager(ClusterOptions.UserSystemExitMode.DISABLED, false);\n         flinkSecurityManager.monitorUserSystemExit();\n         assertTrue(flinkSecurityManager.userSystemExitMonitored());\n         flinkSecurityManager.checkExit(TEST_EXIT_CODE);\n@@ -276,9 +242,7 @@ public void checkPermission(Permission perm) {\n                 };\n         FlinkSecurityManager flinkSecurityManager =\n                 new FlinkSecurityManager(\n-                        ClusterOptions.UserSystemExitMode.DISABLED,\n-                        status -> Assert.fail(),\n-                        originalSecurityManager);\n+                        ClusterOptions.UserSystemExitMode.DISABLED, false, originalSecurityManager);\n \n         assertThrows(\n                 \"not allowed\","
  },
  {
    "sha": "65e2c3315df2bbaf8ec82197afc6b42c5d86ac51",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestJvmProcess.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestJvmProcess.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestJvmProcess.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestJvmProcess.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -288,6 +288,15 @@ public void waitFor() throws InterruptedException {\n         }\n     }\n \n+    public int exitCode() {\n+        Process process = this.process;\n+        if (process != null) {\n+            return process.exitValue();\n+        } else {\n+            throw new IllegalStateException(\"process not started\");\n+        }\n+    }\n+\n     // ---------------------------------------------------------------------------------------------\n     // File based synchronization utilities\n     // ---------------------------------------------------------------------------------------------"
  },
  {
    "sha": "203c94509bde68cc5d0ca24fee31edebaa717592",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/util/FlinkSecurityManagerITCase.java",
    "status": "added",
    "additions": 143,
    "deletions": 0,
    "changes": 143,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/util/FlinkSecurityManagerITCase.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/util/FlinkSecurityManagerITCase.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/util/FlinkSecurityManagerITCase.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.util;\n+\n+import org.apache.flink.configuration.ClusterOptions;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.security.FlinkSecurityManager;\n+import org.apache.flink.runtime.testutils.TestJvmProcess;\n+import org.apache.flink.util.OperatingSystem;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assume.assumeTrue;\n+\n+/** Integration tests for the {@link org.apache.flink.runtime.security.FlinkSecurityManager}. */\n+public class FlinkSecurityManagerITCase extends TestLogger {\n+\n+    @Before\n+    public void ensureSupportedOS() {\n+        // based on the assumption in JvmExitOnFatalErrorTest, and manual testing on Mac, we do not\n+        // support all platforms (in particular not Windows)\n+        assumeTrue(OperatingSystem.isLinux() || OperatingSystem.isMac());\n+    }\n+\n+    // Test will run forever if JVM exit failed\n+    @Test\n+    public void testForcedJVMExit() throws Exception {\n+        final ForcedJVMExitProcess testProcess =\n+                new ForcedJVMExitProcess(ForcedExitEntryPoint.class);\n+\n+        try {\n+            testProcess.startProcess();\n+            testProcess.waitFor();\n+            assertThat(testProcess.exitCode(), is(222));\n+        } finally {\n+            testProcess.destroy();\n+        }\n+    }\n+\n+    @Test\n+    public void testIgnoredJVMExit() throws Exception {\n+        final ForcedJVMExitProcess testProcess =\n+                new ForcedJVMExitProcess(IgnoredExitEntryPoint.class);\n+\n+        try {\n+            testProcess.startProcess();\n+            testProcess.waitFor();\n+            assertThat(testProcess.exitCode(), is(0));\n+\n+        } finally {\n+            testProcess.destroy();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    //  Blocking Process Implementation\n+    // ------------------------------------------------------------------------\n+\n+    private static final class ForcedJVMExitProcess extends TestJvmProcess {\n+\n+        private final Class<?> entryPointName;\n+\n+        private ForcedJVMExitProcess(Class<?> entryPointName) throws Exception {\n+            this.entryPointName = entryPointName;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return getEntryPointClassName();\n+        }\n+\n+        @Override\n+        public String[] getJvmArgs() {\n+            return new String[0];\n+        }\n+\n+        @Override\n+        public String getEntryPointClassName() {\n+            return entryPointName.getName();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    public static final class ForcedExitEntryPoint {\n+\n+        public static void main(String[] args) throws Exception {\n+            Configuration configuration = new Configuration();\n+            // configure FlinkSecurityManager to intercept calls to System.exit().\n+            configuration.set(\n+                    ClusterOptions.INTERCEPT_USER_SYSTEM_EXIT,\n+                    ClusterOptions.UserSystemExitMode.THROW);\n+            FlinkSecurityManager.setFromConfiguration(configuration);\n+\n+            FlinkSecurityManager.forceProcessExit(222);\n+\n+            System.exit(0);\n+        }\n+    }\n+\n+    public static final class IgnoredExitEntryPoint {\n+\n+        public static void main(String[] args) throws Exception {\n+            Configuration configuration = new Configuration();\n+            // configure FlinkSecurityManager to intercept calls to System.exit().\n+            configuration.set(\n+                    ClusterOptions.INTERCEPT_USER_SYSTEM_EXIT,\n+                    ClusterOptions.UserSystemExitMode.THROW);\n+            FlinkSecurityManager.setFromConfiguration(configuration);\n+\n+            FlinkSecurityManager.monitorUserSystemExitForCurrentThread();\n+            // expect this call to be ignored\n+            try {\n+                System.exit(123);\n+            } catch (Throwable t) {\n+                System.err.println(\n+                        \"Caught exception during system exit with message: \" + t.getMessage());\n+            }\n+\n+            System.err.println(\"Test has passed\");\n+        }\n+    }\n+}"
  },
  {
    "sha": "7e84d19c72e37ac3062d78e5b4c4554c775d7cf4",
    "filename": "flink-runtime/src/test/java/org/apache/flink/runtime/util/JvmExitOnFatalErrorTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/apache/flink/blob/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/util/JvmExitOnFatalErrorTest.java",
    "raw_url": "https://github.com/apache/flink/raw/064626fee15d7580f840e76941c2b2f7ca47e436/flink-runtime/src/test/java/org/apache/flink/runtime/util/JvmExitOnFatalErrorTest.java",
    "contents_url": "https://api.github.com/repos/apache/flink/contents/flink-runtime/src/test/java/org/apache/flink/runtime/util/JvmExitOnFatalErrorTest.java?ref=064626fee15d7580f840e76941c2b2f7ca47e436",
    "patch": "@@ -68,6 +68,7 @@\n import org.apache.flink.runtime.testutils.TestJvmProcess;\n import org.apache.flink.util.OperatingSystem;\n import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n \n import org.junit.Rule;\n import org.junit.Test;\n@@ -85,7 +86,7 @@\n  * Test that verifies the behavior of blocking shutdown hooks and of the {@link\n  * JvmShutdownSafeguard} that guards against it.\n  */\n-public class JvmExitOnFatalErrorTest {\n+public class JvmExitOnFatalErrorTest extends TestLogger {\n \n     @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n "
  }
]
