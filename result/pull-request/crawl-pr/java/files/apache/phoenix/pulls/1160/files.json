[
  {
    "sha": "127e577434df42bb5e0aa4ebb955ec9efb4762c5",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/JmxMetricProvider.java",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/JmxMetricProvider.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/JmxMetricProvider.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/JmxMetricProvider.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.monitoring;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hadoop.hbase.metrics.MetricRegistries;\n+import org.apache.hadoop.hbase.metrics.MetricRegistry;\n+import org.apache.hadoop.hbase.metrics.MetricRegistryInfo;\n+import org.apache.phoenix.query.QueryServicesOptions;\n+\n+public class JmxMetricProvider implements MetricPublisherSupplierFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(JmxMetricProvider.class);\n+    static MetricRegistry metricRegistry;\n+\n+    @Override public void registerMetricProvider() {\n+        metricRegistry = createMetricRegistry();\n+        GlobalMetricRegistriesAdapter.getInstance().registerMetricRegistry(metricRegistry,QueryServicesOptions.withDefaults().getClientMetricTag());\n+    }\n+\n+\n+    public static  MetricRegistry getMetricRegistryInstance() {\n+        return metricRegistry;\n+    }\n+\n+    private  MetricRegistry createMetricRegistry() {\n+        LOGGER.info(\"Creating Metric Registry for Phoenix Table Level Metrics\");\n+        MetricRegistryInfo registryInfo = new MetricRegistryInfo(\"PHOENIX-TableLevel\", \"Phoenix Client Metrics\",\n+                \"phoenixTableLevel\", \"Phoenix,sub=CLIENT\", true);\n+        return MetricRegistries.global().create(registryInfo);\n+    }\n+\n+    @Override public void unregisterMetricProvider() {\n+\n+    }\n+}"
  },
  {
    "sha": "7f7136e002795b554bce8f85ddf42497b10d3291",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricPublisherSupplierFactory.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricPublisherSupplierFactory.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricPublisherSupplierFactory.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricPublisherSupplierFactory.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,36 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+/**\n+ * Interface for configurable MetricPublisher interface construction\n+ *\n+ */\n+public interface MetricPublisherSupplierFactory {\n+\n+    /**\n+     * Interface for Registering Publisher Method\n+     */\n+    void registerMetricProvider();\n+\n+    /**\n+     * Interface for UnRegistering Publisher Method\n+     */\n+    void unregisterMetricProvider();\n+}"
  },
  {
    "sha": "777c1c5d4d34d85ea5132747d205906bbf65b823",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricServiceResolver.java",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricServiceResolver.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricServiceResolver.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricServiceResolver.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.phoenix.util.InstanceResolver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+/**\n+ * This class helps resolve the metricpublisher supplier class at the run time.\n+ * Based on the classString name passed, it will return the appropriate class Instance.\n+ */\n+public class MetricServiceResolver {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MetricServiceResolver.class);\n+\n+    MetricPublisherSupplierFactory metricSupplier = null;\n+\n+    public MetricPublisherSupplierFactory instantiate(String classString) {\n+        Preconditions.checkNotNull(classString);\n+        if (metricSupplier == null) {\n+            try {\n+                Class clazz = Class.forName(classString);\n+                List<MetricPublisherSupplierFactory>\n+                        factoryList =\n+                        InstanceResolver.get(MetricPublisherSupplierFactory.class, null);\n+                for (MetricPublisherSupplierFactory factory : factoryList) {\n+                    if (clazz.isInstance(factory)) {\n+                        metricSupplier = factory;\n+                        LOGGER.info(String.format(\n+                                \"Sucessfully loaded class for MetricPublishFactory of type: %s\",\n+                                classString));\n+                        break;\n+                    }\n+                }\n+                if (metricSupplier == null) {\n+                    String msg = String.format(\"Could not load/instantiate class %s\", classString);\n+                    LOGGER.error(msg);\n+                }\n+            } catch (ClassNotFoundException e) {\n+                LOGGER.error(String.format(\"Could not load/instantiate class %s\", classString), e);\n+            }\n+        }\n+        return metricSupplier;\n+    }\n+}"
  },
  {
    "sha": "a3bcffdab614ad4f2ff906c6340bcdc4123a41f3",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricType.java",
    "status": "modified",
    "additions": 77,
    "deletions": 1,
    "changes": 78,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricType.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricType.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/MetricType.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -28,13 +28,89 @@\n public enum MetricType {\n \n \tNO_OP_METRIC(\"no\", \"No op metric\",LogLevel.OFF, PLong.INSTANCE),\n-\t// mutation (write) related metrics \n+\t// mutation (write) related metrics\n+\n     MUTATION_BATCH_SIZE(\"ms\", \"Number of mutations in the batch\",LogLevel.OFF, PLong.INSTANCE),\n     MUTATION_BYTES(\"mb\", \"Size of mutations in bytes\",LogLevel.OFF, PLong.INSTANCE),\n     MUTATION_COMMIT_TIME(\"mt\", \"Time it took to commit a batch of mutations\",LogLevel.OFF, PLong.INSTANCE),\n     MUTATION_BATCH_FAILED_SIZE(\"mfs\", \"Number of mutations that failed to be committed\",LogLevel.OFF, PLong.INSTANCE),\n     MUTATION_SQL_COUNTER(\"msc\", \"Counter for number of mutation sql statements\",LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_SQL_COUNTER(\"uc\", \"Counter for number of upsert sql queries\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_COMMIT_TIME(\"ut\", \"Time it took to commit a batch of upserts\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_MUTATION_BYTES(\"umb\", \"Size of mutations in upsert statement in bytes\",LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_MUTATION_SQL_COUNTER(\"umsc\", \"Counter for number of upsert mutations committed\",LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_BATCH_FAILED_SIZE(\"ubfs\", \"Number of upsert mutations in a batch that failed to be committed\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_BATCH_FAILED_COUNTER(\"ubfc\", \"Number of upsert mutation batches that failed to be committed\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+\n+    UPSERT_AGGREGATE_SUCCESS_SQL_COUNTER(\"uassc\", \"Counter which indicates the total number of upsert Mutations which passed  executeUpdate phase \"\n+            + \"(since last commit called) and subsequent conn.commit() are successful.\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_AGGREGATE_FAILURE_SQL_COUNTER(\"uafsc\", \"Counter which indicates the total number of upsert Mutations for all statements which failed either  in executeUpdate phase  \"\n+            + \"(since last commit called) or subsequent conn.commit() fails\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_SUCCESS_SQL_COUNTER(\"ussc\", \"Counter for number of upsert sql queries that successfully\"\n+            + \" passed the executeMutation phase, or if autoCommit is true, the total\"\n+            + \" number of successful upserts\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_FAILED_SQL_COUNTER(\"ufsc\", \"Counter for number of upsert sql queries that\"\n+            + \" failed the executeMutation phase, or if autoCommit is true, the total\"\n+            + \" number of upsert failures\", LogLevel.OFF, PLong.INSTANCE),\n+    UPSERT_SQL_QUERY_TIME(\"uqt\", \"Time taken by upsert sql queries inside executeMutation or if\"\n+            + \" autoCommit is true, the total time taken for executeMutation + conn.commit\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+\n+    // delete-specific metrics updated during executeMutation\n+    DELETE_SQL_COUNTER(\"dc\", \"Counter for number of delete sql queries\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_SUCCESS_SQL_COUNTER(\"dssc\", \"Counter for number of delete sql queries that successfully\"\n+            + \" passed the executeMutation phase, or if autoCommit is true, the total\"\n+            + \" number of successful deletes\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_AGGREGATE_SUCCESS_SQL_COUNTER(\"dassc\", \"Counter which indicates if everything in the executeUpdate phase for all \"\n+            + \"statements (since last commit called) and subsequent conn.commit() is successful.\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_AGGREGATE_FAILURE_SQL_COUNTER(\"dafsc\", \"Counter which indicates  if anything in the executeUpdate phase for any \"\n+            + \"statements (since last commit called) or subsequent conn.commit() fails.\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_FAILED_SQL_COUNTER(\"dfsc\", \"Counter for number of delete sql queries that\"\n+            + \" failed the executeMutation phase, or if autoCommit is true, the total\"\n+            + \" number of delete failures\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_SQL_QUERY_TIME(\"dqt\", \"Time taken by delete sql queries inside executeMutation or if\"\n+            + \" autoCommit is true, the total time taken for executeMutation + conn.commit\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+\n+    DELETE_COMMIT_TIME(\"dt\", \"Time it took to commit a batch of deletes\", LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_MUTATION_BYTES(\"dmb\", \"Size of mutations in delete statement in bytes\",LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_MUTATION_SQL_COUNTER(\"dmsc\", \"Counter for number of delete mutations committed\",LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_BATCH_FAILED_SIZE(\"dbfs\", \"Number of delete mutations in a batch that failed to be committed\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+    DELETE_BATCH_FAILED_COUNTER(\"dbfc\", \"Number of delete mutation batches that failed to be committed\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+\n+    // select-specific query (read) metrics updated during executeQuery\n+    SELECT_SUCCESS_SQL_COUNTER(\"sss\", \"Counter for number of select sql queries that successfully\"\n+            + \" passed the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_AGGREGATE_SUCCESS_SQL_COUNTER(\"sassc\",\"Counter which indicates  if everything in executeQuery\"\n+            + \" phase and all rs.next() are successful\",LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_AGGREGATE_FAILURE_SQL_COUNTER(\"safsc\",\"Counter which indicates if anything in \"\n+            + \"executeQuery phase or any of the rs.next() fail\",LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER(\"spls\", \"Counter for number of point lookup select sql \"\n+            + \"queries that succeeded the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_SCAN_SUCCESS_SQL_COUNTER(\"sscs\", \"Counter for number of scan select sql queries \"\n+            + \"that succeed the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_FAILED_SQL_COUNTER(\"sfsc\", \"Counter for number of select sql queries that\"\n+            + \" failed the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_POINTLOOKUP_FAILED_SQL_COUNTER(\"splf\", \"Counter for number of point lookup select sql \"\n+            + \"queries that failed the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_SCAN_FAILED_SQL_COUNTER(\"sscf\", \"Counter for number of scan select sql queries \"\n+            + \"that failed the executeQuery phase\", LogLevel.OFF, PLong.INSTANCE),\n+    SELECT_SQL_QUERY_TIME(\"sqt\", \"Time taken by select sql queries inside executeQuery\",\n+            LogLevel.OFF, PLong.INSTANCE),\n+\n     INDEX_COMMIT_FAILURE_SIZE(\"p3s\", \"Number of mutations that failed in phase 3\", LogLevel.OFF, PLong.INSTANCE),\n+    QUERY_POINTLOOKUP_TIMEOUT_COUNTER(\"qplo\", \"Number of times the point lookup select query timed out\"\n+            + \" when fetching results\", LogLevel.DEBUG, PLong.INSTANCE),\n+    QUERY_SCAN_TIMEOUT_COUNTER(\"qso\", \"Number of times the scan select query timed out\"\n+            + \" when fetching results\", LogLevel.DEBUG, PLong.INSTANCE),\n+    QUERY_POINTLOOKUP_FAILED_COUNTER(\"qplf\", \"Number of times the point lookup select query failed\"\n+            + \" when fetching results\", LogLevel.DEBUG, PLong.INSTANCE),\n+    QUERY_SCAN_FAILED_COUNTER(\"qsf\", \"Number of times the scan select query failed when fetching\"\n+            + \" results\", LogLevel.DEBUG, PLong.INSTANCE),\n     // query (read) related metrics\n     QUERY_TIME(\"qt\", \"Query times\",LogLevel.OFF, PLong.INSTANCE),\n     QUERY_TIMEOUT_COUNTER(\"qo\", \"Number of times query timed out\",LogLevel.DEBUG, PLong.INSTANCE),"
  },
  {
    "sha": "486e16856355e01a0c1275ac95008d92ea2c7587",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/NoOpTableMetricsManager.java",
    "status": "added",
    "additions": 50,
    "deletions": 0,
    "changes": 50,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/NoOpTableMetricsManager.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/NoOpTableMetricsManager.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/NoOpTableMetricsManager.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.monitoring;\n+\n+import org.apache.phoenix.query.QueryServicesOptions;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class NoOpTableMetricsManager extends TableMetricsManager {\n+\n+    public NoOpTableMetricsManager(QueryServicesOptions opts) {\n+        super(opts);\n+    }\n+\n+    public static void pushMetricsFromConnInstanceMethod(Map<String, Map<MetricType, Long>> map) {\n+\n+    }\n+\n+    public static Map<String, List<PhoenixTableMetric>> getTableMetricsMethod() {\n+        return null;\n+    }\n+\n+    public static void clearTableLevelMetricsMethod() {\n+\n+    }\n+\n+    public static void updateMetricsMethod(String tableName, MetricType type, long value) {\n+\n+    }\n+\n+    public static Long getMetricValue(String tableName, MetricType type) {\n+        return null;\n+    }\n+}"
  },
  {
    "sha": "920094a478473382e2f7f33342b1b5f10bb49681",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableClientMetrics.java",
    "status": "added",
    "additions": 211,
    "deletions": 0,
    "changes": 211,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableClientMetrics.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableClientMetrics.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableClientMetrics.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,211 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.metrics.Gauge;\n+import org.apache.hadoop.hbase.metrics.MetricRegistry;\n+\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_BATCH_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_BATCH_FAILED_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_POINTLOOKUP_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_POINTLOOKUP_TIMEOUT_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_SCAN_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_SCAN_TIMEOUT_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.RESULT_SET_TIME_MS;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_BATCH_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_BATCH_FAILED_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_COMMIT_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_COMMIT_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.TASK_END_TO_END_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.COUNT_ROWS_SCANNED;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_TIMEOUT_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SCAN_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SQL_QUERY_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_SQL_QUERY_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_BATCH_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_BATCH_FAILED_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_COMMIT_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_SQL_QUERY_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_AGGREGATE_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_AGGREGATE_FAILURE_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_AGGREGATE_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_AGGREGATE_FAILURE_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_AGGREGATE_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_AGGREGATE_FAILURE_SQL_COUNTER;\n+\n+/**\n+ * This is used by TableMetricsManager class to store instance of\n+ * object associated with a tableName.\n+ */\n+public class TableClientMetrics {\n+\n+    public enum TableMetrics {\n+        TABLE_MUTATION_BATCH_FAILED_SIZE(MUTATION_BATCH_FAILED_SIZE),\n+        TABLE_MUTATION_BATCH_SIZE(MUTATION_BATCH_SIZE),\n+        TABLE_MUTATION_BYTES(MUTATION_BYTES),\n+        TABLE_UPSERT_MUTATION_BYTES(UPSERT_MUTATION_BYTES),\n+        TABLE_UPSERT_MUTATION_SQL_COUNTER(UPSERT_MUTATION_SQL_COUNTER),\n+        TABLE_DELETE_MUTATION_BYTES(DELETE_MUTATION_BYTES),\n+        TABLE_DELETE_MUTATION_SQL_COUNTER(DELETE_MUTATION_SQL_COUNTER),\n+        TABLE_MUTATION_SQL_COUNTER(MUTATION_SQL_COUNTER),\n+        TABLE_MUTATION_COMMIT_TIME(MUTATION_COMMIT_TIME),\n+        TABLE_UPSERT_SQL_COUNTER(UPSERT_SQL_COUNTER),\n+        TABLE_UPSERT_SQL_QUERY_TIME(UPSERT_SQL_QUERY_TIME),\n+        TABLE_SUCCESS_UPSERT_SQL_COUNTER(UPSERT_SUCCESS_SQL_COUNTER),\n+        TABLE_FAILED_UPSERT_SQL_COUNTER(UPSERT_FAILED_SQL_COUNTER),\n+        TABLE_UPSERT_BATCH_FAILED_SIZE(UPSERT_BATCH_FAILED_SIZE),\n+        TABLE_UPSERT_BATCH_FAILED_COUNTER(UPSERT_BATCH_FAILED_COUNTER),\n+        TABLE_DELETE_SQL_COUNTER(DELETE_SQL_COUNTER),\n+        TABLE_DELETE_SQL_QUERY_TIME(DELETE_SQL_QUERY_TIME),\n+        TABLE_SUCCESS_DELETE_SQL_COUNTER(DELETE_SUCCESS_SQL_COUNTER),\n+        TABLE_FAILED_DELETE_SQL_COUNTER(DELETE_FAILED_SQL_COUNTER),\n+        TABLE_DELETE_BATCH_FAILED_SIZE(DELETE_BATCH_FAILED_SIZE),\n+        TABLE_DELETE_BATCH_FAILED_COUNTER(DELETE_BATCH_FAILED_COUNTER),\n+        TABLE_UPSERT_COMMIT_TIME(UPSERT_COMMIT_TIME),\n+        TABLE_DELETE_COMMIT_TIME(DELETE_COMMIT_TIME),\n+        TABLE_TASK_END_TO_END_TIME(TASK_END_TO_END_TIME),\n+        TABLE_COUNT_ROWS_SCANNED(COUNT_ROWS_SCANNED),\n+        TABLE_QUERY_FAILED_COUNTER(QUERY_FAILED_COUNTER),\n+        TABLE_QUERY_POINTLOOKUP_FAILED_COUNTER(QUERY_POINTLOOKUP_FAILED_COUNTER),\n+        TABLE_QUERY_SCAN_FAILED_COUNTER(QUERY_SCAN_FAILED_COUNTER),\n+        TABLE_QUERY_TIMEOUT_COUNTER(QUERY_TIMEOUT_COUNTER),\n+        TABLE_QUERY_POINTLOOKUP_TIMEOUT_COUNTER(QUERY_POINTLOOKUP_TIMEOUT_COUNTER),\n+        TABLE_QUERY_SCAN_TIMEOUT_COUNTER(QUERY_SCAN_TIMEOUT_COUNTER),\n+        TABLE_SELECT_QUERY_RESULT_SET_MS(RESULT_SET_TIME_MS),\n+        TABLE_SCANBYTES(SCAN_BYTES),\n+        TABLE_SELECT_SQL_COUNTER(SELECT_SQL_COUNTER),\n+        TABLE_SELECT_SQL_QUERY_TIME(SELECT_SQL_QUERY_TIME),\n+        TABLE_SUCCESS_SELECT_SQL_COUNTER(SELECT_SUCCESS_SQL_COUNTER),\n+        TABLE_FAILED_SELECT_SQL_COUNTER(SELECT_FAILED_SQL_COUNTER),\n+        TABLE_SELECT_POINTLOOKUP_COUNTER_SUCCESS(SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER),\n+        TABLE_SELECT_POINTLOOKUP_COUNTER_FAILED(SELECT_POINTLOOKUP_FAILED_SQL_COUNTER),\n+        TABLE_SELECT_SCAN_COUNTER_SUCCESS(SELECT_SCAN_SUCCESS_SQL_COUNTER),\n+        TABLE_SELECT_SCAN_COUNTER_FAILED(SELECT_SCAN_FAILED_SQL_COUNTER),\n+        TABLE_UPSERT_AGGREGATE_SUCCESS_SQL_COUNTER(UPSERT_AGGREGATE_SUCCESS_SQL_COUNTER),\n+        TABLE_UPSERT_AGGREGATE_FAILURE_SQL_COUNTER(UPSERT_AGGREGATE_FAILURE_SQL_COUNTER),\n+        TABLE_DELETE_AGGREGATE_SUCCESS_SQL_COUNTER(DELETE_AGGREGATE_SUCCESS_SQL_COUNTER),\n+        TABLE_DELETE_AGGREGATE_FAILURE_SQL_COUNTER(DELETE_AGGREGATE_FAILURE_SQL_COUNTER),\n+        TABLE_SELECT_AGGREGATE_SUCCESS_SQL_COUNTER(SELECT_AGGREGATE_SUCCESS_SQL_COUNTER),\n+        TABLE_SELECT_AGGREGATE_FAILURE_SQL_COUNTER(SELECT_AGGREGATE_FAILURE_SQL_COUNTER);\n+\n+        private MetricType metricType;\n+        private PhoenixTableMetric metric;\n+\n+        TableMetrics(MetricType metricType) {\n+            this.metricType = metricType;\n+        }\n+    }\n+\n+    private final String tableName;\n+    private Map<MetricType, PhoenixTableMetric> metricRegister;\n+\n+    public TableClientMetrics(final String tableName) {\n+        this.tableName = tableName;\n+        metricRegister = new HashMap<>();\n+        for (TableMetrics tableMetric : TableMetrics.values()) {\n+            tableMetric.metric = new PhoenixTableMetricImpl(tableMetric.metricType);\n+            metricRegister.put(tableMetric.metricType, tableMetric.metric);\n+        }\n+        MetricRegistry mRegistry = JmxMetricProvider.getMetricRegistryInstance();\n+        //MetricPublisher is Enabled\n+        if(mRegistry !=  null) {\n+            registerMetrics(mRegistry);\n+        }\n+\n+    }\n+\n+    /**\n+     * This function is used to update the value of Metric\n+     * Incase of counter val will passed as 1.\n+     *\n+     * @param type metric type\n+     * @param val update value. In case of counters, this will be 1\n+     */\n+    public void changeMetricValue(MetricType type, long val) {\n+        if (!metricRegister.containsKey(type)) {\n+            return;\n+        }\n+        PhoenixTableMetric metric = metricRegister.get(type);\n+        metric.change(val);\n+    }\n+\n+    public String getTableName() {\n+        return tableName;\n+    }\n+\n+    /**\n+     * This method is called to aggregate all the Metrics across all Tables in Phoenix.\n+     *\n+     * @return map of table name -> list of TableMetric.\n+     */\n+    public List<PhoenixTableMetric> getMetricMap() {\n+        List<PhoenixTableMetric> metricsList = new ArrayList<>();\n+        for(PhoenixTableMetric value : metricRegister.values()){\n+            metricsList.add(value);\n+        }\n+        return metricsList;\n+    }\n+\n+    static class PhoenixMetricGauge implements Gauge<Long> {\n+        private final PhoenixTableMetric metric;\n+        public PhoenixMetricGauge(PhoenixTableMetric metric) {\n+            this.metric = metric;\n+        }\n+\n+        @Override\n+        public Long getValue() {\n+            return metric.getValue();\n+        }\n+    }\n+\n+    public  String getMetricNameFromMetricType(MetricType type){\n+        return tableName + \"_table_\" + type;\n+    }\n+\n+    public void registerMetrics(MetricRegistry metricRegistry){\n+        for(Map.Entry<MetricType,PhoenixTableMetric>  entry : metricRegister.entrySet()){\n+            metricRegistry.register(getMetricNameFromMetricType(entry.getKey()), new PhoenixMetricGauge(entry.getValue()));\n+        }\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "18e172af9bdf210814eadbe08449538af7a76953",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableMetricsManager.java",
    "status": "added",
    "additions": 285,
    "deletions": 0,
    "changes": 285,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableMetricsManager.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableMetricsManager.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/monitoring/TableMetricsManager.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,285 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.query.QueryServicesOptions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central place where we keep track of all the Table Level metrics. Register each tableMetrics and\n+ * store the instance of it associated with TableName in a map\n+ * This class exposes following functions as static methods to help catch all execptions\n+ * 1.clearTableLevelMetricsMethod\n+ * 2.getTableMetricsMethod\n+ * 3.pushMetricsFromConnInstanceMethod\n+ * 4.updateMetricsMethod\n+ */\n+\n+public class TableMetricsManager {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(TableMetricsManager.class);\n+    private static boolean isTableLevelMetricsEnabled;\n+    private static boolean isMetricPublisherEnabled;\n+    private static final Set<String> allowedListOfTableNames = new HashSet<>();\n+    private static ConcurrentMap<String, TableClientMetrics> tableClientMetricsMapping;\n+    // Singleton object\n+    public static TableMetricsManager tableMetricsManager = null;\n+    private static QueryServicesOptions options;\n+\n+    @VisibleForTesting\n+    public TableMetricsManager(QueryServicesOptions opts) {\n+        options = opts;\n+        isTableLevelMetricsEnabled = options.isTableLevelMetricsEnabled();\n+        LOGGER.info(String.format(\"Phoenix Table metrics enabled status: %s\", isTableLevelMetricsEnabled));\n+        // Return simply if table level metrics are not enabled\n+        if (!isTableLevelMetricsEnabled) {\n+            tableMetricsManager = new NoOpTableMetricsManager(options);\n+            return;\n+        }\n+        tableClientMetricsMapping = new ConcurrentHashMap<>();\n+\n+        String tableNamesList = options.getAllowedListTableNames();\n+        if (tableNamesList != null && !tableNamesList.isEmpty()) {\n+            for (String tableName : tableNamesList.split(\",\")) {\n+                allowedListOfTableNames.add(tableName);\n+            }\n+        }\n+\n+        isMetricPublisherEnabled = options.isMetricPublisherEnabled();\n+        LOGGER.info(String.format(\"Phoenix table level metrics publisher enabled status %s\",\n+                isMetricPublisherEnabled));\n+    }\n+\n+    @VisibleForTesting\n+    public static void setInstance(TableMetricsManager metricsManager) {\n+        tableMetricsManager = metricsManager;\n+    }\n+\n+    /**\n+     * Method to provide instance of TableMetricsManager(Create if needed in thread safe manner)\n+     *\n+     * @return\n+     */\n+    private static TableMetricsManager getInstance() {\n+\n+        if (tableMetricsManager == null) {\n+            synchronized (TableMetricsManager.class) {\n+                if (tableMetricsManager == null) {\n+                    QueryServicesOptions options = QueryServicesOptions.withDefaults();\n+                    tableMetricsManager = new TableMetricsManager(options);\n+                    LOGGER.info(\"Phoenix Table metrics created object for metrics manager\");\n+                    if (isMetricPublisherEnabled) {\n+                        String className = options.getMetricPublisherClass();\n+                        if (className != null) {\n+                            MetricServiceResolver mResolver = new MetricServiceResolver();\n+\n+                            LOGGER.info(String.format(\"Phoenix table level metrics publisher className %s\",\n+                                    className));\n+                            try {\n+                                MetricPublisherSupplierFactory mPublisher = mResolver.instantiate(className);\n+                                mPublisher.registerMetricProvider();\n+                            } catch (Throwable e) {\n+                                LOGGER.error(\"The exception from metric publish Function\", e);\n+                            }\n+\n+                        } else {\n+                            LOGGER.error(\"Phoenix table level metrics publisher className cant be null\");\n+                        }\n+\n+                    }\n+                }\n+            }\n+        }\n+        return tableMetricsManager;\n+    }\n+\n+    /**\n+     * This function is provided as hook to publish the tableLevel Metrics to\n+     * LocalStore(tablePhoenixMapping).\n+     *\n+     * @param map of tableName to pair of (MetricType, Metric Value)\n+     */\n+    private void pushMetricsFromConnInstance(Map<String, Map<MetricType, Long>> map) {\n+\n+        if (map == null) {\n+            LOGGER.debug(\"Phoenix table level metrics input map cant be null\");\n+            return;\n+        }\n+\n+        long startTime = EnvironmentEdgeManager.currentTime();\n+        for (Map.Entry<String, Map<MetricType,Long>> tableEntry : map.entrySet()) {\n+            for(Map.Entry<MetricType,Long>metricEntry  : tableEntry.getValue().entrySet()){\n+                updateMetrics(tableEntry.getKey(), metricEntry.getKey(), metricEntry.getValue());\n+            }\n+        }\n+\n+        LOGGER.debug(String.format(\"Phoenix table level metrics completed updating metrics from conn instance, timetaken:\\t%d\",\n+                + EnvironmentEdgeManager.currentTime() - startTime));\n+    }\n+\n+    /**\n+     * This function will be used to add individual MetricType to LocalStore.\n+     *\n+     * @param tableName\n+     * @param type\n+     * @param value\n+     */\n+    private void updateMetrics(String tableName, MetricType type, long value) {\n+\n+        long startTime = EnvironmentEdgeManager.currentTime();\n+\n+        TableClientMetrics tInstance = getTableClientMetrics(tableName);\n+        if (tInstance == null) {\n+            LOGGER.debug(\"Table level client metrics are disabled for table: \" + tableName);\n+            return;\n+        }\n+        tInstance.changeMetricValue(type, value);\n+\n+        LOGGER.debug(String.format(\"Phoenix table level metrics completed updating metric\"\n+                        + \" %s to value %s, timetaken = %s\", type, value,\n+                EnvironmentEdgeManager.currentTime() - startTime));\n+    }\n+\n+    /**\n+     * Get Table specific metrics object and create if not initialized(thread safe)\n+     *\n+     * @param tableName\n+     * @return TableClientMetrics object\n+     */\n+    private TableClientMetrics getTableClientMetrics(String tableName) {\n+\n+        if (Strings.isNullOrEmpty(tableName)) {\n+            LOGGER.debug(\"Phoenix Table metrics TableName cant be null or empty\");\n+            return null;\n+        }\n+\n+        if (!allowedListOfTableNames.isEmpty() && !allowedListOfTableNames.contains(tableName)) {\n+            return null;\n+        }\n+\n+        TableClientMetrics tInstance;\n+        tInstance = tableClientMetricsMapping.get(tableName);\n+        if (tInstance == null) {\n+            synchronized (TableMetricsManager.class) {\n+                tInstance = tableClientMetricsMapping.get(tableName);\n+                if (tInstance == null) {\n+\n+                    LOGGER.info(String.format(\"Phoenix Table metrics creating object for table: %s\", tableName));\n+                    tInstance = new TableClientMetrics(tableName);\n+                    tableClientMetricsMapping.put(tableName, tInstance);\n+                }\n+            }\n+        }\n+        return tInstance;\n+    }\n+\n+    /**\n+     * Publish the metrics to wherever you want them published.\n+     *\n+     * @return map of table name ->TableMetric\n+     */\n+    private Map<String, List<PhoenixTableMetric>> getTableLevelMetrics() {\n+\n+        long startTime = EnvironmentEdgeManager.currentTime();\n+        Map<String, List<PhoenixTableMetric>> map = new HashMap<>();\n+        for (Map.Entry<String, TableClientMetrics> entry : tableClientMetricsMapping.entrySet()) {\n+            map.put(entry.getKey(), entry.getValue().getMetricMap());\n+        }\n+        long timeTakenForMetricConversion = EnvironmentEdgeManager.currentTime() - startTime;\n+        LOGGER.info(String.format(\"Phoenix Table metrics fetching complete, timeTaken: \\t%d\",\n+                + timeTakenForMetricConversion));\n+        return map;\n+    }\n+\n+    /**\n+     * Helps reset the localstore(tableClientMetricsMapping)\n+     */\n+    private void clearTableLevelMetrics() {\n+        if (tableClientMetricsMapping != null) {\n+            tableClientMetricsMapping.clear();\n+        }\n+        LOGGER.info(\"Phoenix Table metrics clearing complete\");\n+    }\n+\n+    // static methods to push, update or retrieve TableLevel Metrics.\n+\n+    public static void updateMetricsMethod(String tableName, MetricType type, long value) {\n+        try {\n+            TableMetricsManager.getInstance().updateMetrics(tableName, type, value);\n+        }\n+        catch(Exception e){\n+            LOGGER.error(\"Failed updating Phoenix table level metrics\",e);\n+        }\n+    }\n+\n+    public static void pushMetricsFromConnInstanceMethod(Map<String, Map<MetricType, Long>> map) {\n+        try {\n+            TableMetricsManager.getInstance().pushMetricsFromConnInstance(map);\n+        }\n+        catch(Exception e){\n+            LOGGER.error(\"Failed pushing Phoenix table level metrics\",e);\n+        }\n+    }\n+\n+    public static Map<String, List<PhoenixTableMetric>> getTableMetricsMethod() {\n+        try {\n+            return TableMetricsManager.getInstance().getTableLevelMetrics();\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed retrieving table level Metrics\", e);\n+        }\n+        return null;\n+    }\n+\n+    public static void clearTableLevelMetricsMethod() {\n+        try {\n+            TableMetricsManager.getInstance().clearTableLevelMetrics();\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed resetting table level Metrics\", e);\n+        }\n+    }\n+\n+    public void clear() {\n+        TableMetricsManager.clearTableLevelMetricsMethod();\n+    }\n+\n+    @VisibleForTesting\n+    public static Long getMetricValue(String tableName, MetricType type) {\n+        TableClientMetrics tableMetrics = getInstance().getTableClientMetrics(tableName);\n+        if (tableMetrics == null) {\n+            return null;\n+        }\n+        for (PhoenixTableMetric metric:  tableMetrics.getMetricMap()) {\n+            if (metric.getMetricType() == type) {\n+                return metric.getValue();\n+            }\n+        }\n+        return null;\n+    }\n+}"
  },
  {
    "sha": "cc649db43659c76e2865bb1b1d34fbe75bb6249e",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/query/QueryServices.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServices.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServices.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServices.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -224,6 +224,12 @@\n     public static final String DEFAULT_TRANSACTION_PROVIDER_ATTRIB = \"phoenix.table.transaction.provider.default\";\n     public static final String GLOBAL_METRICS_ENABLED = \"phoenix.query.global.metrics.enabled\";\n \n+    public static final String TABLE_LEVEL_METRICS_ENABLED = \"phoenix.monitoring.tableMetrics.enabled\";\n+    public static final String METRIC_PUBLISHER_ENABLED = \"phoenix.monitoring.metricsPublisher.enabled\";\n+    public static final String METRIC_PUBLISHER_CLASS_NAME = \"phoenix.monitoring.metricProvider.className\";\n+    public static final String ALLOWED_LIST_FOR_TABLE_LEVEL_METRICS = \"phoenix.monitoring.allowedTableNames.list\";\n+\n+\n     // Tag Name to determine the Phoenix Client Type\n     public static final String CLIENT_METRICS_TAG = \"phoenix.client.metrics.tag\";\n     "
  },
  {
    "sha": "ebc5a2adadbe053dde3511b294e6b1af97364eb4",
    "filename": "phoenix-core/src/main/java/org/apache/phoenix/query/QueryServicesOptions.java",
    "status": "modified",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServicesOptions.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServicesOptions.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/java/org/apache/phoenix/query/QueryServicesOptions.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -18,6 +18,7 @@\n package org.apache.phoenix.query;\n \n import static org.apache.hadoop.hbase.HConstants.DEFAULT_HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD;\n+import static org.apache.phoenix.query.QueryServices.ALLOWED_LIST_FOR_TABLE_LEVEL_METRICS;\n import static org.apache.phoenix.query.QueryServices.ALLOW_ONLINE_TABLE_SCHEMA_UPDATE;\n import static org.apache.phoenix.query.QueryServices.ALLOW_VIEWS_ADD_NEW_CF_BASE_TABLE;\n import static org.apache.phoenix.query.QueryServices.AUTO_UPGRADE_ENABLED;\n@@ -60,6 +61,8 @@\n import static org.apache.phoenix.query.QueryServices.MAX_SERVER_METADATA_CACHE_SIZE_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.MAX_SPOOL_TO_DISK_BYTES_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.MAX_TENANT_MEMORY_PERC_ATTRIB;\n+import static org.apache.phoenix.query.QueryServices.METRIC_PUBLISHER_CLASS_NAME;\n+import static org.apache.phoenix.query.QueryServices.METRIC_PUBLISHER_ENABLED;\n import static org.apache.phoenix.query.QueryServices.MIN_STATS_UPDATE_FREQ_MS_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.MUTATE_BATCH_SIZE_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.NUM_RETRIES_FOR_SCHEMA_UPDATE_CHECK;\n@@ -84,6 +87,7 @@\n import static org.apache.phoenix.query.QueryServices.STATS_GUIDEPOST_WIDTH_BYTES_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.STATS_UPDATE_FREQ_MS_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.STATS_USE_CURRENT_TIME_ATTRIB;\n+import static org.apache.phoenix.query.QueryServices.TABLE_LEVEL_METRICS_ENABLED;\n import static org.apache.phoenix.query.QueryServices.THREAD_POOL_SIZE_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.THREAD_TIMEOUT_MS_ATTRIB;\n import static org.apache.phoenix.query.QueryServices.TRACING_BATCH_SIZE;\n@@ -279,6 +283,10 @@\n     public static final String DEFAULT_TRANSACTION_PROVIDER = TransactionFactory.Provider.getDefault().name();\n     public static final boolean DEFAULT_TRANSACTIONS_ENABLED = false;\n     public static final boolean DEFAULT_IS_GLOBAL_METRICS_ENABLED = true;\n+    public static final boolean DEFAULT_IS_TABLE_LEVEL_METRICS_ENABLED = false;\n+    public static final boolean DEFAULT_IS_METRIC_PUBLISHER_ENABLED = false;\n+    public static final String DEFAULT_ALLOWED_LIST_FOR_TABLE_LEVEL_METRICS = null; //All the tables metrics will be allowed.\n+    public static final String DEFAULT_METRIC_PUBLISHER_CLASS_NAME = null;\n     public static final String DEFAULT_CLIENT_METRICS_TAG = \"FAT_CLIENT\";\n \n     public static final boolean DEFAULT_TRANSACTIONAL = false;\n@@ -683,10 +691,32 @@ public boolean isGlobalMetricsEnabled() {\n         return config.getBoolean(GLOBAL_METRICS_ENABLED, DEFAULT_IS_GLOBAL_METRICS_ENABLED);\n     }\n \n+    public String getMetricPublisherClass() {\n+        return config.get(METRIC_PUBLISHER_CLASS_NAME, DEFAULT_METRIC_PUBLISHER_CLASS_NAME);\n+    }\n+\n     public boolean isUseByteBasedRegex() {\n         return config.getBoolean(USE_BYTE_BASED_REGEX_ATTRIB, DEFAULT_USE_BYTE_BASED_REGEX);\n     }\n \n+    public String getAllowedListTableNames() {\n+        return config.get(ALLOWED_LIST_FOR_TABLE_LEVEL_METRICS,\n+                DEFAULT_ALLOWED_LIST_FOR_TABLE_LEVEL_METRICS);\n+    }\n+\n+    public boolean isTableLevelMetricsEnabled() {\n+        return config\n+                .getBoolean(TABLE_LEVEL_METRICS_ENABLED, DEFAULT_IS_TABLE_LEVEL_METRICS_ENABLED);\n+    }\n+\n+    public void setTableLevelMetricsEnabled() {\n+        set(TABLE_LEVEL_METRICS_ENABLED, true);\n+    }\n+\n+    public boolean isMetricPublisherEnabled() {\n+        return config.getBoolean(METRIC_PUBLISHER_ENABLED, DEFAULT_IS_METRIC_PUBLISHER_ENABLED);\n+    }\n+\n     public int getScanCacheSize() {\n         return config.getInt(SCAN_CACHE_SIZE_ATTRIB, DEFAULT_SCAN_CACHE_SIZE);\n     }"
  },
  {
    "sha": "d7440fb1c37ef0514f6abd23e6ee0573d5ab124c",
    "filename": "phoenix-core/src/main/resources/META-INF/services/org.apache.phoenix.monitoring.MetricPublisherSupplierFactory",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/resources/META-INF/services/org.apache.phoenix.monitoring.MetricPublisherSupplierFactory",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/main/resources/META-INF/services/org.apache.phoenix.monitoring.MetricPublisherSupplierFactory",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/main/resources/META-INF/services/org.apache.phoenix.monitoring.MetricPublisherSupplierFactory?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1 @@\n+org.apache.phoenix.monitoring.JmxMetricProvider\n\\ No newline at end of file"
  },
  {
    "sha": "9db6c2fdacca475bc912e5d0f888897cb7d829ac",
    "filename": "phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableClientMetricsTest.java",
    "status": "added",
    "additions": 220,
    "deletions": 0,
    "changes": 220,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableClientMetricsTest.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableClientMetricsTest.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableClientMetricsTest.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,220 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.junit.Test;\n+import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.phoenix.monitoring.MetricType.COUNT_ROWS_SCANNED;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_BATCH_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_COMMIT_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_TIMEOUT_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SCAN_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SQL_QUERY_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.TASK_END_TO_END_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.countRowsScannedCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.deleteMutationByesCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.deleteMutationSqlCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.mutationBatchSizeCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.mutationSqlCommitTimeCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.mutationSqlCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.queryFailedCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.queryTimeOutCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.scanBytesCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.selectPointLookUpFailedCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.selectPointLookUpSuccessCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.selectScanFailedCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.selectScanSuccessCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.selectSqlQueryTimeCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.taskEndToEndTimeCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.upsertMutationBytesCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.upsertMutationSqlCounter;\n+import static org.apache.phoenix.monitoring.TableLevelMetricsTestData.tableNames;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * This test does UT for TableClientMetrics class\n+ * This class has following API\n+ * 1. changeMetricValue\n+ * 2.getTableName\n+ * 3.getMetricMap\n+ */\n+public class TableClientMetricsTest {\n+\n+    static Map<String, TableClientMetrics> tableMetricsSet = new HashMap<>();\n+\n+    public void verifyMetricsFromTableClientMetrics() {\n+        assertFalse(tableMetricsSet.isEmpty());\n+        for (int i = 0; i < tableNames.length; i++) {\n+            TableClientMetrics instance = tableMetricsSet.get(tableNames[i]);\n+            assertEquals(instance.getTableName(), tableNames[i]);\n+            List<PhoenixTableMetric> metricList = instance.getMetricMap();\n+            for (PhoenixTableMetric metric : metricList) {\n+\n+                if (metric.getMetricType().equals(MUTATION_BATCH_SIZE)) {\n+                    assertEquals(mutationBatchSizeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(UPSERT_MUTATION_BYTES)) {\n+                    assertEquals(upsertMutationBytesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(UPSERT_MUTATION_SQL_COUNTER)) {\n+                    assertEquals(upsertMutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(DELETE_MUTATION_BYTES)) {\n+                    assertEquals(deleteMutationByesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(DELETE_MUTATION_SQL_COUNTER)) {\n+                    assertEquals(deleteMutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(MUTATION_SQL_COUNTER)) {\n+                    assertEquals(mutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(MUTATION_COMMIT_TIME)) {\n+                    assertEquals(mutationSqlCommitTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(TASK_END_TO_END_TIME)) {\n+                    assertEquals(taskEndToEndTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(COUNT_ROWS_SCANNED)) {\n+                    assertEquals(countRowsScannedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(QUERY_FAILED_COUNTER)) {\n+                    assertEquals(queryFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(QUERY_TIMEOUT_COUNTER)) {\n+                    assertEquals(queryTimeOutCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SCAN_BYTES)) {\n+                    assertEquals(scanBytesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER)) {\n+                    assertEquals(selectPointLookUpSuccessCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_POINTLOOKUP_FAILED_SQL_COUNTER)) {\n+                    assertEquals(selectPointLookUpFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SQL_QUERY_TIME)) {\n+                    assertEquals(selectSqlQueryTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SCAN_FAILED_SQL_COUNTER)) {\n+                    assertEquals(selectScanFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SCAN_SUCCESS_SQL_COUNTER)) {\n+                    assertEquals(selectScanSuccessCounter[i], metric.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+    public boolean verifyTableName() {\n+\n+        if (tableMetricsSet.isEmpty()) {\n+            return false;\n+        }\n+        for (String tableName : tableNames) {\n+            TableClientMetrics instance = tableMetricsSet.get(tableName);\n+            if (!instance.getTableName().equals(tableName)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    /**\n+     * This test is for changeMetricValue() Method and getMetricMap()\n+     */\n+    @Test\n+    public void testTableClientMetrics() {\n+        for (int i = 0; i < tableNames.length; i++) {\n+            TableClientMetrics tableClientMetrics = new TableClientMetrics(tableNames[i]);\n+            tableMetricsSet.put(tableNames[i], tableClientMetrics);\n+\n+            tableClientMetrics.changeMetricValue(MUTATION_BATCH_SIZE,\n+                    mutationBatchSizeCounter[i]);\n+            tableClientMetrics.changeMetricValue(UPSERT_MUTATION_BYTES,\n+                    upsertMutationBytesCounter[i]);\n+            tableClientMetrics.changeMetricValue(UPSERT_MUTATION_SQL_COUNTER,\n+                    upsertMutationSqlCounter[i]);\n+            tableClientMetrics.changeMetricValue(DELETE_MUTATION_BYTES,\n+                    deleteMutationByesCounter[i]);\n+            tableClientMetrics.changeMetricValue(DELETE_MUTATION_SQL_COUNTER,\n+                    deleteMutationSqlCounter[i]);\n+            tableClientMetrics.changeMetricValue(MUTATION_SQL_COUNTER,\n+                    mutationSqlCounter[i]);\n+            tableClientMetrics.changeMetricValue(MUTATION_COMMIT_TIME,\n+                    mutationSqlCommitTimeCounter[i]);\n+            tableClientMetrics.changeMetricValue(TASK_END_TO_END_TIME,\n+                    taskEndToEndTimeCounter[i]);\n+            tableClientMetrics.changeMetricValue(COUNT_ROWS_SCANNED,\n+                    countRowsScannedCounter[i]);\n+            tableClientMetrics.changeMetricValue(QUERY_FAILED_COUNTER,\n+                    queryFailedCounter[i]);\n+            tableClientMetrics.changeMetricValue(QUERY_TIMEOUT_COUNTER,\n+                    queryTimeOutCounter[i]);\n+            tableClientMetrics.changeMetricValue(SCAN_BYTES, scanBytesCounter[i]);\n+            tableClientMetrics.changeMetricValue(MetricType.SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER,\n+                    selectPointLookUpSuccessCounter[i]);\n+            tableClientMetrics.changeMetricValue(SELECT_POINTLOOKUP_FAILED_SQL_COUNTER,\n+                    selectPointLookUpFailedCounter[i]);\n+            tableClientMetrics.changeMetricValue(SELECT_SQL_QUERY_TIME,\n+                    selectSqlQueryTimeCounter[i]);\n+            tableClientMetrics.changeMetricValue(SELECT_SCAN_SUCCESS_SQL_COUNTER,\n+                    selectScanSuccessCounter[i]);\n+            tableClientMetrics.changeMetricValue(SELECT_SCAN_FAILED_SQL_COUNTER,\n+                    selectScanFailedCounter[i]);\n+        }\n+        verifyMetricsFromTableClientMetrics();\n+        tableMetricsSet.clear();\n+    }\n+\n+    /**\n+     * This test is for getTableName()\n+     */\n+\n+    @Test\n+    public void testTableClientMetricsforTableName() {\n+        Configuration conf = new Configuration();\n+        for (int i = 0; i < tableNames.length; i++) {\n+            TableClientMetrics tableClientMetrics = new TableClientMetrics(tableNames[i]);\n+            tableMetricsSet.put(tableNames[i], tableClientMetrics);\n+        }\n+        assertTrue(verifyTableName());\n+    }\n+}"
  },
  {
    "sha": "4310f6d19acef8983d0672296885e839c5812363",
    "filename": "phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableLevelMetricsTestData.java",
    "status": "added",
    "additions": 165,
    "deletions": 0,
    "changes": 165,
    "blob_url": "https://github.com/apache/phoenix/blob/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableLevelMetricsTestData.java",
    "raw_url": "https://github.com/apache/phoenix/raw/e4a9e4eaf49b22048dbcab960b83c077878be1ac/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableLevelMetricsTestData.java",
    "contents_url": "https://api.github.com/repos/apache/phoenix/contents/phoenix-core/src/test/java/org/apache/phoenix/monitoring/TableLevelMetricsTestData.java?ref=e4a9e4eaf49b22048dbcab960b83c077878be1ac",
    "patch": "@@ -0,0 +1,165 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.monitoring;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.phoenix.monitoring.MetricType.COUNT_ROWS_SCANNED;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.DELETE_MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_BATCH_SIZE;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_COMMIT_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.MUTATION_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_FAILED_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.QUERY_TIMEOUT_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SCAN_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_FAILED_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SCAN_SUCCESS_SQL_COUNTER;\n+import static org.apache.phoenix.monitoring.MetricType.SELECT_SQL_QUERY_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.TASK_END_TO_END_TIME;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_BYTES;\n+import static org.apache.phoenix.monitoring.MetricType.UPSERT_MUTATION_SQL_COUNTER;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * This class is used primarily to populate data and\n+ * verification methods\n+ */\n+\n+public class TableLevelMetricsTestData {\n+\n+    public static final String[] tableNames = { \"T0001\", \"T0002\", \"T0003\" };\n+    public static Map<String, Map<MetricType, Long>>[] tableMetricsMap = new Map[tableNames.length];\n+    public static final long[] mutationBatchSizeCounter = { 90, 100, 150 };\n+    public static final long[] upsertMutationBytesCounter = { 100, 200, 250 };\n+    public static final long[] upsertMutationSqlCounter = { 100, 200, 300 };\n+    public static final long[] deleteMutationByesCounter = { 100, 200, 150 };\n+    public static final long[] deleteMutationSqlCounter = { 100, 200, 140 };\n+    public static final long[] mutationSqlCounter = { 200, 400, 600 };\n+    public static final long[] mutationSqlCommitTimeCounter = { 150, 300, 100 };\n+    public static final long[] taskEndToEndTimeCounter = { 10, 20, 30 };\n+    public static final long[] countRowsScannedCounter = { 500, 600, 400 };\n+    public static final long[] queryFailedCounter = { 10, 20, 30 };\n+    public static final long[] queryTimeOutCounter = { 30, 40, 40 };\n+    public static final long[] scanBytesCounter = { 500, 600, 400 };\n+    public static final long[] selectPointLookUpFailedCounter = { 10, 29, 49 };\n+    public static final long[] selectSqlQueryTimeCounter = { 30, 40, 55 };\n+    public static final long[] selectPointLookUpSuccessCounter = { 10, 20, 55 };\n+    public static final long[] selectScanSuccessCounter = { 200000, 300000, 4444 };\n+    public static final long[] selectScanFailedCounter = { 1000000, 20000000, 3455 };\n+\n+    public static void populateMetrics() {\n+        for (int i = 0; i < tableMetricsMap.length; i++) {\n+            tableMetricsMap[i] = new HashMap<>();\n+        }\n+        for (int i = 0; i < tableNames.length; i++) {\n+            Map<MetricType, Long> metrics = new HashMap<>();\n+            metrics.put(MUTATION_BATCH_SIZE, mutationBatchSizeCounter[i]);\n+            metrics.put(UPSERT_MUTATION_BYTES, upsertMutationBytesCounter[i]);\n+            metrics.put(UPSERT_MUTATION_SQL_COUNTER, upsertMutationSqlCounter[i]);\n+            metrics.put(DELETE_MUTATION_BYTES, deleteMutationByesCounter[i]);\n+            metrics.put(DELETE_MUTATION_SQL_COUNTER, deleteMutationSqlCounter[i]);\n+            metrics.put(MUTATION_SQL_COUNTER, mutationSqlCounter[i]);\n+            metrics.put(MUTATION_COMMIT_TIME, mutationSqlCommitTimeCounter[i]);\n+            metrics.put(TASK_END_TO_END_TIME, taskEndToEndTimeCounter[i]);\n+            metrics.put(COUNT_ROWS_SCANNED, countRowsScannedCounter[i]);\n+            metrics.put(QUERY_FAILED_COUNTER, queryFailedCounter[i]);\n+            metrics.put(QUERY_TIMEOUT_COUNTER, queryTimeOutCounter[i]);\n+            metrics.put(SCAN_BYTES, scanBytesCounter[i]);\n+            metrics.put(MetricType.SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER,\n+                    selectPointLookUpSuccessCounter[i]);\n+            metrics.put(SELECT_POINTLOOKUP_FAILED_SQL_COUNTER,\n+                    selectPointLookUpFailedCounter[i]);\n+            metrics.put(MetricType.SELECT_SQL_QUERY_TIME, selectSqlQueryTimeCounter[i]);\n+            metrics.put(SELECT_SCAN_SUCCESS_SQL_COUNTER, selectScanSuccessCounter[i]);\n+            metrics.put(MetricType.SELECT_SCAN_FAILED_SQL_COUNTER, selectScanFailedCounter[i]);\n+            tableMetricsMap[i].put(tableNames[i], metrics);\n+        }\n+    }\n+\n+    public void verifyMetricsInjection(int noOfTables) {\n+        Map<String, List<PhoenixTableMetric>> map = TableMetricsManager.getTableMetricsMethod();\n+        assertFalse(map == null || map.isEmpty());\n+        for (int i = 0; i < noOfTables; i++) {\n+            System.out.println(\"CURRENTLY ON: \" + tableNames[i]);\n+            assertTrue(map.containsKey(tableNames[i]));\n+            List<PhoenixTableMetric> tableMetric = map.get(tableNames[i]);\n+            for (PhoenixTableMetric metric : tableMetric) {\n+                if (metric.getMetricType().equals(MUTATION_BATCH_SIZE)) {\n+                    assertEquals(mutationBatchSizeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(UPSERT_MUTATION_BYTES)) {\n+                    assertEquals(upsertMutationBytesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(UPSERT_MUTATION_SQL_COUNTER)) {\n+                    assertEquals(upsertMutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(DELETE_MUTATION_BYTES)) {\n+                    assertEquals(deleteMutationByesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(DELETE_MUTATION_SQL_COUNTER)) {\n+                    assertEquals(deleteMutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(MUTATION_SQL_COUNTER)) {\n+                    assertEquals(mutationSqlCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(MUTATION_COMMIT_TIME)) {\n+                    assertEquals(mutationSqlCommitTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(TASK_END_TO_END_TIME)) {\n+                    assertEquals(taskEndToEndTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(COUNT_ROWS_SCANNED)) {\n+                    assertEquals(countRowsScannedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(QUERY_FAILED_COUNTER)) {\n+                    assertEquals(queryFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(QUERY_TIMEOUT_COUNTER)) {\n+                    assertEquals(queryTimeOutCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SCAN_BYTES)) {\n+                    assertEquals(scanBytesCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_POINTLOOKUP_SUCCESS_SQL_COUNTER)) {\n+                    assertEquals(selectPointLookUpSuccessCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_POINTLOOKUP_FAILED_SQL_COUNTER)) {\n+                    assertEquals(selectPointLookUpFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SQL_QUERY_TIME)) {\n+                    assertEquals(selectSqlQueryTimeCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SCAN_FAILED_SQL_COUNTER)) {\n+                    assertEquals(selectScanFailedCounter[i], metric.getValue());\n+                }\n+                if (metric.getMetricType().equals(SELECT_SCAN_SUCCESS_SQL_COUNTER)) {\n+                    assertEquals(selectScanSuccessCounter[i], metric.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+}"
  }
]
