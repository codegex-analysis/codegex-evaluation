[
  {
    "sha": "2f65b5349d5ef6cac946a2af99904eaa4e444050",
    "filename": "docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.cn.md",
    "status": "modified",
    "additions": 471,
    "deletions": 0,
    "changes": 471,
    "blob_url": "https://github.com/apache/shardingsphere/blob/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.cn.md",
    "raw_url": "https://github.com/apache/shardingsphere/raw/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.cn.md",
    "contents_url": "https://api.github.com/repos/apache/shardingsphere/contents/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.cn.md?ref=d0b668796e7c590716e8a0ce0fb590ad3bf11141",
    "patch": "@@ -22,3 +22,474 @@ spring.shardingsphere.rules.replica-query.load-balancers.<load-balance-algorithm\n ```\n \n 算法类型的详情，请参见[内置负载均衡算法列表](/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/load-balance)。\n+\n+### 数据分片\n+\n+#### 配置项说明\n+\n+```properties\n+spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册\n+\n+# 标准分片表配置\n+spring.shardingsphere.rules.sharding.tables.<table-name>.actual-data-nodes= # 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况\n+\n+# 分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一\n+\n+# 用于单分片键的标准分片场景\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.standard.<sharding-algorithm-name>.sharding-column= # 分片列名称\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.standard.<sharding-algorithm-name>.sharding-algorithm-name= # 分片算法名称\n+\n+# 用于多分片键的复合分片场景\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.complex.<sharding-algorithm-name>.sharding-columns= # 分片列名称，多个列以逗号分隔\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.complex.<sharding-algorithm-name>.sharding-algorithm-name= # 分片算法名称\n+\n+# 用于Hint 的分片策略\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.hint.<sharding-algorithm-name>.sharding-algorithm-name= # 分片算法名称\n+\n+# 分表策略，同分库策略\n+spring.shardingsphere.rules.sharding.tables.<table-name>.table-strategy.xxx= # 省略\n+\n+# 自动分片表配置\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.actual-data-sources= # 数据源名\n+\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.sharding-strategy.standard.sharding-column= # 分片列名称\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.sharding-strategy.standard.sharding-algorithm= # 自动分片算法名称\n+\n+# 分布式序列策略配置\n+spring.shardingsphere.rules.sharding.tables.<table-name>.key-generate-strategy.column= # 分布式序列列名称\n+spring.shardingsphere.rules.sharding.tables.<table-name>.key-generate-strategy.key-generator-name= # 分布式序列算法名称\n+\n+spring.shardingsphere.rules.sharding.binding-tables[0]= # 绑定表规则列表\n+spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表规则列表\n+spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表规则列表\n+\n+spring.shardingsphere.rules.sharding.broadcast-tables[0]= # 广播表规则列表\n+spring.shardingsphere.rules.sharding.broadcast-tables[1]= # 广播表规则列表\n+spring.shardingsphere.rules.sharding.broadcast-tables[x]= # 广播表规则列表\n+\n+spring.shardingsphere.sharding.default-database-strategy.xxx= # 默认数据库分片策略\n+spring.shardingsphere.sharding.default-table-strategy.xxx= # 默认表分片策略\n+spring.shardingsphere.sharding.default-key-generate-strategy.xxx= # 默认分布式序列策略\n+\n+# 分片算法配置\n+spring.shardingsphere.rules.sharding.sharding-algorithms.<sharding-algorithm-name>.type= # 分片算法类型\n+spring.shardingsphere.rules.sharding.sharding-algorithms.<sharding-algorithm-name>.props.xxx=# 分片算法属性配置\n+\n+# 分布式序列算法配置\n+spring.shardingsphere.rules.sharding.key-generators.<key-generate-algorithm-name>.type= # 分布式序列算法类型\n+spring.shardingsphere.rules.sharding.key-generators.<key-generate-algorithm-name>.props.xxx= # 分布式序列算法属性配置\n+```\n+\n+算法类型的详情，请参见[内置分片算法列表](/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding)和[内置分布式序列算法列表](/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/keygen)。\n+\n+### 数据加密\n+\n+#### 配置项说明\n+\n+```properties\n+spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册\n+\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.cipher-column= # 加密列名称\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.assisted-query-column= # 查询列名称\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.plain-column= # 原文列名称\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.encryptor-name= # 加密算法名称\n+\n+# 加密算法配置\n+spring.shardingsphere.rules.encrypt.encryptors.<encrypt-algorithm-name>.type= # 加密算法类型\n+spring.shardingsphere.rules.encrypt.encryptors.<encrypt-algorithm-name>.props.xxx= # 加密算法属性配置\n+```\n+\n+算法类型的详情，请参见[内置分片算法列表](/cn/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/encrypt)\n+\n+### 影子库\n+\n+#### 配置项说明\n+\n+```properties\n+spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册\n+\n+spring.shardingsphere.rules.shadow.column= # 影子字段名称名称\n+spring.shardingsphere.rules.shadow.shadow-mappings.<product-data-source-name>= # 影子数据库名称\n+```\n+\n+### 分布式治理\n+\n+#### 配置项说明\n+\n+```properties\n+spring.shardingsphere.governance.name= # 治理名称\n+spring.shardingsphere.governance.registry-center.type= # 治理持久化类型。如：Zookeeper, etcd, Apollo, Nacos\n+spring.shardingsphere.governance.registry-center.server-lists= # 治理服务列表。包括 IP 地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181\n+spring.shardingsphere.governance.registry-center.props= # 其它配置\n+spring.shardingsphere.governance.overwrite= # 本地配置是否覆盖配置中心配置。如果可覆盖，每次启动都以本地配置为准.\n+```\n+\n+### 混合规则\n+\n+#### 配置项说明\n+\n+```properties\n+# 数据源配置\n+# 数据源名称，多数据源以逗号分隔\n+spring.shardingsphere.datasource.names= write-ds0,write-ds1,write-ds0-read0,write-ds1-read0\n+\n+spring.shardingsphere.datasource.write-ds0.url= # 数据库 URL 连接\n+spring.shardingsphere.datasource.write-ds0.type=  # 数据库连接池类名称\n+spring.shardingsphere.datasource.write-ds0.driver-class-name= # 数据库驱动类名\n+spring.shardingsphere.datasource.write-ds0.username= # 数据库用户名\n+spring.shardingsphere.datasource.write-ds0.password= # 数据库密码\n+spring.shardingsphere.datasource.write-ds0.xxx=  # 数据库连接池的其它属性\n+\n+spring.shardingsphere.datasource.write-ds1.url= # 数据库 URL 连接\n+\n+spring.shardingsphere.datasource.write-ds0-read0.url= # 数据库 URL 连接\n+\n+spring.shardingsphere.datasource.write-ds1-read0.url= # 数据库 URL 连接\n+\n+# 分片规则配置\n+# 分库策略\n+spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=user_id\n+spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=default-database-strategy-inline\n+# 绑定表规则，多组绑定规则使用数组形式配置\n+spring.shardingsphere.rules.sharding.binding-tables[0]=t_user,t_user_detail # 绑定表名称，多个表之间以逗号分隔\n+spring.shardingsphere.rules.sharding.binding-tables[1]= # 绑定表名称，多个表之间以逗号分隔\n+spring.shardingsphere.rules.sharding.binding-tables[x]= # 绑定表名称，多个表之间以逗号分隔\n+# 广播表规则配置\n+spring.shardingsphere.rules.sharding.broadcast-tables= # 广播表名称，多个表之间以逗号分隔\n+\n+# 分表策略\n+# 表达式 `ds_$->{0..1}`枚举的数据源为读写分离配置的逻辑数据源名称\n+spring.shardingsphere.rules.sharding.tables.t_user.actual-data-nodes=ds_$->{0..1}.t_user_$->{0..1}\n+spring.shardingsphere.rules.sharding.tables.t_user.table-strategy.standard.sharding-column=user_id\n+spring.shardingsphere.rules.sharding.tables.t_user.table-strategy.standard.sharding-algorithm-name=user-table-strategy-inline\n+\n+spring.shardingsphere.rules.sharding.tables.t_user_detail.actual-data-nodes=ds_$->{0..1}.t_user_detail_$->{0..1}\n+spring.shardingsphere.rules.sharding.tables.t_user_detail.table-strategy.standard.sharding-column=user_id\n+spring.shardingsphere.rules.sharding.tables.t_user_detail.table-strategy.standard.sharding-algorithm-name=user-detail-table-strategy-inline\n+\n+# 数据加密配置\n+# `t_user` 使用分片规则配置的逻辑表名称\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.user_name.cipher-column=user_name\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.user_name.encryptor-name=name-encryptor\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.pwd.cipher-column=pwd\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.pwd.encryptor-name=pwd-encryptor\n+\n+# 数据加密算法配置\n+spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.type=AES\n+spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.props.aes-key-value=123456abc\n+spring.shardingsphere.rules.encrypt.encryptors.pwd-encryptor.type=AES\n+spring.shardingsphere.rules.encrypt.encryptors.pwd-encryptor.props.aes-key-value=123456abc\n+\n+# 分布式序列策略配置\n+spring.shardingsphere.rules.sharding.tables.t_user.key-generate-strategy.column=user_id\n+spring.shardingsphere.rules.sharding.tables.t_user.key-generate-strategy.key-generator-name=snowflake\n+\n+# 分片算法配置\n+spring.shardingsphere.rules.sharding.sharding-algorithms.default-database-strategy-inline.type=INLINE\n+# 表达式`ds_$->{user_id % 2}` 枚举的数据源为读写分离配置的逻辑数据源名称\n+spring.shardingsphere.rules.sharding.sharding-algorithms.default-database-strategy-inline.algorithm-expression=ds_$->{user_id % 2}\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-table-strategy-inline.type=INLINE\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-table-strategy-inline.algorithm-expression=t_user_$->{user_id % 2}\n+\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-detail-table-strategy-inline.type=INLINE\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-detail-table-strategy-inline.algorithm-expression=t_user_detail_$->{user_id % 2}\n+\n+# 分布式序列算法配置\n+spring.shardingsphere.rules.sharding.key-generators.snowflake.type=SNOWFLAKE\n+spring.shardingsphere.rules.sharding.key-generators.snowflake.props.worker-id=123\n+\n+# 读写分离策略配置\n+# ds_0,ds_1为读写分离配置的逻辑数据源名称\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.write-data-source-name=write-ds0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.read-data-source-names=write-ds0-read0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.load-balancer-name=read-random\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.write-data-source-name=write-ds1\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.read-data-source-names=write-ds1-read0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.load-balancer-name=read-random\n+\n+# 负载均衡算法配置\n+spring.shardingsphere.rules.read-write-splitting.load-balancers.read-random.type=RANDOM\n+```\n+\n+## shardingsphere-4.x\n+\n+### 读写分离\n+\n+#### 配置项说明\n+\n+```properties\n+#省略数据源配置，与数据分片一致\n+\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #主库数据源名称\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #从库数据源名称列表\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #从库数据源名称列表\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #从库数据源名称列表\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #从库负载均衡算法类名称。该类需实现MasterSlaveLoadBalanceAlgorithm接口且提供无参数构造器\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #从库负载均衡算法类型，可选值：ROUND_ROBIN，RANDOM。若`load-balance-algorithm-class-name`存在则忽略该配置\n+\n+spring.shardingsphere.props.sql.show= #是否开启SQL显示，默认值: false\n+spring.shardingsphere.props.executor.size= #工作线程数量，默认值: CPU核数\n+spring.shardingsphere.props.check.table.metadata.enabled= #是否在启动时检查分表元数据一致性，默认值: false\n+```\n+\n+### 数据分片\n+\n+#### 配置项说明\n+\n+```properties\n+spring.shardingsphere.datasource.names= #数据源名称，多数据源以逗号分隔\n+\n+spring.shardingsphere.datasource.<data-source-name>.type= #数据库连接池类名称\n+spring.shardingsphere.datasource.<data-source-name>.driver-class-name= #数据库驱动类名\n+spring.shardingsphere.datasource.<data-source-name>.url= #数据库url连接\n+spring.shardingsphere.datasource.<data-source-name>.username= #数据库用户名\n+spring.shardingsphere.datasource.<data-source-name>.password= #数据库密码\n+spring.shardingsphere.datasource.<data-source-name>.xxx= #数据库连接池的其它属性\n+\n+spring.shardingsphere.sharding.tables.<logic-table-name>.actual-data-nodes= #由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况\n+\n+#分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一\n+\n+#用于单分片键的标准分片场景\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.sharding-column= #分片列名称\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.precise-algorithm-class-name= #精确分片算法类名称，用于=和IN。该类需实现PreciseShardingAlgorithm接口并提供无参数的构造器\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.range-algorithm-class-name= #范围分片算法类名称，用于BETWEEN，可选。该类需实现RangeShardingAlgorithm接口并提供无参数的构造器\n+\n+#用于多分片键的复合分片场景\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.complex.sharding-columns= #分片列名称，多个列以逗号分隔\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.complex.algorithm-class-name= #复合分片算法类名称。该类需实现ComplexKeysShardingAlgorithm接口并提供无参数的构造器\n+\n+#行表达式分片策略\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.inline.sharding-column= #分片列名称\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.inline.algorithm-expression= #分片算法行表达式，需符合groovy语法\n+\n+#Hint分片策略\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.hint.algorithm-class-name= #Hint分片算法类名称。该类需实现HintShardingAlgorithm接口并提供无参数的构造器\n+\n+#分表策略，同分库策略\n+spring.shardingsphere.sharding.tables.<logic-table-name>.table-strategy.xxx= #省略\n+\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.column= #自增列名称，缺省表示不使用自增主键生成器\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.type= #自增列值生成器类型，缺省表示使用默认自增列值生成器。可使用用户自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.props.<property-name>= #属性配置, 注意：使用SNOWFLAKE算法，需要配置worker.id与max.tolerate.time.difference.milliseconds属性。若使用此算法生成值作分片值，建议配置max.vibration.offset属性\n+\n+spring.shardingsphere.sharding.binding-tables[0]= #绑定表规则列表\n+spring.shardingsphere.sharding.binding-tables[1]= #绑定表规则列表\n+spring.shardingsphere.sharding.binding-tables[x]= #绑定表规则列表\n+\n+spring.shardingsphere.sharding.broadcast-tables[0]= #广播表规则列表\n+spring.shardingsphere.sharding.broadcast-tables[1]= #广播表规则列表\n+spring.shardingsphere.sharding.broadcast-tables[x]= #广播表规则列表\n+\n+spring.shardingsphere.sharding.default-data-source-name= #未配置分片规则的表将通过默认数据源定位\n+spring.shardingsphere.sharding.default-database-strategy.xxx= #默认数据库分片策略，同分库策略\n+spring.shardingsphere.sharding.default-table-strategy.xxx= #默认表分片策略，同分表策略\n+spring.shardingsphere.sharding.default-key-generator.type= #默认自增列值生成器类型，缺省将使用org.apache.shardingsphere.core.keygen.generator.impl.SnowflakeKeyGenerator。可使用用户自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID\n+spring.shardingsphere.sharding.default-key-generator.props.<property-name>= #自增列值生成器属性配置, 比如SNOWFLAKE算法的worker.id与max.tolerate.time.difference.milliseconds\n+\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #详见读写分离部分\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #详见读写分离部分\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #详见读写分离部分\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #详见读写分离部分\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #详见读写分离部分\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #详见读写分离部分\n+\n+spring.shardingsphere.props.sql.show= #是否开启SQL显示，默认值: false\n+spring.shardingsphere.props.executor.size= #工作线程数量，默认值: CPU核数\n+```\n+\n+### 编排治理\n+\n+#### 治理\n+\n+##### 配置项说明\n+\n+```properties\n+#省略数据源、数据分片、读写分离和数据脱敏配置\n+\n+spring.shardingsphere.orchestration.name= #治理实例名称\n+spring.shardingsphere.orchestration.overwrite= #本地配置是否覆盖注册中心配置。如果可覆盖，每次启动都以本地配置为准\n+spring.shardingsphere.orchestration.registry.type= #配置中心类型。如：zookeeper\n+spring.shardingsphere.orchestration.registry.server-lists= #连接注册中心服务器的列表。包括IP地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181\n+spring.shardingsphere.orchestration.registry.namespace= #注册中心的命名空间\n+spring.shardingsphere.orchestration.registry.digest= #连接注册中心的权限令牌。缺省为不需要权限验证\n+spring.shardingsphere.orchestration.registry.operation-timeout-milliseconds= #操作超时的毫秒数，默认500毫秒\n+spring.shardingsphere.orchestration.registry.max-retries= #连接失败后的最大重试次数，默认3次\n+spring.shardingsphere.orchestration.registry.retry-interval-milliseconds= #重试间隔毫秒数，默认500毫秒\n+spring.shardingsphere.orchestration.registry.time-to-live-seconds= #临时节点存活秒数，默认60秒\n+spring.shardingsphere.orchestration.registry.props= #配置中心其它属性\n+```\n+\n+### 数据脱敏\n+\n+#### 配置项说明\n+\n+```properties\n+#省略数据源配置，与数据分片一致\n+\n+spring.shardingsphere.encrypt.encryptors.<encryptor-name>.type= #加解密器类型，可自定义或选择内置类型：MD5/AES\n+spring.shardingsphere.encrypt.encryptors.<encryptor-name>.props.<property-name>= #属性配置, 注意：使用AES加密器，需要配置AES加密器的KEY属性：aes.key.value\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.plainColumn= #存储明文的字段\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.cipherColumn= #存储密文的字段\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.assistedQueryColumn= #辅助查询字段，针对ShardingQueryAssistedEncryptor类型的加解密器进行辅助查询\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.encryptor= #加密器名字\n+```\n+\n+## shardingsphere-3.x\n+\n+### 数据分片\n+\n+#### 配置项说明\n+\n+```properties\n+sharding.jdbc.datasource.names= #数据源名称，多数据源以逗号分隔\n+\n+sharding.jdbc.datasource.<data-source-name>.type= #数据库连接池类名称\n+sharding.jdbc.datasource.<data-source-name>.driver-class-name= #数据库驱动类名\n+sharding.jdbc.datasource.<data-source-name>.url= #数据库url连接\n+sharding.jdbc.datasource.<data-source-name>.username= #数据库用户名\n+sharding.jdbc.datasource.<data-source-name>.password= #数据库密码\n+sharding.jdbc.datasource.<data-source-name>.xxx= #数据库连接池的其它属性\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.actual-data-nodes= #由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点。用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况\n+\n+#分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一\n+\n+#用于单分片键的标准分片场景\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.sharding-column= #分片列名称\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.precise-algorithm-class-name= #精确分片算法类名称，用于=和IN。该类需实现PreciseShardingAlgorithm接口并提供无参数的构造器\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.range-algorithm-class-name= #范围分片算法类名称，用于BETWEEN，可选。该类需实现RangeShardingAlgorithm接口并提供无参数的构造器\n+\n+#用于多分片键的复合分片场景\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.complex.sharding-columns= #分片列名称，多个列以逗号分隔\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.complex.algorithm-class-name= #复合分片算法类名称。该类需实现ComplexKeysShardingAlgorithm接口并提供无参数的构造器\n+\n+#行表达式分片策略\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.inline.sharding-column= #分片列名称\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.inline.algorithm-expression= #分片算法行表达式，需符合groovy语法\n+\n+#Hint分片策略\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.hint.algorithm-class-name= #Hint分片算法类名称。该类需实现HintShardingAlgorithm接口并提供无参数的构造器\n+\n+#分表策略，同分库策略\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.table-strategy.xxx= #省略\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-column-name= #自增列名称，缺省表示不使用自增主键生成器\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-class-name= #自增列值生成器类名称，缺省表示使用默认自增列值生成器。该类需提供无参数的构造器\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.logic-index= #逻辑索引名称，对于分表的Oracle/PostgreSQL数据库中DROP INDEX XXX语句，需要通过配置逻辑索引名称定位所执行SQL的真实分表\n+\n+sharding.jdbc.config.sharding.binding-tables[0]= #绑定表规则列表\n+sharding.jdbc.config.sharding.binding-tables[1]= #绑定表规则列表\n+sharding.jdbc.config.sharding.binding-tables[x]= #绑定表规则列表\n+\n+sharding.jdbc.config.sharding.broadcast-tables[0]= #广播表规则列表\n+sharding.jdbc.config.sharding.broadcast-tables[1]= #广播表规则列表\n+sharding.jdbc.config.sharding.broadcast-tables[x]= #广播表规则列表\n+\n+sharding.jdbc.config.sharding.default-data-source-name= #未配置分片规则的表将通过默认数据源定位\n+sharding.jdbc.config.sharding.default-database-strategy.xxx= #默认数据库分片策略，同分库策略\n+sharding.jdbc.config.sharding.default-table-strategy.xxx= #默认表分片策略，同分表策略\n+sharding.jdbc.config.sharding.default-key-generator-class-name= #默认自增列值生成器类名称，缺省使用io.shardingsphere.core.keygen.DefaultKeyGenerator。该类需实现KeyGenerator接口并提供无参数的构造器\n+\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #详见读写分离部分\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #详见读写分离部分\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #详见读写分离部分\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #详见读写分离部分\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #详见读写分离部分\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #详见读写分离部分\n+\n+sharding.jdbc.config.props.sql.show= #是否开启SQL显示，默认值: false\n+sharding.jdbc.config.props.executor.size= #工作线程数量，默认值: CPU核数\n+\n+sharding.jdbc.config.config.map.key1= #用户自定义配置\n+sharding.jdbc.config.config.map.key2= #用户自定义配置\n+sharding.jdbc.config.config.map.keyx= #用户自定义配置\n+```\n+\n+### 读写分离\n+\n+#### 配置项说明\n+\n+```properties\n+#省略数据源配置，与数据分片一致\n+\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #主库数据源名称\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #从库数据源名称列表\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #从库数据源名称列表\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #从库数据源名称列表\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #从库负载均衡算法类名称。该类需实现MasterSlaveLoadBalanceAlgorithm接口且提供无参数构造器\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #从库负载均衡算法类型，可选值：ROUND_ROBIN，RANDOM。若`load-balance-algorithm-class-name`存在则忽略该配置\n+\n+sharding.jdbc.config.config.map.key1= #用户自定义配置\n+sharding.jdbc.config.config.map.key2= #用户自定义配置\n+sharding.jdbc.config.config.map.keyx= #用户自定义配置\n+\n+sharding.jdbc.config.props.sql.show= #是否开启SQL显示，默认值: false\n+sharding.jdbc.config.props.executor.size= #工作线程数量，默认值: CPU核数\n+sharding.jdbc.config.props.check.table.metadata.enabled= #是否在启动时检查分表元数据一致性，默认值: false\n+```\n+\n+### 数据治理\n+\n+#### 配置项说明\n+\n+```properties\n+#省略数据源、数据分片和读写分离配置\n+\n+sharding.jdbc.config.sharding.orchestration.name= #数据治理实例名称\n+sharding.jdbc.config.sharding.orchestration.overwrite= #本地配置是否覆盖注册中心配置。如果可覆盖，每次启动都以本地配置为准\n+sharding.jdbc.config.sharding.orchestration.registry.server-lists= #连接注册中心服务器的列表。包括IP地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181\n+sharding.jdbc.config.sharding.orchestration.registry.namespace= #注册中心的命名空间\n+sharding.jdbc.config.sharding.orchestration.registry.digest= #连接注册中心的权限令牌。缺省为不需要权限验证\n+sharding.jdbc.config.sharding.orchestration.registry.operation-timeout-milliseconds= #操作超时的毫秒数，默认500毫秒\n+sharding.jdbc.config.sharding.orchestration.registry.max-retries= #连接失败后的最大重试次数，默认3次\n+sharding.jdbc.config.sharding.orchestration.registry.retry-interval-milliseconds= #重试间隔毫秒数，默认500毫秒\n+sharding.jdbc.config.sharding.orchestration.registry.time-to-live-seconds= #临时节点存活秒数，默认60秒\n+```\n+\n+## shardingsphere-2.x\n+\n+### 读写分离\n+\n+#### 配置项说明\n+\n+```properties\n+\n+sharding.jdbc.config.masterslave.load-balance-algorithm-type= #从库负载均衡算法类型，可选值：ROUND_ROBIN，RANDOM。若`load-balance-algorithm-class-name`存在则忽略该配置\n+sharding.jdbc.config.masterslave.name= #主库名称\n+sharding.jdbc.config.masterslave.master-data-source-name= #主库数据源名称\n+sharding.jdbc.config.masterslave.slave-data-source-names= #从数据源名称，多个使用逗号隔开\n+```\n+\n+### 分库分表\n+\n+#### 配置说明\n+\n+```properties\n+\n+sharding.jdbc.config.sharding.default-data-source-name= #未配置分片规则的表将通过默认数据源定位\n+sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column= #默认分库数据列\n+sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression= # 默认分库inline表达式\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.actualDataNodes= #由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点。用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.tableStrategy.inline.shardingColumn= #默认分表的列\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.tableStrategy.inline.algorithmInlineExpression= #默认分表inline表达式\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.keyGeneratorColumnName=  #默认自增列值生成器类名称\n+```\n+\n+### 编排治理\n+\n+#### 配置项说明\n+\n+```properties\n+\n+sharding.jdbc.config.orchestration.name= #数据治理实例名称\n+sharding.jdbc.config.orchestration.overwrite= #本地配置是否覆盖注册中心配置。如果可覆盖，每次启动都以本地配置为准\n+\n+# zookeeper配置说明\n+sharding.jdbc.config.orchestration.zookeeper.namespace= # zookeeper配置中心命名空间\n+sharding.jdbc.config.orchestration.zookeeper.server-lists= #连接zookeeper注册中心服务器的列表。包括IP地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181\n+\n+# etcd配置说明\n+sharding.jdbc.config.orchestration.etcd.server-lists= #连接etcd注册中心服务器的列表。包括IP地址和端口号。多个地址用逗号分隔。如: host1:2181,host2:2181\n+```\n\\ No newline at end of file"
  },
  {
    "sha": "27751307618f6a3384bd333d1aa34a6c65dfc34c",
    "filename": "docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.en.md",
    "status": "modified",
    "additions": 485,
    "deletions": 0,
    "changes": 485,
    "blob_url": "https://github.com/apache/shardingsphere/blob/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.en.md",
    "raw_url": "https://github.com/apache/shardingsphere/raw/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.en.md",
    "contents_url": "https://api.github.com/repos/apache/shardingsphere/contents/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/change-history.en.md?ref=d0b668796e7c590716e8a0ce0fb590ad3bf11141",
    "patch": "@@ -22,3 +22,488 @@ spring.shardingsphere.rules.replica-query.load-balancers.<load-balance-algorithm\n ```\n \n Please refer to [Built-in Load Balance Algorithm List](/en/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/load-balance) for more details about type of algorithm.\n+\n+### Sharding\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+spring.shardingsphere.datasource.names= # Omit the data source configuration, please refer to the usage\n+\n+# Standard sharding table configuration\n+spring.shardingsphere.rules.sharding.tables.<table-name>.actual-data-nodes= # Describe data source names and actual tables, delimiter as point, multiple data nodes separated with comma, support inline expression. Absent means sharding databases only.\n+\n+# Databases sharding strategy, use default databases sharding strategy if absent. sharding strategy below can choose only one.\n+\n+# For single sharding column scenario\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.standard.<sharding-algorithm-name>.sharding-column= # Sharding column name\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.standard.<sharding-algorithm-name>.sharding-algorithm-name= # Sharding algorithm name\n+\n+# For multiple sharding columns scenario\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.complex.<sharding-algorithm-name>.sharding-columns= # Sharding column names, multiple columns separated with comma\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.complex.<sharding-algorithm-name>.sharding-algorithm-name= # Sharding algorithm name\n+\n+# Sharding by hint\n+spring.shardingsphere.rules.sharding.tables.<table-name>.database-strategy.hint.<sharding-algorithm-name>.sharding-algorithm-name= # Sharding algorithm name\n+\n+# Tables sharding strategy, same as database sharding strategy\n+spring.shardingsphere.rules.sharding.tables.<table-name>.table-strategy.xxx= # Omitted\n+\n+# Auto sharding table configuraiton\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.actual-data-sources= # data source names\n+\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.sharding-strategy.standard.sharding-column= # Sharding column name\n+spring.shardingsphere.rules.sharding.auto-tables.<auto-table-name>.sharding-strategy.standard.sharding-algorithm= # Auto sharding algorithm name\n+\n+# Key generator strategy configuration\n+spring.shardingsphere.rules.sharding.tables.<table-name>.key-generate-strategy.column= # Column name of key generator\n+spring.shardingsphere.rules.sharding.tables.<table-name>.key-generate-strategy.key-generator-name= # Key generator name\n+\n+spring.shardingsphere.rules.sharding.binding-tables[0]= # Binding table name\n+spring.shardingsphere.rules.sharding.binding-tables[1]= # Binding table name\n+spring.shardingsphere.rules.sharding.binding-tables[x]= # Binding table name\n+\n+spring.shardingsphere.rules.sharding.broadcast-tables[0]= # Broadcast tables\n+spring.shardingsphere.rules.sharding.broadcast-tables[1]= # Broadcast tables\n+spring.shardingsphere.rules.sharding.broadcast-tables[x]= # Broadcast tables\n+\n+spring.shardingsphere.sharding.default-database-strategy.xxx= # Default strategy for database sharding\n+spring.shardingsphere.sharding.default-table-strategy.xxx= # Default strategy for table sharding\n+spring.shardingsphere.sharding.default-key-generate-strategy.xxx= # Default Key generator strategy\n+\n+# Sharding algorithm configuration\n+spring.shardingsphere.rules.sharding.sharding-algorithms.<sharding-algorithm-name>.type= # Sharding algorithm type\n+spring.shardingsphere.rules.sharding.sharding-algorithms.<sharding-algorithm-name>.props.xxx=# Sharding algorithm properties\n+\n+# Key generate algorithm configuration\n+spring.shardingsphere.rules.sharding.key-generators.<key-generate-algorithm-name>.type= # Key generate algorithm type\n+spring.shardingsphere.rules.sharding.key-generators.<key-generate-algorithm-name>.props.xxx= # Key generate algorithm properties\n+```\n+\n+Please refer to [Built-in sharding Algorithm List](/en/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/sharding) and [Built-in keygen Algorithm List](/en/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/keygen)。\n+\n+\n+### Encryption\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+spring.shardingsphere.datasource.names= # Omit the data source configuration, please refer to the usage\n+\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.cipher-column= # Cipher column name\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.assisted-query-column= # Assisted query column name\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.plain-column= # Plain column name\n+spring.shardingsphere.rules.encrypt.tables.<table-name>.columns.<column-name>.encryptor-name= # Encrypt algorithm name\n+\n+# Encrypt algorithm configuration\n+spring.shardingsphere.rules.encrypt.encryptors.<encrypt-algorithm-name>.type= # Encrypt algorithm type\n+spring.shardingsphere.rules.encrypt.encryptors.<encrypt-algorithm-name>.props.xxx= # Encrypt algorithm properties\n+```\n+\n+### Shadow DB\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+spring.shardingsphere.datasource.names= # Omit the data source configuration, please refer to the usage\n+\n+spring.shardingsphere.rules.shadow.column= # Shadow column name\n+spring.shardingsphere.rules.shadow.shadow-mappings.<product-data-source-name>= # Shadow data source name\n+```\n+\n+### Governance\n+\n+#### Configuration Item Explanation\n+\n+##### Management\n+\n+```properties\n+spring.shardingsphere.governance.name= # Governance name\n+spring.shardingsphere.governance.registry-center.type= # Governance instance type. Example:Zookeeper, etcd, Apollo, Nacos\n+spring.shardingsphere.governance.registry-center.server-lists= # The list of servers that connect to governance instance, including IP and port number; use commas to separate\n+spring.shardingsphere.governance.registry-center.props= # Other properties\n+spring.shardingsphere.governance.overwrite= # Whether to overwrite local configurations with config center configurations; if it can, each initialization should refer to local configurations\n+```\n+\n+### Mixed Rules\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+# data source configuration\n+spring.shardingsphere.datasource.names= write-ds0,write-ds1,write-ds0-read0,write-ds1-read0\n+\n+spring.shardingsphere.datasource.write-ds0.url= # Database URL connection\n+spring.shardingsphere.datasource.write-ds0.type=  # Database connection pool type name\n+spring.shardingsphere.datasource.write-ds0.driver-class-name= # Database driver class name\n+spring.shardingsphere.datasource.write-ds0.username= # Database username\n+spring.shardingsphere.datasource.write-ds0.password= # Database password\n+spring.shardingsphere.datasource.write-ds0.xxx=  # Other properties of database connection pool\n+\n+spring.shardingsphere.datasource.write-ds1.url= # Database URL connection\n+# ...Omit specific configuration.\n+\n+spring.shardingsphere.datasource.write-ds0-read0.url= # Database URL connection\n+# ...Omit specific configuration.\n+\n+spring.shardingsphere.datasource.write-ds1-read0.url= # Database URL connection\n+# ...Omit specific configuration.\n+\n+# Sharding rules configuration\n+# Databases sharding strategy\n+spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-column=user_id\n+spring.shardingsphere.rules.sharding.default-database-strategy.standard.sharding-algorithm-name=default-database-strategy-inline\n+# Binding table rules configuration ,and multiple groups of binding-tables configured with arrays\n+spring.shardingsphere.rules.sharding.binding-tables[0]=t_user,t_user_detail\n+spring.shardingsphere.rules.sharding.binding-tables[1]= # Binding table names,multiple table name are separated by commas\n+spring.shardingsphere.rules.sharding.binding-tables[x]= # Binding table names,multiple table name are separated by commas\n+# Broadcast table rules configuration\n+spring.shardingsphere.rules.sharding.broadcast-tables= # Broadcast table names,multiple table name are separated by commas\n+\n+# Table sharding strategy\n+# The enumeration value of `ds_$->{0..1}` is the name of the logical data source configured with read-write-splitting\n+spring.shardingsphere.rules.sharding.tables.t_user.actual-data-nodes=ds_$->{0..1}.t_user_$->{0..1}\n+spring.shardingsphere.rules.sharding.tables.t_user.table-strategy.standard.sharding-column=user_id\n+spring.shardingsphere.rules.sharding.tables.t_user.table-strategy.standard.sharding-algorithm-name=user-table-strategy-inline\n+\n+# Data encrypt configuration\n+# Table `t_user` is the name of the logical table that uses for data sharding configuration.\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.user_name.cipher-column=user_name\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.user_name.encryptor-name=name-encryptor\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.pwd.cipher-column=pwd\n+spring.shardingsphere.rules.encrypt.tables.t_user.columns.pwd.encryptor-name=pwd-encryptor\n+\n+# Data encrypt algorithm configuration\n+spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.type=AES\n+spring.shardingsphere.rules.encrypt.encryptors.name-encryptor.props.aes-key-value=123456abc\n+spring.shardingsphere.rules.encrypt.encryptors.pwd-encryptor.type=AES\n+spring.shardingsphere.rules.encrypt.encryptors.pwd-encryptor.props.aes-key-value=123456abc\n+\n+# Key generate strategy configuration\n+spring.shardingsphere.rules.sharding.tables.t_user.key-generate-strategy.column=user_id\n+spring.shardingsphere.rules.sharding.tables.t_user.key-generate-strategy.key-generator-name=snowflake\n+\n+# Sharding algorithm configuration\n+spring.shardingsphere.rules.sharding.sharding-algorithms.default-database-strategy-inline.type=INLINE\n+# The enumeration value of `ds_$->{user_id % 2}` is the name of the logical data source configured with read-write-splitting\n+spring.shardingsphere.rules.sharding.sharding-algorithms.default-database-strategy-inline.algorithm-expression=ds$->{user_id % 2}\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-table-strategy-inline.type=INLINE\n+spring.shardingsphere.rules.sharding.sharding-algorithms.user-table-strategy-inline.algorithm-expression=t_user_$->{user_id % 2}\n+\n+# Key generate algorithm configuration\n+spring.shardingsphere.rules.sharding.key-generators.snowflake.type=SNOWFLAKE\n+spring.shardingsphere.rules.sharding.key-generators.snowflake.props.worker-id=123\n+\n+# read query configuration\n+# ds_0,ds_1 is the logical data source name of the read-write-splitting\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.write-data-source-name=write-ds0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.read-data-source-names=write-ds0-read0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_0.load-balancer-name=read-random\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.write-data-source-name=write-ds1\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.read-data-source-names=write-ds1-read0\n+spring.shardingsphere.rules.read-write-splitting.data-sources.ds_1.load-balancer-name=read-random\n+\n+# Load balance algorithm configuration\n+spring.shardingsphere.rules.read-write-splitting.load-balancers.read-random.type=RANDOM\n+```\n+\n+## Shardingsphere-4.x\n+\n+### Read-Write Split\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+#Omit data source configurations; keep it consistent with data sharding\n+\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #Data source name of master database\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #Data source name list of slave database\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #Data source name list of slave database\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #Data source name list of slave database\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #Load balance algorithm class name; the class needs to implement MasterSlaveLoadBalanceAlgorithm interface and provide parameter-free constructor\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #Load balance algorithm class of slave database; optional value: ROUND_ROBIN and RANDOM; if there is load-balance-algorithm-class-name, the configuration can be omitted\n+\n+spring.shardingsphere.props.sql.show= #Show SQL or not; default value: false\n+spring.shardingsphere.props.executor.size= #Executing thread number; default value: CPU core number\n+spring.shardingsphere.props.check.table.metadata.enabled= #Whether to check meta-data consistency of sharding table when it initializes; default value: false\n+```\n+\n+### Data Sharding\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+spring.shardingsphere.datasource.names= #Data source name; multiple data sources are separated by commas\n+\n+spring.shardingsphere.datasource.<data-source-name>.type= #Database connection pool type name\n+spring.shardingsphere.datasource.<data-source-name>.driver-class-name= #Database driver class name\n+spring.shardingsphere.datasource.<data-source-name>.url= #Database url connection\n+spring.shardingsphere.datasource.<data-source-name>.username= #Database username\n+spring.shardingsphere.datasource.<data-source-name>.password= #Database password\n+spring.shardingsphere.datasource.<data-source-name>.xxx= #Other properties of database connection pool\n+\n+spring.shardingsphere.sharding.tables.<logic-table-name>.actual-data-nodes= #It is consisted of data source name + table name, separated by decimal points; multiple tables are separated by commas and support inline expressions; default means using existing data sources and logic table names to generate data nodes; it can be applied in broadcast tables (each database needs a same table for relevance query, dictionary table mostly) or the situation with sharding database but without sharding table (table structures of all the databases are consistent)\n+\n+#Database sharding strategy; default means using default database sharding strategy; it can only choose one of the following sharding strategies\n+\n+#It is applied in standard sharding situation of single-sharding key\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.sharding-column= #Sharding column name\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.precise-algorithm-class-name= #Precise algorithm class name, applied in = and IN; the class needs to implement PreciseShardingAlgorithm interface and provide parameter-free constructor\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.standard.range-algorithm-class-name= #Range sharding algorithm class name, applied in BETWEEN, optional; the class should implement RangeShardingAlgorithm interface and provide parameter-free constructor\n+\n+#It is applied in complex sharding situations with multiple sharding keys\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.complex.sharding-columns= #Sharding column name, with multiple columns separated by commas\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.complex.algorithm-class-name= #Complex sharding algorithm class name; the class needs to implement ComplexKeysShardingAlgorithm interface and provide parameter-free constructor\n+\n+#Inline expression sharding strategy\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.inline.sharding-column= #Sharding column name\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.inline.algorithm-expression= #Inline expression of sharding algorithm, which needs to conform to groovy statements\n+\n+#Hint Sharding Strategy\n+spring.shardingsphere.sharding.tables.<logic-table-name>.database-strategy.hint.algorithm-class-name= #Hint algorithm class name;  the class needs to implement HintShardingAlgorithm interface and provide parameter-free constructor\n+\n+#Table sharding strategy, same as database sharding strategy\n+spring.shardingsphere.sharding.tables.<logic-table-name>.table-strategy.xxx= #Omitted\n+\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.column= #Auto-increment column name; default means not using auto-increment key generator\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.type= #Auto-increament key generator type; default means using default auto-increament key generator; user defined generator or internal generator (SNOWFLAKE, UUID) can both be selected\n+spring.shardingsphere.sharding.tables.<logic-table-name>.key-generator.props.<property-name>= #Properties, Notice: when use SNOWFLAKE, `worker.id` and `max.tolerate.time.difference.milliseconds` for `SNOWFLAKE` need to be set. To use the generated value of this algorithm as sharding value, it is recommended to configure `max.vibration.offset`\n+\n+spring.shardingsphere.sharding.binding-tables[0]= #Binding table rule list\n+spring.shardingsphere.sharding.binding-tables[1]= #Binding table rule list\n+spring.shardingsphere.sharding.binding-tables[x]= #Binding table rule list\n+\n+spring.shardingsphere.sharding.broadcast-tables[0]= #Broadcast table rule list\n+spring.shardingsphere.sharding.broadcast-tables[1]= #Broadcast table rule list\n+spring.shardingsphere.sharding.broadcast-tables[x]= #Broadcast table rule list\n+\n+spring.shardingsphere.sharding.default-data-source-name= #Tables without sharding rules will be located through default data source\n+spring.shardingsphere.sharding.default-database-strategy.xxx= #Default database sharding strategy\n+spring.shardingsphere.sharding.default-table-strategy.xxx= #Default table sharding strategy\n+spring.shardingsphere.sharding.default-key-generator.type= #Default auto-increament key generator of type; it will use org.apache.shardingsphere.core.keygen.generator.impl.SnowflakeKeyGenerator in default; user defined generator or internal generator (SNOWFLAKE or UUID) can both be used\n+spring.shardingsphere.sharding.default-key-generator.props.<property-name>= #Auto-increament key generator property configuration, such as worker.id and max.tolerate.time.difference.milliseconds of SNOWFLAKE algorithm\n+\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #Refer to read-write split part for more details\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #Refer to read-write split part for more details\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #Refer to read-write split part for more details\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #Refer to read-write split part for more details\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #Refer to read-write split part for more details\n+spring.shardingsphere.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #Refer to read-write split part for more details\n+\n+spring.shardingsphere.props.sql.show= #Show SQL or not; default value: false\n+spring.shardingsphere.props.executor.size= #Executing thread number; default value: CPU core number\n+```\n+\n+### Data Masking\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+#Omit data source configurations; keep it consistent with data sharding\n+\n+spring.shardingsphere.encrypt.encryptors.<encryptor-name>.type= #Type of encryptor，use user-defined ones or built-in ones, e.g. MD5/AES  \n+spring.shardingsphere.encrypt.encryptors.<encryptor-name>.props.<property-name>= #Properties, Notice: when use AES encryptor, `aes.key.value` for AES encryptor need to be set\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.plainColumn= #Plain column name\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.cipherColumn= #Cipher column name \n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.assistedQueryColumn= #AssistedColumns for query，when use ShardingQueryAssistedEncryptor, it can help query encrypted data\n+spring.shardingsphere.encrypt.tables.<table-name>.columns.<logic-column-name>.encryptor= #Encryptor name\n+```\n+\n+### Orchestration\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+#Omit data source, data sharding, read-write split and data masking configurations\n+\n+spring.shardingsphere.orchestration.name= #Orchestration instance name\n+spring.shardingsphere.orchestration.overwrite= #Whether to overwrite local configurations with registry center configurations; if it can, each initialization should refer to local configurations\n+spring.shardingsphere.orchestration.registry.type= #Registry center type. Example:zookeeper\n+spring.shardingsphere.orchestration.registry.server-lists= #The list of servers that connect to registry center, including IP and port number; use commas to separate\n+spring.shardingsphere.orchestration.registry.namespace= #Registry center namespace\n+spring.shardingsphere.orchestration.registry.digest= #The token that connects to the registry center; default means there is no need for authentication\n+spring.shardingsphere.orchestration.registry.operation-timeout-milliseconds= #The millisecond number for operation timeout; default value: 500 milliseconds\n+spring.shardingsphere.orchestration.registry.max-retries= #Maximum retry time after failing; default value: 3 times\n+spring.shardingsphere.orchestration.registry.retry-interval-milliseconds= #Interval time to retry; default value: 500 milliseconds\n+spring.shardingsphere.orchestration.registry.time-to-live-seconds= #Living time of temporary nodes; default value: 60 seconds\n+spring.shardingsphere.orchestration.registry.props= #Customize registry center props.\n+```\n+\n+## shardingsphere-3.x\n+\n+### Sharding\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+sharding.jdbc.datasource.names= #Names of data sources. Multiple data sources separated with comma\n+\n+sharding.jdbc.datasource.<data-source-name>.type= #Class name of data source pool\n+sharding.jdbc.datasource.<data-source-name>.driver-class-name= #Class name of database driver\n+sharding.jdbc.datasource.<data-source-name>.url= #Database URL\n+sharding.jdbc.datasource.<data-source-name>.username= #Database username\n+sharding.jdbc.datasource.<data-source-name>.password= #Database password\n+sharding.jdbc.datasource.<data-source-name>.xxx= #Other properties for data source pool\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.actual-data-nodes= #Describe data source names and actual tables, delimiter as point, multiple data nodes separated with comma, support inline expression. Absent means sharding databases only. Example: ds${0..7}.tbl${0..7}\n+\n+#Databases sharding strategy, use default databases sharding strategy if absent. sharding strategy below can choose only one.\n+\n+#Standard sharding scenario for single sharding column\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.sharding-column= #Name of sharding column\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.precise-algorithm-class-name= #Precise algorithm class name used for `=` and `IN`. This class need to implements PreciseShardingAlgorithm, and require a no argument constructor\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.standard.range-algorithm-class-name= #Range algorithm class name used for `BETWEEN`. This class need to implements RangeShardingAlgorithm, and require a no argument constructor\n+\n+#Complex sharding scenario for multiple sharding columns\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.complex.sharding-columns= #Names of sharding columns. Multiple columns separated with comma\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.complex.algorithm-class-name= #Complex sharding algorithm class name. This class need to implements ComplexKeysShardingAlgorithm, and require a no argument constructor\n+\n+#Inline expression sharding scenario for si-gle s-arding column\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.inline.sharding-column= #Name of sharding column\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.inline.algorithm-expression= #Inline expression for sharding algorithm\n+\n+#Hint sharding strategy\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.database-strategy.hint.algorithm-class-name= #Hint sharding algorithm class name. This class need to implements HintShardingAlgorithm, and require a no argument constructor\n+\n+#Tables sharding strategy, Same as database- shar-ing strategy\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.table-strategy.xxx= #Ignore\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-column-name= #Column name of key generator, do not use Key generator if absent\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-class-name= #Key generator, use default key generator if absent. This class need to implements KeyGenerator, and require a no argument constructor\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.logic-index= #Name if logic index. If use `DROP INDEX XXX` SQL in Oracle/PostgreSQL, This property needs to be set for finding the actual tables\n+\n+sharding.jdbc.config.sharding.binding-tables[0]= #Binding table rule configurations\n+sharding.jdbc.config.sharding.binding-tables[1]= #Binding table rule configurations\n+sharding.jdbc.config.sharding.binding-tables[x]= #Binding table rule configurations\n+\n+sharding.jdbc.config.sharding.broadcast-tables[0]= #Broadcast table rule configurations\n+sharding.jdbc.config.sharding.broadcast-tables[1]= #Broadcast table rule configurations\n+sharding.jdbc.config.sharding.broadcast-tables[x]= #Broadcast table rule configurations\n+\n+sharding.jdbc.config.sharding.default-data-source-name= #If table not configure at table rule, will route to defaultDataSourceName\n+sharding.jdbc.config.sharding.default-database-strategy.xxx= #Default strategy for sharding databases, same as databases sharding strategy\n+sharding.jdbc.config.sharding.default-table-strategy.xxx= #Default strategy for sharding tables, same as tables sharding strategy\n+sharding.jdbc.config.sharding.default-key-generator-class-name= #Default key generator class name, default value is `io.shardingsphere.core.keygen.DefaultKeyGenerator`. This class need to implements KeyGenerator, and require a no argument constructor\n+\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #more details can reference Read-write splitting part\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]= #more details can reference Read-write splitting part\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #more details can reference Read-write splitting part\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #more details can reference Read-write splitting part\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #more details can reference Read-write splitting part\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #more details can reference Read-write splitting part\n+sharding.jdbc.config.config.map.key1= #more details can reference Read-write splitting part\n+sharding.jdbc.config.config.map.key2= #more details can reference Read-write splitting part\n+sharding.jdbc.config.config.map.keyx= #more details can reference Read-write splitting part\n+\n+sharding.jdbc.config.props.sql.show= #To show SQLS or not, default value: false\n+sharding.jdbc.config.props.executor.size= #The number of working threads, default value: CPU count\n+\n+sharding.jdbc.config.config.map.key1= #User-defined arguments\n+sharding.jdbc.config.config.map.key2= #User-defined arguments\n+sharding.jdbc.config.config.map.keyx= #User-defined arguments\n+```\n+\n+### Read-write splitting\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+#Ignore data sources configuration, same as sharding\n+\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.master-data-source-name= #Name of master data source\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[0]=  #Name of master data source\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[1]= #Names of Slave data sources\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.slave-data-source-names[x]= #Names of Slave data sources\n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-class-name= #Load balance algorithm class name. This class need to implements MasterSlaveLoadBalanceAlgorithm, and require a no argument constructor \n+sharding.jdbc.config.sharding.master-slave-rules.<master-slave-data-source-name>.load-balance-algorithm-type= #Load balance algorithm type, values should be: `ROUND_ROBIN` or `RANDOM`. Ignore if `load-balance-algorithm-class-name` is present \n+\n+sharding.jdbc.config.config.map.key1= #User-defined arguments\n+sharding.jdbc.config.config.map.key2= #User-defined arguments\n+sharding.jdbc.config.config.map.keyx= #User-defined arguments\n+\n+sharding.jdbc.config.props.sql.show= #To show SQLS or not, default value: false\n+sharding.jdbc.config.props.executor.size= #The number of working threads, default value: CPU count\n+sharding.jdbc.config.props.check.table.metadata.enabled= #Check the metadata consistency of all the tables, default value: false\n+```\n+\n+### Orchestration\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+#Ignore data sources, sharding and read-write splitting configuration\n+\n+sharding.jdbc.config.sharding.orchestration.name= #Name of orchestration instance\n+sharding.jdbc.config.sharding.orchestration.overwrite= #Use local configuration to overwrite registry center or not\n+sharding.jdbc.config.sharding.orchestration.registry.server-lists= #Rgistry servers list, multiple split as comma. Example: host1:2181,host2:2181\n+sharding.jdbc.config.sharding.orchestration.registry.namespace= #Namespace of registry\n+sharding.jdbc.config.sharding.orchestration.registry.digest= #Digest for registry. Default is not need digest.\n+sharding.jdbc.config.sharding.orchestration.registry.operation-timeout-milliseconds= #Operation timeout time in milliseconds, default value is 500 milliseconds\n+sharding.jdbc.config.sharding.orchestration.registry.max-retries= #Max number of times to retry, default value is 3\n+sharding.jdbc.config.sharding.orchestration.registry.retry-interval-milliseconds= #Time interval in milliseconds on each retry, default value is 500 milliseconds\n+sharding.jdbc.config.sharding.orchestration.registry.time-to-live-seconds= #Time to live in seconds of ephemeral keys, default value is 60 seconds\n+```\n+\n+## Shardingsphere-2.x\n+\n+### Read-write splitting\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+# Ignore data sources configuration\n+\n+sharding.jdbc.config.masterslave.load-balance-algorithm-type= #Load balance algorithm class of slave database; optional value: ROUND_ROBIN and RANDOM; if there is load-balance-algorithm-class-name, the configuration can be omitted\n+sharding.jdbc.config.masterslave.name= # master name\n+sharding.jdbc.config.masterslave.master-data-source-name= #Name of master data source\n+sharding.jdbc.config.masterslave.slave-data-source-names= #Name of master data source\n+```\n+\n+### Sharding\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+# Ignore data sources configuration\n+sharding.jdbc.config.sharding.default-data-source-name= #Tables without sharding rules will be located through default data source\n+sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column= #Name of database sharding column\n+sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression= #Inline expression for database sharding algorithm\n+sharding.jdbc.config.sharding.tables.t_order.actualDataNodes= #Describe data source names and actual tables, delimiter as point, multiple data nodes separated with comma, support inline expression. Absent means sharding databases only. Example: ds${0..7}.tbl${0..7}\n+sharding.jdbc.config.sharding.tables.t_order.tableStrategy.inline.shardingColumn= #Name of table sharding column\n+sharding.jdbc.config.sharding.tables.t_order.tableStrategy.inline.algorithmInlineExpression= #Inline expression for table sharding algorithm\n+sharding.jdbc.config.sharding.tables.t_order.keyGeneratorColumnName= #Column name of key generator, do not use Key generator if absent\n+\n+\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-column-name= #Column name of key generator, do not use Key generator if absent\n+sharding.jdbc.config.sharding.tables.<logic-table-name>.key-generator-class-name= #Key generator, use default key generator if absent. This class need to implements KeyGenerator, and require a no argument constructor\n+\n+```\n+\n+### Orchestration\n+\n+#### Configuration Item Explanation\n+\n+```properties\n+# Ignore data sources configuration\n+sharding.jdbc.config.orchestration.name= #Name of orchestration instance\n+sharding.jdbc.config.orchestration.overwrite= #Use local configuration to overwrite registry center or not\n+\n+\n+sharding.jdbc.config.sharding.orchestration.name= #Name of orchestration instance\n+sharding.jdbc.config.sharding.orchestration.overwrite= #Use local configuration to overwrite registry center or not\n+sharding.jdbc.config.sharding.orchestration.registry.server-lists= #Rgistry servers list, multiple split as comma. Example: host1:2181,host2:2181\n+sharding.jdbc.config.sharding.orchestration.registry.namespace= #Namespace of registry\n+sharding.jdbc.config.sharding.orchestration.registry.digest= #Digest for registry. Default is not need digest.\n+sharding.jdbc.config.sharding.orchestration.registry.operation-timeout-milliseconds= #Operation timeout time in milliseconds, default value is 500 milliseconds\n+sharding.jdbc.config.sharding.orchestration.registry.max-retries= #Max number of times to retry, default value is 3\n+sharding.jdbc.config.sharding.orchestration.registry.retry-interval-milliseconds= #Time interval in milliseconds on each retry, default value is 500 milliseconds\n+sharding.jdbc.config.sharding.orchestration.registry.time-to-live-seconds= #Time to live in seconds of ephemeral keys, default value is 60 seconds\n+\n+# The configuration in Zookeeper\n+sharding.jdbc.config.orchestration.zookeeper.namespace= #Namespace of zookeeper registry\n+sharding.jdbc.config.orchestration.zookeeper.server-lists= #Zookeeper Rgistry servers list, multiple split as comma. Example: host1:2181,host2:2181\n+\n+# The configuration in Etcd\n+sharding.jdbc.config.orchestration.etcd.server-lists= #Etcd Rgistry servers list, multiple split as comma. Example: host1:2181,host2:2181\n+```\n\\ No newline at end of file"
  },
  {
    "sha": "e0efc9c2e39411fc562cd8de22382fbd035ec212",
    "filename": "docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow.cn.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apache/shardingsphere/blob/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow.cn.md",
    "raw_url": "https://github.com/apache/shardingsphere/raw/d0b668796e7c590716e8a0ce0fb590ad3bf11141/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow.cn.md",
    "contents_url": "https://api.github.com/repos/apache/shardingsphere/contents/docs/document/content/user-manual/shardingsphere-jdbc/configuration/spring-boot-starter/shadow.cn.md?ref=d0b668796e7c590716e8a0ce0fb590ad3bf11141",
    "patch": "@@ -8,6 +8,6 @@ weight = 4\n ```properties\n spring.shardingsphere.datasource.names= # 省略数据源配置，请参考使用手册\n \n-spring.shardingsphere.rules.shadow.column= # 影子字段名称名称\n+spring.shardingsphere.rules.shadow.column= # 影子字段名称\n spring.shardingsphere.rules.shadow.shadow-mappings.<product-data-source-name>= # 影子数据库名称\n ```\n\\ No newline at end of file"
  }
]
