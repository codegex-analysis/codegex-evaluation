[
  {
    "sha": "89772ecc262ada7335f76de3172d7d18adae637b",
    "filename": "src/com/cici/avl/IntegerAVLTree.java",
    "status": "added",
    "additions": 140,
    "deletions": 0,
    "changes": 140,
    "blob_url": "https://github.com/QianHx/BalancedTrees-Java/blob/fc2c582f57b424fdf7fabb4a9f0e209d03e98022/src/com/cici/avl/IntegerAVLTree.java",
    "raw_url": "https://github.com/QianHx/BalancedTrees-Java/raw/fc2c582f57b424fdf7fabb4a9f0e209d03e98022/src/com/cici/avl/IntegerAVLTree.java",
    "contents_url": "https://api.github.com/repos/QianHx/BalancedTrees-Java/contents/src/com/cici/avl/IntegerAVLTree.java?ref=fc2c582f57b424fdf7fabb4a9f0e209d03e98022",
    "patch": "@@ -0,0 +1,140 @@\n+package com.cici.avl;\n+\n+\n+public class IntegerAVLTree {\n+\t\n+\tpublic IntegerAVLTree() {\n+\t\troot = null;\n+\t}\n+\n+    private IntegerAVLTreeNode root;\n+\n+    public IntegerAVLTreeNode find(int key) {\n+    \tIntegerAVLTreeNode current = root;\n+        while (current != null) {\n+            if (current.key == key) {\n+               break;\n+            }\n+            current = current.key < key ? current.right : current.left;\n+        }\n+        return current;\n+    }\n+\n+    public void insert(int key) {\n+        root = insert(root, key);\n+    }\n+\n+    public void delete(int key) {\n+        root = delete(root, key);\n+    }\n+\n+    public IntegerAVLTreeNode getRoot() {\n+        return root;\n+    }\n+\n+    public int height() {\n+        return root == null ? -1 : root.height;\n+    }\n+\n+    private IntegerAVLTreeNode insert(IntegerAVLTreeNode node, int key) {\n+        if (node == null) {\n+            return new IntegerAVLTreeNode(key);\n+        } else if (node.key > key) {\n+            node.left = insert(node.left, key);\n+        } else if (node.key < key) {\n+            node.right = insert(node.right, key);\n+        } else {\n+            throw new RuntimeException(\"duplicate Key!\");\n+        }\n+        return rebalance(node);\n+    }\n+\n+    private IntegerAVLTreeNode delete(IntegerAVLTreeNode node, int key) {\n+        if (node == null) {\n+            return node;\n+        } else if (node.key > key) {\n+            node.left = delete(node.left, key);\n+        } else if (node.key < key) {\n+            node.right = delete(node.right, key);\n+        } else {\n+            if (node.left == null || node.right == null) {\n+                node = (node.left == null) ? node.right : node.left;\n+            } else {\n+            \t// Change with the minimum node in the left tree\n+            \tIntegerAVLTreeNode mostLeftChild = mostLeftChild(node.right);\n+                node.key = mostLeftChild.key;\n+                node.right = delete(node.right, node.key);\n+            }\n+        }\n+        if (node != null) {\n+            node = rebalance(node);\n+        }\n+        return node;\n+    }\n+\n+    private IntegerAVLTreeNode mostLeftChild(IntegerAVLTreeNode node) {\n+    \tIntegerAVLTreeNode current = node;\n+        /* loop down to find the leftmost leaf */\n+        while (current.left != null) {\n+            current = current.left;\n+        }\n+        return current;\n+    }\n+\n+    private IntegerAVLTreeNode rebalance(IntegerAVLTreeNode z) {\n+        updateHeight(z);\n+        int balance = getBalance(z);\n+        if (balance > 1) {\n+            if (height(z.right.right) > height(z.right.left)) {\n+            \t// RR\n+                z = rotateLeft(z);\n+            } else {\n+            \t// RL\n+                z.right = rotateRight(z.right);\n+                z = rotateLeft(z);\n+            }\n+        } else if (balance < -1) {\n+            if (height(z.left.left) > height(z.left.right)) {\n+            \t// LL\n+                z = rotateRight(z);\n+            } else {\n+            \t// LR\n+                z.left = rotateLeft(z.left);\n+                z = rotateRight(z);\n+            }\n+        }\n+        return z;\n+    }\n+\n+    private IntegerAVLTreeNode rotateRight(IntegerAVLTreeNode y) {\n+        IntegerAVLTreeNode x = y.left;\n+        IntegerAVLTreeNode z = x.right;\n+        x.right = y;\n+        y.left = z;\n+        updateHeight(y);\n+        updateHeight(x);\n+        return x;\n+    }\n+\n+    private IntegerAVLTreeNode rotateLeft(IntegerAVLTreeNode y) {\n+        IntegerAVLTreeNode x = y.right;\n+        IntegerAVLTreeNode z = x.left;\n+        x.left = y;\n+        y.right = z;\n+        updateHeight(y);\n+        updateHeight(x);\n+        return x;\n+    }\n+\n+    private void updateHeight(IntegerAVLTreeNode n) {\n+        n.height = 1 + Math.max(height(n.left), height(n.right));\n+    }\n+\n+    private int height(IntegerAVLTreeNode n) {\n+        return n == null ? -1 : n.height;\n+    }\n+\n+    public int getBalance(IntegerAVLTreeNode n) {\n+        return (n == null) ? 0 : height(n.right) - height(n.left);\n+    }\n+}"
  },
  {
    "sha": "6ce1e4eff9170df4b1f6d1ee91d69d19817af238",
    "filename": "src/com/cici/avl/IntegerAVLTreeNode.java",
    "status": "added",
    "additions": 13,
    "deletions": 0,
    "changes": 13,
    "blob_url": "https://github.com/QianHx/BalancedTrees-Java/blob/fc2c582f57b424fdf7fabb4a9f0e209d03e98022/src/com/cici/avl/IntegerAVLTreeNode.java",
    "raw_url": "https://github.com/QianHx/BalancedTrees-Java/raw/fc2c582f57b424fdf7fabb4a9f0e209d03e98022/src/com/cici/avl/IntegerAVLTreeNode.java",
    "contents_url": "https://api.github.com/repos/QianHx/BalancedTrees-Java/contents/src/com/cici/avl/IntegerAVLTreeNode.java?ref=fc2c582f57b424fdf7fabb4a9f0e209d03e98022",
    "patch": "@@ -0,0 +1,13 @@\n+package com.cici.avl;\n+\n+\n+public class IntegerAVLTreeNode {\n+\tint key;\n+    int height;\n+    IntegerAVLTreeNode left;\n+    IntegerAVLTreeNode right;\n+\n+    IntegerAVLTreeNode(int key) {\n+        this.key = key;\n+    }\n+}"
  }
]
