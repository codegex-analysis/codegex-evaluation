[
  {
    "sha": "eefb16a69de688b2cee713d955fc78e7db216d9d",
    "filename": "src/geekbrains/Main.java",
    "status": "modified",
    "additions": 212,
    "deletions": 1,
    "changes": 213,
    "blob_url": "https://github.com/maxboronin/java/blob/64ed9971b24d4fbf107a843fb00a432cf24b1960/src/geekbrains/Main.java",
    "raw_url": "https://github.com/maxboronin/java/raw/64ed9971b24d4fbf107a843fb00a432cf24b1960/src/geekbrains/Main.java",
    "contents_url": "https://api.github.com/repos/maxboronin/java/contents/src/geekbrains/Main.java?ref=64ed9971b24d4fbf107a843fb00a432cf24b1960",
    "patch": "@@ -1,8 +1,219 @@\n package geekbrains;\n \n+import java.util.Arrays;\n+\n public class Main {\n \n     public static void main(String[] args) {\n-\t// write your code here\n+        /**\n+         * 1. Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;\n+         */\n+        replaceZeroAndOneInArray();\n+\n+        /**\n+         * 2. Задать пустой целочисленный массив размером 8. С помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;\n+         */\n+        System.out.println(\"\\n\");\n+        fillEmptyArray();\n+\n+        /**\n+         * 3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ] пройти по нему циклом, и числа меньшие 6 умножить на 2;\n+         */\n+        System.out.println(\"\\n\");\n+        multiplyByTwoNumbersLessSixInArray();\n+\n+        /**\n+         * 4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое) и с помощью цикла(-ов) заполнить его диагональные элементы единицами;\n+         */\n+        System.out.println(\"\\n\");\n+        createQuadArrayAndFillDiags();\n+\n+        /**\n+         * 5. ** Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);\n+         */\n+        System.out.println(\"\\n\");\n+        createArrayAndSearchMinAndMaxValues();\n+\n+        /**\n+         * 6. ** Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true, если в массиве есть место, в котором сумма левой и правой части массива равны.\n+         * Примеры: checkBalance([2, 2, 2, 1, 2, 2, || 10, 1]) → true, checkBalance([1, 1, 1, || 2, 1]) → true, граница показана символами ||, эти символы в массив не входят.\n+         */\n+        System.out.println(\"\\n\");\n+        int[] arrayToCheckPartsEquals = {2, 2, 2, 1, 2, 2, 10, 1};\n+        System.out.println(\"6. ** Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true, если в массиве есть место, в котором сумма левой и правой части массива равны.\\n\" +\n+                \"Примеры: checkBalance([2, 2, 2, 1, 2, 2, || 10, 1]) → true, checkBalance([1, 1, 1, || 2, 1]) → true, граница показана символами ||, эти символы в массив не входят.\");\n+        System.out.println(\"Массив: \" + Arrays.toString(arrayToCheckPartsEquals));\n+        System.out.println(\"Результат: \" + checkArrayPartsEquals( arrayToCheckPartsEquals ));\n+\n+        /**\n+         * 7. **** Написать метод, которому на вход подается одномерный массив и число n (может быть положительным, или отрицательным), при этом метод должен сместить все элементы массива на n позиций.\n+         * Элементы смещаются циклично. Для усложнения задачи нельзя пользоваться вспомогательными массивами. Примеры: [ 1, 2, 3 ] при n = 1 (на один вправо) -> [ 3, 1, 2 ]; [ 3, 5, 6, 1]\n+         * при n = -2 (на два влево) -> [ 6, 1, 3, 5 ]. При каком n в какую сторону сдвиг можете выбирать сами.\n+         */\n+        System.out.println(\"\\n\");\n+        System.out.println(\"7. **** Написать метод, которому на вход подается одномерный массив и число n (может быть положительным, или отрицательным), при этом метод должен сместить все элементы массива на n позиций.\\n\" +\n+                \"Элементы смещаются циклично. Для усложнения задачи нельзя пользоваться вспомогательными массивами. Примеры: [ 1, 2, 3 ] при n = 1 (на один вправо) -> [ 3, 1, 2 ]; [ 3, 5, 6, 1]\\n\" +\n+                \"при n = -2 (на два влево) -> [ 6, 1, 3, 5 ]. При каком n в какую сторону сдвиг можете выбирать сами.\\n\");\n+        int[] arrayToShift1 = { 6, 1, 3, 5 };\n+        System.out.println(\"Массив: \" + Arrays.toString(arrayToShift1));\n+        shiftArray( arrayToShift1, -13);\n+        System.out.println(\"Сдвиг влево на 13: \" + Arrays.toString(arrayToShift1));\n+        int[] arrayToShift2 = { 6, 1, 3, 5 };\n+        System.out.println(\"Массив: \" + Arrays.toString(arrayToShift2));\n+        shiftArray( arrayToShift2, 13);\n+        System.out.println(\"Сдвиг вправо на 13: \" + Arrays.toString(arrayToShift2));\n+    }\n+\n+    /**\n+     * 1. Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;\n+     */\n+    private static void replaceZeroAndOneInArray() {\n+        int[] zeroOneArray = {1, 1, 0, 0, 1, 0, 1, 1, 0, 0};\n+\n+        System.out.println(\"1. Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;\");\n+        System.out.println(\"Исходный массив: \" + Arrays.toString(zeroOneArray));\n+\n+        for(int i=0; i < zeroOneArray.length; i++){\n+            zeroOneArray[i] = zeroOneArray[i] == 1 ? 0: 1;\n+        }\n+\n+        System.out.println(\"Результирующий массив: \" + Arrays.toString(zeroOneArray));\n+    }\n+\n+    /**\n+     * 2. Задать пустой целочисленный массив размером 8. С помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;\n+     */\n+    private static void fillEmptyArray(){\n+        int[] emptyArrayToFill = new int[8];\n+\n+        for (int i=0; i < emptyArrayToFill.length; i++){\n+            emptyArrayToFill[i] = i*3;\n+        }\n+\n+        System.out.println(\"2. Задать пустой целочисленный массив размером 8. С помощью цикла заполнить его значениями 0 3 6 9 12 15 18 21;\");\n+        System.out.println(\"Результат: \" + Arrays.toString(emptyArrayToFill));\n+    }\n+\n+    /**\n+     * 3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ] пройти по нему циклом, и числа меньшие 6 умножить на 2;\n+     */\n+    private static void multiplyByTwoNumbersLessSixInArray(){\n+        int[] arrayToMultiply = { 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 };\n+\n+        System.out.println(\"3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ] пройти по нему циклом, и числа меньшие 6 умножить на 2;\");\n+        System.out.println(\"Исходный массив: \" + Arrays.toString(arrayToMultiply));\n+\n+        for (int i=0; i < arrayToMultiply.length; i++) {\n+            if(arrayToMultiply[i] < 6){\n+                arrayToMultiply[i] *= 2;\n+            }\n+        }\n+\n+        System.out.println(\"Результирующий массив: \" + Arrays.toString(arrayToMultiply));\n     }\n+\n+    /**\n+     * 4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое) и с помощью цикла(-ов) заполнить его диагональные элементы единицами;\n+     */\n+    private static void createQuadArrayAndFillDiags() {\n+        int[][] quadArray = new int[7][7];\n+        System.out.println(\"4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов одинаковое) и с помощью цикла(-ов) заполнить его диагональные элементы единицами;\");\n+\n+        for ( int i=0; i< quadArray.length; i++){\n+            quadArray[i][i] = quadArray[i][quadArray.length - i - 1] = 1;\n+        }\n+\n+        System.out.println(\"Результирующий массив: \");\n+        for ( int i=0; i< quadArray.length; i++){\n+            System.out.println(Arrays.toString(quadArray[i]));\n+        }\n+    }\n+\n+    /**\n+     * 5. ** Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);\n+     */\n+    private static void createArrayAndSearchMinAndMaxValues() {\n+        int[] arrayToSearch = { 1, 2 -1, -10, 0, 5, 22, 33, -80};\n+        int min = arrayToSearch[0];\n+        int max = arrayToSearch[0];\n+\n+        System.out.println(\"5. ** Задать одномерный массив и найти в нем минимальный и максимальный элементы (без помощи интернета);\");\n+        System.out.println(\"Массив для поиска: \" + Arrays.toString(arrayToSearch));\n+\n+        for ( int i=0; i < arrayToSearch.length; i++ ){\n+            if(min > arrayToSearch[i]){\n+                min = arrayToSearch[i];\n+            }\n+            if(max < arrayToSearch[i]){\n+                max = arrayToSearch[i];\n+            }\n+        }\n+\n+        System.out.println(\"Минимальное значение: \" + min);\n+        System.out.println(\"Максимальное значение: \" + max);\n+    }\n+\n+    /**\n+     * 6. ** Написать метод, в который передается не пустой одномерный целочисленный массив, метод должен вернуть true, если в массиве есть место, в котором сумма левой и правой части массива равны.\n+     * Примеры: checkBalance([2, 2, 2, 1, 2, 2, || 10, 1]) → true, checkBalance([1, 1, 1, || 2, 1]) → true, граница показана символами ||, эти символы в массив не входят.\n+     *\n+     */\n+    private static boolean checkArrayPartsEquals(int[] arrayToCheck) {\n+        for ( int cursor = 0; cursor < arrayToCheck.length; cursor++ ){\n+            int leftSum = 0;\n+            int rightSum = 0;\n+            for ( int i = 0; i < arrayToCheck.length; i++ ){\n+                if( i <= cursor ){\n+                    leftSum += arrayToCheck[i];\n+                }else{\n+                    rightSum += arrayToCheck[i];\n+                }\n+            }\n+            if(leftSum == rightSum){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * 7. **** Написать метод, которому на вход подается одномерный массив и число n (может быть положительным, или отрицательным), при этом метод должен сместить все элементы массива на n позиций.\n+     * Элементы смещаются циклично. Для усложнения задачи нельзя пользоваться вспомогательными массивами. Примеры: [ 1, 2, 3 ] при n = 1 (на один вправо) -> [ 3, 1, 2 ]; [ 3, 5, 6, 1]\n+     * при n = -2 (на два влево) -> [ 6, 1, 3, 5 ]. При каком n в какую сторону сдвиг можете выбирать сами.\n+     */\n+    private static int[] shiftArray( int[] arrayToShift, int n) {\n+        boolean left = n < 0;\n+\n+        if(left){\n+            arrayToShift = reverseArray( arrayToShift );\n+        }\n+\n+        n = Math.abs(n);\n+\n+        int fullLengthInsideN = n / arrayToShift.length;\n+        int shiftsInsideArrayLength = n - fullLengthInsideN * arrayToShift.length;\n+        for(int step = 1; step <= shiftsInsideArrayLength; step++){\n+            int buffer = arrayToShift[arrayToShift.length - 1];\n+            for (int k = 0; k < arrayToShift.length - 1; k++ ){\n+                arrayToShift[arrayToShift.length - 1 - k] = arrayToShift[arrayToShift.length - 2 - k];\n+            }\n+            arrayToShift[0] = buffer;\n+        }\n+\n+        if(left){\n+            return reverseArray( arrayToShift );\n+        }\n+\n+        return arrayToShift;\n+    }\n+\n+    private static int[] reverseArray(int[] arrayToReverse) {\n+        for(int i=0; i < arrayToReverse.length / 2; i++ ){\n+            int buff = arrayToReverse[i];\n+            arrayToReverse[i] = arrayToReverse[arrayToReverse.length - i - 1];\n+            arrayToReverse[arrayToReverse.length - i - 1] = buff;\n+        }\n+        return arrayToReverse;\n+    }\n+\n }"
  }
]
