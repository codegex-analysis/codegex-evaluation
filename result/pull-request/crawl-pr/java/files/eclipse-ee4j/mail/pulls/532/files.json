[
  {
    "sha": "171bae1f082040d0d0736d4d3a4ecf5f1fee97a3",
    "filename": "doc/release/CHANGES.txt",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/doc/release/CHANGES.txt",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/doc/release/CHANGES.txt",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/doc/release/CHANGES.txt?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -31,6 +31,7 @@ E  473\tSeveral modules are not included in build when JDK11 is used\n E  493\tjavamail.providers file missing from provider jars after 1.6.5\n E  505\tWriteTimeoutSocket::getFileDescriptor$ support for Conscrypt\n E  512\tImprove code coverage in logging-mailhandler tests\n+E  529\tCompactFormatter support for LogRecord::getLongThreadID\n \n \n \t\t  CHANGES IN THE 2.0.0 RELEASE"
  },
  {
    "sha": "2cf5190a418da15896a5f06011eaa661d130abfa",
    "filename": "mail/src/main/java/com/sun/mail/util/logging/CompactFormatter.java",
    "status": "modified",
    "additions": 11,
    "deletions": 10,
    "changes": 21,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/main/java/com/sun/mail/util/logging/CompactFormatter.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/main/java/com/sun/mail/util/logging/CompactFormatter.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/main/java/com/sun/mail/util/logging/CompactFormatter.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -1,6 +1,6 @@\n /*\r\n- * Copyright (c) 2013, 2019 Oracle and/or its affiliates. All rights reserved.\r\n- * Copyright (c) 2013, 2019 Jason Mehrens. All rights reserved.\r\n+ * Copyright (c) 2013, 2021 Oracle and/or its affiliates. All rights reserved.\r\n+ * Copyright (c) 2013, 2021 Jason Mehrens. All rights reserved.\r\n  *\r\n  * This program and the accompanying materials are made available under the\r\n  * terms of the Eclipse Public License v. 2.0, which is available at\r\n@@ -335,21 +335,22 @@ public String formatLoggerName(final LogRecord record) {\n     }\r\n \r\n     /**\r\n-     * Formats the thread id property of the given log record. By default this\r\n-     * is formatted as a {@code long} by an unsigned conversion.\r\n+     * Formats the thread id property of the given log record.  Long thread ids\r\n+     * are preferred if supported.  Otherwise, the integer thread id is\r\n+     * formatted as a {@code long} by an unsigned conversion.\r\n      *\r\n      * @param record the record.\r\n      * @return the formatted thread id as a number.\r\n      * @throws NullPointerException if the given record is null.\r\n      * @since JavaMail 1.5.4\r\n      */\r\n+    @SuppressWarnings(\"deprecation\") //See JDK-8245302\r\n     public Number formatThreadID(final LogRecord record) {\r\n-        /**\r\n-         * Thread.getID is defined as long and LogRecord.getThreadID is defined\r\n-         * as int. Convert to unsigned as a means to better map the two types of\r\n-         * thread identifiers.\r\n-         */\r\n-        return (((long) record.getThreadID()) & 0xffffffffL);\r\n+        Long id = LogManagerProperties.getLongThreadID(record);\r\n+        if (id == null) {\r\n+            id = (((long) record.getThreadID()) & 0xffffffffL);\r\n+        }\r\n+        return id;\r\n     }\r\n \r\n     /**\r"
  },
  {
    "sha": "bc260a56072803e5b44df25bcceb8d4881d2ffbb",
    "filename": "mail/src/main/java/com/sun/mail/util/logging/LogManagerProperties.java",
    "status": "modified",
    "additions": 113,
    "deletions": 71,
    "changes": 184,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/main/java/com/sun/mail/util/logging/LogManagerProperties.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/main/java/com/sun/mail/util/logging/LogManagerProperties.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/main/java/com/sun/mail/util/logging/LogManagerProperties.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -1,6 +1,6 @@\n /*\n- * Copyright (c) 2009, 2019 Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2009, 2019 Jason Mehrens. All rights reserved.\n+ * Copyright (c) 2009, 2021 Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021 Jason Mehrens. All rights reserved.\n  *\n  * This program and the accompanying materials are made available under the\n  * terms of the Eclipse Public License v. 2.0, which is available at\n@@ -17,6 +17,10 @@\n package com.sun.mail.util.logging;\n \n import java.io.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n@@ -55,63 +59,83 @@\n      * Generated serial id.\n      */\n     private static final long serialVersionUID = -2239983349056806252L;\n+\n+    /**\n+     * Public lookup for method handles.\n+     */\n+    private static final Lookup LOOKUP = MethodHandles.publicLookup();\n+\n     /**\n      * Holds the method used to get the LogRecord instant if running on JDK 9 or\n      * later.\n      */\n-    private static final Method LR_GET_INSTANT;\n+    private static final MethodHandle LR_GET_INSTANT;\n+\n+    /**\n+     * Holds the method used to get the long thread id if running on JDK 16 or\n+     * later.\n+     */\n+    private static final MethodHandle LR_GET_LONG_TID;\n \n     /**\n      * Holds the method used to get the default time zone if running on JDK 9 or\n      * later.\n      */\n-    private static final Method ZI_SYSTEM_DEFAULT;\n+    private static final MethodHandle ZI_SYSTEM_DEFAULT;\n \n     /**\n      * Holds the method used to convert and instant to a zoned date time if\n      * running on JDK 9 later.\n      */\n-    private static final Method ZDT_OF_INSTANT;\n+    private static final MethodHandle ZDT_OF_INSTANT;\n \n-    static {\n-        Method lrgi = null;\n-        Method zisd = null;\n-        Method zdtoi = null;\n-        try {\n-            lrgi = LogRecord.class.getMethod(\"getInstant\");\n-            assert Comparable.class\n-                    .isAssignableFrom(lrgi.getReturnType()) : lrgi;\n-            zisd = findClass(\"java.time.ZoneId\")\n-                    .getMethod(\"systemDefault\");\n-            if (!Modifier.isStatic(zisd.getModifiers())) {\n-                throw new NoSuchMethodException(zisd.toString());\n-            }\n \n-            zdtoi = findClass(\"java.time.ZonedDateTime\")\n-                    .getMethod(\"ofInstant\", findClass(\"java.time.Instant\"),\n-                            findClass(\"java.time.ZoneId\"));\n-            if (!Modifier.isStatic(zdtoi.getModifiers())) {\n-                throw new NoSuchMethodException(zdtoi.toString());\n-            }\n+    static { //Added in JDK16 see JDK-8245302\n+        MethodHandle lrgltid = null;\n+        try {\n+            lrgltid = LOOKUP.findVirtual(LogRecord.class,\n+                    \"getLongThreadID\", MethodType.methodType(long.class));\n+        } catch (final RuntimeException ignore) {\n+        } catch (final Exception ignore) { //No need for specific catch.\n+        } catch (final LinkageError ignore) {\n+        }\n+        LR_GET_LONG_TID = lrgltid;\n+    }\n \n-            if (!Comparable.class.isAssignableFrom(zdtoi.getReturnType())) {\n-                throw new NoSuchMethodException(zdtoi.toString());\n-            }\n+    static { //Added in JDK 9 see JDK-8072645\n+        MethodHandle lrgi = null;\n+        MethodHandle zisd = null;\n+        MethodHandle zdtoi = null;\n+        try {\n+            lrgi = LOOKUP.findVirtual(LogRecord.class, \"getInstant\",\n+                    MethodType.methodType(findClass(\"java.time.Instant\")));\n+\n+            zisd = LOOKUP.findStatic(findClass(\"java.time.ZoneId\"),\n+                    \"systemDefault\",\n+                    MethodType.methodType(findClass(\"java.time.ZoneId\")));\n+\n+            zdtoi = LOOKUP.findStatic(findClass(\"java.time.ZonedDateTime\"),\n+                    \"ofInstant\",\n+                    MethodType.methodType(findClass(\"java.time.ZonedDateTime\"),\n+                            findClass(\"java.time.Instant\"),\n+                            findClass(\"java.time.ZoneId\")));\n         } catch (final RuntimeException ignore) {\n         } catch (final Exception ignore) { //No need for specific catch.\n         } catch (final LinkageError ignore) {\n         } finally {\n             if (lrgi == null || zisd == null || zdtoi == null) {\n-                lrgi = null; //If any are null then clear all.\n+                lrgi = null;\n                 zisd = null;\n                 zdtoi = null;\n+                zdtoi = null;\n             }\n         }\n \n         LR_GET_INSTANT = lrgi;\n         ZI_SYSTEM_DEFAULT = zisd;\n         ZDT_OF_INSTANT = zdtoi;\n     }\n+\n     /**\n      * Caches the read only reflection class names string array. Declared\n      * volatile for safe publishing only. The VO_VOLATILE_REFERENCE_TO_ARRAY\n@@ -299,30 +323,47 @@ static boolean hasLogManager() {\n      * @throws NullPointerException if record is null.\n      * @since JavaMail 1.5.6\n      */\n-    @SuppressWarnings(\"UseSpecificCatch\")\n-    static Comparable<?> getZonedDateTime(LogRecord record) {\n+    static Comparable<?> getZonedDateTime(final LogRecord record) {\n         if (record == null) {\n            throw new NullPointerException();\n         }\n-        final Method m = ZDT_OF_INSTANT;\n+\n+        MethodHandle m = ZDT_OF_INSTANT;\n         if (m != null) {\n             try {\n-                return (Comparable<?>) m.invoke((Object) null,\n+                return (Comparable<?>) m.invoke(\n                         LR_GET_INSTANT.invoke(record),\n-                        ZI_SYSTEM_DEFAULT.invoke((Object) null));\n-            } catch (final RuntimeException ignore) {\n-                assert LR_GET_INSTANT != null\n-                        && ZI_SYSTEM_DEFAULT != null : ignore;\n-            } catch (final InvocationTargetException ite) {\n-                final Throwable cause = ite.getCause();\n-                if (cause instanceof Error) {\n-                    throw (Error) cause;\n-                } else if (cause instanceof RuntimeException) {\n-                    throw (RuntimeException) cause;\n-                } else { //Should never happen.\n-                    throw new UndeclaredThrowableException(ite);\n-                }\n-            } catch (final Exception ignore) {\n+                        ZI_SYSTEM_DEFAULT.invoke());\n+            } catch (final RuntimeException | Error e) {\n+                throw e; //Avoid catch all\n+            } catch (final Throwable ute) {\n+                throw new UndeclaredThrowableException(ute);\n+            }        \n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the long thread id from the given log record.\n+     *\n+     * @param record used to get the long thread id.\n+     * @return null if LogRecord doesn't support long thread ids.\n+     * @throws NullPointerException if record is null.\n+     * @since JakartaMail 2.0.1\n+     */\n+    static Long getLongThreadID(final LogRecord record) {\n+        if (record == null) {\n+           throw new NullPointerException();\n+        }\n+\n+        final MethodHandle m = LR_GET_LONG_TID;\n+        if (m != null) {\n+            try {\n+                return (long) m.invoke(record);\n+            } catch (final RuntimeException | Error e) {\n+                throw e;\n+            } catch (final Throwable ute) {\n+                throw new UndeclaredThrowableException(ute);\n             }\n         }\n         return null;\n@@ -367,7 +408,7 @@ static String getLocalHost(final Object s) throws Exception {\n      * @return the number of milliseconds parsed from the duration.\n      * @throws ClassNotFoundException if the java.time classes are not present.\n      * @throws IllegalAccessException if the method is inaccessible.\n-     * @throws InvocationTargetException if the method throws an exception.\n+     * @throws RuntimeException if the method throws an exception.\n      * @throws LinkageError if the linkage fails.\n      * @throws NullPointerException if the given duration is null.\n      * @throws ExceptionInInitializerError if the static initializer fails.\n@@ -378,24 +419,23 @@ static String getLocalHost(final Object s) throws Exception {\n      * @since JavaMail 1.5.5\n      */\n     static long parseDurationToMillis(final CharSequence value) throws Exception {\n-        try {\n-            final Class<?> k = findClass(\"java.time.Duration\");\n-            final Method parse = k.getMethod(\"parse\", CharSequence.class);\n-            if (!k.isAssignableFrom(parse.getReturnType())\n-                    || !Modifier.isStatic(parse.getModifiers())) {\n-               throw new NoSuchMethodException(parse.toString());\n-            }\n+        if (value == null) {\n+           throw new NullPointerException();\n+        }\n \n-            final Method toMillis = k.getMethod(\"toMillis\");\n-            if (!Long.TYPE.isAssignableFrom(toMillis.getReturnType())\n-                    || Modifier.isStatic(toMillis.getModifiers())) {\n-                throw new NoSuchMethodException(toMillis.toString());\n-            }\n-            return (Long) toMillis.invoke(parse.invoke(null, value));\n-        } catch (final ExceptionInInitializerError EIIE) {\n-            throw wrapOrThrow(EIIE);\n-        } catch (final InvocationTargetException ite) {\n-            throw paramOrError(ite);\n+        try {\n+            Class<?> k = findClass(\"java.time.Duration\");\n+            MethodHandle dp = LOOKUP.findStatic(k, \"parse\",\n+                    MethodType.methodType(k, CharSequence.class));\n+\n+            MethodHandle dtm = LOOKUP.findVirtual(k, \"toMillis\",\n+                    MethodType.methodType(Long.TYPE));\n+            return (long) dtm.invoke(dp.invoke(value));\n+        } catch (final RuntimeException | LinkageError\n+                | ReflectiveOperationException fail) {\n+            throw fail; //avoid catch all\n+        } catch (Throwable cause) {\n+            throw new InvocationTargetException(cause);\n         }\n     }\n \n@@ -517,9 +557,9 @@ static Formatter newFormatter(String name) throws Exception {\n         }\n \n         Comparator<T> reverse = null;\n-        //Comparator in Java 1.8 has 'reversed' as a default method.\n+        //Comparator in JDK8 has 'reversed' as a default method.\n         //This code calls that method first to allow custom\n-        //code to define what reverse order means.\n+        //code to define what reverse order means in versions older than JDK8.\n         try {\n             //assert Modifier.isPublic(c.getClass().getModifiers()) :\n             //        Modifier.toString(c.getClass().getModifiers());\n@@ -532,11 +572,9 @@ static Formatter newFormatter(String name) throws Exception {\n                     throw wrapOrThrow(eiie);\n                 }\n             }\n-        } catch (final NoSuchMethodException ignore) {\n-        } catch (final IllegalAccessException ignore) {\n-        } catch (final RuntimeException ignore) {\n         } catch (final InvocationTargetException ite) {\n             paramOrError(ite); //Ignore invocation bugs (returned values).\n+        } catch (final ReflectiveOperationException | RuntimeException ignore) {\n         }\n \n         if (reverse == null) {\n@@ -642,6 +680,8 @@ static boolean isReflectionClass(String name) throws Exception {\n         final Class<?> thisClass = LogManagerProperties.class;\n         assert Modifier.isFinal(thisClass.getModifiers()) : thisClass;\n         try {\n+            //This code must use reflection to capture extra frames.\n+            //The invoke API doesn't produce the frames needed.\n             final HashSet<String> traces = new HashSet<>();\n             Throwable t = Throwable.class.getConstructor().newInstance();\n             for (StackTraceElement ste : t.getStackTrace()) {\n@@ -652,6 +692,8 @@ static boolean isReflectionClass(String name) throws Exception {\n                 }\n             }\n \n+            //This code must use reflection to capture extra frames.\n+            //The invoke API doesn't produce the frames needed.\n             Throwable.class.getMethod(\"fillInStackTrace\").invoke(t);\n             for (StackTraceElement ste : t.getStackTrace()) {\n                 if (!thisClass.getName().equals(ste.getClassName())) {\n@@ -756,10 +798,10 @@ private static InvocationTargetException wrapOrThrow(\n     }\n \n     /**\n-     * This code is modified from the LogManager, which explictly states\n+     * This code is modified from the LogManager, which explicitly states\n      * searching the system class loader first, then the context class loader.\n      * There is resistance (compatibility) to change this behavior to simply\n-     * searching the context class loader.\n+     * searching the context class loader. See JDK-6878454.\n      *\n      * @param name full class name\n      * @return the class."
  },
  {
    "sha": "466a8d8cfb22ff42b6dbc6a44f4ccd2512f4246f",
    "filename": "mail/src/test/java/com/sun/mail/util/logging/AbstractLogging.java",
    "status": "modified",
    "additions": 44,
    "deletions": 2,
    "changes": 46,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/AbstractLogging.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/AbstractLogging.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/test/java/com/sun/mail/util/logging/AbstractLogging.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -1,6 +1,6 @@\n /*\r\n- * Copyright (c) 2016, 2020 Oracle and/or its affiliates. All rights reserved.\r\n- * Copyright (c) 2016, 2018 Jason Mehrens. All rights reserved.\r\n+ * Copyright (c) 2016, 2021 Oracle and/or its affiliates. All rights reserved.\r\n+ * Copyright (c) 2016, 2021 Jason Mehrens. All rights reserved.\r\n  *\r\n  * This program and the accompanying materials are made available under the\r\n  * terms of the Eclipse Public License v. 2.0, which is available at\r\n@@ -140,6 +140,48 @@ static void setEpochSecond(final LogRecord record, final long epochSecond,\n         set.invoke(record, instant.invoke(null, epochSecond, nanoAdjustment));\r\n     }\r\n \r\n+    /**\r\n+     * Sets the int thread id for the given log record.\r\n+     *\r\n+     * @param record a non null log record.\r\n+     * @param id the thread id.\r\n+     * @throws NullPointerException if the given record is null.\r\n+     */\r\n+    @SuppressWarnings(\"deprecation\") //See JDK-8245302\r\n+    static void setIntThreadID(final LogRecord record, int id) {\r\n+        record.setThreadID(id);\r\n+    }\r\n+\r\n+    /**\r\n+     * Gets the int thread id for the given log record.\r\n+     *\r\n+     * @param record a non null log record.\r\n+     * @param id the thread id.\r\n+     * @throws NullPointerException if the given record is null.\r\n+     */\r\n+    @SuppressWarnings(\"deprecation\") //See JDK-8245302\r\n+    static int getIntThreadID(final LogRecord record) {\r\n+        return record.getThreadID();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the long thread id for the given log record if it is supported.\r\n+     *\r\n+     * @param record a non-null record.\r\n+     * @param id the long thread id.\r\n+     * @throws Exception if there is a problem.\r\n+     * @throws NoSuchMethodException if JDK is older than JDK 16.\r\n+     * @throws NullPointerException if the given record is null.\r\n+     */\r\n+    static void setLongThreadID(final LogRecord record, long id)\r\n+                                                        throws Exception {\r\n+        if (record == null) {\r\n+            throw new NullPointerException();\r\n+        }\r\n+        LogRecord.class.getMethod(\"setLongThreadID\", Long.TYPE)\r\n+                .invoke(record, id);\r\n+    }\r\n+\r\n     /**\r\n      * Determines if the {@code java.time} APIs are available for this JVM.\r\n      *\r"
  },
  {
    "sha": "4d2340d4b8f3a56cfd8d31517a90266e99c4da24",
    "filename": "mail/src/test/java/com/sun/mail/util/logging/CompactFormatterTest.java",
    "status": "modified",
    "additions": 90,
    "deletions": 7,
    "changes": 97,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/CompactFormatterTest.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/CompactFormatterTest.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/test/java/com/sun/mail/util/logging/CompactFormatterTest.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -1043,23 +1043,106 @@ public void testFormatThrownNullRecord() {\n         fail(cf.toString());\r\n     }\r\n \r\n+    @Test\r\n+    public void testFormatIntThreadIDReturnType() throws Exception {\r\n+        LogRecord record = new LogRecord(Level.SEVERE, \"\");\r\n+        setIntThreadID(record, 10);\r\n+        CompactFormatter cf = new CompactFormatter(\"%10$d\");\r\n+        Number id = cf.formatThreadID(record);\r\n+\r\n+        //Default should be long or wider.\r\n+        if (id.getClass() != Long.class) {\r\n+            fail(id.getClass().toString());\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testFormatLongThreadIDReturnType() throws Exception {\r\n+        LogRecord record = new LogRecord(Level.SEVERE, \"\");\r\n+        try {\r\n+            setLongThreadID(record, 11L);\r\n+            CompactFormatter cf = new CompactFormatter(\"%10$d\");\r\n+            Number id = cf.formatThreadID(record);\r\n+            //Default should be long or wider.\r\n+            if (id.getClass() != Long.class) {\r\n+                fail(id.getClass().toString());\r\n+            }\r\n+        } catch (NoSuchMethodException JDK8245302) {\r\n+            try {\r\n+              Method m = LogRecord.class.getMethod(\"getLongThreadID\");\r\n+              fail(m.toString());\r\n+            } catch (NoSuchMethodException expect) {\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testFormatLongThreadID() throws Exception {\r\n+        LogRecord record = new LogRecord(Level.SEVERE, \"\");\r\n+        try {\r\n+            long expected = 10L;\r\n+            if (Thread.currentThread().getId() == expected) {\r\n+                ++expected;\r\n+            }\r\n+            setLongThreadID(record, expected);\r\n+            assertNotEquals(expected, Thread.currentThread().getId());\r\n+\r\n+            CompactFormatter cf = new CompactFormatter(\"%10$d\");\r\n+            String output = cf.format(record);\r\n+            String expect = Long.toString(expected);\r\n+            assertEquals(expect, output);\r\n+\r\n+            setLongThreadID(record, -1L);\r\n+            output = cf.format(record);\r\n+            expect = Long.toString(-1L);\r\n+            assertEquals(expect, output);\r\n+\r\n+            //Test that downcast works right.\r\n+            Number id = cf.formatThreadID(record);\r\n+            assertEquals(-1, id.intValue());\r\n+            assertEquals(expect, Long.toString(id.longValue()));\r\n+\r\n+            setLongThreadID(record, Long.MAX_VALUE >>> 1L);\r\n+            output = cf.format(record);\r\n+            expect = Long.toString(Long.MAX_VALUE >>> 1L);\r\n+            assertEquals(expect, output);\r\n+\r\n+            int tid = getIntThreadID(record);\r\n+            assertTrue(String.valueOf(tid), tid < 0);\r\n+        } catch (NoSuchMethodException JDK8245302) {\r\n+            try {\r\n+              Method m = LogRecord.class.getMethod(\"getLongThreadID\");\r\n+              fail(m.toString());\r\n+            } catch (NoSuchMethodException expect) {\r\n+                assertNull(LogManagerProperties.getLongThreadID(record));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+\r\n     @Test\r\n     public void testFormatThreadID() {\r\n         CompactFormatter cf = new CompactFormatter(\"%10$d\");\r\n         LogRecord record = new LogRecord(Level.SEVERE, \"\");\r\n-        record.setThreadID(10);\r\n+        setIntThreadID(record, 10);\r\n         String output = cf.format(record);\r\n-        String expect = Long.toString(record.getThreadID());\r\n+        String expect = Long.toString(getIntThreadID(record));\r\n         assertEquals(expect, output);\r\n \r\n-        record.setThreadID(-1); //Largest value for the CompactFormatter.\r\n+        setIntThreadID(record, -1);\r\n         output = cf.format(record);\r\n-        expect = Long.toString((1L << 32L) - 1L);\r\n-        assertEquals(expect, output);\r\n+        Long ltid = LogManagerProperties.getLongThreadID(record);\r\n+        if (ltid == null) {\r\n+            expect = Long.toString((1L << 32L) - 1L);\r\n+            assertEquals(expect, output);\r\n+        } else {\r\n+            expect = Long.toString(-1L);\r\n+            assertEquals(expect, output);\r\n+        }\r\n \r\n         //Test that downcast works right.\r\n         Number id = cf.formatThreadID(record);\r\n-        assertEquals(record.getThreadID(), id.intValue());\r\n+        assertEquals(getIntThreadID(record), id.intValue());\r\n         assertEquals(expect, Long.toString(id.longValue()));\r\n     }\r\n \r\n@@ -1230,7 +1313,7 @@ public void testFormatExample5() {\n         String p = \"[%9$d][%1$tT][%10$d][%2$s] %5$s%n%6$s%n\";\r\n         LogRecord r = new LogRecord(Level.SEVERE, \"Unable to send notification.\");\r\n         r.setSequenceNumber(125);\r\n-        r.setThreadID(38);\r\n+        setIntThreadID(r, 38);\r\n         r.setSourceClassName(\"MyClass\");\r\n         r.setSourceMethodName(\"fatal\");\r\n         setEpochMilli(r, 1248203502449L);\r"
  },
  {
    "sha": "62bcbe96387164c6a6fec8ad8c39a75f82a87714",
    "filename": "mail/src/test/java/com/sun/mail/util/logging/DurationFilterTest.java",
    "status": "modified",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/DurationFilterTest.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/DurationFilterTest.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/test/java/com/sun/mail/util/logging/DurationFilterTest.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -625,6 +625,11 @@ public void testInitDuration() throws Exception {\n         testInitDuration(\"1024\", 1024);\r\n     }\r\n \r\n+    @Test\r\n+    public void testInitDurationLiteralNull() throws Exception {\r\n+        testInitDuration(\"null\", 15L * 60L * 1000L);\r\n+    }\r\n+\r\n     @Test\r\n     public void testInitDurationZero() throws Exception {\r\n         testInitDuration(\"0\", 15L * 60L * 1000L);\r\n@@ -651,6 +656,8 @@ public void testInitDurationPartExp() throws Exception {\n         testInitDuration(\"15 *\", 15L * 60L * 1000L);\r\n         testInitDuration(\" * 15\", 15L * 60L * 1000L);\r\n         testInitDuration(\"15 * \", 15L * 60L * 1000L);\r\n+        testInitDuration(\"*\", 15L * 60L * 1000L);\r\n+        testInitDuration(\" * \", 15L * 60L * 1000L);\r\n     }\r\n \r\n     @Test\r\n@@ -754,6 +761,21 @@ public void testInitDurationIso8601All() throws Exception {\n         }\r\n     }\r\n \r\n+    @Test\r\n+    public void testInitDurationIso8601OverFlow() throws Exception {\r\n+        if (hasJavaTimeModule()) {\r\n+            testInitDuration(\"PT2562047788015H12M55.808S\", 15L * 60L * 1000L);\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void testInitDurationIso8601UnderFlow() throws Exception {\r\n+        if (hasJavaTimeModule()) {\r\n+            testInitDuration(\"PT-2562047788015H-12M-55.809S\",\r\n+                    15L * 60L * 1000L);\r\n+        }\r\n+    }\r\n+\r\n     private void testInitDuration(String d, long expect) throws Exception {\r\n         testInit(\"duration\", d, expect);\r\n         testInit(\"duration\", d.toUpperCase(Locale.ENGLISH), expect);\r"
  },
  {
    "sha": "07d18023bd6b42fab53aa5384490b123a6694a28",
    "filename": "mail/src/test/java/com/sun/mail/util/logging/LogManagerPropertiesTest.java",
    "status": "modified",
    "additions": 88,
    "deletions": 10,
    "changes": 98,
    "blob_url": "https://github.com/eclipse-ee4j/mail/blob/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/LogManagerPropertiesTest.java",
    "raw_url": "https://github.com/eclipse-ee4j/mail/raw/2fbbe2e467d3418fb056751668186e52a6907355/mail/src/test/java/com/sun/mail/util/logging/LogManagerPropertiesTest.java",
    "contents_url": "https://api.github.com/repos/eclipse-ee4j/mail/contents/mail/src/test/java/com/sun/mail/util/logging/LogManagerPropertiesTest.java?ref=2fbbe2e467d3418fb056751668186e52a6907355",
    "patch": "@@ -1,6 +1,6 @@\n /*\n- * Copyright (c) 2009, 2020 Oracle and/or its affiliates. All rights reserved.\n- * Copyright (c) 2009, 2018 Jason Mehrens. All rights reserved.\n+ * Copyright (c) 2009, 2021 Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021 Jason Mehrens. All rights reserved.\n  *\n  * This program and the accompanying materials are made available under the\n  * terms of the Eclipse Public License v. 2.0, which is available at\n@@ -406,15 +406,14 @@ public void testGetLocalHostSecure() throws Exception {\n         }\n     }\n \n-    @Test\n+    @Test(expected=NoSuchMethodException.class)\n+    public void testGetLocalHostNoLoop() throws Exception {\n+        LogManagerProperties.getLocalHost(new Object());\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n     public void testGetLocalHostNull() throws Exception {\n-        boolean fail = true;\n-        try {\n-            LogManagerProperties.getLocalHost((Service) null);\n-        } catch (NullPointerException expected) {\n-            fail = false;\n-        }\n-        Assert.assertFalse(fail);\n+        LogManagerProperties.getLocalHost((Service) null);\n     }\n \n     @Test\n@@ -480,6 +479,54 @@ public void testParseDurationAll() throws Exception {\n         }\n     }\n \n+    @Test(expected=NullPointerException.class)\n+    public void testParseDurationNull() throws Exception {\n+        LogManagerProperties.parseDurationToMillis((CharSequence) null);\n+    }\n+\n+    @Test\n+    public void testParseDurationParseException() throws Exception {\n+        try {\n+            String name = LogManagerPropertiesTest.class.getName();\n+            long ms = LogManagerProperties.parseDurationToMillis(name);\n+            fail(Long.toString(ms));\n+        } catch (ClassNotFoundException | NoClassDefFoundError ignore) {\n+            assertFalse(ignore.toString(), hasJavaTimeModule());\n+        } catch (RuntimeException expected) {\n+            //Allow subclasses of DTPE\n+            Class<?> k = Class.forName(\n+                    \"java.time.format.DateTimeParseException\");\n+            assertTrue(expected.toString(),\n+                    k.isAssignableFrom(expected.getClass()));\n+        }\n+    }\n+\n+    @Test\n+    public void testParseDurationParseOverflow() throws Exception {\n+        testParseDurationNotExact(\"PT2562047788015H12M55.808S\");\n+    }\n+\n+    @Test\n+    public void testParseDurationParseUnderflow() throws Exception {\n+        testParseDurationNotExact(\"PT-2562047788015H-12M-55.809S\");\n+    }\n+\n+    public void testParseDurationNotExact(String underOrOver) throws Exception {\n+        try {\n+            long ms = LogManagerProperties.parseDurationToMillis(underOrOver);\n+            fail(Long.toString(ms));\n+        } catch (ClassNotFoundException | NoClassDefFoundError ignore) {\n+            assertFalse(ignore.toString(), hasJavaTimeModule());\n+        } catch (ArithmeticException expected) {\n+        } catch (RuntimeException allowed) {\n+            //Allow subclasses of DTPE\n+            Class<?> k = Class.forName(\n+                    \"java.time.format.DateTimeParseException\");\n+            assertTrue(allowed.toString(),\n+                    k.isAssignableFrom(allowed.getClass()));\n+        }\n+    }\n+\n     @Test\n     public void testGetProperty_String() throws Exception {\n         String prefix = LogManagerPropertiesTest.class.getName();\n@@ -1134,6 +1181,37 @@ public void testEscapingFormatter() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testGetLongThreadID() throws Exception {\n+        long id = Thread.currentThread().getId();\n+        if (id <= Integer.MAX_VALUE) {\n+           id = ((long) Integer.MAX_VALUE) + 1L;\n+        } else {\n+           id++;\n+        }\n+\n+        LogRecord r1 = new LogRecord(Level.SEVERE, \"\");\n+        LogRecord r2 = new LogRecord(Level.SEVERE, \"\");\n+        try {\n+            setLongThreadID(r1, id);\n+            setLongThreadID(r2, id);\n+            assertEquals(id, (long) LogManagerProperties.getLongThreadID(r1));\n+            assertEquals(id, (long) LogManagerProperties.getLongThreadID(r2));\n+        } catch (final NoSuchMethodException preJdkSixteen) {\n+            try {\n+              Method m = LogRecord.class.getMethod(\"getLongThreadID\");\n+              fail(m.toString());\n+            } catch (NoSuchMethodException expect) {\n+                assertNull(LogManagerProperties.getLongThreadID(r1));\n+            }\n+        }\n+    }\n+\n+    @Test(expected=NullPointerException.class)\n+    public void testGetLongThreadIDNull() throws Exception {\n+        LogManagerProperties.getLongThreadID((LogRecord) null);\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testGetZonedDateTime() throws Exception {"
  }
]
