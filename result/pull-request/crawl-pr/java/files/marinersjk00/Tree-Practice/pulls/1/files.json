[
  {
    "sha": "c2d9c0073da2a1748dbd086d36a78162958032d5",
    "filename": "Node.java",
    "status": "modified",
    "additions": 96,
    "deletions": 71,
    "changes": 167,
    "blob_url": "https://github.com/marinersjk00/Tree-Practice/blob/4d0b1f8b05ef2ed39d45e40f71d0ec563c58d024/Node.java",
    "raw_url": "https://github.com/marinersjk00/Tree-Practice/raw/4d0b1f8b05ef2ed39d45e40f71d0ec563c58d024/Node.java",
    "contents_url": "https://api.github.com/repos/marinersjk00/Tree-Practice/contents/Node.java?ref=4d0b1f8b05ef2ed39d45e40f71d0ec563c58d024",
    "patch": "@@ -1,29 +1,26 @@\n-/*\n- * To change this license header, choose License Headers in Project Properties.\n- * To change this template file, choose Tools | Templates\n- * and open the template in the editor.\n- */\n-\n-/**\n- *\n- * @author jskuschner\n- */\n public class Node {\n+\n     int data;\n     Node left;\n     Node right;\n-    \n-    Node(){}\n-    Node(int data){\n+\n+    Node() {\n+    }\n+\n+    Node(int data) {\n         this.data = data;\n     }\n-   \n+\n }\n \n- class BinaryTree {\n-     \n+class BinaryTree {\n+\n     static Node root;\n \n+    BinaryTree() {\n+        root = null;\n+    }\n+\n     public static Node addNode(Node root, int n) {\n         Node curr = root;\n         if (curr == null) {\n@@ -37,83 +34,111 @@ public static Node addNode(Node root, int n) {\n         }\n         return curr;\n     }\n-    public static boolean containsNode(Node curr, int n){\n-        if (curr == null){\n-            System.out.println(\"Integer not Found.\");\n+\n+    public static boolean containsNode(Node curr, int n) {\n+        if (curr == null) {\n+            //  System.out.println(\"Integer not Found.\");\n             return false;\n         }\n-        if (curr.data == n){\n-            System.out.println(\"Integer Found.\");\n+        if (curr.data == n) {\n+            // System.out.println(\"Integer Found.\");\n             return true;\n         }\n-            if(n > curr.data){\n-                return containsNode(curr.right, n); //searches again, shifting root to the right\n-            }else{\n-                return containsNode(curr.left, n); //searches again, shifting root to left\n-            }\n-        \n-        \n+        if (n > curr.data) {\n+            return containsNode(curr.right, n); //searches again, shifting root to the right\n+        } else {\n+            return containsNode(curr.left, n); //searches again, shifting root to left\n+        }\n+\n     }\n-    public static int findSmallest(Node root){\n+\n+    public static int findSmallest(Node root) {\n         int smallest;\n-        while (root.left != null){ //finds the leftmost child which is the smallest node\n+        while (root.left != null) { //finds the leftmost child which is the smallest node\n             root = root.left;\n         }\n         smallest = root.data;\n         return smallest;\n-        \n+\n     }\n-    public static Node deleteNode(Node curr, int n){\n-        \n-        if (curr == null){ //list is empty\n-           // System.out.println(\"Nothing to delete.\");\n+\n+    public static Node deleteNode(Node root, int n) {\n+\n+        if (root == null) { //list is empty\n+            System.out.println(\"Node not found.\");\n             return null;\n         }\n-        \n-        if (curr.data == n){ //element to be deleted is found\n-            if(curr.left == null && curr.right == null){ //no children\n-                return null;\n-            }\n-            if(curr.left == null && curr.right != null){ //if node has one child on right\n-                curr = curr.right;\n-                return curr;\n-            }\n-            if(curr.right == null && curr.left != null){ //if node has one child on left\n-                curr = curr.left;\n-                return curr;\n-            }\n-            if(curr.right != null && curr.left != null){ //two children\n-                int smallest = findSmallest(curr); //finds smallest number from current root\n-                curr.data = smallest; //sets current data to the smallest number from current root\n-                curr.right = deleteNode(curr.right, smallest); //deletes the repeated smallest value and sets proper pointer\n-                return curr;\n-                \n-                \n+\n+        if (n < root.data) { //move to left where numbers are smaller\n+            root.left = deleteNode(root.left, n);\n+        } else if (n > root.data) { //move to right where numbers are bigger\n+            root.right = deleteNode(root.right, n);\n+        } else {\n+            //if there are zero or one children\n+                if (root.left == null) { \n+                    return root.right; //returns right value if root.right is not null, returns null if root.right is null\n+                } else if (root.right == null) {\n+                    return root.left;\n+                }\n+                //if there are two children\n+                root.data = findSmallest(root.right); //finds next inorder on right subtree\n+                root.right = deleteNode(root.right, root.data); //deletes node and replaces it with inorder successor\n+\n             }\n-        }\n-        \n-        if (n < curr.data){ //move to left where numbers are smaller\n-            curr.left = deleteNode(curr.left, n);\n-        }else if(n > curr.data){\n-            curr.right = deleteNode(curr.right, n);\n-        }\n-        \n-        \n-    \n+\n         \n-        return curr;\n+\n+        return root;\n     }\n-    \n-    public static void delete(int n){\n+\n+    public static void delete(int n) {\n         root = deleteNode(root, n);\n     }\n-            \n-    public static boolean contains(int n){\n+\n+    public static boolean contains(int n) {\n         return containsNode(root, n);\n     }\n-    \n+\n     public static void add(int n) {\n+        if(!contains(n)){\n         root = addNode(root, n);\n+        }else{\n+            System.out.print(\"No Duplicates.\");\n+        }\n+\n+    }\n+\n+    public static void inorder(Node root) {\n+        if (root == null) {\n+            return;\n+        }\n+        inorder(root.left);\n+\n+        System.out.print(root.data + \" \");\n+\n+        inorder(root.right);\n+    }\n+\n+    public static void postOrder(Node root) {\n+        if (root == null) {\n+            return;\n+        }\n+        postOrder(root.left);\n+\n+        postOrder(root.right);\n+\n+        System.out.print(root.data + \" \");\n+    }\n+\n+    public static void preOrder(Node root) {\n+        if (root == null) {\n+            return;\n+        }\n+        System.out.print(root.data + \" \");\n+\n+        preOrder(root.left);\n+        preOrder(root.right);\n+\n     }\n \n     public static void printBinaryTree(Node root, int level) { //print function taken from stackexchange"
  }
]
