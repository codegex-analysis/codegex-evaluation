[
  {
    "sha": "bd5d8387c0154d406a00689307d918d21bf9ed94",
    "filename": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java",
    "status": "modified",
    "additions": 18,
    "deletions": 6,
    "changes": 24,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/SystemSessionProperties.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/SystemSessionProperties.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/SystemSessionProperties.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -39,6 +39,7 @@\n import static io.trino.plugin.base.session.PropertyMetadataUtil.durationProperty;\n import static io.trino.spi.StandardErrorCode.INVALID_SESSION_PROPERTY;\n import static io.trino.spi.session.PropertyMetadata.booleanProperty;\n+import static io.trino.spi.session.PropertyMetadata.doubleProperty;\n import static io.trino.spi.session.PropertyMetadata.enumProperty;\n import static io.trino.spi.session.PropertyMetadata.integerProperty;\n import static io.trino.spi.session.PropertyMetadata.stringProperty;\n@@ -75,7 +76,8 @@\n     public static final String PUSH_TABLE_WRITE_THROUGH_UNION = \"push_table_write_through_union\";\n     public static final String EXECUTION_POLICY = \"execution_policy\";\n     public static final String DICTIONARY_AGGREGATION = \"dictionary_aggregation\";\n-    public static final String PLAN_WITH_TABLE_NODE_PARTITIONING = \"plan_with_table_node_partitioning\";\n+    public static final String USE_TABLE_SCAN_NODE_PARTITIONING = \"use_table_scan_node_partitioning\";\n+    public static final String TABLE_SCAN_NODE_PARTITIONING_MIN_BUCKET_TO_TASK_RATIO = \"table_scan_node_partitioning_min_bucket_to_task_ratio\";\n     public static final String SPATIAL_JOIN = \"spatial_join\";\n     public static final String SPATIAL_PARTITIONING_TABLE_NAME = \"spatial_partitioning_table_name\";\n     public static final String COLOCATED_JOIN = \"colocated_join\";\n@@ -310,9 +312,14 @@ public SystemSessionProperties(\n                         1,\n                         false),\n                 booleanProperty(\n-                        PLAN_WITH_TABLE_NODE_PARTITIONING,\n-                        \"Adapt plan to pre-partitioned tables\",\n-                        featuresConfig.isPlanWithTableNodePartitioning(),\n+                        USE_TABLE_SCAN_NODE_PARTITIONING,\n+                        \"Adapt plan to node pre-partitioned tables\",\n+                        featuresConfig.isUseTableScanNodePartitioning(),\n+                        false),\n+                doubleProperty(\n+                        TABLE_SCAN_NODE_PARTITIONING_MIN_BUCKET_TO_TASK_RATIO,\n+                        \"Min table scan bucket to task ratio for which plan will be adopted to node pre-partitioned tables\",\n+                        featuresConfig.getTableScanNodePartitioningMinBucketToTaskRatio(),\n                         false),\n                 enumProperty(\n                         JOIN_REORDERING_STRATEGY,\n@@ -735,9 +742,14 @@ public static int getQueryMaxStageCount(Session session)\n         return session.getSystemProperty(QUERY_MAX_STAGE_COUNT, Integer.class);\n     }\n \n-    public static boolean isPlanWithTableNodePartitioning(Session session)\n+    public static boolean isUseTableScanNodePartitioning(Session session)\n+    {\n+        return session.getSystemProperty(USE_TABLE_SCAN_NODE_PARTITIONING, Boolean.class);\n+    }\n+\n+    public static double getTableScanNodePartitioningMinBucketToTaskRatio(Session session)\n     {\n-        return session.getSystemProperty(PLAN_WITH_TABLE_NODE_PARTITIONING, Boolean.class);\n+        return session.getSystemProperty(TABLE_SCAN_NODE_PARTITIONING_MIN_BUCKET_TO_TASK_RATIO, Double.class);\n     }\n \n     public static JoinReorderingStrategy getJoinReorderingStrategy(Session session)"
  },
  {
    "sha": "6fbb8622fb8f42185e79188731002abc0f443977",
    "filename": "core/trino-main/src/main/java/io/trino/sql/analyzer/FeaturesConfig.java",
    "status": "modified",
    "additions": 23,
    "deletions": 7,
    "changes": 30,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/analyzer/FeaturesConfig.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/analyzer/FeaturesConfig.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/analyzer/FeaturesConfig.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -130,7 +130,8 @@\n     private boolean rewriteFilteringSemiJoinToInnerJoin = true;\n     private boolean optimizeDuplicateInsensitiveJoins = true;\n     private boolean useLegacyWindowFilterPushdown;\n-    private boolean planWithTableNodePartitioning = true;\n+    private boolean useTableScanNodePartitioning = true;\n+    private double tableScanNodePartitioningMinBucketToTaskRatio = 0.5;\n \n     private Duration iterativeOptimizerTimeout = new Duration(3, MINUTES); // by default let optimizer wait a long time in case it retrieves some data from ConnectorMetadata\n     private DataSize filterAndProjectMinOutputPageSize = DataSize.of(500, KILOBYTE);\n@@ -1020,16 +1021,31 @@ public FeaturesConfig setUseLegacyWindowFilterPushdown(boolean useLegacyWindowFi\n         return this;\n     }\n \n-    public boolean isPlanWithTableNodePartitioning()\n+    public boolean isUseTableScanNodePartitioning()\n     {\n-        return planWithTableNodePartitioning;\n+        return useTableScanNodePartitioning;\n     }\n \n-    @Config(\"optimizer.plan-with-table-node-partitioning\")\n-    @ConfigDescription(\"Adapt plan to pre-partitioned tables\")\n-    public FeaturesConfig setPlanWithTableNodePartitioning(boolean planWithTableNodePartitioning)\n+    @Config(\"optimizer.use-table-scan-node-partitioning\")\n+    @LegacyConfig(\"optimizer.plan-with-table-node-partitioning\")\n+    @ConfigDescription(\"Adapt plan to node pre-partitioned tables\")\n+    public FeaturesConfig setUseTableScanNodePartitioning(boolean useTableScanNodePartitioning)\n     {\n-        this.planWithTableNodePartitioning = planWithTableNodePartitioning;\n+        this.useTableScanNodePartitioning = useTableScanNodePartitioning;\n+        return this;\n+    }\n+\n+    @Min(0)\n+    public double getTableScanNodePartitioningMinBucketToTaskRatio()\n+    {\n+        return tableScanNodePartitioningMinBucketToTaskRatio;\n+    }\n+\n+    @Config(\"optimizer.table-scan-node-partitioning-min-bucket-to-task-ratio\")\n+    @ConfigDescription(\"Min table scan bucket to task ratio for which plan will be adopted to node pre-partitioned tables\")\n+    public FeaturesConfig setTableScanNodePartitioningMinBucketToTaskRatio(double tableScanNodePartitioningMinBucketToTaskRatio)\n+    {\n+        this.tableScanNodePartitioningMinBucketToTaskRatio = tableScanNodePartitioningMinBucketToTaskRatio;\n         return this;\n     }\n }"
  },
  {
    "sha": "cf782eed104a2e771c86140665097968c4a5aeac",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/LogicalPlanner.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/LogicalPlanner.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/LogicalPlanner.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/LogicalPlanner.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -319,7 +319,7 @@ private RelationPlan createAnalyzePlan(Analysis analysis, Analyze analyzeStateme\n                 idAllocator.getNextId(),\n                 new AggregationNode(\n                         idAllocator.getNextId(),\n-                        TableScanNode.newInstance(idAllocator.getNextId(), targetTable, tableScanOutputs.build(), symbolToColumnHandle.build(), false),\n+                        TableScanNode.newInstance(idAllocator.getNextId(), targetTable, tableScanOutputs.build(), symbolToColumnHandle.build(), false, Optional.empty()),\n                         statisticAggregations.getAggregations(),\n                         singleGroupingSet(groupingSymbols),\n                         ImmutableList.of(),"
  },
  {
    "sha": "aca03221b9494a637df96a83ea3bbc9af67c1965",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/PlanCopier.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanCopier.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanCopier.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/PlanCopier.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -120,7 +120,7 @@ public PlanNode visitSample(SampleNode node, RewriteContext<Void> context)\n         @Override\n         public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n         {\n-            return new TableScanNode(idAllocator.getNextId(), node.getTable(), node.getOutputSymbols(), node.getAssignments(), node.getEnforcedConstraint(), node.isUpdateTarget());\n+            return new TableScanNode(idAllocator.getNextId(), node.getTable(), node.getOutputSymbols(), node.getAssignments(), node.getEnforcedConstraint(), node.isUpdateTarget(), node.getUseConnectorNodePartitioning());\n         }\n \n         @Override"
  },
  {
    "sha": "d8a573d108f74a95d7b84f5a91aaf8261cc903bb",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/PlanFragmenter.java",
    "status": "modified",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanFragmenter.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanFragmenter.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/PlanFragmenter.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -307,6 +307,7 @@ public PlanNode visitTableScan(TableScanNode node, RewriteContext<FragmentProper\n         {\n             PartitioningHandle partitioning = metadata.getTableProperties(session, node.getTable())\n                     .getTablePartitioning()\n+                    .filter(value -> node.isUseConnectorNodePartitioning())\n                     .map(TablePartitioning::getPartitioningHandle)\n                     .orElse(SOURCE_DISTRIBUTION);\n \n@@ -668,7 +669,7 @@ private GroupedExecutionProperties processWindowFunction(PlanNode node)\n         public GroupedExecutionProperties visitTableScan(TableScanNode node, Void context)\n         {\n             Optional<TablePartitioning> tablePartitioning = metadata.getTableProperties(session, node.getTable()).getTablePartitioning();\n-            if (tablePartitioning.isEmpty()) {\n+            if (tablePartitioning.isEmpty() || !node.isUseConnectorNodePartitioning()) {\n                 return GroupedExecutionProperties.notCapable();\n             }\n             List<ConnectorPartitionHandle> partitionHandles = nodePartitioningManager.listPartitionHandles(session, tablePartitioning.get().getPartitioningHandle());\n@@ -772,6 +773,7 @@ public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n         {\n             PartitioningHandle partitioning = metadata.getTableProperties(session, node.getTable())\n                     .getTablePartitioning()\n+                    .filter(value -> node.isUseConnectorNodePartitioning())\n                     .map(TablePartitioning::getPartitioningHandle)\n                     .orElse(SOURCE_DISTRIBUTION);\n             if (partitioning.equals(fragmentPartitioningHandle)) {\n@@ -786,7 +788,10 @@ public PlanNode visitTableScan(TableScanNode node, RewriteContext<Void> context)\n                     node.getOutputSymbols(),\n                     node.getAssignments(),\n                     node.getEnforcedConstraint(),\n-                    node.isUpdateTarget());\n+                    node.isUpdateTarget(),\n+                    // plan was already fragmented with scan node's partitioning\n+                    // and new partitioning is compatible with previous one\n+                    node.getUseConnectorNodePartitioning());\n         }\n     }\n }"
  },
  {
    "sha": "6535eb486b5d3a906f879b8a106aa4f4651225dc",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/PlanOptimizers.java",
    "status": "modified",
    "additions": 8,
    "deletions": 3,
    "changes": 11,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanOptimizers.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/PlanOptimizers.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/PlanOptimizers.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -47,6 +47,7 @@\n import io.trino.sql.planner.iterative.rule.DetermineJoinDistributionType;\n import io.trino.sql.planner.iterative.rule.DeterminePreferredWritePartitioning;\n import io.trino.sql.planner.iterative.rule.DetermineSemiJoinDistributionType;\n+import io.trino.sql.planner.iterative.rule.DetermineTableScanNodePartitioning;\n import io.trino.sql.planner.iterative.rule.EliminateCrossJoins;\n import io.trino.sql.planner.iterative.rule.EvaluateZeroSample;\n import io.trino.sql.planner.iterative.rule.ExtractDereferencesFromFilterAboveScan;\n@@ -257,7 +258,8 @@ public PlanOptimizers(\n             @EstimatedExchanges CostCalculator estimatedExchangesCostCalculator,\n             CostComparator costComparator,\n             TaskCountEstimator taskCountEstimator,\n-            RuleStatsRecorder ruleStats)\n+            RuleStatsRecorder ruleStats,\n+            NodePartitioningManager nodePartitioningManager)\n     {\n         this(metadata,\n                 typeOperators,\n@@ -272,7 +274,8 @@ public PlanOptimizers(\n                 estimatedExchangesCostCalculator,\n                 costComparator,\n                 taskCountEstimator,\n-                ruleStats);\n+                ruleStats,\n+                nodePartitioningManager);\n     }\n \n     @PostConstruct\n@@ -303,7 +306,8 @@ public PlanOptimizers(\n             CostCalculator estimatedExchangesCostCalculator,\n             CostComparator costComparator,\n             TaskCountEstimator taskCountEstimator,\n-            RuleStatsRecorder ruleStats)\n+            RuleStatsRecorder ruleStats,\n+            NodePartitioningManager nodePartitioningManager)\n     {\n         this.ruleStats = ruleStats;\n         this.exporter = exporter;\n@@ -743,6 +747,7 @@ public PlanOptimizers(\n                 ImmutableSet.of(\n                         // Must run before AddExchanges\n                         new PushDeleteIntoConnector(metadata),\n+                        new DetermineTableScanNodePartitioning(metadata, nodePartitioningManager, taskCountEstimator),\n                         // Must run after join reordering because join reordering creates\n                         // new join nodes without JoinNode.maySkipOutputDuplicates flag set\n                         new OptimizeDuplicateInsensitiveJoins(metadata))));"
  },
  {
    "sha": "5fc5e0dc825e798b31f57cfce585809bec8b8fc0",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/RelationPlanner.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/RelationPlanner.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/RelationPlanner.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/RelationPlanner.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -203,7 +203,7 @@ protected RelationPlan visitTable(Table node, Void context)\n \n             List<Symbol> outputSymbols = outputSymbolsBuilder.build();\n             boolean updateTarget = analysis.isUpdateTarget(node);\n-            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build(), updateTarget);\n+            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build(), updateTarget, Optional.empty());\n \n             plan = new RelationPlan(root, scope, outputSymbols, outerContext);\n         }"
  },
  {
    "sha": "d55ee9066b2c64527399b6379251aab9e27aa791",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/ApplyTableScanRedirection.java",
    "status": "modified",
    "additions": 4,
    "deletions": 2,
    "changes": 6,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/ApplyTableScanRedirection.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/ApplyTableScanRedirection.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/ApplyTableScanRedirection.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -134,7 +134,8 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                             scanNode.getOutputSymbols(),\n                             newAssignments,\n                             TupleDomain.all(),\n-                            scanNode.isUpdateTarget()));\n+                            scanNode.isUpdateTarget(),\n+                            Optional.empty()));\n         }\n \n         ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n@@ -185,7 +186,8 @@ public Result apply(TableScanNode scanNode, Captures captures, Context context)\n                 newOutputSymbols,\n                 newAssignmentsBuilder.build(),\n                 TupleDomain.all(),\n-                scanNode.isUpdateTarget());\n+                scanNode.isUpdateTarget(),\n+                Optional.empty());\n \n         FilterNode filterNode = new FilterNode(\n                 context.getIdAllocator().getNextId(),"
  },
  {
    "sha": "bf98175c6d35c1a23e1f73fd8ac06962cc72db85",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DetermineTableScanNodePartitioning.java",
    "status": "added",
    "additions": 81,
    "deletions": 0,
    "changes": 81,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DetermineTableScanNodePartitioning.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DetermineTableScanNodePartitioning.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DetermineTableScanNodePartitioning.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import io.trino.cost.TaskCountEstimator;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.metadata.TableProperties;\n+import io.trino.metadata.TableProperties.TablePartitioning;\n+import io.trino.spi.connector.ConnectorBucketNodeMap;\n+import io.trino.sql.planner.NodePartitioningManager;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.TableScanNode;\n+\n+import static io.trino.SystemSessionProperties.getTableScanNodePartitioningMinBucketToTaskRatio;\n+import static io.trino.SystemSessionProperties.isUseTableScanNodePartitioning;\n+import static io.trino.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.Math.max;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DetermineTableScanNodePartitioning\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan()\n+            .matching(tableScan -> tableScan.getUseConnectorNodePartitioning().isEmpty());\n+\n+    private final Metadata metadata;\n+    private final NodePartitioningManager nodePartitioningManager;\n+    private final TaskCountEstimator taskCountEstimator;\n+\n+    public DetermineTableScanNodePartitioning(Metadata metadata, NodePartitioningManager nodePartitioningManager, TaskCountEstimator taskCountEstimator)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.nodePartitioningManager = requireNonNull(nodePartitioningManager, \"nodePartitioningManager is null\");\n+        this.taskCountEstimator = requireNonNull(taskCountEstimator, \"taskCountEstimator is null\");\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode node, Captures captures, Context context)\n+    {\n+        TableProperties properties = metadata.getTableProperties(context.getSession(), node.getTable());\n+        if (properties.getTablePartitioning().isEmpty()) {\n+            return Result.ofPlanNode(node.withUseConnectorNodePartitioning(false));\n+        }\n+\n+        TablePartitioning partitioning = properties.getTablePartitioning().get();\n+        ConnectorBucketNodeMap bucketNodeMap = nodePartitioningManager.getConnectorBucketNodeMap(context.getSession(), partitioning.getPartitioningHandle());\n+        if (bucketNodeMap.hasFixedMapping()) {\n+            // use connector table scan node partitioning when bucket to node assignments are fixed\n+            return Result.ofPlanNode(node.withUseConnectorNodePartitioning(true));\n+        }\n+\n+        if (!isUseTableScanNodePartitioning(context.getSession())) {\n+            return Result.ofPlanNode(node.withUseConnectorNodePartitioning(false));\n+        }\n+\n+        int numberOfBuckets = bucketNodeMap.getBucketCount();\n+        int numberOfTasks = max(taskCountEstimator.estimateSourceDistributedTaskCount(context.getSession()), 1);\n+\n+        return Result.ofPlanNode(node\n+                .withUseConnectorNodePartitioning((double) numberOfBuckets / numberOfTasks >= getTableScanNodePartitioningMinBucketToTaskRatio(context.getSession())));\n+    }\n+}"
  },
  {
    "sha": "979ec4b53d471c65ab355ce8d55b3297d3b95493",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PruneTableScanColumns.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PruneTableScanColumns.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PruneTableScanColumns.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PruneTableScanColumns.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -116,6 +116,7 @@ public PruneTableScanColumns(Metadata metadata)\n                 newOutputs,\n                 newAssignments,\n                 enforcedConstraint,\n-                node.isUpdateTarget()));\n+                node.isUpdateTarget(),\n+                node.getUseConnectorNodePartitioning()));\n     }\n }"
  },
  {
    "sha": "8f5a7eeeb5ff9987a3b01f21dd40cbcf40e16b23",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushAggregationIntoTableScan.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushAggregationIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushAggregationIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushAggregationIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -204,7 +204,9 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n                                 result.getHandle(),\n                                 newScanOutputs.build(),\n                                 scanAssignments,\n-                                tableScan.isUpdateTarget()),\n+                                tableScan.isUpdateTarget(),\n+                                // table scan partitioning might have changed with new table handle\n+                                Optional.empty()),\n                         assignmentBuilder.build()));\n     }\n "
  },
  {
    "sha": "7eb374fba172d0eb5cb3278ad4c7fb2f5cc75225",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushJoinIntoTableScan.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushJoinIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushJoinIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushJoinIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -194,7 +194,8 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n                                 ImmutableList.copyOf(assignments.keySet()),\n                                 assignments,\n                                 newEnforcedConstraint,\n-                                false),\n+                                false,\n+                                Optional.empty()),\n                         Assignments.identity(joinNode.getOutputSymbols())));\n     }\n "
  },
  {
    "sha": "4776cb5e09dde7bc020d6c10ce3f0b8328e27b25",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushLimitIntoTableScan.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushLimitIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushLimitIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushLimitIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -23,6 +23,8 @@\n import io.trino.sql.planner.plan.PlanNode;\n import io.trino.sql.planner.plan.TableScanNode;\n \n+import java.util.Optional;\n+\n import static io.trino.SystemSessionProperties.isAllowPushdownIntoConnectors;\n import static io.trino.matching.Capture.newCapture;\n import static io.trino.sql.planner.plan.Patterns.limit;\n@@ -70,7 +72,9 @@ public boolean isEnabled(Session session)\n                             tableScan.getOutputSymbols(),\n                             tableScan.getAssignments(),\n                             tableScan.getEnforcedConstraint(),\n-                            tableScan.isUpdateTarget());\n+                            tableScan.isUpdateTarget(),\n+                            // table scan partitioning might have changed with new table handle\n+                            Optional.empty());\n \n                     if (!result.isLimitGuaranteed()) {\n                         node = new LimitNode(limit.getId(), node, limit.getCount(), limit.isPartial());"
  },
  {
    "sha": "af8768a46ad7108886ce1e26f31a8ce65f41d005",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushPredicateIntoTableScan.java",
    "status": "modified",
    "additions": 30,
    "deletions": 2,
    "changes": 32,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushPredicateIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushPredicateIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushPredicateIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -22,6 +22,8 @@\n import io.trino.metadata.Metadata;\n import io.trino.metadata.TableHandle;\n import io.trino.metadata.TableLayoutResult;\n+import io.trino.metadata.TableProperties;\n+import io.trino.metadata.TableProperties.TablePartitioning;\n import io.trino.operator.scalar.TryFunction;\n import io.trino.spi.connector.ColumnHandle;\n import io.trino.spi.connector.Constraint;\n@@ -50,6 +52,7 @@\n import java.util.Optional;\n import java.util.Set;\n \n+import static com.google.common.base.Verify.verify;\n import static com.google.common.collect.ImmutableSet.toImmutableSet;\n import static com.google.common.collect.Sets.intersection;\n import static io.trino.SystemSessionProperties.isAllowPushdownIntoConnectors;\n@@ -199,6 +202,7 @@ private boolean arePlansSame(FilterNode filter, TableScanNode tableScan, PlanNod\n         }\n \n         TableHandle newTable;\n+        Optional<TablePartitioning> newTablePartitioning;\n         TupleDomain<ColumnHandle> remainingFilter;\n         if (!metadata.usesLegacyTableLayouts(session, node.getTable())) {\n             // check if new domain is wider than domain already provided by table scan\n@@ -231,7 +235,9 @@ private boolean arePlansSame(FilterNode filter, TableScanNode tableScan, PlanNod\n \n             newTable = result.get().getHandle();\n \n-            if (metadata.getTableProperties(session, newTable).getPredicate().isNone()) {\n+            TableProperties newTableProperties = metadata.getTableProperties(session, newTable);\n+            newTablePartitioning = newTableProperties.getTablePartitioning();\n+            if (newTableProperties.getPredicate().isNone()) {\n                 return Optional.of(new ValuesNode(node.getId(), node.getOutputSymbols(), ImmutableList.of()));\n             }\n \n@@ -251,16 +257,20 @@ private boolean arePlansSame(FilterNode filter, TableScanNode tableScan, PlanNod\n             }\n \n             newTable = layout.get().getNewTableHandle();\n+            newTablePartitioning = layout.get().getTableProperties().getTablePartitioning();\n             remainingFilter = layout.get().getUnenforcedConstraint();\n         }\n \n+        verifyTablePartitioning(session, metadata, node, newTablePartitioning);\n+\n         TableScanNode tableScan = new TableScanNode(\n                 node.getId(),\n                 newTable,\n                 node.getOutputSymbols(),\n                 node.getAssignments(),\n                 computeEnforced(newDomain, remainingFilter),\n-                node.isUpdateTarget());\n+                node.isUpdateTarget(),\n+                node.getUseConnectorNodePartitioning());\n \n         Expression resultingPredicate = createResultingPredicate(\n                 metadata,\n@@ -275,6 +285,24 @@ private boolean arePlansSame(FilterNode filter, TableScanNode tableScan, PlanNod\n         return Optional.of(tableScan);\n     }\n \n+    // PushPredicateIntoTableScan might be executed after AddExchanges and DetermineTableScanNodePartitioning.\n+    // In that case, table scan node partitioning (if present) was used to fragment plan with ExchangeNodes.\n+    // Therefore table scan node partitioning should not change after AddExchanges is executed since it would\n+    // make plan with ExchangeNodes invalid.\n+    private static void verifyTablePartitioning(\n+            Session session,\n+            Metadata metadata,\n+            TableScanNode oldTableScan,\n+            Optional<TablePartitioning> newTablePartitioning)\n+    {\n+        if (oldTableScan.getUseConnectorNodePartitioning().isEmpty()) {\n+            return;\n+        }\n+\n+        Optional<TablePartitioning> oldTablePartitioning = metadata.getTableProperties(session, oldTableScan.getTable()).getTablePartitioning();\n+        verify(newTablePartitioning.equals(oldTablePartitioning), \"Partitioning must not change after predicate is pushed down\");\n+    }\n+\n     static Expression createResultingPredicate(\n             Metadata metadata,\n             Expression unenforcedConstraints,"
  },
  {
    "sha": "7e336fc0c777eecb20bff46234b9ac68a0fafe34",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushProjectionIntoTableScan.java",
    "status": "modified",
    "additions": 23,
    "deletions": 1,
    "changes": 24,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushProjectionIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushProjectionIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushProjectionIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -21,6 +21,7 @@\n import io.trino.matching.Pattern;\n import io.trino.metadata.Metadata;\n import io.trino.metadata.TableHandle;\n+import io.trino.metadata.TableProperties.TablePartitioning;\n import io.trino.spi.connector.Assignment;\n import io.trino.spi.connector.ColumnHandle;\n import io.trino.spi.connector.ProjectionApplicationResult;\n@@ -43,6 +44,7 @@\n import java.util.Optional;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.trino.SystemSessionProperties.isAllowPushdownIntoConnectors;\n@@ -154,6 +156,7 @@ public Result apply(ProjectNode project, Captures captures, Context context)\n             newProjectionAssignments.put(entry.getKey(), replaceExpression(entry.getValue(), nodesToNewPartialProjections));\n         });\n \n+        verifyTablePartitioning(context, tableScan, result.get().getHandle());\n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n@@ -162,7 +165,26 @@ public Result apply(ProjectNode project, Captures captures, Context context)\n                                 result.get().getHandle(),\n                                 newScanOutputs,\n                                 newScanAssignments,\n-                                tableScan.isUpdateTarget()),\n+                                tableScan.isUpdateTarget(),\n+                                tableScan.getUseConnectorNodePartitioning()),\n                         newProjectionAssignments.build()));\n     }\n+\n+    // PushProjectionIntoTableScan might be executed after AddExchanges and DetermineTableScanNodePartitioning.\n+    // In that case, table scan node partitioning (if present) was used to fragment plan with ExchangeNodes.\n+    // Therefore table scan node partitioning should not change after AddExchanges is executed since it would\n+    // make plan with ExchangeNodes invalid.\n+    private void verifyTablePartitioning(\n+            Context context,\n+            TableScanNode oldTableScan,\n+            TableHandle newTable)\n+    {\n+        if (oldTableScan.getUseConnectorNodePartitioning().isEmpty()) {\n+            return;\n+        }\n+\n+        Optional<TablePartitioning> oldTablePartitioning = metadata.getTableProperties(context.getSession(), oldTableScan.getTable()).getTablePartitioning();\n+        Optional<TablePartitioning> newTablePartitioning = metadata.getTableProperties(context.getSession(), newTable).getTablePartitioning();\n+        verify(newTablePartitioning.equals(oldTablePartitioning), \"Partitioning must not change after projection is pushed down\");\n+    }\n }"
  },
  {
    "sha": "a6e874d888eef912b2b9e0a09c2c499dd2d70803",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushSampleIntoTableScan.java",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushSampleIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushSampleIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushSampleIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -24,6 +24,8 @@\n import io.trino.sql.planner.plan.SampleNode.Type;\n import io.trino.sql.planner.plan.TableScanNode;\n \n+import java.util.Optional;\n+\n import static io.trino.SystemSessionProperties.isAllowPushdownIntoConnectors;\n import static io.trino.matching.Capture.newCapture;\n import static io.trino.sql.planner.plan.Patterns.Sample.sampleType;\n@@ -70,7 +72,9 @@ public boolean isEnabled(Session session)\n                         tableScan.getOutputSymbols(),\n                         tableScan.getAssignments(),\n                         tableScan.getEnforcedConstraint(),\n-                        tableScan.isUpdateTarget())))\n+                        tableScan.isUpdateTarget(),\n+                        // table scan partitioning might have changed with new table handle\n+                        Optional.empty())))\n                 .orElseGet(Result::empty);\n     }\n "
  },
  {
    "sha": "96fe58c402319b19fe119ab26d2832da785ed0f7",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushTopNIntoTableScan.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushTopNIntoTableScan.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushTopNIntoTableScan.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/PushTopNIntoTableScan.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -29,6 +29,7 @@\n \n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n \n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.trino.SystemSessionProperties.isAllowPushdownIntoConnectors;\n@@ -86,7 +87,9 @@ public Result apply(TopNNode topNNode, Captures captures, Context context)\n                             result.getHandle(),\n                             tableScan.getOutputSymbols(),\n                             tableScan.getAssignments(),\n-                            tableScan.isUpdateTarget());\n+                            tableScan.isUpdateTarget(),\n+                            // table scan partitioning might have changed with new table handle\n+                            Optional.empty());\n \n                     if (!result.isTopNGuaranteed()) {\n                         node = topNNode.replaceChildren(ImmutableList.of(node));"
  },
  {
    "sha": "caec54d1ef305e5025e35debb7abf6b6a0d7c20d",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/optimizations/BeginTableWrite.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/BeginTableWrite.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/BeginTableWrite.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/BeginTableWrite.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -269,7 +269,9 @@ private PlanNode rewriteModifyTableScan(PlanNode node, TableHandle handle)\n                         scan.getOutputSymbols(),\n                         scan.getAssignments(),\n                         scan.getEnforcedConstraint(),\n-                        scan.isUpdateTarget());\n+                        scan.isUpdateTarget(),\n+                        // partitioning should not change with write table handle\n+                        scan.getUseConnectorNodePartitioning());\n             }\n \n             if (node instanceof FilterNode) {"
  },
  {
    "sha": "5e5de457db80acabd163da7f78f1cbed060c14a0",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/optimizations/PropertyDerivations.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/PropertyDerivations.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/PropertyDerivations.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/PropertyDerivations.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -94,7 +94,6 @@\n import static com.google.common.base.Verify.verify;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableSet.toImmutableSet;\n-import static io.trino.SystemSessionProperties.isPlanWithTableNodePartitioning;\n import static io.trino.spi.predicate.TupleDomain.extractFixedValues;\n import static io.trino.sql.planner.SystemPartitioningHandle.ARBITRARY_DISTRIBUTION;\n import static io.trino.sql.planner.optimizations.ActualProperties.Global.arbitraryPartition;\n@@ -761,7 +760,7 @@ public ActualProperties visitTableScan(TableScanNode node, List<ActualProperties\n             properties.constants(symbolConstants);\n \n             // Partitioning properties\n-            properties.global(deriveGlobalProperties(layout, assignments, globalConstants));\n+            properties.global(deriveGlobalProperties(node, layout, assignments, globalConstants));\n \n             // Append the global constants onto the local properties to maximize their translation potential\n             List<LocalProperty<ColumnHandle>> constantAppendedLocalProperties = ImmutableList.<LocalProperty<ColumnHandle>>builder()\n@@ -773,12 +772,12 @@ public ActualProperties visitTableScan(TableScanNode node, List<ActualProperties\n             return properties.build();\n         }\n \n-        private Global deriveGlobalProperties(TableProperties layout, Map<ColumnHandle, Symbol> assignments, Map<ColumnHandle, NullableValue> constants)\n+        private Global deriveGlobalProperties(TableScanNode node, TableProperties layout, Map<ColumnHandle, Symbol> assignments, Map<ColumnHandle, NullableValue> constants)\n         {\n             Optional<List<Symbol>> streamPartitioning = layout.getStreamPartitioningColumns()\n                     .flatMap(columns -> translateToNonConstantSymbols(columns, assignments, constants));\n \n-            if (isPlanWithTableNodePartitioning(session) && layout.getTablePartitioning().isPresent()) {\n+            if (layout.getTablePartitioning().isPresent() && node.isUseConnectorNodePartitioning()) {\n                 TablePartitioning tablePartitioning = layout.getTablePartitioning().get();\n                 if (assignments.keySet().containsAll(tablePartitioning.getPartitioningColumns())) {\n                     List<Symbol> arguments = tablePartitioning.getPartitioningColumns().stream()"
  },
  {
    "sha": "8198964637424802562dc257a951fbe8150d0d5f",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/optimizations/UnaliasSymbolReferences.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/UnaliasSymbolReferences.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/UnaliasSymbolReferences.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/optimizations/UnaliasSymbolReferences.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -286,7 +286,7 @@ public PlanAndMappings visitTableScan(TableScanNode node, UnaliasContext context\n             });\n \n             return new PlanAndMappings(\n-                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint(), node.isUpdateTarget()),\n+                    new TableScanNode(node.getId(), node.getTable(), newOutputs, newAssignments, node.getEnforcedConstraint(), node.isUpdateTarget(), node.getUseConnectorNodePartitioning()),\n                     mapping);\n         }\n "
  },
  {
    "sha": "e5f50ae47bdacc4fd82a31a224ff6008d39dd462",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/plan/TableScanNode.java",
    "status": "modified",
    "additions": 36,
    "deletions": 4,
    "changes": 40,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/plan/TableScanNode.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/plan/TableScanNode.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/plan/TableScanNode.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -15,6 +15,7 @@\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.VerifyException;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import io.trino.metadata.TableHandle;\n@@ -26,6 +27,7 @@\n \n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n@@ -42,6 +44,7 @@\n \n     private final TupleDomain<ColumnHandle> enforcedConstraint;\n     private final boolean updateTarget;\n+    private final Optional<Boolean> useConnectorNodePartitioning;\n \n     // We need this factory method to disambiguate with the constructor used for deserializing\n     // from a json object. The deserializer sets some fields which are never transported\n@@ -51,9 +54,10 @@ public static TableScanNode newInstance(\n             TableHandle table,\n             List<Symbol> outputs,\n             Map<Symbol, ColumnHandle> assignments,\n-            boolean updateTarget)\n+            boolean updateTarget,\n+            Optional<Boolean> useConnectorNodePartitioning)\n     {\n-        return new TableScanNode(id, table, outputs, assignments, TupleDomain.all(), updateTarget);\n+        return new TableScanNode(id, table, outputs, assignments, TupleDomain.all(), updateTarget, useConnectorNodePartitioning);\n     }\n \n     /*\n@@ -67,7 +71,8 @@ public TableScanNode(\n             @JsonProperty(\"table\") TableHandle table,\n             @JsonProperty(\"outputSymbols\") List<Symbol> outputs,\n             @JsonProperty(\"assignments\") Map<Symbol, ColumnHandle> assignments,\n-            @JsonProperty(\"updateTarget\") boolean updateTarget)\n+            @JsonProperty(\"updateTarget\") boolean updateTarget,\n+            @JsonProperty(\"useConnectorNodePartitioning\") Optional<Boolean> useConnectorNodePartitioning)\n     {\n         super(id);\n         this.table = requireNonNull(table, \"table is null\");\n@@ -76,6 +81,7 @@ public TableScanNode(\n         checkArgument(assignments.keySet().containsAll(outputs), \"assignments does not cover all of outputs\");\n         this.enforcedConstraint = null;\n         this.updateTarget = updateTarget;\n+        this.useConnectorNodePartitioning = requireNonNull(useConnectorNodePartitioning, \"useConnectorNodePartitioning is null\");\n     }\n \n     public TableScanNode(\n@@ -84,7 +90,8 @@ public TableScanNode(\n             List<Symbol> outputs,\n             Map<Symbol, ColumnHandle> assignments,\n             TupleDomain<ColumnHandle> enforcedConstraint,\n-            boolean updateTarget)\n+            boolean updateTarget,\n+            Optional<Boolean> useConnectorNodePartitioning)\n     {\n         super(id);\n         this.table = requireNonNull(table, \"table is null\");\n@@ -93,6 +100,7 @@ public TableScanNode(\n         checkArgument(assignments.keySet().containsAll(outputs), \"assignments does not cover all of outputs\");\n         this.enforcedConstraint = requireNonNull(enforcedConstraint, \"enforcedConstraint is null\");\n         this.updateTarget = updateTarget;\n+        this.useConnectorNodePartitioning = requireNonNull(useConnectorNodePartitioning, \"useTableNodePartitioning is null\");\n     }\n \n     @JsonProperty(\"table\")\n@@ -135,6 +143,18 @@ public boolean isUpdateTarget()\n         return updateTarget;\n     }\n \n+    @JsonProperty(\"useConnectorNodePartitioning\")\n+    public Optional<Boolean> getUseConnectorNodePartitioning()\n+    {\n+        return useConnectorNodePartitioning;\n+    }\n+\n+    public boolean isUseConnectorNodePartitioning()\n+    {\n+        return useConnectorNodePartitioning\n+                .orElseThrow(() -> new VerifyException(\"useConnectorNodePartitioning is not present\"));\n+    }\n+\n     @Override\n     public List<PlanNode> getSources()\n     {\n@@ -165,4 +185,16 @@ public PlanNode replaceChildren(List<PlanNode> newChildren)\n         checkArgument(newChildren.isEmpty(), \"newChildren is not empty\");\n         return this;\n     }\n+\n+    public TableScanNode withUseConnectorNodePartitioning(boolean useConnectorNodePartitioning)\n+    {\n+        return new TableScanNode(\n+                getId(),\n+                table,\n+                outputSymbols,\n+                assignments,\n+                enforcedConstraint,\n+                updateTarget,\n+                Optional.of(useConnectorNodePartitioning));\n+    }\n }"
  },
  {
    "sha": "307e8cc25725a8b0e7034e559fa228f518afa2c7",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/sanity/PlanSanityChecker.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/sanity/PlanSanityChecker.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/sanity/PlanSanityChecker.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/sanity/PlanSanityChecker.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -55,6 +55,7 @@ public PlanSanityChecker(boolean forceSingleNode)\n                         new NoIdentifierLeftChecker(),\n                         new VerifyOnlyOneOutputNode(),\n                         new VerifyNoFilteredAggregations(),\n+                        new VerifyUseConnectorNodePartitioningSet(),\n                         new ValidateAggregationsWithDefaultValues(forceSingleNode),\n                         new ValidateStreamingAggregations(),\n                         new DynamicFiltersChecker(),"
  },
  {
    "sha": "23e3e482507867f24f91f50b8f0b6b51f9a2d1d2",
    "filename": "core/trino-main/src/main/java/io/trino/sql/planner/sanity/VerifyUseConnectorNodePartitioningSet.java",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/sanity/VerifyUseConnectorNodePartitioningSet.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/sql/planner/sanity/VerifyUseConnectorNodePartitioningSet.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/sql/planner/sanity/VerifyUseConnectorNodePartitioningSet.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.sanity;\n+\n+import io.trino.Session;\n+import io.trino.execution.warnings.WarningCollector;\n+import io.trino.metadata.Metadata;\n+import io.trino.spi.type.TypeOperators;\n+import io.trino.sql.planner.TypeAnalyzer;\n+import io.trino.sql.planner.TypeProvider;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.TableScanNode;\n+\n+import static io.trino.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n+import static java.lang.String.format;\n+\n+public final class VerifyUseConnectorNodePartitioningSet\n+        implements PlanSanityChecker.Checker\n+{\n+    @Override\n+    public void validate(PlanNode plan,\n+            Session session,\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            TypeAnalyzer typeAnalyzer,\n+            TypeProvider types,\n+            WarningCollector warningCollector)\n+    {\n+        searchFrom(plan)\n+                .where(TableScanNode.class::isInstance)\n+                .<TableScanNode>findAll()\n+                .stream()\n+                .filter(scan -> scan.getUseConnectorNodePartitioning().isEmpty())\n+                .forEach(scan -> {\n+                    throw new IllegalStateException(format(\"TableScanNode (%s) doesn't have useConnectorNodePartitioning set\", scan));\n+                });\n+    }\n+}"
  },
  {
    "sha": "a1dec712ad5507df685206089871a0a0d627284e",
    "filename": "core/trino-main/src/main/java/io/trino/testing/LocalQueryRunner.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/testing/LocalQueryRunner.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/main/java/io/trino/testing/LocalQueryRunner.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/main/java/io/trino/testing/LocalQueryRunner.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -869,7 +869,8 @@ public Plan createPlan(Session session, @Language(\"SQL\") String sql, LogicalPlan\n                 estimatedExchangesCostCalculator,\n                 new CostComparator(featuresConfig),\n                 taskCountEstimator,\n-                new RuleStatsRecorder()).get();\n+                new RuleStatsRecorder(),\n+                nodePartitioningManager).get();\n     }\n \n     public Plan createPlan(Session session, @Language(\"SQL\") String sql, List<PlanOptimizer> optimizers, WarningCollector warningCollector)"
  },
  {
    "sha": "7aa59d1696feb4cee8c4dab256c344d0f88ebaaf",
    "filename": "core/trino-main/src/test/java/io/trino/connector/MockConnector.java",
    "status": "modified",
    "additions": 4,
    "deletions": 1,
    "changes": 5,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/connector/MockConnector.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/connector/MockConnector.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/connector/MockConnector.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -79,6 +79,7 @@\n     private final MockConnectorFactory.ApplyTableScanRedirect applyTableScanRedirect;\n     private final BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout;\n     private final BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> getNewTableLayout;\n+    private final BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties;\n     private final Supplier<Iterable<EventListener>> eventListeners;\n     private final MockConnectorFactory.ListRoleGrants roleGrants;\n     private final MockConnectorAccessControl accessControl;\n@@ -97,6 +98,7 @@\n             MockConnectorFactory.ApplyTableScanRedirect applyTableScanRedirect,\n             BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,\n             BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> getNewTableLayout,\n+            BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties,\n             Supplier<Iterable<EventListener>> eventListeners,\n             MockConnectorFactory.ListRoleGrants roleGrants,\n             MockConnectorAccessControl accessControl)\n@@ -114,6 +116,7 @@\n         this.applyTableScanRedirect = requireNonNull(applyTableScanRedirect, \"applyTableScanRedirection is null\");\n         this.getInsertLayout = requireNonNull(getInsertLayout, \"getInsertLayout is null\");\n         this.getNewTableLayout = requireNonNull(getNewTableLayout, \"getNewTableLayout is null\");\n+        this.getTableProperties = requireNonNull(getTableProperties, \"getTableProperties is null\");\n         this.eventListeners = requireNonNull(eventListeners, \"eventListeners is null\");\n         this.roleGrants = requireNonNull(roleGrants, \"roleGrants is null\");\n         this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n@@ -317,7 +320,7 @@ public boolean usesLegacyTableLayouts()\n         @Override\n         public ConnectorTableProperties getTableProperties(ConnectorSession session, ConnectorTableHandle table)\n         {\n-            return new ConnectorTableProperties();\n+            return getTableProperties.apply(session, table);\n         }\n \n         @Override"
  },
  {
    "sha": "13cce62efb499bea6bbce1324a1360e2e34d9451",
    "filename": "core/trino-main/src/test/java/io/trino/connector/MockConnectorFactory.java",
    "status": "modified",
    "additions": 20,
    "deletions": 2,
    "changes": 22,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/connector/MockConnectorFactory.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/connector/MockConnectorFactory.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/connector/MockConnectorFactory.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -28,6 +28,7 @@\n import io.trino.spi.connector.ConnectorSession;\n import io.trino.spi.connector.ConnectorTableHandle;\n import io.trino.spi.connector.ConnectorTableMetadata;\n+import io.trino.spi.connector.ConnectorTableProperties;\n import io.trino.spi.connector.ConnectorViewDefinition;\n import io.trino.spi.connector.Constraint;\n import io.trino.spi.connector.ConstraintApplicationResult;\n@@ -74,6 +75,7 @@\n     private final ApplyTableScanRedirect applyTableScanRedirect;\n     private final BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout;\n     private final BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> getNewTableLayout;\n+    private final BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties;\n     private final Supplier<Iterable<EventListener>> eventListeners;\n     private final ListRoleGrants roleGrants;\n     private final MockConnectorAccessControl accessControl;\n@@ -92,6 +94,7 @@ private MockConnectorFactory(\n             ApplyTableScanRedirect applyTableScanRedirect,\n             BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,\n             BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> getNewTableLayout,\n+            BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties,\n             Supplier<Iterable<EventListener>> eventListeners,\n             ListRoleGrants roleGrants,\n             MockConnectorAccessControl accessControl)\n@@ -109,6 +112,7 @@ private MockConnectorFactory(\n         this.applyTableScanRedirect = requireNonNull(applyTableScanRedirect, \"applyTableScanRedirection is null\");\n         this.getInsertLayout = requireNonNull(getInsertLayout, \"getInsertLayout is null\");\n         this.getNewTableLayout = requireNonNull(getNewTableLayout, \"getNewTableLayout is null\");\n+        this.getTableProperties = requireNonNull(getTableProperties, \"getTableProperties is null\");\n         this.eventListeners = requireNonNull(eventListeners, \"eventListeners is null\");\n         this.roleGrants = requireNonNull(roleGrants, \"roleGrants is null\");\n         this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n@@ -143,6 +147,7 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n                 applyTableScanRedirect,\n                 getInsertLayout,\n                 getNewTableLayout,\n+                getTableProperties,\n                 eventListeners,\n                 roleGrants,\n                 accessControl);\n@@ -228,6 +233,7 @@ public static Builder builder()\n         private ApplyJoin applyJoin = (session, joinType, left, right, joinConditions, leftAssignments, rightAssignments) -> Optional.empty();\n         private BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout = defaultGetInsertLayout();\n         private BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> getNewTableLayout = defaultGetNewTableLayout();\n+        private BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties = defaultGetTableProperties();\n         private Supplier<Iterable<EventListener>> eventListeners = ImmutableList::of;\n         private ListRoleGrants roleGrants = defaultRoleAuthorizations();\n         private ApplyTopN applyTopN = (session, handle, topNCount, sortItems, assignments) -> Optional.empty();\n@@ -320,6 +326,12 @@ public Builder withGetNewTableLayout(BiFunction<ConnectorSession, ConnectorTable\n             return this;\n         }\n \n+        public Builder withGetTableProperties(BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> getTableProperties)\n+        {\n+            this.getTableProperties = requireNonNull(getTableProperties, \"getTableProperties is null\");\n+            return this;\n+        }\n+\n         public Builder withEventListener(EventListener listener)\n         {\n             requireNonNull(listener, \"listener is null\");\n@@ -364,6 +376,7 @@ public MockConnectorFactory build()\n                     applyTableScanRedirect,\n                     getInsertLayout,\n                     getNewTableLayout,\n+                    getTableProperties,\n                     eventListeners,\n                     roleGrants,\n                     new MockConnectorAccessControl(schemaGrants, tableGrants));\n@@ -396,12 +409,17 @@ public static ListRoleGrants defaultRoleAuthorizations()\n \n         public static BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> defaultGetInsertLayout()\n         {\n-            return (session, tableHandle) -> Optional.empty();\n+            return (session, schemaTableName) -> Optional.empty();\n         }\n \n         public static BiFunction<ConnectorSession, ConnectorTableMetadata, Optional<ConnectorNewTableLayout>> defaultGetNewTableLayout()\n         {\n-            return (session, tableHandle) -> Optional.empty();\n+            return (session, tableMetadata) -> Optional.empty();\n+        }\n+\n+        public static BiFunction<ConnectorSession, ConnectorTableHandle, ConnectorTableProperties> defaultGetTableProperties()\n+        {\n+            return (session, tableHandle) -> new ConnectorTableProperties();\n         }\n \n         public static Function<SchemaTableName, List<ColumnMetadata>> defaultGetColumns()"
  },
  {
    "sha": "f365a7f6af71a82d76ef3d4ea63823cb16df6c78",
    "filename": "core/trino-main/src/test/java/io/trino/cost/TestCostCalculator.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/cost/TestCostCalculator.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/cost/TestCostCalculator.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/cost/TestCostCalculator.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -797,7 +797,8 @@ private TableScanNode tableScan(String id, String... symbols)\n                 symbolsList,\n                 assignments.build(),\n                 TupleDomain.all(),\n-                false);\n+                false,\n+                Optional.of(false));\n     }\n \n     private PlanNode project(String id, PlanNode source, String symbol, Expression expression)"
  },
  {
    "sha": "61d3073affb4b0060a183a1053e6e33d808100b5",
    "filename": "core/trino-main/src/test/java/io/trino/execution/MockRemoteTaskFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/MockRemoteTaskFactory.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/MockRemoteTaskFactory.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/execution/MockRemoteTaskFactory.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -112,7 +112,8 @@ public MockRemoteTask createTableScanTask(TaskId taskId, InternalNode newNode, L\n                         TEST_TABLE_HANDLE,\n                         ImmutableList.of(symbol),\n                         ImmutableMap.of(symbol, new TestingColumnHandle(\"column\")),\n-                        false),\n+                        false,\n+                        Optional.empty()),\n                 ImmutableMap.of(symbol, VARCHAR),\n                 SOURCE_DISTRIBUTION,\n                 ImmutableList.of(sourceId),"
  },
  {
    "sha": "bb605f995b51096453e2c8c46ea561f7cda19029",
    "filename": "core/trino-main/src/test/java/io/trino/execution/TaskTestUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/TaskTestUtils.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/TaskTestUtils.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/execution/TaskTestUtils.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -92,7 +92,8 @@ private TaskTestUtils() {}\n                     TEST_TABLE_HANDLE,\n                     ImmutableList.of(SYMBOL),\n                     ImmutableMap.of(SYMBOL, new TestingColumnHandle(\"column\", 0, BIGINT)),\n-                    false),\n+                    false,\n+                    Optional.empty()),\n             ImmutableMap.of(SYMBOL, VARCHAR),\n             SOURCE_DISTRIBUTION,\n             ImmutableList.of(TABLE_SCAN_NODE_ID),"
  },
  {
    "sha": "6e08489b8f64ed9c44ac11a29eeed5a18f4ba09c",
    "filename": "core/trino-main/src/test/java/io/trino/execution/TestPlannerWarnings.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/trinodb/trino/blob/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/TestPlannerWarnings.java",
    "raw_url": "https://github.com/trinodb/trino/raw/3a99eeea8387c28021faf0e7d901004f21c7a5cd/core/trino-main/src/test/java/io/trino/execution/TestPlannerWarnings.java",
    "contents_url": "https://api.github.com/repos/trinodb/trino/contents/core/trino-main/src/test/java/io/trino/execution/TestPlannerWarnings.java?ref=3a99eeea8387c28021faf0e7d901004f21c7a5cd",
    "patch": "@@ -46,8 +46,7 @@\n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableSet.toImmutableSet;\n-import static io.trino.sql.planner.LogicalPlanner.Stage.CREATED;\n-import static io.trino.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.trino.sql.planner.LogicalPlanner.Stage.OPTIMIZED;\n import static io.trino.sql.planner.plan.Patterns.project;\n import static io.trino.testing.TestingSession.testSessionBuilder;\n import static java.util.Objects.requireNonNull;\n@@ -101,7 +100,7 @@ public static void assertPlannerWarnings(LocalQueryRunner queryRunner, @Language\n                     createPlan(queryRunner, transactionSession, sql, warningCollector, rules.get());\n                 }\n                 else {\n-                    queryRunner.createPlan(transactionSession, sql, CREATED, false, warningCollector);\n+                    queryRunner.createPlan(transactionSession, sql, OPTIMIZED, false, warningCollector);\n                 }\n                 return null;\n             });\n@@ -128,7 +127,7 @@ private static Plan createPlan(LocalQueryRunner queryRunner, Session session, St\n                 queryRunner.getCostCalculator(),\n                 ImmutableSet.copyOf(rules));\n \n-        return queryRunner.createPlan(session, sql, ImmutableList.of(optimizer), OPTIMIZED_AND_VALIDATED, warningCollector);\n+        return queryRunner.createPlan(session, sql, ImmutableList.of(optimizer), OPTIMIZED, warningCollector);\n     }\n \n     public static List<TrinoWarning> createTestWarnings(int numberOfWarnings)"
  }
]
