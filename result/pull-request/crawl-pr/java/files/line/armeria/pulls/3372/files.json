[
  {
    "sha": "6862ff3a49a84d27f7559b5734cb0b8ce549190b",
    "filename": "core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClient.java",
    "status": "modified",
    "additions": 87,
    "deletions": 9,
    "changes": 96,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClient.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClient.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClient.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -23,7 +23,12 @@\n import java.util.Map;\n import java.util.function.Function;\n \n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Streams;\n \n import com.linecorp.armeria.client.ClientRequestContext;\n@@ -33,18 +38,21 @@\n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpRequest;\n import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n \n /**\n  * A {@link DecoratingClient} that requests and decodes HTTP encoding (e.g., gzip) that has been applied to the\n  * content of an {@link HttpResponse}.\n  */\n public final class DecodingClient extends SimpleDecoratingHttpClient {\n \n+    private static final Splitter ENCODING_SPLITTER = Splitter.on(',').trimResults();\n+\n     /**\n      * Creates a new {@link DecodingClient} decorator with the default encodings of 'gzip' and 'deflate'.\n      */\n     public static Function<? super HttpClient, DecodingClient> newDecorator() {\n-        return newDecorator(ImmutableList.of(StreamDecoderFactory.gzip(), StreamDecoderFactory.deflate()));\n+        return builder().newDecorator();\n     }\n \n     /**\n@@ -64,36 +72,106 @@\n         requireNonNull(decoderFactories, \"decoderFactories\");\n         final List<? extends StreamDecoderFactory>\n                 immutableDecoderFactories = ImmutableList.copyOf(decoderFactories);\n-        return client -> new DecodingClient(client, immutableDecoderFactories);\n+        return client -> new DecodingClient(client, immutableDecoderFactories, true, false);\n+    }\n+\n+    /**\n+     * Returns a new {@link DecodingClientBuilder}.\n+     */\n+    public static DecodingClientBuilder builder() {\n+        return new DecodingClientBuilder();\n     }\n \n     private final Map<String, StreamDecoderFactory> decoderFactories;\n     private final String acceptEncodingHeader;\n+    private final boolean autoFillAcceptEncoding;\n+    private final boolean strictContentEncoding;\n \n     /**\n      * Creates a new instance that decorates the specified {@link HttpClient} with the provided decoders.\n      */\n     DecodingClient(HttpClient delegate,\n-                   Iterable<? extends StreamDecoderFactory> decoderFactories) {\n+                   Iterable<? extends StreamDecoderFactory> decoderFactories,\n+                   boolean autoFillAcceptEncoding,\n+                   boolean strictContentEncoding) {\n         super(delegate);\n         this.decoderFactories = Streams.stream(decoderFactories)\n                                        .collect(toImmutableMap(StreamDecoderFactory::encodingHeaderValue,\n                                                                Function.identity()));\n         acceptEncodingHeader = String.join(\",\", this.decoderFactories.keySet());\n+        this.autoFillAcceptEncoding = autoFillAcceptEncoding;\n+        this.strictContentEncoding = strictContentEncoding;\n     }\n \n     @Override\n     public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) throws Exception {\n-        if (req.headers().contains(HttpHeaderNames.ACCEPT_ENCODING)) {\n-            // Client specified encoding, so we don't do anything automatically.\n+        Map<String, StreamDecoderFactory> decoderFactories = this.decoderFactories;\n+\n+        if (autoFillAcceptEncoding) {\n+            if (req.headers().contains(HttpHeaderNames.ACCEPT_ENCODING)) {\n+                // Client specified encoding, so we don't do anything automatically.\n+                return unwrap().execute(ctx, req);\n+            }\n+\n+            req = updateAcceptEncoding(ctx, req, acceptEncodingHeader);\n+            return executeAndDecodeResponse(ctx, req, decoderFactories);\n+        }\n+\n+        // Respect user-defined accept-encoding.\n+        final String acceptEncoding = req.headers().get(HttpHeaderNames.ACCEPT_ENCODING);\n+        if (Strings.isNullOrEmpty(acceptEncoding)) {\n+            // No accept-encoding is specified.\n             return unwrap().execute(ctx, req);\n         }\n \n-        req = req.withHeaders(req.headers().toBuilder()\n-                                 .set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncodingHeader));\n-        ctx.updateRequest(req);\n+        final List<String> encodings = ImmutableList.copyOf(ENCODING_SPLITTER.split(acceptEncoding));\n+        final ImmutableMap.Builder<String, StreamDecoderFactory> factoryBuilder =\n+                ImmutableMap.builderWithExpectedSize(encodings.size());\n+\n+        for (String encoding : encodings) {\n+            final StreamDecoderFactory factory = decoderFactories.get(encoding);\n+            if (factory != null) {\n+                factoryBuilder.put(factory.encodingHeaderValue(), factory);\n+            }\n+        }\n \n+        final Map<String, StreamDecoderFactory> availableFactories = factoryBuilder.build();\n+        if (availableFactories.isEmpty()) {\n+            // Unsupported encoding.\n+            req = updateAcceptEncoding(ctx, req, null);\n+            return unwrap().execute(ctx, req);\n+        }\n+\n+        if (encodings.size() != availableFactories.size()) {\n+            // Use only supported encodings.\n+            final String acceptEncodingHeader = String.join(\",\", availableFactories.keySet());\n+            req = updateAcceptEncoding(ctx, req, acceptEncodingHeader);\n+        }\n+        decoderFactories = availableFactories;\n+\n+        return executeAndDecodeResponse(ctx, req, decoderFactories);\n+    }\n+\n+    private HttpDecodedResponse executeAndDecodeResponse(\n+            ClientRequestContext ctx, HttpRequest req,\n+            Map<String, StreamDecoderFactory> decoderFactories) throws Exception {\n         final HttpResponse res = unwrap().execute(ctx, req);\n-        return new HttpDecodedResponse(res, decoderFactories, ctx.alloc());\n+        return new HttpDecodedResponse(res, decoderFactories, ctx.alloc(), strictContentEncoding);\n+    }\n+\n+    private static HttpRequest updateAcceptEncoding(ClientRequestContext ctx, HttpRequest req,\n+                                                    @Nullable String acceptEncoding) {\n+        final RequestHeadersBuilder headersBuilder;\n+        if (acceptEncoding == null) {\n+            headersBuilder = req.headers().toBuilder()\n+                                .removeAndThen(HttpHeaderNames.ACCEPT_ENCODING);\n+        } else {\n+            headersBuilder = req.headers().toBuilder()\n+                                .set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n+        }\n+\n+        final HttpRequest updated = req.withHeaders(headersBuilder);\n+        ctx.updateRequest(updated);\n+        return updated;\n     }\n }"
  },
  {
    "sha": "a8d3a0a6e8376d92d74bdc13ed47cbed811ac450",
    "filename": "core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClientBuilder.java",
    "status": "added",
    "additions": 105,
    "deletions": 0,
    "changes": 105,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClientBuilder.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClientBuilder.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/main/java/com/linecorp/armeria/client/encoding/DecodingClientBuilder.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2021 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.encoding;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.encoding.StreamDecoderFactory;\n+\n+/**\n+ * A builder class for {@link DecodingClient}.\n+ */\n+public final class DecodingClientBuilder {\n+\n+    private List<StreamDecoderFactory> decoderFactories = ImmutableList.of(StreamDecoderFactory.gzip(),\n+                                                                           StreamDecoderFactory.deflate());\n+\n+    private boolean autoFillAcceptEncoding = true;\n+    private boolean strictContentEncoding;\n+\n+    DecodingClientBuilder() {}\n+\n+    /**\n+     * Sets the specified {@link StreamDecoderFactory}s.\n+     * If not specified, {@link StreamDecoderFactory#gzip()} and {@link StreamDecoderFactory#deflate()} are\n+     * used by default.\n+     */\n+    public DecodingClientBuilder decoderFactories(StreamDecoderFactory... decoderFactories) {\n+        requireNonNull(decoderFactories, \"decoderFactories\");\n+        return decoderFactories(ImmutableList.copyOf(decoderFactories));\n+    }\n+\n+    /**\n+     * Sets the specified {@link StreamDecoderFactory}s.\n+     * If not specified, {@link StreamDecoderFactory#gzip()} and {@link StreamDecoderFactory#deflate()} are\n+     * used by default.\n+     */\n+    public DecodingClientBuilder decoderFactories(Iterable<? extends StreamDecoderFactory> decoderFactories) {\n+        requireNonNull(decoderFactories, \"decoderFactories\");\n+        this.decoderFactories = ImmutableList.copyOf(decoderFactories);\n+        return this;\n+    }\n+\n+    /**\n+     * Automatically fills possible {@link HttpHeaderNames#ACCEPT_ENCODING}s specified in\n+     * {@link #decoderFactories(StreamDecoderFactory...)} if an {@link HttpHeaderNames#ACCEPT_ENCODING} is not\n+     * set in {@link RequestHeaders}.\n+     * This option is enabled by default.\n+     */\n+    public DecodingClientBuilder autoFillAcceptEncoding(boolean autoFillAcceptEncoding) {\n+        this.autoFillAcceptEncoding = autoFillAcceptEncoding;\n+        return this;\n+    }\n+\n+    /**\n+     * Strictly validates {@link HttpHeaderNames#CONTENT_ENCODING}. If an unsupported\n+     * {@link HttpHeaderNames#CONTENT_ENCODING} is received, the {@link HttpResponse} will be failed with\n+     * {@link UnsupportedEncodingException}.\n+     *\n+     * <p>This option is disabled by default. That means if an unsupported\n+     * {@link HttpHeaderNames#CONTENT_ENCODING} is received, the decoding for the content will be skipped.\n+     */\n+    public DecodingClientBuilder strictContentEncoding(boolean strict) {\n+        strictContentEncoding = strict;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns a newly-created decorator that decorates an {@link HttpClient} with a new\n+     * {@link DecodingClient} based on the properties of this builder.\n+     */\n+    public Function<? super HttpClient, DecodingClient> newDecorator() {\n+        return this::build;\n+    }\n+\n+    /**\n+     * Returns a newly-created {@link DecodingClient} based on the properties of this builder.\n+     */\n+    public DecodingClient build(HttpClient delegate) {\n+        return new DecodingClient(delegate, decoderFactories, autoFillAcceptEncoding, strictContentEncoding);\n+    }\n+}"
  },
  {
    "sha": "bd3e81b72a6540119dabb64630053b12ef5341c9",
    "filename": "core/src/main/java/com/linecorp/armeria/client/encoding/HttpDecodedResponse.java",
    "status": "modified",
    "additions": 16,
    "deletions": 3,
    "changes": 19,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/HttpDecodedResponse.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/client/encoding/HttpDecodedResponse.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/main/java/com/linecorp/armeria/client/encoding/HttpDecodedResponse.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.client.encoding;\n \n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n \n import javax.annotation.Nullable;\n@@ -30,6 +31,7 @@\n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.util.Exceptions;\n import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.buffer.ByteBufAllocator;\n@@ -39,18 +41,22 @@\n  */\n final class HttpDecodedResponse extends FilteredHttpResponse {\n \n+    private final HttpResponse delegate;\n     private final Map<String, StreamDecoderFactory> availableDecoders;\n     private final ByteBufAllocator alloc;\n+    private final boolean strictContentEncoding;\n \n     @Nullable\n     private StreamDecoder responseDecoder;\n     private boolean headersReceived;\n \n     HttpDecodedResponse(HttpResponse delegate, Map<String, StreamDecoderFactory> availableDecoders,\n-                        ByteBufAllocator alloc) {\n+                        ByteBufAllocator alloc, boolean strictContentEncoding) {\n         super(delegate, true);\n+        this.delegate = delegate;\n         this.availableDecoders = availableDecoders;\n         this.alloc = alloc;\n+        this.strictContentEncoding = strictContentEncoding;\n     }\n \n     @Override\n@@ -80,10 +86,17 @@ protected HttpObject filter(HttpObject obj) {\n             if (contentEncoding != null) {\n                 final StreamDecoderFactory decoderFactory =\n                         availableDecoders.get(Ascii.toLowerCase(contentEncoding));\n-                // If the server returned an encoding we don't support (shouldn't happen since we set\n-                // Accept-Encoding), decoding will be skipped which is ok.\n                 if (decoderFactory != null) {\n                     responseDecoder = decoderFactory.newDecoder(alloc);\n+                } else {\n+                    // The server returned an encoding we don't support.\n+                    // This shouldn't happen normally since we set Accept-Encoding.\n+                    if (strictContentEncoding) {\n+                        Exceptions.throwUnsafely(\n+                                new UnsupportedEncodingException(\"encoding: \" + contentEncoding));\n+                    } else {\n+                        // Decoding is skipped.\n+                    }\n                 }\n             }\n "
  },
  {
    "sha": "7e4017c21d524752bde90bfd95fe78b6d8461bdb",
    "filename": "core/src/main/java/com/linecorp/armeria/common/stream/FilteredStreamMessage.java",
    "status": "modified",
    "additions": 23,
    "deletions": 2,
    "changes": 25,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/common/stream/FilteredStreamMessage.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/java/com/linecorp/armeria/common/stream/FilteredStreamMessage.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/main/java/com/linecorp/armeria/common/stream/FilteredStreamMessage.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -176,20 +176,41 @@ public final void abort(Throwable cause) {\n         private final Subscriber<? super U> delegate;\n         private final boolean subscribedWithPooledObjects;\n \n+        @Nullable\n+        private Subscription upstream;\n+\n         FilteringSubscriber(Subscriber<? super U> delegate, boolean subscribedWithPooledObjects) {\n             this.delegate = requireNonNull(delegate, \"delegate\");\n             this.subscribedWithPooledObjects = subscribedWithPooledObjects;\n         }\n \n         @Override\n         public void onSubscribe(Subscription s) {\n-            beforeSubscribe(delegate, s);\n+            upstream = s;\n+            try {\n+                beforeSubscribe(delegate, s);\n+            } catch (Throwable ex) {\n+                s.cancel();\n+                logger.warn(\"Unexpected exception from {}#beforeSubscribe()\",\n+                            FilteredStreamMessage.this.getClass().getName(), ex);\n+                return;\n+            }\n+\n             delegate.onSubscribe(s);\n         }\n \n         @Override\n         public void onNext(T o) {\n-            U filtered = filter(o);\n+            U filtered;\n+            try {\n+                filtered = filter(o);\n+            } catch (Throwable ex) {\n+                StreamMessageUtil.closeOrAbort(o);\n+                upstream.cancel();\n+                onError(ex);\n+                return;\n+            }\n+\n             if (!subscribedWithPooledObjects) {\n                 filtered = PooledObjects.copyAndClose(filtered);\n             }"
  },
  {
    "sha": "de81570b462fc2a5448a1e642b1532b224fca113",
    "filename": "core/src/main/resources/com/linecorp/armeria/public_suffixes.txt",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/resources/com/linecorp/armeria/public_suffixes.txt",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/main/resources/com/linecorp/armeria/public_suffixes.txt",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/main/resources/com/linecorp/armeria/public_suffixes.txt?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -48,6 +48,7 @@\n *.kunden.ortsinfo.at\n *.landing.myjino.ru\n *.lcl.dev\n+*.lclstage.dev\n *.linodeobjects.com\n *.magentosite.cloud\n *.mm\n@@ -77,6 +78,7 @@\n *.spectrum.myjino.ru\n *.statics.cloud\n *.stg.dev\n+*.stgstage.dev\n *.stolos.io\n *.svc.firenet.ch\n *.sys.qcx.io\n@@ -1381,6 +1383,7 @@ cloudns.org\n cloudns.pro\n cloudns.pw\n cloudns.us\n+cloudsite.builders\n cloudycluster.net\n club\n club.aero\n@@ -2514,6 +2517,8 @@ fr-1.paas.massivegrid.net\n fr.eu.org\n fr.it\n fra1-de.cloudjiffy.net\n+framer.app\n+framercanvas.com\n frana.no\n francaise.museum\n frankfurt.museum\n@@ -7099,6 +7104,7 @@ servep2p.com\n servepics.com\n servequake.com\n servesarcasm.com\n+service.gov.scot\n service.gov.uk\n service.one\n services\n@@ -7399,6 +7405,7 @@ square7.net\n sr\n sr.gov.pl\n sr.it\n+srht.site\n srl\n srv.br\n ss"
  },
  {
    "sha": "fa5d23fa33c2c4d90eccefc344673a69901cb1bf",
    "filename": "core/src/test/java/com/linecorp/armeria/client/encoding/DecodingClientTest.java",
    "status": "modified",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/test/java/com/linecorp/armeria/client/encoding/DecodingClientTest.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/test/java/com/linecorp/armeria/client/encoding/DecodingClientTest.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/test/java/com/linecorp/armeria/client/encoding/DecodingClientTest.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -16,11 +16,19 @@\n \n package com.linecorp.armeria.client.encoding;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n \n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.RegisterExtension;\n \n+import com.linecorp.armeria.client.HttpClient;\n import com.linecorp.armeria.client.WebClient;\n import com.linecorp.armeria.common.AggregatedHttpResponse;\n import com.linecorp.armeria.common.HttpData;\n@@ -53,6 +61,17 @@ protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req)\n                             HttpData.ofUtf8(\"more content to compress\"));\n                 }\n             }.decorate(EncodingService.newDecorator()));\n+\n+            sb.service(\"/malformed-encoding\", (ctx, req) -> {\n+                return HttpResponse.of(\n+                        ResponseHeaders.of(HttpStatus.OK, HttpHeaderNames.CONTENT_ENCODING, \"unsupported\"),\n+                        HttpData.ofUtf8(\"unsupported content encoding\"));\n+            });\n+\n+            sb.service(\"/echo-encoding\", (ctx, req) -> {\n+                return HttpResponse\n+                        .of(firstNonNull(req.headers().get(HttpHeaderNames.ACCEPT_ENCODING), \"none\"));\n+            });\n         }\n     };\n \n@@ -108,4 +127,69 @@ void httpDeflateDecodingTestWithOldDecoder() throws Exception {\n         assertThat(response.headers().get(HttpHeaderNames.CONTENT_ENCODING)).isEqualTo(\"deflate\");\n         assertThat(response.contentUtf8()).isEqualTo(\"some content to compress more content to compress\");\n     }\n+\n+    @Test\n+    void disableAutoFillAcceptEncoding() throws Exception {\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .decorator(DecodingClient.builder()\n+                                                                   .autoFillAcceptEncoding(false)\n+                                                                   .newDecorator())\n+                                          .build();\n+\n+        // Accept-encoding is unspecified.\n+        AggregatedHttpResponse response =\n+                client.execute(RequestHeaders.of(HttpMethod.GET, \"/encoding-test\")).aggregate().get();\n+        assertThat(response.headers().get(HttpHeaderNames.CONTENT_ENCODING)).isNull();\n+\n+        // 'gzip' is specified.\n+        final RequestHeaders header =\n+                RequestHeaders.of(HttpMethod.GET, \"/encoding-test\", HttpHeaderNames.ACCEPT_ENCODING, \"gzip\");\n+        response = client.execute(header).aggregate().get();\n+        assertThat(response.headers().get(HttpHeaderNames.CONTENT_ENCODING)).isEqualTo(\"gzip\");\n+        assertThat(response.contentUtf8()).isEqualTo(\"some content to compress more content to compress\");\n+    }\n+\n+    @Test\n+    void strictContentEncoding() {\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .decorator(DecodingClient.builder()\n+                                                                   .strictContentEncoding(true)\n+                                                                   .newDecorator())\n+                                          .build();\n+\n+        // Accept-encoding is unspecified.\n+        final CompletableFuture<AggregatedHttpResponse> response =\n+                client.execute(RequestHeaders.of(HttpMethod.GET, \"/malformed-encoding\")).aggregate();\n+\n+        assertThatThrownBy(response::join)\n+                .isInstanceOf(CompletionException.class)\n+                .getCause()\n+                .isInstanceOf(UnsupportedEncodingException.class)\n+                .hasMessage(\"encoding: unsupported\");\n+    }\n+\n+    @Test\n+    void shouldFilterOutUnsupportedAcceptEncoding() {\n+        final Function<? super HttpClient, DecodingClient> decodingClient =\n+                DecodingClient.builder()\n+                              .decoderFactories(\n+                                      com.linecorp.armeria.common.encoding.StreamDecoderFactory.gzip())\n+                              .autoFillAcceptEncoding(false)\n+                              .newDecorator();\n+\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .decorator(decodingClient)\n+                                          .build();\n+        // 'br' is specified.\n+        RequestHeaders header = RequestHeaders.of(HttpMethod.GET, \"/echo-encoding\",\n+                                                  HttpHeaderNames.ACCEPT_ENCODING, \"br\");\n+        AggregatedHttpResponse response = client.execute(header).aggregate().join();\n+        assertThat(response.contentUtf8()).isEqualTo(\"none\");\n+\n+        // 'gzip,br' is specified.\n+        header = RequestHeaders.of(HttpMethod.GET, \"/echo-encoding\",\n+                                   HttpHeaderNames.ACCEPT_ENCODING, \"gzip,br\");\n+        response = client.execute(header).aggregate().join();\n+        assertThat(response.contentUtf8()).isEqualTo(\"gzip\");\n+    }\n }"
  },
  {
    "sha": "c034254a0bc860043cd7bcd04fbbb2327c4dc441",
    "filename": "core/src/test/java/com/linecorp/armeria/client/encoding/HttpDecodedResponseTest.java",
    "status": "modified",
    "additions": 16,
    "deletions": 8,
    "changes": 24,
    "blob_url": "https://github.com/line/armeria/blob/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/test/java/com/linecorp/armeria/client/encoding/HttpDecodedResponseTest.java",
    "raw_url": "https://github.com/line/armeria/raw/008f03956fa59f0cd8bfc1d609ece06c6c77bff6/core/src/test/java/com/linecorp/armeria/client/encoding/HttpDecodedResponseTest.java",
    "contents_url": "https://api.github.com/repos/line/armeria/contents/core/src/test/java/com/linecorp/armeria/client/encoding/HttpDecodedResponseTest.java?ref=008f03956fa59f0cd8bfc1d609ece06c6c77bff6",
    "patch": "@@ -70,7 +70,8 @@\n     void unpooledPayload_unpooledDrain() {\n         final HttpData payload = HttpData.wrap(PAYLOAD);\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, false);\n \n         assertThat(decodedPayload.isPooled()).isFalse();\n@@ -81,7 +82,8 @@ void pooledPayload_unpooledDrain() {\n         final ByteBuf payloadBuf = ByteBufAllocator.DEFAULT.buffer().writeBytes(PAYLOAD);\n         final HttpData payload = HttpData.wrap(payloadBuf).withEndOfStream();\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, false);\n \n         assertThat(decodedPayload.isPooled()).isFalse();\n@@ -92,7 +94,8 @@ void pooledPayload_unpooledDrain() {\n     void unpooledPayload_pooledDrain() {\n         final HttpData payload = HttpData.wrap(PAYLOAD);\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded = new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT,\n+                                                             false);\n         final HttpData decodedPayload = responseData(decoded, true);\n \n         assertThat(decodedPayload.isPooled()).isTrue();\n@@ -105,7 +108,8 @@ void pooledPayload_pooledDrain() {\n         final ByteBuf payloadBuf = ByteBufAllocator.DEFAULT.buffer().writeBytes(PAYLOAD);\n         final HttpData payload = HttpData.wrap(payloadBuf).withEndOfStream();\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, true);\n         final ByteBuf decodedPayloadBuf = decodedPayload.byteBuf();\n \n@@ -119,7 +123,8 @@ void pooledPayload_pooledDrain() {\n     void unpooledPayload_unpooledDrain_withOldDecoder() {\n         final HttpData payload = HttpData.wrap(PAYLOAD);\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, false);\n \n         assertThat(decodedPayload.isPooled()).isFalse();\n@@ -130,7 +135,8 @@ void pooledPayload_unpooledDrain_withOldDecoder() {\n         final ByteBuf payloadBuf = ByteBufAllocator.DEFAULT.buffer().writeBytes(PAYLOAD);\n         final HttpData payload = HttpData.wrap(payloadBuf).withEndOfStream();\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, false);\n \n         assertThat(decodedPayload.isPooled()).isFalse();\n@@ -141,7 +147,8 @@ void pooledPayload_unpooledDrain_withOldDecoder() {\n     void unpooledPayload_pooledDrain_withOldDecoder() {\n         final HttpData payload = HttpData.wrap(PAYLOAD);\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, true);\n \n         assertThat(decodedPayload.isPooled()).isTrue();\n@@ -154,7 +161,8 @@ void pooledPayload_pooledDrain_withOldDecoder() {\n         final ByteBuf payloadBuf = ByteBufAllocator.DEFAULT.buffer().writeBytes(PAYLOAD);\n         final HttpData payload = HttpData.wrap(payloadBuf).withEndOfStream();\n         final HttpResponse delegate = HttpResponse.of(RESPONSE_HEADERS, payload);\n-        final HttpResponse decoded = new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT);\n+        final HttpResponse decoded =\n+                new HttpDecodedResponse(delegate, OLD_DECODER, ByteBufAllocator.DEFAULT, false);\n         final HttpData decodedPayload = responseData(decoded, true);\n         final ByteBuf decodedPayloadBuf = decodedPayload.byteBuf();\n "
  }
]
