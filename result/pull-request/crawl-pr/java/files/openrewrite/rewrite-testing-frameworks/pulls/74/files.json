[
  {
    "sha": "0a33d9599c2d6adc4e1fcd741d67740a594503da",
    "filename": "src/main/java/org/openrewrite/java/testing/junit5/UpdateTestWatcher.java",
    "status": "added",
    "additions": 179,
    "deletions": 0,
    "changes": 179,
    "blob_url": "https://github.com/openrewrite/rewrite-testing-frameworks/blob/dcadcf4f1d99c670815e3fdeee903c62b4d35cad/src/main/java/org/openrewrite/java/testing/junit5/UpdateTestWatcher.java",
    "raw_url": "https://github.com/openrewrite/rewrite-testing-frameworks/raw/dcadcf4f1d99c670815e3fdeee903c62b4d35cad/src/main/java/org/openrewrite/java/testing/junit5/UpdateTestWatcher.java",
    "contents_url": "https://api.github.com/repos/openrewrite/rewrite-testing-frameworks/contents/src/main/java/org/openrewrite/java/testing/junit5/UpdateTestWatcher.java?ref=dcadcf4f1d99c670815e3fdeee903c62b4d35cad",
    "patch": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.testing.junit5;\n+\n+import lombok.SneakyThrows;\n+import org.openrewrite.*;\n+import org.openrewrite.internal.ListUtils;\n+import org.openrewrite.java.JavaIsoVisitor;\n+import org.openrewrite.java.JavaParser;\n+import org.openrewrite.java.JavaTemplate;\n+import org.openrewrite.java.tree.J;\n+import org.openrewrite.java.tree.JavaType;\n+import org.openrewrite.java.tree.TypeUtils;\n+\n+import java.text.RuleBasedCollator;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+/**\n+ * Translates JUnit 4's org.junit.rules.TestWatcher into JUnit 5's org.junit.jupiter.api.extension.TestWatcher.\n+ * <p>\n+ * In JUnit 4, TestWatcher is an abstract class which is instantiated and its API methods overridden by the user.\n+ * For JUnit 5, TestWatcher has been moved to an interface designed to be implemented by an Extension classes and registered with the Test class.\n+ * <p>\n+ * Therefore, to migrate from JUnit 4 to JUnit 5, practically-speaking, this recipe follows these steps:\n+ * <ul>\n+ * <li>We replace direct instantiations of TestWatcher with a new class we generate which implements TestWatcher.</li>\n+ * <li>We map JUnit 4's org.junit.rules.TestWatcher API signature method bodies to JUnit 5's API rough equivalents.</li>\n+ * <li>We then register our newly-created TestWatcherExtension with the Test class using the ExtendWith annotation.</li>\n+ * </ul>\n+ * <p>\n+ * Direct examples can be seen in the unit tests.\n+ * Details on mapping the TestWatcher API signatures are provided further below.\n+ * <p>\n+ * JUnit 4's TestWatcher has the following API signatures which we account for (at the time of writing):\n+ * <PRE>\n+ * protected void failed(Throwable e, Description description)\n+ * protected void finished(Description description)\n+ * protected void skipped(AssumptionViolatedException e, Description description)\n+ * protected void starting(Description description)\n+ * protected void succeeded(Description description)\n+ * </PRE>\n+ * <p>\n+ * Whereas JUnit 5's TestWatcher interface has the following:\n+ * <PRE>\n+ * default void testDisabled(ExtensionContext context, Optional<String> reason)\n+ * default void testSuccessful(ExtensionContext context)\n+ * default void testAborted(ExtensionContext context, Throwable cause)\n+ * default void testFailed(ExtensionContext context, Throwable cause)\n+ * </PRE>\n+ * <p>\n+ * Notice how the JUnit 5 TestWatcher interface does not have the same set of \"lifecycle hooks\" which the JUnit 4 TestWatcher handled.\n+ * Therefore, we cannot do an exact one-to-one mapping.\n+ * <p>\n+ * Here are the JUnit 4 TestWatcher API methods mapped to their JUnit 5 interface API equivalents:\n+ * <PRE>\n+ * protected void failed(Throwable e, Description description) == default void testFailed(ExtensionContext context, Throwable cause)\n+ * protected void finished(Description description) == NO_DIRECT_MAPPING_IN_TESTWATCHER\n+ * protected void skipped(AssumptionViolatedException e, Description description) == default void testDisabled(ExtensionContext context, Optional<String> reason)\n+ * protected void starting(Description description) == NO_DIRECT_MAPPING_IN_TESTWATCHER\n+ * protected void succeeded(Description description) == default void testSuccessful(ExtensionContext context)\n+ * </PRE>\n+ * This recipe migrates the JUnit 4 TestWatcher signatures to JUnit 5 on a best-match basis.\n+ * If the JUnit 4 TestWatcher API methods which can be mapped to a JUnit 5 equivalent are used, we update them.\n+ * However, if a JUnit 4 API method is being used which does not have a direct JUnit 5 equivalent, we conditionally add another \"implements\"\n+ * for the corresponding JUnit 5 lifecycle hook to be used in the generated \"Extension\".\n+ * <p>\n+ * Instead, for JUnit 4 TestWatcher API methods which do not have JUnit 5 TestWatcher equivalents, we implement other lifecycle callbacks\n+ * from org.junit.jupiter.api.extension.BeforeTestExecutionCallback and org.junit.jupiter.api.extension.AfterTestExecutionCallback:\n+ * <PRE>\n+ * protected void starting(Description description) == public void beforeTestExecution(ExtensionContext context) in org.junit.jupiter.api.extension.BeforeTestExecutionCallback\n+ * protected void finished(Description description) == public void afterTestExecution(ExtensionContext context) in org.junit.jupiter.api.extension.AfterTestExecutionCallback\n+ * </PRE>\n+ */\n+@Incubating(since = \"7.0.0\")\n+public class UpdateTestWatcher extends Recipe {\n+\n+    @Override\n+    public String getDisplayName() {\n+        return \"Update TestWatcher from JUnit 4 to 5\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return \"update JUnit 4's TestWatcher to the JUnit 5 equivalent.\";\n+    }\n+\n+    @Override\n+    protected TreeVisitor<?, ExecutionContext> getVisitor() {\n+        return new UpdateTestWatcherVisitor();\n+    }\n+\n+    private static class UpdateTestWatcherVisitor extends JavaIsoVisitor<ExecutionContext> {\n+\n+        // all of this is todo\n+        private final JavaTemplate.Builder addPlaceholderTestWatcherExtension = template(\"@ExtendWith(PlaceholderTestWatcherExtension.class)\")\n+                .javaParser(JavaParser.fromJavaVersion()\n+                        .dependsOn(Arrays.asList(\n+                                Parser.Input.fromString(\"public class PlaceholderTestWatcherExtension {}\"),\n+                                Parser.Input.fromString(\"package org.junit.jupiter.api.extension.ExtendWith;\\n\" +\n+                                        \"public @interface ExtendWith {\\n\" +\n+                                        \"  Class[] value();\\n\" +\n+                                        \"}\")\n+                        ))\n+                        .build())\n+                .imports(\"org.junit.jupiter.api.extension.ExtendWith\");\n+\n+\n+        // @Override\n+        // public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {\n+        //     // we need to see whether or not this TestWatcher is really even needed anymore, b/c the lifecycle hooks might not be necessary todo\n+        //     doAfterVisit(new ChangeType(\"org.junit.rules.TestWatcher\", \"org.junit.jupiter.api.extension.TestWatcher\"));\n+        //     return super.visitCompilationUnit(cu, ctx);\n+        // }\n+\n+        @SneakyThrows\n+        @Override\n+        public J.ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {\n+            J.ClassDeclaration cd = super.visitClassDeclaration(classDecl, ctx);\n+\n+            cd = cd.withBody(cd.getBody().withStatements(ListUtils.map(cd.getBody().getStatements(), s -> {\n+                if (!(s instanceof J.VariableDeclarations)) {\n+                    return s;\n+                }\n+\n+                J.VariableDeclarations field = (J.VariableDeclarations) s;\n+                JavaType.Class fieldType = field.getTypeAsClass();\n+                if (TypeUtils.isOfClassType(fieldType, \"org.junit.rules.TestWatcher\")) { // todo\n+                    maybeRemoveImport(\"org.junit.rules.TestWatcher\");\n+                    // // storing as text for later though it may not be needed at all todo\n+                    // maybeRemoveImport(\"org.junit.Rule\");\n+                    // maybeRemoveImport(\"org.junit.runner.Description\");\n+                    // maybeRemoveImport(\"org.junit.AssumptionViolatedException\");\n+\n+                    String fieldName = field.getVariables().get(0).getSimpleName();\n+                    // etc todo\n+\n+                    return null;\n+                }\n+\n+                return s;\n+            })));\n+\n+            if (cd.getBody() != classDecl.getBody()) {\n+                cd = cd.withTemplate(addPlaceholderTestWatcherExtension.build(),\n+                        cd.getCoordinates().addAnnotation(Comparator.comparing(\n+                                J.Annotation::getSimpleName,\n+                                new RuleBasedCollator(\"< ExtendWith\")\n+                        ))\n+                );\n+\n+                maybeAddImport(\"org.junit.jupiter.api.extension.TestWatcher\");\n+                maybeAddImport(\"org.junit.jupiter.api.extension.ExtendWith\");\n+                // // storing as text for later though it may not be needed at all todo\n+                // maybeAddImport(\"org.junit.jupiter.api.extension.ExtensionContext\");\n+                // maybeAddImport(\"org.junit.jupiter.api.extension.BeforeTestExecutionCallback\");\n+                // maybeAddImport(\"org.junit.jupiter.api.extension.AfterTestExecutionCallback\");\n+            }\n+\n+            return cd;\n+        }\n+\n+    }\n+\n+}\n+"
  },
  {
    "sha": "0413c357d4fb23cf97f271f5479bbaa2c33228eb",
    "filename": "src/test/kotlin/org/openrewrite/java/testing/junit5/UpdateTestWatcherTest.kt",
    "status": "added",
    "additions": 390,
    "deletions": 0,
    "changes": 390,
    "blob_url": "https://github.com/openrewrite/rewrite-testing-frameworks/blob/dcadcf4f1d99c670815e3fdeee903c62b4d35cad/src/test/kotlin/org/openrewrite/java/testing/junit5/UpdateTestWatcherTest.kt",
    "raw_url": "https://github.com/openrewrite/rewrite-testing-frameworks/raw/dcadcf4f1d99c670815e3fdeee903c62b4d35cad/src/test/kotlin/org/openrewrite/java/testing/junit5/UpdateTestWatcherTest.kt",
    "contents_url": "https://api.github.com/repos/openrewrite/rewrite-testing-frameworks/contents/src/test/kotlin/org/openrewrite/java/testing/junit5/UpdateTestWatcherTest.kt?ref=dcadcf4f1d99c670815e3fdeee903c62b4d35cad",
    "patch": "@@ -0,0 +1,390 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.openrewrite.java.testing.junit5\n+\n+import org.junit.jupiter.api.Disabled\n+import org.junit.jupiter.api.Test\n+import org.openrewrite.Parser\n+import org.openrewrite.Recipe\n+import org.openrewrite.java.JavaParser\n+import org.openrewrite.java.JavaRecipeTest\n+import org.openrewrite.java.tree.J\n+\n+/**\n+ * WIP\n+ * @see ExpectedExceptionToAssertThrowsTest\n+ * @see RunnerToExtension\n+ */\n+class UpdateTestWatcherTest : JavaRecipeTest {\n+    override val parser: Parser<J.CompilationUnit> = JavaParser.fromJavaVersion()\n+        .classpath(\"junit\")\n+        .build()\n+\n+    override val recipe: Recipe\n+        get() = UpdateTestWatcher()\n+\n+    @Test\n+    @Disabled // wip\n+    fun assertJUnit4TestWatcherMethodsWithCorrespondingJUnit5TestWatcherMethodsUpdate() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.AssumptionViolatedException;\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import org.junit.runner.Description;\n+\n+            public class ExampleTest {\n+                @Rule\n+                public TestWatcher watchman = new TestWatcher() {\n+                    @Override\n+                    protected void failed(Throwable e, Description description) { \n+                        System.out.println(\"failed\"); \n+                    }\n+                    \n+                    @Override\n+                    protected void skipped(AssumptionViolatedException e, Description description) {\n+                        System.out.println(\"skipped\");\n+                    }\n+\n+                    @Override\n+                    protected void succeeded(Description description) {\n+                        System.out.println(\"succeeded\");\n+                    }\n+                };\n+\n+                public void test() {\n+                }\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.TestWatcher;\n+            import java.util.Optional;\n+\n+            @ExtendWith(WatchmanTestWatcherExtension.class)\n+            public class ExampleTest {\n+                public void test() {\n+                }\n+            }\n+\n+            private class WatchmanTestWatcherExtension implements TestWatcher {\n+                @Override\n+                public void testFailed(ExtensionContext extensionContext, Throwable throwable) {\n+                    System.out.println(\"failed\");\n+                }\n+                \n+                @Override\n+                public void testDisabled(ExtensionContext context, Optional<String> reason) {\n+                    System.out.println(\"skipped\");\n+                }\n+\n+                @Override\n+                public void testSuccessful(ExtensionContext extensionContext) {\n+                    System.out.println(\"succeeded\");\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+    @Test\n+    @Disabled\n+    fun assertJUnit4TestWatcherMethodsWithoutCorrespondingJUnit5TestWatcherMethodsUpdate() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import org.junit.runner.Description;\n+\n+            public class ExampleTest {\n+                @Rule\n+                public TestWatcher watchman = new TestWatcher() {\n+                    protected void starting(Description description) { \n+                        System.out.println(\"starting\");\n+                    }\n+                    \n+                    protected void finished(Description description) { \n+                        System.out.println(\"finished\");\n+                    }\n+                };\n+\n+                public void test() {\n+                }\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+            import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;\n+            import org.junit.jupiter.api.extension.AfterTestExecutionCallback;\n+\n+            @ExtendWith(WatchmanTestWatcherExtension.class)\n+            public class ExampleTest {\n+                public void test() {\n+                }\n+            }\n+\n+            private class WatchmanTestWatcherExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {\n+                @Override\n+                public void beforeTestExecution(ExtensionContext extensionContext) {\n+                    System.out.println(\"starting\");\n+                }\n+                \n+                @Override\n+                public void afterTestExecution(ExtensionContext context) {\n+                    System.out.println(\"finished\");\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+    @Test\n+    @Disabled\n+    fun assertJUnit4TestWatcherMethodsMixCorrespondingJUnit5TestWatcherMethodsUpdate() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import org.junit.runner.Description;\n+\n+            public class ExampleTest {\n+                @Rule\n+                public TestWatcher watchman = new TestWatcher() {\n+                    protected void starting(Description description) { \n+                        System.out.println(\"starting\");\n+                    }\n+                    \n+                    protected void finished(Description description) { \n+                        System.out.println(\"finished\");\n+                    }\n+                    \n+                    protected void failed(Throwable e, Description description) { \n+                        System.out.println(\"failed\"); \n+                    }\n+                };\n+\n+                public void test() {\n+                }\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.TestWatcher;\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+            import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;\n+            import org.junit.jupiter.api.extension.AfterTestExecutionCallback;\n+\n+            @ExtendWith(WatchmanTestWatcherExtension.class)\n+            public class ExampleTest {\n+                public void test() {\n+                }\n+            }\n+\n+            private class WatchmanTestWatcherExtension implements TestWatcher, BeforeTestExecutionCallback, AfterTestExecutionCallback {\n+                @Override\n+                public void beforeTestExecution() {\n+                    System.out.println(\"starting\");\n+                }\n+                \n+                @Override\n+                public void afterTestExecution() {\n+                    System.out.println(\"finished\");\n+                }\n+\n+                @Override\n+                public void testFailed(ExtensionContext extensionContext, Throwable throwable) {\n+                    System.out.println(\"failed\");\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+    @Test\n+    @Disabled // does this test imply this should be part of the inner class? can that ... work? // todo\n+    fun assertTestWatcherConversionHandlesPublicAbstractTestClass() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.Test;\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import lombok.extern.slf4j.Slf4j;\n+            import org.junit.runner.Description;\n+\n+            @Slf4j\n+            public abstract class ExampleTest {\n+                @Rule\n+                public TestRule watcher = new TestWatcher() {\n+                    protected void starting(Description description) { \n+                        log.info(\"=================================================\");\n+                        log.info(\"STARTING TEST: {}\" , description.getMethodName());\n+                        log.info(\"=================================================\");\n+                    }\n+                    \n+                    protected void succeeded(Description description) {\n+                        log.info(\"=================================================\");\n+                        log.info(\"SUCCEEDED TEST: {}\" , description.getMethodName());\n+                        log.info(\"=================================================\");\n+                    }\n+                    \n+                    protected void failed(Throwable e, Description description) {\n+                        log.info(\"=================================================\");\n+                        log.info(\"FAILED TEST: {}\" , description.getMethodName(), e);\n+                        log.info(\"=================================================\");\n+                    }\n+                };\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import lombok.extern.slf4j.Slf4j;\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.TestWatcher;\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+            \n+            @ExtendWith(WatcherTestWatcherExtension.class)\n+            public abstract class ExampleTest {\n+            }\n+            \n+            @Slf4j\n+            private class WatcherTestWatcherExtension implements TestWatcher, BeforeTestExecutionCallback {\n+                @Override\n+                public void beforeTestExecution(ExtensionContext extensionContext) {\n+                    log.info(\"=================================================\");\n+                    log.info(\"STARTING TEST: {}\" , extensionContext.getMethodName());\n+                    log.info(\"=================================================\");\n+                }\n+\n+                @Override\n+                public void testFailed(ExtensionContext extensionContext, Throwable throwable) { // todo throwable e to throwable name\n+                    log.info(\"=================================================\");\n+                    log.info(\"FAILED TEST: {}\" , extensionContext.getMethodName(), e);\n+                    log.info(\"=================================================\");\n+                }\n+\n+                @Override\n+                public void testSuccessful(ExtensionContext extensionContext) {\n+                    log.info(\"=================================================\");\n+                    log.info(\"SUCCEEDED TEST: {}\" , extensionContext.getMethodName());\n+                    log.info(\"=================================================\");\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+    @Test\n+    @Disabled\n+    fun assertTestWatcherConversionHandlesDescriptionMethodParameter() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import org.junit.runner.Description;\n+\n+            public class WatchmanTest {\n+                @Rule\n+                public TestWatcher watchman = new TestWatcher() {\n+                    @Override\n+                    protected void failed(Throwable e, Description description) { \n+                        System.out.println(description + \" failed\"); \n+                    }\n+\n+                    @Override\n+                    protected void succeeded(Description description) {\n+                        System.out.println(description + \" success\");\n+                    }\n+                };\n+\n+                public void test() {\n+                }\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.TestWatcher;\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+\n+            @ExtendWith(WatchmanTestWatcherExtension.class)\n+            public class WatchmanTest {\n+                public void test() {\n+                }\n+            }\n+\n+            private class WatchmanTestWatcherExtension implements TestWatcher {\n+                @Override\n+                public void testFailed(ExtensionContext extensionContext, Throwable throwable) {\n+                    System.out.println(extensionContext.getDisplayName() + \" failed\");\n+                }\n+\n+                @Override\n+                public void testSuccessful(ExtensionContext extensionContext) {\n+                    System.out.println(extensionContext.getDisplayName() + \" success\");\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+\n+    @Test\n+    @Disabled // what should this look like? // todo\n+    fun assertTestWatcherConversionHandlesStaticContexts() = assertChanged(\n+        before = \"\"\"\n+            import org.junit.Rule;\n+            import org.junit.rules.TestWatcher;\n+            import org.junit.runner.Description;\n+\n+            public static class WatchmanTest {\n+                private static String watchedLog;\n+\n+                @Rule\n+                public TestWatcher watchman = new TestWatcher() {\n+                    @Override\n+                    protected void failed(Throwable e, Description description) { \n+                        watchedLog += \"failed\"; \n+                    }\n+\n+                    @Override\n+                    protected void succeeded(Description description) {\n+                        watchedLog += \"succeeded\";\n+                    }\n+                };\n+\n+                public void test() {\n+                }\n+            }\n+        \"\"\",\n+        after = \"\"\"\n+            import org.junit.jupiter.api.extension.ExtensionContext;\n+            import org.junit.jupiter.api.extension.TestWatcher;\n+            import org.junit.jupiter.api.extension.ExtendWith;\n+\n+            @ExtendWith(WatchmanTestWatcherExtension.class)\n+            public static class WatchmanTest {\n+                private static String watchedLog;\n+\n+                public void test() {\n+                }\n+            }\n+\n+            private class WatchmanTestWatcherExtension implements TestWatcher {\n+                @Override\n+                public void testFailed(ExtensionContext extensionContext, Throwable throwable) {\n+                    watchedLog += \"failed\";\n+                }\n+\n+                @Override\n+                public void testSuccessful(ExtensionContext extensionContext) {\n+                    watchedLog += \"succeeded\";\n+                }\n+            }\n+        \"\"\"\n+    )\n+\n+\n+}"
  }
]
