[
  {
    "sha": "7bca2fe0327080ffab6c6eae23746634278a41c2",
    "filename": "core/src/main/java/org/bitcoinj/core/AddressFormatException.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/bitcoinj/bitcoinj/blob/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/AddressFormatException.java",
    "raw_url": "https://github.com/bitcoinj/bitcoinj/raw/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/AddressFormatException.java",
    "contents_url": "https://api.github.com/repos/bitcoinj/bitcoinj/contents/core/src/main/java/org/bitcoinj/core/AddressFormatException.java?ref=fab77b67ec37b4f5387f35e80ec577ab08dc39c0",
    "patch": "@@ -73,6 +73,20 @@ public InvalidChecksum(String message) {\n         }\n     }\n \n+    /**\n+     * This exception is thrown by {@link SegwitAddress} when you try to decode data and the witness version doesn't\n+     * match the Bech32 encoding as per BIP350. You shouldn't allow the user to proceed in this case.\n+     */\n+    public static class UnexpectedWitnessVersion extends AddressFormatException {\n+        public UnexpectedWitnessVersion() {\n+            super(\"Unexpected witness version\");\n+        }\n+\n+        public UnexpectedWitnessVersion(String message) {\n+            super(message);\n+        }\n+    }\n+\n     /**\n      * This exception is thrown by the {@link PrefixedChecksummedBytes} hierarchy of classes when you try and decode an\n      * address or private key with an invalid prefix (version header or human-readable part). You shouldn't allow the"
  },
  {
    "sha": "0a13e7cba034bec678ebde987dff121310db9415",
    "filename": "core/src/main/java/org/bitcoinj/core/Bech32.java",
    "status": "modified",
    "additions": 33,
    "deletions": 10,
    "changes": 43,
    "blob_url": "https://github.com/bitcoinj/bitcoinj/blob/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/Bech32.java",
    "raw_url": "https://github.com/bitcoinj/bitcoinj/raw/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/Bech32.java",
    "contents_url": "https://api.github.com/repos/bitcoinj/bitcoinj/contents/core/src/main/java/org/bitcoinj/core/Bech32.java?ref=fab77b67ec37b4f5387f35e80ec577ab08dc39c0",
    "patch": "@@ -16,11 +16,19 @@\n \n package org.bitcoinj.core;\n \n+import javax.annotation.Nullable;\n+\n import static com.google.common.base.Preconditions.checkArgument;\n \n import java.util.Arrays;\n import java.util.Locale;\n \n+/**\n+ * <p>Implementation of the Bech32 encoding.</p>\n+ *\n+ * <p>See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki\">BIP350</a> and\n+ * <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\">BIP173</a> for details.</p>\n+ */\n public class Bech32 {\n     /** The Bech32 character set for encoding. */\n     private static final String CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n@@ -37,11 +45,18 @@\n              1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1\n     };\n \n+    private static final int BECH32_CONST = 1;\n+    private static final int BECH32M_CONST = 0x2bc830a3;\n+\n+    public enum Encoding { BECH32, BECH32M }\n+\n     public static class Bech32Data {\n+        public final Encoding encoding;\n         public final String hrp;\n         public final byte[] data;\n \n-        private Bech32Data(final String hrp, final byte[] data) {\n+        private Bech32Data(final Encoding encoding, final String hrp, final byte[] data) {\n+            this.encoding = encoding;\n             this.hrp = hrp;\n             this.data = data;\n         }\n@@ -76,21 +91,28 @@ private static int polymod(final byte[] values) {\n     }\n \n     /** Verify a checksum. */\n-    private static boolean verifyChecksum(final String hrp, final byte[] values) {\n+    private static @Nullable\n+    Encoding verifyChecksum(final String hrp, final byte[] values) {\n         byte[] hrpExpanded = expandHrp(hrp);\n         byte[] combined = new byte[hrpExpanded.length + values.length];\n         System.arraycopy(hrpExpanded, 0, combined, 0, hrpExpanded.length);\n         System.arraycopy(values, 0, combined, hrpExpanded.length, values.length);\n-        return polymod(combined) == 1;\n+        final int check = polymod(combined);\n+        if (check == BECH32_CONST)\n+            return Encoding.BECH32;\n+        else if (check == BECH32M_CONST)\n+            return Encoding.BECH32M;\n+        else\n+            return null;\n     }\n \n     /** Create a checksum. */\n-    private static byte[] createChecksum(final String hrp, final byte[] values)  {\n+    private static byte[] createChecksum(final Encoding encoding, final String hrp, final byte[] values)  {\n         byte[] hrpExpanded = expandHrp(hrp);\n         byte[] enc = new byte[hrpExpanded.length + values.length + 6];\n         System.arraycopy(hrpExpanded, 0, enc, 0, hrpExpanded.length);\n         System.arraycopy(values, 0, enc, hrpExpanded.length, values.length);\n-        int mod = polymod(enc) ^ 1;\n+        int mod = polymod(enc) ^ (encoding == Encoding.BECH32 ? BECH32_CONST : BECH32M_CONST);\n         byte[] ret = new byte[6];\n         for (int i = 0; i < 6; ++i) {\n             ret[i] = (byte) ((mod >>> (5 * (5 - i))) & 31);\n@@ -100,15 +122,15 @@ private static boolean verifyChecksum(final String hrp, final byte[] values) {\n \n     /** Encode a Bech32 string. */\n     public static String encode(final Bech32Data bech32) {\n-        return encode(bech32.hrp, bech32.data);\n+        return encode(bech32.encoding, bech32.hrp, bech32.data);\n     }\n \n     /** Encode a Bech32 string. */\n-    public static String encode(String hrp, final byte[] values) {\n+    public static String encode(Encoding encoding, String hrp, final byte[] values) {\n         checkArgument(hrp.length() >= 1, \"Human-readable part is too short\");\n         checkArgument(hrp.length() <= 83, \"Human-readable part is too long\");\n         hrp = hrp.toLowerCase(Locale.ROOT);\n-        byte[] checksum = createChecksum(hrp, values);\n+        byte[] checksum = createChecksum(encoding, hrp, values);\n         byte[] combined = new byte[values.length + checksum.length];\n         System.arraycopy(values, 0, combined, 0, values.length);\n         System.arraycopy(checksum, 0, combined, values.length, checksum.length);\n@@ -153,7 +175,8 @@ public static Bech32Data decode(final String str) throws AddressFormatException\n             values[i] = CHARSET_REV[c];\n         }\n         String hrp = str.substring(0, pos).toLowerCase(Locale.ROOT);\n-        if (!verifyChecksum(hrp, values)) throw new AddressFormatException.InvalidChecksum();\n-        return new Bech32Data(hrp, Arrays.copyOfRange(values, 0, values.length - 6));\n+        Encoding encoding = verifyChecksum(hrp, values);\n+        if (encoding == null) throw new AddressFormatException.InvalidChecksum();\n+        return new Bech32Data(encoding, hrp, Arrays.copyOfRange(values, 0, values.length - 6));\n     }\n }"
  },
  {
    "sha": "e22fa35a4ad1bf6ff84f7eb3e86430bc8cae9d0f",
    "filename": "core/src/main/java/org/bitcoinj/core/SegwitAddress.java",
    "status": "modified",
    "additions": 17,
    "deletions": 4,
    "changes": 21,
    "blob_url": "https://github.com/bitcoinj/bitcoinj/blob/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/SegwitAddress.java",
    "raw_url": "https://github.com/bitcoinj/bitcoinj/raw/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/main/java/org/bitcoinj/core/SegwitAddress.java",
    "contents_url": "https://api.github.com/repos/bitcoinj/bitcoinj/contents/core/src/main/java/org/bitcoinj/core/SegwitAddress.java?ref=fab77b67ec37b4f5387f35e80ec577ab08dc39c0",
    "patch": "@@ -37,7 +37,8 @@\n  * bits into groups of 5).</li>\n  * </ul>\n  *\n- * <p>See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\">BIP173</a> for details.</p>\n+ * <p>See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki\">BIP350</a> and\n+ * <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\">BIP173</a> for details.</p>\n  *\n  * <p>However, you don't need to care about the internals. Use {@link #fromBech32(NetworkParameters, String)},\n  * {@link #fromHash(NetworkParameters, byte[])} or {@link #fromKey(NetworkParameters, ECKey)} to construct a native\n@@ -168,16 +169,25 @@ public static SegwitAddress fromBech32(@Nullable NetworkParameters params, Strin\n         if (params == null) {\n             for (NetworkParameters p : Networks.get()) {\n                 if (bechData.hrp.equals(p.getSegwitAddressHrp()))\n-                    return new SegwitAddress(p, bechData.data);\n+                    return fromBechData(p, bechData);\n             }\n             throw new AddressFormatException.InvalidPrefix(\"No network found for \" + bech32);\n         } else {\n             if (bechData.hrp.equals(params.getSegwitAddressHrp()))\n-                return new SegwitAddress(params, bechData.data);\n+                return fromBechData(params, bechData);\n             throw new AddressFormatException.WrongNetwork(bechData.hrp);\n         }\n     }\n \n+    private static SegwitAddress fromBechData(NetworkParameters params, Bech32.Bech32Data bechData) {\n+        final SegwitAddress address = new SegwitAddress(params, bechData.data);\n+        final int witnessVersion = address.getWitnessVersion();\n+        if ((witnessVersion == 0 && bechData.encoding != Bech32.Encoding.BECH32) ||\n+                (witnessVersion != 0 && bechData.encoding != Bech32.Encoding.BECH32M))\n+            throw new AddressFormatException.UnexpectedWitnessVersion(\"Unexpected witness version: \" + witnessVersion);\n+        return address;\n+    }\n+\n     /**\n      * Construct a {@link SegwitAddress} that represents the given hash, which is either a pubkey hash or a script hash.\n      * The resulting address will be either a P2WPKH or a P2WSH type of address.\n@@ -213,7 +223,10 @@ public static SegwitAddress fromKey(NetworkParameters params, ECKey key) {\n      * @return textual form encoded in bech32\n      */\n     public String toBech32() {\n-        return Bech32.encode(params.getSegwitAddressHrp(), bytes);\n+        if (getWitnessVersion() == 0)\n+            return Bech32.encode(Bech32.Encoding.BECH32, params.getSegwitAddressHrp(), bytes);\n+        else\n+            return Bech32.encode(Bech32.Encoding.BECH32M, params.getSegwitAddressHrp(), bytes);\n     }\n \n     /**"
  },
  {
    "sha": "179ed6e9e9527f45f250de4c6f4fd7233c25296c",
    "filename": "core/src/test/java/org/bitcoinj/core/Bech32Test.java",
    "status": "modified",
    "additions": 65,
    "deletions": 21,
    "changes": 86,
    "blob_url": "https://github.com/bitcoinj/bitcoinj/blob/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/test/java/org/bitcoinj/core/Bech32Test.java",
    "raw_url": "https://github.com/bitcoinj/bitcoinj/raw/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/test/java/org/bitcoinj/core/Bech32Test.java",
    "contents_url": "https://api.github.com/repos/bitcoinj/bitcoinj/contents/core/src/test/java/org/bitcoinj/core/Bech32Test.java?ref=fab77b67ec37b4f5387f35e80ec577ab08dc39c0",
    "patch": "@@ -25,20 +25,29 @@\n \n public class Bech32Test {\n     @Test\n-    public void valid() {\n-        for (String valid : VALID) {\n-            Bech32.Bech32Data bechData = Bech32.decode(valid);\n-            String recode = Bech32.encode(bechData);\n-            assertEquals(String.format(\"Failed to roundtrip '%s' -> '%s'\", valid, recode),\n-                    valid.toLowerCase(Locale.ROOT), recode.toLowerCase(Locale.ROOT));\n-            // Test encoding with an uppercase HRP\n-            recode = Bech32.encode(bechData.hrp.toUpperCase(Locale.ROOT), bechData.data);\n-            assertEquals(String.format(\"Failed to roundtrip '%s' -> '%s'\", valid, recode),\n-                    valid.toLowerCase(Locale.ROOT), recode.toLowerCase(Locale.ROOT));\n-        }\n+    public void valid_bech32() {\n+        for (String valid : VALID_BECH32)\n+            valid(valid);\n+    }\n+\n+    @Test\n+    public void valid_bech32m() {\n+        for (String valid : VALID_BECH32M)\n+            valid(valid);\n     }\n \n-    private static final String[] VALID = {\n+    private void valid(String valid) {\n+        Bech32.Bech32Data bechData = Bech32.decode(valid);\n+        String recode = Bech32.encode(bechData);\n+        assertEquals(String.format(\"Failed to roundtrip '%s' -> '%s'\", valid, recode),\n+                valid.toLowerCase(Locale.ROOT), recode.toLowerCase(Locale.ROOT));\n+        // Test encoding with an uppercase HRP\n+        recode = Bech32.encode(bechData.encoding, bechData.hrp.toUpperCase(Locale.ROOT), bechData.data);\n+        assertEquals(String.format(\"Failed to roundtrip '%s' -> '%s'\", valid, recode),\n+                valid.toLowerCase(Locale.ROOT), recode.toLowerCase(Locale.ROOT));\n+    }\n+\n+    private static final String[] VALID_BECH32 = {\n             \"A12UEL5L\",\n             \"a12uel5l\",\n             \"an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs\",\n@@ -47,20 +56,38 @@ public void valid() {\n             \"split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w\",\n             \"?1ezyfcl\",\n     };\n+    private static final String[] VALID_BECH32M = {\n+            \"A1LQFN3A\",\n+            \"a1lqfn3a\",\n+            \"an83characterlonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11sg7hg6\",\n+            \"abcdef1l7aum6echk45nj3s0wdvt2fg8x9yrzpqzd3ryx\",\n+            \"11llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllludsr8\",\n+            \"split1checkupstagehandshakeupstreamerranterredcaperredlc445v\",\n+            \"?1v759aa\"\n+    };\n \n     @Test\n-    public void invalid() {\n-        for (String invalid : INVALID) {\n-            try {\n-                Bech32.decode(invalid);\n-                fail(String.format(\"Parsed an invalid code: '%s'\", invalid));\n-            } catch (AddressFormatException x) {\n-                /* expected */\n-            }\n+    public void invalid_bech32() {\n+        for (String invalid : INVALID_BECH32)\n+            invalid(invalid);\n+    }\n+\n+    @Test\n+    public void invalid_bech32m() {\n+        for (String invalid : INVALID_BECH32M)\n+            invalid(invalid);\n+    }\n+\n+    private void invalid(String invalid) {\n+        try {\n+            Bech32.decode(invalid);\n+            fail(String.format(\"Parsed an invalid code: '%s'\", invalid));\n+        } catch (AddressFormatException x) {\n+            /* expected */\n         }\n     }\n \n-    private static final String[] INVALID = {\n+    private static final String[] INVALID_BECH32 = {\n             \" 1nwldj5\", // HRP character out of range\n             new String(new char[] { 0x7f }) + \"1axkwrx\", // HRP character out of range\n             new String(new char[] { 0x80 }) + \"1eym55h\", // HRP character out of range\n@@ -75,6 +102,23 @@ public void invalid() {\n             \"1qzzfhee\", // empty HRP\n     };\n \n+    private static final String[] INVALID_BECH32M = {\n+            \" 1xj0phk\", // HRP character out of range\n+            new String(new char[] { 0x7f }) + \"1g6xzxy\", // HRP character out of range\n+            new String(new char[] { 0x80 }) + \"1vctc34\", // HRP character out of range\n+            \"an84characterslonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11d6pts4\", // overall max length exceeded\n+            \"qyrz8wqd2c9m\", // No separator character\n+            \"1qyrz8wqd2c9m\", // Empty HRP\n+            \"y1b0jsk6g\", // Invalid data character\n+            \"lt1igcx5c0\", // Invalid data character\n+            \"in1muywd\", // Too short checksum\n+            \"mm1crxm3i\", // Invalid character in checksum\n+            \"au1s5cgom\", // Invalid character in checksum\n+            \"M1VUXWEZ\", // checksum calculated with uppercase form of HRP\n+            \"16plkw9\", // empty HRP\n+            \"1p2gdwpf\", // empty HRP\n+    };\n+\n     @Test(expected = AddressFormatException.InvalidCharacter.class)\n     public void decode_invalidCharacter_notInAlphabet() {\n         Bech32.decode(\"A12OUEL5X\");"
  },
  {
    "sha": "e702a5e0fcab4ee846748343dda79f3ac071412e",
    "filename": "core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java",
    "status": "modified",
    "additions": 25,
    "deletions": 6,
    "changes": 31,
    "blob_url": "https://github.com/bitcoinj/bitcoinj/blob/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java",
    "raw_url": "https://github.com/bitcoinj/bitcoinj/raw/fab77b67ec37b4f5387f35e80ec577ab08dc39c0/core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java",
    "contents_url": "https://api.github.com/repos/bitcoinj/bitcoinj/contents/core/src/test/java/org/bitcoinj/core/SegwitAddressTest.java?ref=fab77b67ec37b4f5387f35e80ec577ab08dc39c0",
    "patch": "@@ -148,16 +148,22 @@ public String toString() {\n     }\n \n     private static AddressData[] VALID_ADDRESSES = {\n+            // from BIP350 (includes the corrected BIP173 vectors):\n             new AddressData(\"BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4\", MAINNET,\n                     \"0014751e76e8199196d454941c45d1b3a323f1433bd6\", 0),\n             new AddressData(\"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7\", TESTNET,\n                     \"00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\", 0),\n-            new AddressData(\"bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx\", MAINNET,\n+            new AddressData(\"bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kt5nd6y\", MAINNET,\n                     \"5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6\", 1),\n-            new AddressData(\"BC1SW50QA3JX3S\", MAINNET, \"6002751e\", 16),\n-            new AddressData(\"bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj\", MAINNET, \"5210751e76e8199196d454941c45d1b3a323\", 2),\n+            new AddressData(\"BC1SW50QGDZ25J\", MAINNET, \"6002751e\", 16),\n+            new AddressData(\"bc1zw508d6qejxtdg4y5r3zarvaryvaxxpcs\", MAINNET, \"5210751e76e8199196d454941c45d1b3a323\", 2),\n             new AddressData(\"tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy\", TESTNET,\n-                    \"0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433\", 0) };\n+                    \"0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433\", 0),\n+            new AddressData(\"tb1pqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesf3hn0c\", TESTNET,\n+                    \"5120000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433\", 1),\n+            new AddressData(\"bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqzk5jj0\", MAINNET,\n+                    \"512079be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\", 1),\n+    };\n \n     @Test\n     public void invalidAddresses() {\n@@ -171,7 +177,8 @@ public void invalidAddresses() {\n         }\n     }\n \n-    private static String[] INVALID_ADDRESSES = { //\n+    private static String[] INVALID_ADDRESSES = {\n+            // from BIP173:\n             \"tc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty\", // Invalid human-readable part\n             \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5\", // Invalid checksum\n             \"BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2\", // Invalid witness version\n@@ -182,6 +189,18 @@ public void invalidAddresses() {\n             \"bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du\", // Zero padding of more than 4 bits\n             \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv\", // Non-zero padding in 8-to-5 conversion\n             \"bc1gmk9yu\", // Empty data section\n+\n+            // from BIP350:\n+            \"tc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty\", // Invalid human-readable part\n+            \"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5\", // Invalid checksum\n+            \"BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2\", // Invalid witness version\n+            \"bc1rw5uspcuh\", // Invalid program length\n+            \"bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90\", // Invalid program length\n+            \"BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P\", // Invalid program length for witness version 0 (per BIP141)\n+            \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7\", // Mixed case\n+            \"bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du\", // zero padding of more than 4 bits\n+            \"tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv\", // Non-zero padding in 8-to-5 conversion\n+            \"bc1gmk9yu\", // Empty data section\n     };\n \n     @Test(expected = AddressFormatException.InvalidDataLength.class)\n@@ -211,7 +230,7 @@ public void fromBech32_wrongNetwork() {\n \n     @Test\n     public void testJavaSerialization() throws Exception {\n-        SegwitAddress address = SegwitAddress.fromBech32(null, \"BC1SW50QA3JX3S\");\n+        SegwitAddress address = SegwitAddress.fromBech32(null, \"BC1SW50QGDZ25J\");\n \n         ByteArrayOutputStream os = new ByteArrayOutputStream();\n         new ObjectOutputStream(os).writeObject(address);"
  }
]
