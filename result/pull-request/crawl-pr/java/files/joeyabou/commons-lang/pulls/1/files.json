[
  {
    "sha": "5b4750958a4823772761eca9632ddeeeec9c5c8d",
    "filename": ".github/dependabot.yml",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.github/dependabot.yml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.github/dependabot.yml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/.github/dependabot.yml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -0,0 +1,25 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+version: 2\n+updates:\n+  - package-ecosystem: \"maven\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\"\n+  - package-ecosystem: \"github-actions\"\n+    directory: \"/\"\n+    schedule:\n+      interval: \"daily\""
  },
  {
    "sha": "204253498cba8b17b60000a9ce22bcfbd51ff44f",
    "filename": ".github/workflows/maven.yml",
    "status": "modified",
    "additions": 16,
    "deletions": 5,
    "changes": 21,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.github/workflows/maven.yml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.github/workflows/maven.yml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/.github/workflows/maven.yml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -15,21 +15,32 @@\n \n name: Java CI\n \n-on: [push]\n+on: [push, pull_request]\n \n jobs:\n   build:\n \n     runs-on: ubuntu-latest\n+    continue-on-error: ${{ matrix.experimental }}\n     strategy:\n       matrix:\n-        java: [ '1.8', '11.0.4', '12.0.2' ]\n+        java: [ 8, 11, 16 ]\n+        experimental: [false]\n+        include:\n+          - java: 17-ea\n+            experimental: true        \n         \n     steps:\n-    - uses: actions/checkout@v1\n+    - uses: actions/checkout@v2.3.4\n+    - uses: actions/cache@v2.1.4\n+      with:\n+        path: ~/.m2/repository\n+        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}\n+        restore-keys: |\n+          ${{ runner.os }}-maven-\n     - name: Set up JDK ${{ matrix.java }}\n-      uses: actions/setup-java@v1\n+      uses: actions/setup-java@v1.4.3\n       with:\n         java-version: ${{ matrix.java }}\n     - name: Build with Maven\n-      run: mvn -V apache-rat:check spotbugs:check javadoc:javadoc -Ddoclint=all package --file pom.xml\n+      run: mvn -V -Ddoclint=all --file pom.xml --no-transfer-progress"
  },
  {
    "sha": "5e905d66cd5daf691d8b17501b061ea1a10d16b8",
    "filename": ".travis.yml",
    "status": "modified",
    "additions": 9,
    "deletions": 7,
    "changes": 16,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.travis.yml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/.travis.yml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/.travis.yml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -14,21 +14,23 @@\n # limitations under the License.\n \n language: java\n+\n+cache:\n+  directories:\n+    - $HOME/.m2\n+\n jdk:\n   - openjdk8\n   - openjdk11\n-  - openjdk13\n+  - openjdk15\n   - openjdk-ea\n \n matrix:\n-  include:\n-    - os: linux-ppc64le\n-      jdk: openjdk8\n   allow_failures:\n     - jdk: openjdk-ea\n \n script:\n-  - mvn\n-\n+  - mvn -V --no-transfer-progress\n+ \n after_success:\n-  - mvn clean test jacoco:report coveralls:report -Ptravis-jacoco javadoc:javadoc -Ddoclint=all\n+  - mvn -V --no-transfer-progress clean test jacoco:report coveralls:report -Ptravis-jacoco javadoc:javadoc -Ddoclint=all"
  },
  {
    "sha": "18d9c28e7f8d9eefccc91a06d595939f8e98ee7e",
    "filename": "CONTRIBUTING.md",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/CONTRIBUTING.md",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/CONTRIBUTING.md",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/CONTRIBUTING.md?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -25,7 +25,7 @@\n  | commons-build-plugin/trunk/src/main/resources/commons-xdoc-templates |\n  +======================================================================+\n  |                                                                      |\n- | 1) Re-generate using: mvn commons:contributing-md                    |\n+ | 1) Re-generate using: mvn commons-build:contributing-md              |\n  |                                                                      |\n  | 2) Set the following properties in the component's pom:              |\n  |    - commons.jira.id  (required, alphabetic, upper case)             |"
  },
  {
    "sha": "3d4c6906ab02de0ea24f378dbfd3bef0b3b40ad5",
    "filename": "NOTICE.txt",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/NOTICE.txt",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/NOTICE.txt",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/NOTICE.txt?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -1,5 +1,5 @@\n Apache Commons Lang\n-Copyright 2001-2020 The Apache Software Foundation\n+Copyright 2001-2021 The Apache Software Foundation\n \n This product includes software developed at\n-The Apache Software Foundation (http://www.apache.org/).\n+The Apache Software Foundation (https://www.apache.org/)."
  },
  {
    "sha": "5238ce5371ff2ed8dd9e574ac7f96462e6e3501e",
    "filename": "README.md",
    "status": "modified",
    "additions": 8,
    "deletions": 7,
    "changes": 15,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/README.md",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/README.md",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/README.md?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -25,7 +25,7 @@\n  | commons-build-plugin/trunk/src/main/resources/commons-xdoc-templates |\n  +======================================================================+\n  |                                                                      |\n- | 1) Re-generate using: mvn commons:readme-md                          |\n+ | 1) Re-generate using: mvn commons-build:readme-md                    |\n  |                                                                      |\n  | 2) Set the following properties in the component's pom:              |\n  |    - commons.componentid (required, alphabetic, lower case)          |\n@@ -43,10 +43,11 @@\n Apache Commons Lang\n ===================\n \n-[![Build Status](https://travis-ci.org/apache/commons-lang.svg)](https://travis-ci.org/apache/commons-lang)\n+[![Travis-CI Status](https://travis-ci.org/apache/commons-lang.svg)](https://travis-ci.org/apache/commons-lang)\n+[![GitHub Actions Status](https://github.com/apache/commons-lang/workflows/Java%20CI/badge.svg)](https://github.com/apache/commons-lang/actions)\n [![Coverage Status](https://coveralls.io/repos/apache/commons-lang/badge.svg)](https://coveralls.io/r/apache/commons-lang)\n [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-lang3/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.apache.commons/commons-lang3/)\n-[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-lang3/3.9.svg)](https://javadoc.io/doc/org.apache.commons/commons-lang3/3.9)\n+[![Javadocs](https://javadoc.io/badge/org.apache.commons/commons-lang3/3.12.0.svg)](https://javadoc.io/doc/org.apache.commons/commons-lang3/3.12.0)\n \n Apache Commons Lang, a package of Java utility classes for the\n   classes that are in java.lang's hierarchy, or are considered to be so\n@@ -55,21 +56,21 @@ Apache Commons Lang, a package of Java utility classes for the\n Documentation\n -------------\n \n-More information can be found on the [Apache Commons Lang homepage](https://commons.apache.org/proper/commons-lang/).\n-The [Javadoc](https://commons.apache.org/proper/commons-lang/javadocs/api-release/) can be browsed.\n+More information can be found on the [Apache Commons Lang homepage](https://commons.apache.org/proper/commons-lang).\n+The [Javadoc](https://commons.apache.org/proper/commons-lang/apidocs) can be browsed.\n Questions related to the usage of Apache Commons Lang should be posted to the [user mailing list][ml].\n \n Where can I get the latest release?\n -----------------------------------\n-You can download source and binaries from our [download page](https://commons.apache.org/proper/commons-lang3/download_lang3.cgi).\n+You can download source and binaries from our [download page](https://commons.apache.org/proper/commons-lang/download_lang.cgi).\n \n Alternatively you can pull it from the central Maven repositories:\n \n ```xml\n <dependency>\n   <groupId>org.apache.commons</groupId>\n   <artifactId>commons-lang3</artifactId>\n-  <version>3.9</version>\n+  <version>3.12.0</version>\n </dependency>\n ```\n "
  },
  {
    "sha": "8828a1141b8e1adc926248017e42e99364573469",
    "filename": "RELEASE-NOTES.txt",
    "status": "modified",
    "additions": 319,
    "deletions": 2,
    "changes": 321,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/RELEASE-NOTES.txt",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/RELEASE-NOTES.txt",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/RELEASE-NOTES.txt?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -1,3 +1,320 @@\n+                        Apache Commons Lang\n+                        Version 3.12.0\n+                        Release Notes\n+\n+INTRODUCTION:\n+\n+This document contains the release notes for the 3.12.0 version of Apache Commons Lang.\n+Commons Lang is a set of utility functions and reusable components that should be of use in any \n+Java environment.\n+\n+Lang 3.9 and onwards now targets Java 8, making use of features that arrived with Java 8.\n+\n+For the advice on upgrading from 2.x to 3.x, see the following page: \n+\n+    https://commons.apache.org/lang/article3_0.html\n+\n+Apache Commons Lang, a package of Java utility classes for the\n+classes that are in java.lang's hierarchy, or are considered to be so\n+standard as to justify existence in java.lang.\n+\n+New features and bug fixes.\n+\n+Changes in this version include:\n+\n+New features:\n+o            Add BooleanUtils.booleanValues(). Thanks to Gary Gregory.\n+o            Add BooleanUtils.primitiveValues(). Thanks to Gary Gregory.\n+o LANG-1535: Add StringUtils.containsAnyIgnoreCase(CharSequence, CharSequence...). Thanks to Gary Gregory, Isira Seneviratne.\n+o LANG-1359: Add StopWatch.getStopTime(). Thanks to Gary Gregory, Keegan Witt.\n+o            More test coverage for CharSequenceUtils. #631. Thanks to Edgar Asatryan.\n+o            Add fluent-style ArraySorter. Thanks to Gary Gregory.\n+o            Add and use LocaleUtils.toLocale(Locale) to avoid NPEs. Thanks to Gary Gregory.\n+o            Add FailableShortSupplier, handy for JDBC APIs. Thanks to Gary Gregory.\n+o            Add JavaVersion.JAVA_17. Thanks to Gary Gregory.\n+o LANG-1636: Add missing boolean[] join method #686. Thanks to .\n+o            Add StringUtils.substringBefore(String, int). Thanks to Gary Gregory.\n+o            Add Range.INTEGER. Thanks to Gary Gregory.\n+o            Add DurationUtils. Thanks to Gary Gregory.\n+o            Introduce the use of @Nonnull, and @Nullable, and the Objects class as a helper tool.\n+o            Add and use true and false String constants #714. Thanks to Arturo Bernal, Gary Gregory.\n+o            Add and use ObjectUtils.requireNonEmpty() #716. Thanks to Arturo Bernal, Gary Gregory.\n+\n+Fixed Bugs:\n+o LANG-1592: Correct implementation of RandomUtils.nextLong(long, long) Thanks to Huang Pingcai, Alex Herbert.\n+o LANG-1600: Restore handling of collections for non-JSON ToStringStyle #610. Thanks to Michael F.\n+o            ContextedException Javadoc add missing semicolon #581. Thanks to iamchao1129.\n+o LANG-1608: Resolve JUnit pioneer transitive dependencies using JUnit BOM. Thanks to Edgar Asatryan.\n+o            NumberUtilsTest - incorrect types in min/max tests #634. Thanks to HubertWo, Gary Gregory.\n+o LANG-1579: Improve StringUtils.stripAccents conversion of remaining accents. Thanks to XenoAmess.\n+o LANG-1606: StringUtils.countMatches - clarify Javadoc. Thanks to Rustem Galiev.\n+o LANG-1591: Remove redundant argument from substring call. Thanks to bhawna94.\n+o LANG-1613: BigDecimal is created when you pass it the min and max values, #642. Thanks to Arturo Bernal, Gary Gregory.\n+o LANG-1541: ArrayUtils.contains() and indexOf() fail to handle Double.NaN #647. Thanks to Arturo Bernal, Gary Gregory.\n+o LANG-1615: ArrayUtils contains() and indexOf() fail to handle Float.NaN # #561. Thanks to Arturo Bernal, Gary Gregory.\n+o            Fix potential NPE in TypeUtils.isAssignable(Type, ParameterizedType, Map, Type>). Thanks to Gary Gregory.\n+o LANG-1420: TypeUtils.isAssignable returns wrong result for GenericArrayType and ParameterizedType, #643. Thanks to Gordon Fraser, Rostislav Krasny, Arturo Bernal, Gary Gregory.\n+o LANG-1612: testGetAllFields and testGetFieldsWithAnnotation sometimes fail. Thanks to XinT, Gary Gregory.\n+o            Fix Javadoc for SystemUtils.isJavaVersionAtMost() #638. Thanks to John R. D'Orazio.\n+o LANG-1610: Fix StringUtils.unwrap throws StringIndexOutOfBoundsException #636. Thanks to Tony Liang.\n+o            Fix formatting of isAnyBlank() and isAnyEmpty(). #513. Thanks to Isira Seneviratne.\n+o LANG-1618: TypeUtils. containsTypeVariables does not support GenericArrayType #661. Thanks to Arturo Bernal.\n+o LANG-1622: Javadoc of some methods incorrectly refers to another method, #667, #668. #670. Thanks to Kanak Sony, anomen-s.\n+o LANG-1620: Refine StringUtils.lastIndexOfIgnoreCase #664. Thanks to Arturo Bernal.\n+o LANG-1619: Refine StringUtils.abbreviate #663. Thanks to Arturo Bernal.\n+o LANG-1584: Refine StringUtils.isNumericSpace #573. Thanks to Arturo Bernal.\n+o LANG-1580: Refine StringUtils.deleteWhitespace #569. Thanks to Arturo Bernal.\n+o LANG-1626: Correction in Javadoc of some methods. #673 Thanks to Kanak Sony.\n+o LANG-1628: Javadoc for RandomStringUtils.random() letters, numbers parameters is wrong. Thanks to Jarkko Rantavuori.\n+o            Correct markup in Javadoc for unbalanced braces #679. Thanks to Felix Schumacher.\n+o LANG-1544: MethodUtils.invokeMethod NullPointerException in case of null in args list #680. Thanks to Peter Nagy, Michael Buck, Gary Gregory.\n+o LANG-1637: Fix 2 digit week year formatting #688. Thanks to Uri Gonen, Gary Gregory, Michael Osipov.\n+o            Fix broken Javadoc links to commons-text #712. Thanks to Chris Smowton.\n+o            Add and use ThreadUtils.sleep(Duration). Thanks to Gary Gregory.\n+o            Add and use ThreadUtils.join(Thread, Duration). Thanks to Gary Gregory.\n+o            Add ObjectUtils.wait(Duration). Thanks to Gary Gregory.\n+\n+Changes:\n+o LANG-1596: ArrayUtils.toPrimitive(Object) does not support boolean and other types #607. Thanks to Richard Eckart de Castilho.\n+o            Enable Dependabot #587. Thanks to Gary Gregory.\n+o            Bump junit-jupiter from 5.6.2 to 5.7.0.\n+o            Bump spotbugs from 4.1.2 to 4.2.1, #627, #671, #708. Thanks to chtompki, Dependabot.\n+o            Bump spotbugs-maven-plugin from 4.0.0 to 4.2.0, #593, #596, #609, #623, #632, #692. Thanks to Dependabot.\n+o            Bump biz.aQute.bndlib from 5.1.1 to 5.3.0 #592, #628, #715. Thanks to Dependabot.\n+o            Bump junit-pioneer from 0.6.0 to 1.1.0, #589, #597, #600, #624, #625, #662. Thanks to Dependabot.\n+o            Bump checkstyle from 8.34 to 8.40, #594, #614, #637, #665, #706. Thanks to Dependabot.\n+o            Bump actions/checkout from v2.3.1 to v2.3.4 #601, #639. Thanks to Dependabot.\n+o            Bump actions/setup-java from v1.4.0 to v1.4.2 #612. Thanks to Dependabot.\n+o            Update commons.jacoco.version 0.8.5 to 0.8.6 (Fixes Java 15 builds). Thanks to Gary Gregory.\n+o            Update maven-surefire-plugin 2.22.2 -> 3.0.0-M5. Thanks to Gary Gregory.\n+o            Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #660. Thanks to Dependabot.\n+o            Bump jmh.version from 1.21 to 1.27 #674. Thanks to Dependabot.\n+o            Update commons.japicmp.version 0.14.3 -> 0.15.2. Thanks to Gary Gregory.\n+o            Processor.java: check enum equality with == instead of .equals() method #690. Thanks to Ali K. Nouri.\n+o            Bump junit-pioneer from 1.1.0 to 1.3.0 #702. Thanks to Dependabot.\n+o            Bump maven-checkstyle-plugin from 3.1.1 to 3.1.2 #705. Thanks to Dependabot.\n+o            Bump actions/cache from v2 to v2.1.4 #710. Thanks to Dependabot.\n+o            Bump junit-bom from 5.7.0 to 5.7.1 #707. Thanks to Dependabot.\n+o            Minor Improvements #701. Thanks to Arturo Bernal.\n+o            Minor Improvement: Add final variable.try to make the code read-only #700. Thanks to Arturo Bernal.\n+o            Minor Improvement: Remove redundant initializer #699. Thanks to Arturo Bernal.\n+o            Use own validator ObjectUtils.anyNull to check null String input #718. Thanks to Arturo Bernal.\n+\n+\n+Historical list of changes: https://commons.apache.org/proper/commons-lang/changes-report.html\n+\n+For complete information on Apache Commons Lang, including instructions on how to submit bug reports,\n+patches, or suggestions for improvement, see the Apache Apache Commons Lang website:\n+\n+https://commons.apache.org/proper/commons-lang/\n+\n+Download page: https://commons.apache.org/proper/commons-lang/download_lang.cgi\n+\n+Have fun!\n+-Apache Commons Team\n+\n+=============================================================================\n+\n+                        Apache Commons Lang\n+                        Version 3.11\n+                        Release Notes\n+\n+\n+INTRODUCTION:\n+\n+This document contains the release notes for the 3.11 version of Apache Commons Lang.\n+Commons Lang is a set of utility functions and reusable components that should be of use in any \n+Java environment.\n+\n+Lang 3.9 and onwards now targets Java 8, making use of features that arrived with Java 8.\n+\n+For the advice on upgrading from 2.x to 3.x, see the following page: \n+\n+    https://commons.apache.org/lang/article3_0.html\n+\n+Apache Commons Lang, a package of Java utility classes for the\n+classes that are in java.lang's hierarchy, or are considered to be so\n+standard as to justify existence in java.lang.\n+\n+New features and bug fixes.\n+\n+Changes in this version include:\n+\n+New features:\n+o            Add ArrayUtils.isSameLength() to compare more array types #430. Thanks to XenoAmess, Gary Gregory.\n+o            Added the Locks class as a convenient possibility to deal with locked objects.\n+o LANG-1568: Add to Functions: FailableBooleanSupplier, FailableIntSupplier, FailableLongSupplier, FailableDoubleSupplier, and so on.\n+o LANG-1569: Add ArrayUtils.get(T[], index, T) to provide an out-of-bounds default value.\n+o LANG-1570: Add JavaVersion enum constants for Java 14 and 15. #553. Thanks to Edgar Asatryan.\n+o            Add JavaVersion enum constants for Java 16. Thanks to Gary Gregory.\n+o LANG-1556: Use Java 8 lambdas and Map operations. Thanks to XenoAmess.\n+o LANG-1565: Change removeLastFieldSeparator to use endsWith #550. Thanks to XenoAmess.\n+o LANG-1557: Change a Pattern to a static final field, for not letting it compile each time the function invoked. #542. Thanks to XenoAmess, Gary Gregory.\n+o            Add ImmutablePair factory methods left() and right().\n+o            Add ObjectUtils.toString(Object, Supplier<String>).\n+o            Add org.apache.commons.lang3.StringUtils.substringAfter(String, int).\n+o            Add org.apache.commons.lang3.StringUtils.substringAfterLast(String, int).\n+\n+Fixed Bugs:\n+o            Fix Javadoc for StringUtils.appendIfMissingIgnoreCase() #507. Thanks to contextshuffling.\n+o LANG-1560: Refine Javadoc #545. Thanks to XenoAmess.\n+o LANG-1554: Fix typos #539. Thanks to XenoAmess.\n+o LANG-1555: Ignored exception `ignored`, should not be called so #540. Thanks to XenoAmess.\n+o LANG-1528: StringUtils.replaceEachRepeatedly gives IllegalStateException #505. Thanks to Edwin Delgado H.\n+o LANG-1543: [JSON string for maps] ToStringBuilder.reflectionToString doesnt render nested maps correctly. Thanks to Swaraj Pal, Wander Costa, Gary Gregory.\n+o            Correct Javadocs of methods that use Validate.notNull() and replace some uses of Validate.isTrue() with Validate.notNull(). #525. Thanks to Isira Seneviratne.\n+o LANG-1539: Add allNull() and anyNull() methods to ObjectUtils. #522. Thanks to Isira Seneviratne.\n+\n+Changes:\n+o            Refine test output for FastDateParserTest Thanks to Jin Xu.\n+o LANG-1549: CharSequenceUtils.lastIndexOf : remake it Thanks to Jin Xu.\n+o            remove encoding and docEncoding and use inherited values from commons-parent Thanks to XenoAmess.\n+o            Simplify null checks in Pair.hashCode() using Objects.hashCode(). #517. Thanks to Isira Seneviratne, Bruno P. Kinoshita.\n+o            Simplify null checks in Triple.hashCode() using Objects.hashCode(). #516. Thanks to Isira Seneviratne, Bruno P. Kinoshita.\n+o            Simplify some if statements in StringUtils. #521. Thanks to Isira Seneviratne, Bruno P. Kinoshita.\n+o LANG-1537: Simplify a null check in the private replaceEach() method of StringUtils. #514. Thanks to Isira Seneviratne, Bruno P. Kinoshita.\n+o LANG-1534: Replace some usages of the ternary operator with calls to Math.max() and Math.min() #512. Thanks to Isira Seneviratne, Bruno P. Kinoshita.\n+o            (Javadoc) Fix return tag for throwableOf*() methods #518. Thanks to Arend v. Reinersdorff, Bruno P. Kinoshita.\n+o LANG-1545: CharSequenceUtils.regionMatches is wrong dealing with Georgian. Thanks to XenoAmess, Gary Gregory.\n+o LANG-1550: Optimize ArrayUtils::isArrayIndexValid method. #551. Thanks to Edgar Asatryan.\n+o LANG-1561: Use List.sort instead of Collection.sort #546. Thanks to XenoAmess.\n+o LANG-1563: Use StandardCharsets.UTF_8 #548. Thanks to XenoAmess.\n+o LANG-1564: Use Collections.singletonList insteadof Arrays.asList when there be only one element. #549. Thanks to XenoAmess.\n+o LANG-1553: Change array style from `int a[]` to `int[] a` #537. Thanks to XenoAmess.\n+o LANG-1552: Change from addAll to constructors for some List #536. Thanks to XenoAmess.\n+o LANG-1558: Simplify if as some conditions are covered by others #543. Thanks to XenoAmess.\n+o LANG-1567: Fixed Javadocs for setTestRecursive() #556. Thanks to Miguel Muï¿½oz, Bruno P. Kinoshita, Gary Gregory.\n+o LANG-1542: ToStringBuilder.reflectionToString - Wrong JSON format when object has a List of Enum. Thanks to Tr?n Ng?c Khoa, Gary Gregory.\n+o            Make org.apache.commons.lang3.CharSequenceUtils.toCharArray(CharSequence) public.\n+o            org.apache.commons:commons-parent 50 -> 51.\n+o            org.junit-pioneer:junit-pioneer 0.5.4 -> 0.6.0.\n+o            org.junit.jupiter:junit-jupiter 5.6.0 -> 5.6.2.\n+o            com.github.spotbugs:spotbugs 4.0.0 -> 4.0.6.\n+o            com.puppycrawl.tools:checkstyle 8.29 -> 8.34.\n+o            commons.surefire.version 3.0.0-M4 -> 3.0.0-M5..\n+\n+\n+Historical list of changes: https://commons.apache.org/proper/commons-lang/changes-report.html\n+\n+For complete information on Apache Commons Lang, including instructions on how to submit bug reports,\n+patches, or suggestions for improvement, see the Apache Apache Commons Lang website:\n+\n+https://commons.apache.org/proper/commons-lang/\n+\n+Download page: https://commons.apache.org/proper/commons-lang/download_csv.cgi\n+\n+Have fun!\n+-Apache Commons Team\n+\n+=============================================================================\n+\n+                        Apache Commons Lang\n+                        Version 3.10\n+                        Release Notes\n+\n+\n+INTRODUCTION:\n+\n+This document contains the release notes for the 3.10 version of Apache Commons Lang.\n+Commons Lang is a set of utility functions and reusable components that should be of use in any \n+Java environment.\n+\n+Lang 3.9 and onwards now targets Java 8, making use of features that arrived with Java 8.\n+\n+For the advice on upgrading from 2.x to 3.x, see the following page: \n+\n+    https://commons.apache.org/lang/article3_0.html\n+\n+Apache Commons Lang, a package of Java utility classes for the\n+classes that are in java.lang's hierarchy, or are considered to be so\n+standard as to justify existence in java.lang.\n+\n+New features and bug fixes. Requires Java 8, supports Java 9, 10, 11.\n+\n+Changes in this version include:\n+\n+New features:\n+o LANG-1457: Add ExceptionUtils.throwableOfType(Throwable, Class) and friends.\n+o LANG-1458: Add EMPTY_ARRAY constants to classes in org.apache.commons.lang3.tuple.\n+o LANG-1461: Add null-safe StringUtils APIs to wrap String#getBytes([Charset|String]).\n+o LANG-1467: Add zero arg constructor for org.apache.commons.lang3.NotImplementedException.\n+o LANG-1470: Add ArrayUtils.addFirst() methods.\n+o LANG-1479: Add Range.fit(T) to fit a value into a range.\n+o LANG-1477: Added Functions.as*, and tests thereof, as suggested by Peter Verhas\n+o LANG-1485: Add getters for lhs and rhs objects in DiffResult #451. Thanks to nicolasbd.\n+o LANG-1486: Generify builder classes Diffable, DiffBuilder, and DiffResult #452. Thanks to Gary Gregory.\n+o LANG-1487: Add ClassLoaderUtils with toString() implementations #453. Thanks to Gary Gregory.\n+o LANG-1489: Add null-safe APIs as StringUtils.toRootLowerCase(String) and StringUtils.toRootUpperCase(String) #456. Thanks to Gary Gregory.\n+o LANG-1494: Add org.apache.commons.lang3.time.Calendars. Thanks to Gary Gregory.\n+o LANG-1495: Add EnumUtils getEnum() methods with default values #475. Thanks to Cheong Voon Leong.\n+o LANG-1177: Added indexesOf methods and simplified removeAllOccurences #471. Thanks to Liel Fridman.\n+o LANG-1498: Add support of lambda value evaluation for defaulting methods #416. Thanks to Lysergid, Gary Gregory.\n+o LANG-1503: Add factory methods to Pair classes with Map.Entry input. #454. Thanks to XenoAmess, Gary Gregory.\n+o LANG-1505: Add StopWatch convenience APIs to format times and create a simple instance. Thanks to Gary Gregory.\n+o LANG-1506: Allow a StopWatch to carry an optional message. Thanks to Gary Gregory.\n+o LANG-1507: Add ComparableUtils #398. Thanks to Sam Kruglov, Mark Dacek, Marc Magon, Pascal Schumacher, Rob Tompkins, Bruno P. Kinoshita, Amey Jadiye, Gary Gregory.\n+o LANG-1508: Add org.apache.commons.lang3.SystemUtils.getUserName(). Thanks to Gary Gregory.\n+o LANG-1509: Add ObjectToStringComparator. #483. Thanks to Gary Gregory.\n+o LANG-1510: Add org.apache.commons.lang3.arch.Processor.Arch.getLabel(). Thanks to Gary Gregory.\n+o LANG-1512: Add IS_JAVA_14 and IS_JAVA_15 to org.apache.commons.lang3.SystemUtils. Thanks to Gary Gregory.\n+o LANG-1513: ObjectUtils: Get first non-null supplier value. Thanks to Bernhard Bonigl, Gary Gregory.\n+o            Added the Streams class, and Functions.stream() as an accessor thereof.\n+\n+Fixed Bugs:\n+o LANG-1514: Make test more stable by wrapping assertions in hashset. Thanks to contextshuffling.\n+o LANG-1450: Generate Javadoc jar on build.\n+o LANG-1460: Trivial: year of release for 3.9 says 2018, should be 2019 Thanks to Larry West.\n+o LANG-1476: Use synchronize on a set created with Collections.synchronizedSet before iterating Thanks to emopers.\n+o LANG-1475: StringUtils.unwrap incorrect throw StringIndexOutOfBoundsException. Thanks to stzx.\n+o LANG-1406: StringIndexOutOfBoundsException in StringUtils.replaceIgnoreCase #423. Thanks to geratorres.\n+o LANG-1453: StringUtils.removeIgnoreCase(\"?a\", \"a\") throws IndexOutOfBoundsException #423. Thanks to geratorres.\n+o LANG-1426: Corrected usage examples in Javadocs #458. Thanks to Brower, Mikko Maunu, Suraj Gautam.\n+o LANG-1463: StringUtils abbreviate returns String of length greater than maxWidth #477. Thanks to bbeckercscc, Gary Gregory.\n+o LANG-1500: Test may fail due to a different order of fields returned by reflection api #480. Thanks to contextshuffling.\n+o LANG-1501: Sort fields in ReflectionToStringBuilder for deterministic order #481. Thanks to contextshuffling.\n+o LANG-1433: MethodUtils will throw a NPE if invokeMethod() is called for a var-args method #407. Thanks to Christian Franzen.\n+o LANG-1518: MethodUtils.getAnnotation() with searchSupers = true does not work if super is generic #494. Thanks to Michele Preti, Bruno P. Kinoshita, Gary Gregory.\n+\n+Changes:\n+o LANG-1437: Remove redundant if statements in join methods #411. Thanks to Andrei Troie.\n+o            commons.japicmp.version 0.13.1 -> 0.14.1.\n+o            junit-jupiter 5.5.0 -> 5.5.1.\n+o            junit-jupiter 5.5.1 -> 5.5.2.\n+o            Improve Javadoc based on the discussion of the GitHub PR #459. Thanks to Jonathan Leitschuh, Bruno P. Kinoshita, Rob Tompkins, Gary Gregory.\n+o            maven-checkstyle-plugin 3.0.0 -> 3.1.0.\n+o LANG-696:  Update documentation related to the issue LANG-696 #449. Thanks to Peter Verhas.\n+o            AnnotationUtils little cleanup #467. Thanks to Peter Verhas.\n+o            Update test dependency: org.easymock:easymock 4.0.2 -> 4.1. Thanks to Gary Gregory.\n+o            Update test dependency: org.hamcrest:hamcrest 2.1 -> 2.2. Thanks to Gary Gregory.\n+o            Update test dependency: org.junit-pioneer:junit-pioneer 0.3.0 -> 0.4.2. Thanks to Gary Gregory.\n+o            Update build dependency: com.puppycrawl.tools:checkstyle 8.18 -> 8.27. Thanks to Gary Gregory.\n+o            Update POM parent: org.apache.commons:commons-parent 48 -> 50. Thanks to Gary Gregory.\n+o            BooleanUtils Javadoc #469. Thanks to Peter Verhas.\n+o            Functions Javadoc #466. Thanks to Peter Verhas.\n+o            org.easymock:easymock 4.1 -> 4.2. Thanks to Gary Gregory.\n+o            org.junit-pioneer:junit-pioneer 0.4.2 -> 0.5.4. Thanks to Gary Gregory.\n+o            org.junit.jupiter:junit-jupiter 5.5.2 -> 5.6.0. Thanks to Gary Gregory.\n+o            Use Javadoc {@code} instead of pre tags. #490. Thanks to Peter Verhas.\n+o            ExceptionUtilsTest to 100% #486. Thanks to Peter Verhas.\n+o            Reuse own code in Functions.java #493. Thanks to Peter Verhas.\n+o LANG-1523: Avoid unnecessary allocation in StringUtils.wrapIfMissing. #496. Thanks to Edgar Asatryan, Bruno P. Kinoshita, Gary Gregory.\n+o LANG-1525: Internally use Validate.notNull(foo, ...) instead of Validate.isTrue(foo != null, ...). Thanks to Edgar Asatryan, Bruno P. Kinoshita, Gary Gregory.\n+o LANG-1526: Add 1 and 0 in toBooleanObject(final String str) #502. Thanks to Dominik Schramm.\n+o LANG-1527: Remove an redundant argument check in NumberUtils #504. Thanks to Pengyu Nie.\n+o LANG-1529: Deprecate org.apache.commons.lang3.ArrayUtils.removeAllOccurences(*) for org.apache.commons.lang3.ArrayUtils.removeAllOccurrences(*). Thanks to Gary Gregory, BillCindy, Bruno P. Kinoshita.\n+\n+\n+Historical list of changes: https://commons.apache.org/proper/commons-lang/changes-report.html\n+\n+For complete information on Apache Commons Lang, including instructions on how to submit bug reports,\n+patches, or suggestions for improvement, see the Apache Apache Commons Lang website:\n+\n+https://commons.apache.org/proper/commons-lang/\n+\n+Download page: https://commons.apache.org/proper/commons-lang/download_lang.cgi\n+\n+=============================================================================\n+\n                         Apache Commons Lang\n                             Version 3.9\n                            Release Notes\n@@ -311,7 +628,7 @@ o LANG-1319: MultilineRecursiveToStringStyle StackOverflowError when object is\n              an array.\n o LANG-1320: LocaleUtils#toLocale does not support language followed by UN M.49\n              numeric-3 area code followed by variant.\n-o LANG-1300: Clarify or improve behaviour of int-based indexOf methods in\n+o LANG-1300: Clarify or improve behavior of int-based indexOf methods in\n              StringUtils. Thanks to Mark Dacek.\n o LANG-1286: RandomStringUtils random method can overflow and return characters\n              outside of specified range.\n@@ -1021,7 +1338,7 @@ o LANG-831:  FastDateParser does not handle white-space properly.\n o LANG-830:  FastDateParser could use \\Q \\E to quote regexes.\n o LANG-828:  FastDateParser does not handle non-Gregorian calendars properly.\n o LANG-826:  FastDateParser does not handle non-ASCII digits correctly.\n-o LANG-822:  NumberUtils#createNumber - bad behaviour for leading \"--\".\n+o LANG-822:  NumberUtils#createNumber - bad behavior for leading \"--\".\n o LANG-818:  FastDateFormat's \"z\" pattern does not respect timezone of Calendar\n              instances passed to format().\n o LANG-817:  Add org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS_8."
  },
  {
    "sha": "51943ba7b485b574c514ea099a3610a3a338f9f7",
    "filename": "SECURITY.md",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/SECURITY.md",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/SECURITY.md",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/SECURITY.md?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -0,0 +1,17 @@\n+<!---\n+ Licensed to the Apache Software Foundation (ASF) under one or more\n+ contributor license agreements.  See the NOTICE file distributed with\n+ this work for additional information regarding copyright ownership.\n+ The ASF licenses this file to You under the Apache License, Version 2.0\n+ (the \"License\"); you may not use this file except in compliance with\n+ the License.  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+-->\n+The Apache Commons security page is [https://commons.apache.org/security.html](https://commons.apache.org/security.html)."
  },
  {
    "sha": "f84db14e67110e67e89095ceb8013e30bb5a1b24",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 72,
    "deletions": 33,
    "changes": 105,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/pom.xml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/pom.xml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/pom.xml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -22,11 +22,11 @@\n   <parent>\n     <groupId>org.apache.commons</groupId>\n     <artifactId>commons-parent</artifactId>\n-    <version>50</version>\n+    <version>52</version>\n   </parent>\n   <modelVersion>4.0.0</modelVersion>\n   <artifactId>commons-lang3</artifactId>\n-  <version>3.10-SNAPSHOT</version>\n+  <version>3.13.0-SNAPSHOT</version>\n   <name>Apache Commons Lang</name>\n \n   <inceptionYear>2001</inceptionYear>\n@@ -47,7 +47,7 @@\n     <connection>scm:git:http://gitbox.apache.org/repos/asf/commons-lang.git</connection>\n     <developerConnection>scm:git:https://gitbox.apache.org/repos/asf/commons-lang.git</developerConnection>\n     <url>https://gitbox.apache.org/repos/asf?p=commons-lang.git</url>\n-    <tag>commons-lang-3.9</tag>\n+    <tag>commons-lang-3.12.0</tag>\n   </scm>\n \n   <developers>\n@@ -508,21 +508,35 @@\n     <contributor>\n       <name>Peter Verhas</name>\n     </contributor>\n+    <contributor>\n+      <name>Jin Xu</name>\n+    </contributor>\n   </contributors>\n \n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>org.junit</groupId>\n+        <artifactId>junit-bom</artifactId>\n+        <version>5.7.1</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+\n   <!-- Lang should depend on very little -->\n   <dependencies>\n     <!-- testing -->\n     <dependency>\n       <groupId>org.junit.jupiter</groupId>\n       <artifactId>junit-jupiter</artifactId>\n-      <version>5.6.0</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>org.junit-pioneer</groupId>\n       <artifactId>junit-pioneer</artifactId>\n-      <version>0.5.4</version>\n+      <version>1.3.8</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n@@ -552,7 +566,12 @@\n       <version>${jmh.version}</version>\n       <scope>test</scope>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>com.google.code.findbugs</groupId>\n+      <artifactId>jsr305</artifactId>\n+      <version>3.0.2</version>\n+      <scope>test</scope>\n+    </dependency>\n   </dependencies>\n \n   <distributionManagement>\n@@ -584,7 +603,7 @@\n     <commons.packageId>lang3</commons.packageId>\n     <commons.module.name>org.apache.commons.lang3</commons.module.name>\n     <!-- Current 3.x release series -->\n-    <commons.release.version>3.10</commons.release.version>\n+    <commons.release.version>3.13.0</commons.release.version>\n     <commons.release.desc>(Java 8+)</commons.release.desc>\n     <!-- Previous 2.x release series -->\n     <commons.release.2.version>2.6</commons.release.2.version>\n@@ -599,27 +618,26 @@\n     <commons.scmPubCheckoutDirectory>site-content</commons.scmPubCheckoutDirectory>\n     <commons.encoding>utf-8</commons.encoding>\n \n-    <checkstyle.plugin.version>3.1.1</checkstyle.plugin.version>\n-    <checkstyle.version>8.29</checkstyle.version>\n+    <checkstyle.plugin.version>3.1.2</checkstyle.plugin.version>\n+    <checkstyle.version>8.41</checkstyle.version>\n     <checkstyle.configdir>src/site/resources/checkstyle</checkstyle.configdir>\n \n-    <spotbugs.plugin.version>3.1.12.2</spotbugs.plugin.version>\n+    <spotbugs.plugin.version>4.2.0</spotbugs.plugin.version>\n+    <spotbugs.impl.version>4.2.2</spotbugs.impl.version>\n     <japicmp.skip>false</japicmp.skip>\n+    <clirr.skip>true</clirr.skip>\n \n     <!-- JMH Benchmark related properties, version, target compiler and name of the benchmarking uber jar. -->\n-    <jmh.version>1.21</jmh.version>\n+    <jmh.version>1.27</jmh.version>\n     <uberjar.name>benchmarks</uberjar.name>\n \n-    <commons.jacoco.version>0.8.5</commons.jacoco.version>\n-    <commons.surefire.version>3.0.0-M4</commons.surefire.version>\n-    <commons.javadoc.version>3.1.1</commons.javadoc.version>\n-\n-    <!-- generate report even if there are binary incompatible changes -->\n-    <commons.japicmp.breakBuildOnBinaryIncompatibleModifications>false</commons.japicmp.breakBuildOnBinaryIncompatibleModifications>\n-    <commons.japicmp.version>0.14.3</commons.japicmp.version>\n+    <commons.jacoco.version>0.8.6</commons.jacoco.version>\n+    <commons.surefire.version>3.0.0-M5</commons.surefire.version>\n+    <commons.javadoc.version>3.2.0</commons.javadoc.version>\n+    <commons.japicmp.version>0.15.2</commons.japicmp.version>\n \n     <!-- Commons Release Plugin -->\n-    <commons.bc.version>3.9</commons.bc.version>\n+    <commons.bc.version>3.12.0</commons.bc.version>\n     <commons.rc.version>RC1</commons.rc.version>\n     <commons.release.isDistModule>true</commons.release.isDistModule>\n     <commons.distSvnStagingUrl>scm:svn:https://dist.apache.org/repos/dist/dev/commons/lang</commons.distSvnStagingUrl>\n@@ -629,7 +647,7 @@\n \n \n   <build>\n-   <defaultGoal>clean verify apache-rat:check clirr:check checkstyle:check spotbugs:check javadoc:javadoc</defaultGoal>\n+   <defaultGoal>clean package apache-rat:check checkstyle:check japicmp:cmp spotbugs:check javadoc:javadoc</defaultGoal>\n    <pluginManagement>\n       <plugins>\n         <plugin>\n@@ -645,14 +663,6 @@\n             </excludes>\n           </configuration>\n         </plugin>\n-        <!-- override skip property of parent pom -->\n-        <plugin>\n-          <groupId>com.github.siom79.japicmp</groupId>\n-          <artifactId>japicmp-maven-plugin</artifactId>\n-          <configuration>\n-            <skip>false</skip>\n-          </configuration>\n-        </plugin>\n       </plugins>\n     </pluginManagement>\n     <plugins>\n@@ -661,8 +671,6 @@\n         <configuration>\n           <source>${maven.compiler.source}</source>\n           <quiet>true</quiet>\n-          <encoding>utf-8</encoding>\n-          <docEncoding>utf-8</docEncoding>\n           <notimestamp>true</notimestamp>\n           <links>\n             <link>https://docs.oracle.com/javase/8/docs/api/</link>\n@@ -689,6 +697,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${commons.surefire.version}</version>\n         <executions>\n           <execution>\n             <id>plain</id>\n@@ -765,15 +774,25 @@\n           <dependency>\n             <groupId>com.github.spotbugs</groupId>\n             <artifactId>spotbugs</artifactId>\n-            <version>4.0.0</version>\n+            <version>${spotbugs.impl.version}</version>\n          </dependency>\n         </dependencies>        \n         <configuration>\n           <excludeFilterFile>${basedir}/spotbugs-exclude-filter.xml</excludeFilterFile>\n         </configuration>\n       </plugin>\n+      <plugin>\n+        <groupId>org.apache.felix</groupId>\n+        <artifactId>maven-bundle-plugin</artifactId>\n+        <dependencies>\n+          <dependency>\n+            <groupId>biz.aQute.bnd</groupId>\n+            <artifactId>biz.aQute.bndlib</artifactId>\n+            <version>5.3.0</version>\n+          </dependency>\n+        </dependencies>\n+      </plugin>\n     </plugins>\n-\n   </build>\n \n   <reporting>\n@@ -805,7 +824,7 @@\n       </plugin>\n       <plugin>\n         <artifactId>maven-pmd-plugin</artifactId>\n-        <version>3.13.0</version>\n+        <version>3.14.0</version>\n         <configuration>\n           <targetJdk>${maven.compiler.target}</targetJdk>\n         </configuration>\n@@ -925,6 +944,26 @@\n         <jacoco.skip>true</jacoco.skip>\n       </properties>\n     </profile>\n+    <profile>\n+      <id>java15</id>\n+      <activation>\n+        <!-- This is ONLY activated for Java 15 -->\n+        <jdk>15</jdk>\n+      </activation>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <groupId>org.apache.maven.plugins</groupId>\n+            <artifactId>maven-surefire-plugin</artifactId>\n+            <configuration>\n+              <excludes>\n+                <exclude>org/apache/commons/lang3/time/Java15BugFastDateParserTest.java</exclude>               \n+              </excludes>\n+            </configuration>\n+          </plugin>        \n+        </plugins>\n+      </build>\n+    </profile>\n \n     <profile>\n       <id>benchmark</id>"
  },
  {
    "sha": "be00732748b28bcc239f4b4bed8b4363b3e6da2c",
    "filename": "spotbugs-exclude-filter.xml",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/spotbugs-exclude-filter.xml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/spotbugs-exclude-filter.xml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/spotbugs-exclude-filter.xml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -153,4 +153,12 @@\n     <Method name=\"compare\" />\n     <Bug pattern=\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\" />\n   </Match>\n+\n+  <!-- Reason: requireNonNull is supposed to take a nullable parameter,\n+       whatever Spotbugs thinks of it. -->\n+  <Match>\n+    <Class name=\"org.apache.commons.lang3.function.Objects\" />\n+    <Method name=\"requireNonNull\" />\n+    <Bug pattern=\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\" />\n+  </Match>\n </FindBugsFilter>"
  },
  {
    "sha": "017a983da5ad1f1a0abce224ce315863a55a08f6",
    "filename": "src/changes/changes.xml",
    "status": "modified",
    "additions": 150,
    "deletions": 10,
    "changes": 160,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/changes/changes.xml",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/changes/changes.xml",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/changes/changes.xml?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -20,7 +20,7 @@\n This file is also used by the maven-changes-plugin to generate the release notes.\n Useful ways of finding items to add to this file are:\n \n-1.  Add items when you fix a bug or add a feature (this makes the \n+1.  Add items when you fix a bug or add a feature (this makes the\n release process easy :-).\n \n 2.  Do a JIRA search for tickets closed since the previous release.\n@@ -32,7 +32,7 @@ To generate the release notes from this file:\n \n mvn changes:announcement-generate -Prelease-notes [-Dchanges.version=nnn]\n \n-then tweak the formatting if necessary \n+then tweak the formatting if necessary\n and commit\n \n The <action> type attribute can be add,update,fix,remove.\n@@ -45,7 +45,142 @@ The <action> type attribute can be add,update,fix,remove.\n   </properties>\n   <body>\n \n-  <release version=\"3.10\" date=\"YYYY-MM-DD\" description=\"New features and bug fixes. Requires Java 8, supports Java 9, 10, 11.\">\n+  <release version=\"3.13.0\" date=\"2021-MM-DD\" description=\"New features and bug fixes (Java 8).\">\n+    <!-- FIX -->\n+    <action issue=\"LANG-1645\" type=\"fix\" dev=\"aherbert\" due-to=\"Alex Herbert\">NumberUtils.createNumber to recognize hex integers prefixed with +.</action>\n+    <action issue=\"LANG-1646\" type=\"fix\" dev=\"aherbert\" due-to=\"Alex Herbert\">NumberUtils.createNumber to return requested floating point type for zero.</action>\n+    <!-- ADD -->\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add EnumUtils.getEnumSystemProperty(...).</action>\n+  </release>\n+\n+  <release version=\"3.12.0\" date=\"2021-02-26\" description=\"New features and bug fixes (Java 8).\">\n+    <!-- FIX -->\n+    <action issue=\"LANG-1592\" type=\"fix\" dev=\"aherbert\" due-to=\"Huang Pingcai, Alex Herbert\">Correct implementation of RandomUtils.nextLong(long, long)</action>\n+    <action issue=\"LANG-1600\" type=\"fix\" dev=\"ggregory\" due-to=\"Michael F\">Restore handling of collections for non-JSON ToStringStyle #610.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"iamchao1129\">ContextedException Javadoc add missing semicolon #581.</action>\n+    <action issue=\"LANG-1608\" type=\"fix\" dev=\"aherbert\" due-to=\"Edgar Asatryan\">Resolve JUnit pioneer transitive dependencies using JUnit BOM.</action>\n+    <action                   type=\"fix\" dev=\"aherbert\" due-to=\"HubertWo, Gary Gregory\">NumberUtilsTest - incorrect types in min/max tests #634.</action>\n+    <action issue=\"LANG-1579\" type=\"fix\" dev=\"aherbert\" due-to=\"XenoAmess\">Improve StringUtils.stripAccents conversion of remaining accents.</action>\n+    <action issue=\"LANG-1606\" type=\"fix\" dev=\"sebb\" due-to=\"Rustem Galiev\">StringUtils.countMatches - clarify Javadoc.</action>\n+    <action issue=\"LANG-1591\" type=\"fix\" dev=\"kinow\" due-to=\"bhawna94\">Remove redundant argument from substring call.</action>\n+    <action issue=\"LANG-1613\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal, Gary Gregory\">BigDecimal is created when you pass it the min and max values, #642.</action>\n+    <action issue=\"LANG-1541\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal, Gary Gregory\">ArrayUtils.contains() and indexOf() fail to handle Double.NaN #647.</action>\n+    <action issue=\"LANG-1615\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal, Gary Gregory\">ArrayUtils contains() and indexOf() fail to handle Float.NaN # #561.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix potential NPE in TypeUtils.isAssignable(Type, ParameterizedType, Map, Type>).</action>\n+    <action issue=\"LANG-1420\" type=\"fix\" dev=\"ggregory\" due-to=\"Gordon Fraser, Rostislav Krasny, Arturo Bernal, Gary Gregory\">TypeUtils.isAssignable returns wrong result for GenericArrayType and ParameterizedType, #643.</action>\n+    <action issue=\"LANG-1612\" type=\"fix\" dev=\"ggregory\" due-to=\"XinT, Gary Gregory\">testGetAllFields and testGetFieldsWithAnnotation sometimes fail.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"John R. D'Orazio\">Fix Javadoc for SystemUtils.isJavaVersionAtMost() #638.</action>\n+    <action issue=\"LANG-1610\" type=\"fix\" dev=\"ggregory\" due-to=\"Tony Liang\">Fix StringUtils.unwrap throws StringIndexOutOfBoundsException #636.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Isira Seneviratne\">Fix formatting of isAnyBlank() and isAnyEmpty(). #513.</action>\n+    <action issue=\"LANG-1618\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">TypeUtils. containsTypeVariables does not support GenericArrayType #661.</action>\n+    <action issue=\"LANG-1622\" type=\"fix\" dev=\"ggregory\" due-to=\"Kanak Sony, anomen-s\">Javadoc of some methods incorrectly refers to another method, #667, #668. #670.</action>\n+    <action issue=\"LANG-1620\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Refine StringUtils.lastIndexOfIgnoreCase #664.</action>\n+    <action issue=\"LANG-1619\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Refine StringUtils.abbreviate #663.</action>\n+    <action issue=\"LANG-1584\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Refine StringUtils.isNumericSpace #573.</action>\n+    <action issue=\"LANG-1580\" type=\"fix\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Refine StringUtils.deleteWhitespace #569.</action>\n+    <action issue=\"LANG-1626\" type=\"fix\" dev=\"ggregory\" due-to=\"Kanak Sony\">Correction in Javadoc of some methods. #673</action>\n+    <action issue=\"LANG-1628\" type=\"fix\" dev=\"kinow\" due-to=\"Jarkko Rantavuori\">Javadoc for RandomStringUtils.random() letters, numbers parameters is wrong.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Felix Schumacher\">Correct markup in Javadoc for unbalanced braces #679.</action>\n+    <action issue=\"LANG-1544\" type=\"fix\" dev=\"kinow\" due-to=\"Peter Nagy, Michael Buck, Gary Gregory\">MethodUtils.invokeMethod NullPointerException in case of null in args list #680.</action>\n+    <action issue=\"LANG-1637\" type=\"fix\" dev=\"ggregory\" due-to=\"Uri Gonen, Gary Gregory, Michael Osipov\">Fix 2 digit week year formatting #688.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Chris Smowton\">Fix broken Javadoc links to commons-text #712.</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use ThreadUtils.sleep(Duration).</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use ThreadUtils.join(Thread, Duration).</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add ObjectUtils.wait(Duration).</action>\n+    <!-- ADD -->\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add BooleanUtils.booleanValues().</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add BooleanUtils.primitiveValues().</action>\n+    <action issue=\"LANG-1535\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Isira Seneviratne\">Add StringUtils.containsAnyIgnoreCase(CharSequence, CharSequence...).</action>\n+    <action issue=\"LANG-1359\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory, Keegan Witt\">Add StopWatch.getStopTime().</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Edgar Asatryan\">More test coverage for CharSequenceUtils. #631.</action>\n+    <action issue=\"LANG-1596\" type=\"update\" dev=\"aherbert\" due-to=\"Richard Eckart de Castilho\">ArrayUtils.toPrimitive(Object) does not support boolean and other types #607.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add fluent-style ArraySorter.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add and use LocaleUtils.toLocale(Locale) to avoid NPEs.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add FailableShortSupplier, handy for JDBC APIs.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add JavaVersion.JAVA_17.</action>\n+    <action issue=\"LANG-1636\" type=\"add\" dev=\"ggregory\" due-to=\"\">Add missing boolean[] join method #686.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add StringUtils.substringBefore(String, int).</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add Range.INTEGER.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add DurationUtils.</action>\n+    <action                   type=\"add\" dev=\"jochen\">Introduce the use of @Nonnull, and @Nullable, and the Objects class as a helper tool.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Arturo Bernal, Gary Gregory\">Add and use true and false String constants #714.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Arturo Bernal, Gary Gregory\">Add and use ObjectUtils.requireNonEmpty() #716.</action>\n+    <!-- UPDATE -->\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Enable Dependabot #587.</action>\n+    <action                   type=\"update\" dev=\"chtompki\">Bump junit-jupiter from 5.6.2 to 5.7.0.</action>\n+    <action                   type=\"update\" dev=\"chtompki\" due-to=\"chtompki, Dependabot\">Bump spotbugs from 4.1.2 to 4.2.2, #627, #671, #708, #726.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump spotbugs-maven-plugin from 4.0.0 to 4.2.0, #593, #596, #609, #623, #632, #692.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump biz.aQute.bndlib from 5.1.1 to 5.3.0 #592, #628, #715.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-pioneer from 0.6.0 to 1.1.0, #589, #597, #600, #624, #625, #662.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump checkstyle from 8.34 to 8.41, #594, #614, #637, #665, #706, #722.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/checkout from v2.3.1 to v2.3.4 #601, #639.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/setup-java from v1.4.0 to v1.4.2 #612.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update commons.jacoco.version 0.8.5 to 0.8.6 (Fixes Java 15 builds).</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update maven-surefire-plugin 2.22.2 -> 3.0.0-M5.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-pmd-plugin from 3.13.0 to 3.14.0 #660.</action>\n+    <action                   type=\"update\" dev=\"kinow\" due-to=\"Dependabot\">Bump jmh.version from 1.21 to 1.27 #674.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory\">Update commons.japicmp.version 0.14.3 -> 0.15.2.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Ali K. Nouri\">Processor.java: check enum equality with == instead of .equals() method #690.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-pioneer from 1.1.0 to 1.3.8, #702, #721.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump maven-checkstyle-plugin from 3.1.1 to 3.1.2 #705.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump actions/cache from v2 to v2.1.4 #710.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Dependabot\">Bump junit-bom from 5.7.0 to 5.7.1 #707.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor Improvements #701.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor Improvement: Add final variable.try to make the code read-only #700.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Minor Improvement: Remove redundant initializer #699.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Arturo Bernal\">Use own validator ObjectUtils.anyNull to check null String input #718.</action>\n+  </release>\n+  <release version=\"3.11\" date=\"2020-07-12\" description=\"New features and bug fixes (Java 8).\">\n+    <action                   type=\"update\" dev=\"chtompki\" due-to=\"Jin Xu\">Refine test output for FastDateParserTest</action>\n+    <action issue=\"LANG-1549\" type=\"update\" dev=\"chtompki\" due-to=\"Jin Xu\">CharSequenceUtils.lastIndexOf : remake it</action>\n+    <action                   type=\"update\" dev=\"kinow\" due-to=\"XenoAmess\">remove encoding and docEncoding and use inherited values from commons-parent</action>\n+    <action                   type=\"fix\"    dev=\"kinow\" due-to=\"contextshuffling\">Fix Javadoc for StringUtils.appendIfMissingIgnoreCase() #507.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Isira Seneviratne, Bruno P. Kinoshita\">Simplify null checks in Pair.hashCode() using Objects.hashCode(). #517.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Isira Seneviratne, Bruno P. Kinoshita\">Simplify null checks in Triple.hashCode() using Objects.hashCode(). #516.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Isira Seneviratne, Bruno P. Kinoshita\">Simplify some if statements in StringUtils. #521.</action>\n+    <action issue=\"LANG-1537\" type=\"update\" dev=\"ggregory\" due-to=\"Isira Seneviratne, Bruno P. Kinoshita\">Simplify a null check in the private replaceEach() method of StringUtils. #514.</action>\n+    <action issue=\"LANG-1534\" type=\"update\" dev=\"ggregory\" due-to=\"Isira Seneviratne, Bruno P. Kinoshita\">Replace some usages of the ternary operator with calls to Math.max() and Math.min() #512.</action>\n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Arend v. Reinersdorff, Bruno P. Kinoshita\">(Javadoc) Fix return tag for throwableOf*() methods #518.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"XenoAmess, Gary Gregory\">Add ArrayUtils.isSameLength() to compare more array types #430.</action>\n+    <action issue=\"LANG-1545\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess, Gary Gregory\">CharSequenceUtils.regionMatches is wrong dealing with Georgian.</action>\n+    <action                   type=\"add\" dev=\"jochen\">Added the Locks class as a convenient possibility to deal with locked objects.</action>\n+    <action issue=\"LANG-1568\" type=\"add\" dev=\"ggregory\">Add to Functions: FailableBooleanSupplier, FailableIntSupplier, FailableLongSupplier, FailableDoubleSupplier, and so on.</action>\n+    <action issue=\"LANG-1569\" type=\"add\" dev=\"ggregory\">Add ArrayUtils.get(T[], index, T) to provide an out-of-bounds default value.</action>\n+    <action issue=\"LANG-1550\" type=\"update\" dev=\"ggregory\" due-to=\"Edgar Asatryan\">Optimize ArrayUtils::isArrayIndexValid method. #551.</action>\n+    <action issue=\"LANG-1561\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Use List.sort instead of Collection.sort #546.</action>\n+    <action issue=\"LANG-1563\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Use StandardCharsets.UTF_8 #548.</action>\n+    <action issue=\"LANG-1564\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Use Collections.singletonList insteadof Arrays.asList when there be only one element. #549.</action>\n+    <action issue=\"LANG-1560\" type=\"fix\" dev=\"ggregory\" due-to=\"XenoAmess\">Refine Javadoc #545.</action>\n+    <action issue=\"LANG-1553\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Change array style from `int a[]` to `int[] a` #537.</action>\n+    <action issue=\"LANG-1552\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Change from addAll to constructors for some List #536.</action>\n+    <action issue=\"LANG-1554\" type=\"fix\" dev=\"ggregory\" due-to=\"XenoAmess\">Fix typos #539.</action>\n+    <action issue=\"LANG-1555\" type=\"fix\" dev=\"ggregory\" due-to=\"XenoAmess\">Ignored exception `ignored`, should not be called so #540.</action>\n+    <action issue=\"LANG-1558\" type=\"update\" dev=\"ggregory\" due-to=\"XenoAmess\">Simplify if as some conditions are covered by others #543.</action>\n+    <action issue=\"LANG-1528\" type=\"fix\" dev=\"ggregory\" due-to=\"Edwin Delgado H\">StringUtils.replaceEachRepeatedly gives IllegalStateException #505.</action>\n+    <action issue=\"LANG-1570\" type=\"add\" dev=\"ggregory\" due-to=\"Edgar Asatryan\">Add JavaVersion enum constants for Java 14 and 15. #553.</action>\n+    <action                   type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add JavaVersion enum constants for Java 16.</action>\n+    <action issue=\"LANG-1556\" type=\"add\" dev=\"ggregory\" due-to=\"XenoAmess\">Use Java 8 lambdas and Map operations.</action>\n+    <action issue=\"LANG-1565\" type=\"add\" dev=\"ggregory\" due-to=\"XenoAmess\">Change removeLastFieldSeparator to use endsWith #550.</action>\n+    <action issue=\"LANG-1557\" type=\"add\" dev=\"ggregory\" due-to=\"XenoAmess, Gary Gregory\">Change a Pattern to a static final field, for not letting it compile each time the function invoked. #542.</action>\n+    <action                   type=\"add\" dev=\"ggregory\">Add ImmutablePair factory methods left() and right().</action>\n+    <action                   type=\"add\" dev=\"ggregory\">Add ObjectUtils.toString(Object, Supplier&lt;String&gt;).</action>\n+    <action issue=\"LANG-1567\" type=\"update\" dev=\"ggregory\" due-to=\"Miguel MuÃ±oz, Bruno P. Kinoshita, Gary Gregory\">Fixed Javadocs for setTestRecursive() #556.</action>\n+    <action issue=\"LANG-1542\" type=\"update\" dev=\"ggregory\" due-to=\" Tráº§n Ngá»c Khoa, Gary Gregory\">ToStringBuilder.reflectionToString - Wrong JSON format when object has a List of Enum.</action>\n+    <action issue=\"LANG-1543\" type=\"fix\" dev=\"ggregory\" due-to=\"Swaraj Pal, Wander Costa, Gary Gregory\">[JSON string for maps] ToStringBuilder.reflectionToString doesnt render nested maps correctly.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">Make org.apache.commons.lang3.CharSequenceUtils.toCharArray(CharSequence) public.</action>\n+    <action                   type=\"add\" dev=\"ggregory\">Add org.apache.commons.lang3.StringUtils.substringAfter(String, int).</action>\n+    <action                   type=\"add\" dev=\"ggregory\">Add org.apache.commons.lang3.StringUtils.substringAfterLast(String, int).</action>\n+    <action                   type=\"fix\" dev=\"ggregory\" due-to=\"Isira Seneviratne\">Correct Javadocs of methods that use Validate.notNull() and replace some uses of Validate.isTrue() with Validate.notNull(). #525.</action>\n+    <action issue=\"LANG-1539\" type=\"fix\" dev=\"ggregory\" due-to=\"Isira Seneviratne\">Add allNull() and anyNull() methods to ObjectUtils. #522.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">org.apache.commons:commons-parent 50 -> 51.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">org.junit-pioneer:junit-pioneer 0.5.4 -> 0.6.0.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">org.junit.jupiter:junit-jupiter 5.6.0 -> 5.6.2.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">com.github.spotbugs:spotbugs 4.0.0 -> 4.0.6.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">com.puppycrawl.tools:checkstyle 8.29 -> 8.34.</action>\n+    <action                   type=\"update\" dev=\"ggregory\">commons.surefire.version 3.0.0-M4 -> 3.0.0-M5..</action>\n+  </release>\n+\n+  <release version=\"3.10\" date=\"2020-03-22\" description=\"New features and bug fixes. Requires Java 8, supports Java 9, 10, 11.\">\n     <action issue=\"LANG-1514\" type=\"fix\" dev=\"kinow\" due-to=\"contextshuffling\">Make test more stable by wrapping assertions in hashset.</action>\n     <action issue=\"LANG-1450\" type=\"fix\" dev=\"chtompki\">Generate Javadoc jar on build.</action>\n     <action issue=\"LANG-1457\" type=\"add\" dev=\"ggregory\">Add ExceptionUtils.throwableOfType(Throwable, Class) and friends.</action>\n@@ -105,6 +240,11 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-1433\" type=\"fix\" dev=\"ggregory\" due-to=\"Christian Franzen\">MethodUtils will throw a NPE if invokeMethod() is called for a var-args method #407.</action>\n     <action                   type=\"update\" dev=\"ggregory\" due-to=\"Peter Verhas\">Reuse own code in Functions.java #493.</action>\n     <action issue=\"LANG-1518\" type=\"fix\" dev=\"ggregory\" due-to=\"Michele Preti, Bruno P. Kinoshita, Gary Gregory\">MethodUtils.getAnnotation() with searchSupers = true does not work if super is generic #494.</action>\n+    <action issue=\"LANG-1523\" type=\"update\" dev=\"ggregory\" due-to=\"Edgar Asatryan, Bruno P. Kinoshita, Gary Gregory\">Avoid unnecessary allocation in StringUtils.wrapIfMissing. #496.</action>\n+    <action issue=\"LANG-1525\" type=\"update\" dev=\"ggregory\" due-to=\"Edgar Asatryan, Bruno P. Kinoshita, Gary Gregory\">Internally use Validate.notNull(foo, ...) instead of Validate.isTrue(foo != null, ...).</action>\n+    <action issue=\"LANG-1526\" type=\"update\" dev=\"ggregory\" due-to=\"Dominik Schramm\">Add 1 and 0 in toBooleanObject(final String str) #502.</action>\n+    <action issue=\"LANG-1527\" type=\"update\" dev=\"ggregory\" due-to=\"Pengyu Nie\">Remove an redundant argument check in NumberUtils #504.</action>\n+    <action issue=\"LANG-1529\" type=\"update\" dev=\"ggregory\" due-to=\"Gary Gregory, BillCindy, Bruno P. Kinoshita\">Deprecate org.apache.commons.lang3.ArrayUtils.removeAllOccurences(*) for org.apache.commons.lang3.ArrayUtils.removeAllOccurrences(*).</action>\n   </release>\n \n   <release version=\"3.9\" date=\"2019-04-09\" description=\"New features and bug fixes. Requires Java 8, supports Java 9, 10, 11.\">\n@@ -121,7 +261,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-1422\" type=\"add\" dev=\"ggregory\">Add null-safe StringUtils.valueOf(char[]) to delegate to String.valueOf(char[])</action>\n     <action issue=\"LANG-1427\" type=\"add\" dev=\"ggregory\">Add API org.apache.commons.lang3.SystemUtils.isJavaVersionAtMost(JavaVersion)</action>\n     <action issue=\"LANG-1436\" type=\"update\" dev=\"aherbert\">Consolidate the StringUtils equals and equalsIgnoreCase Javadoc and implementation</action>\n-    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Andrei Troie aft90\">(doc) Fix javadoc for 'startIndex' parameter of StringUtils.join() methods. GitHub PR #412.</action>    \n+    <action                   type=\"update\" dev=\"ggregory\" due-to=\"Andrei Troie aft90\">(doc) Fix javadoc for 'startIndex' parameter of StringUtils.join() methods. GitHub PR #412.</action>\n   </release>\n \n   <release version=\"3.8.1\" date=\"2018-09-19\" description=\"This release is a bugfix for Restoring Bundle-SymbolicName in the MANIFEST.mf file.\">\n@@ -146,9 +286,9 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-1352\" type=\"add\" dev=\"pschumacher\" due-to=\"Ruslan Sibgatullin\">EnumUtils.getEnumIgnoreCase and isValidEnumIgnoreCase methods added</action>\n     <action issue=\"LANG-1372\" type=\"add\" dev=\"pschumacher\" due-to=\"SÃ©rgio Ozaki\">Add ToStringSummary annotation</action>\n     <action issue=\"LANG-1356\" type=\"add\" dev=\"pschumacher\" due-to=\"Yathos UG\">Add bypass option for classes to recursive and reflective EqualsBuilder</action>\n-    <action issue=\"LANG-1391\" type=\"add\" dev=\"ggregory\" due-to=\"Sauro Matulli, Oleg Chubaryov\">Improve Javadoc for StringUtils.isAnyEmpty(null)</action>   \n-    <action issue=\"LANG-1393\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API SystemUtils.String getEnvironmentVariable(final String name, final String defaultValue)</action>   \n-    <action issue=\"LANG-1394\" type=\"add\" dev=\"ggregory\" due-to=\"Sebb, Gary Gregory\">org.apache.commons.lang3.SystemUtils should not write to System.err.</action>   \n+    <action issue=\"LANG-1391\" type=\"add\" dev=\"ggregory\" due-to=\"Sauro Matulli, Oleg Chubaryov\">Improve Javadoc for StringUtils.isAnyEmpty(null)</action>\n+    <action issue=\"LANG-1393\" type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add API SystemUtils.String getEnvironmentVariable(final String name, final String defaultValue)</action>\n+    <action issue=\"LANG-1394\" type=\"add\" dev=\"ggregory\" due-to=\"Sebb, Gary Gregory\">org.apache.commons.lang3.SystemUtils should not write to System.err.</action>\n     <action issue=\"LANG-1238\" type=\"add\" dev=\"ggregory\" due-to=\"Christopher Cordeiro, Gary Gregory, Bruno P. Kinoshita, Oleg Chubaryov\">Add RegexUtils class instead of overloading methods in StringUtils that take a regex to take precompiled Pattern.</action>\n     <action issue=\"LANG-1390\" type=\"add\" dev=\"ggregory\" due-to=\"Jochen Schalanda\">StringUtils.join() with support for List&lt;?> with configurable start/end indices.</action>\n     <action issue=\"LANG-1392\" type=\"add\" dev=\"pschumacher\" due-to=\"Jeff Nelson\">Methods for getting first non empty or non blank value</action>\n@@ -184,7 +324,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-1256\" type=\"add\" dev=\"pschumacher\" due-to=\"C0rWin\">Add JMH maven dependencies</action>\n     <action issue=\"LANG-1167\" type=\"add\" dev=\"chtompki\" due-to=\"Mark Dacek\">Add null filter to ReflectionToStringBuilder</action>\n     <action issue=\"LANG-1320\" type=\"fix\" dev=\"britter\">LocaleUtils#toLocale does not support language followed by UN M.49 numeric-3 area code followed by variant</action>\n-    <action issue=\"LANG-1300\" type=\"fix\" dev=\"chtompki\" due-to=\"Mark Dacek\">Clarify or improve behaviour of int-based indexOf methods in StringUtils</action>\n+    <action issue=\"LANG-1300\" type=\"fix\" dev=\"chtompki\" due-to=\"Mark Dacek\">Clarify or improve behavior of int-based indexOf methods in StringUtils</action>\n     <action issue=\"LANG-1299\" type=\"add\" dev=\"djones\">Add method for converting string to an array of code points</action>\n     <action issue=\"LANG-1286\" type=\"fix\" dev=\"djones\">RandomStringUtils random method can overflow and return characters outside of specified range</action>\n     <action issue=\"LANG-660\" type=\"add\" dev=\"djones\">Add methods to insert arrays into arrays at an index</action>\n@@ -254,7 +394,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-1195\" type=\"add\" dev=\"pschumacher\" due-to=\"Derek C. Ashmore\">Enhance MethodUtils to allow invocation of private methods</action>\n     <action issue=\"LANG-1199\" type=\"fix\" dev=\"pschumacher\" due-to=\"M. Steiger\">Fix implementation of StringUtils.getJaroWinklerDistance()</action>\n     <action issue=\"LANG-1244\" type=\"fix\" dev=\"pschumacher\" due-to=\"jjbankert\">Fix dead links in StringUtils.getLevenshteinDistance() javadoc</action>\n-    <action issue=\"LANG-1242\" type=\"fix\" dev=\"pschumacher\" due-to=\"Neal Stewart\">\"\\u2284\":\"&nsub;\" mapping missing from EntityArrays#HTML40_EXTENDED_ESCAPE</action>\n+    <action issue=\"LANG-1242\" type=\"fix\" dev=\"pschumacher\" due-to=\"Neal Stewart\">\"\\u2284\":\"nsub\" mapping missing from EntityArrays#HTML40_EXTENDED_ESCAPE</action>\n     <action issue=\"LANG-1243\" type=\"update\" dev=\"sebb\">Simplify ArrayUtils removeElements by using new decrementAndGet() method</action>\n     <action issue=\"LANG-1189\" type=\"add\" dev=\"sebb\" due-to=\"haiyang li / Matthew Bartenschlag \">Add getAndIncrement/getAndDecrement/getAndAdd/incrementAndGet/decrementAndGet/addAndGet in Mutable* classes</action>\n     <action issue=\"LANG-1240\" type=\"update\" dev=\"pschumacher\" due-to=\"zhanhb\">Optimize BitField constructor implementation</action>\n@@ -518,7 +658,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <action issue=\"LANG-828\" type=\"fix\">FastDateParser does not handle non-Gregorian calendars properly</action>\n     <action issue=\"LANG-826\" type=\"fix\">FastDateParser does not handle non-ASCII digits correctly</action>\n     <action issue=\"LANG-825\" type=\"add\">Create StrBuilder APIs similar to String.format(String, Object...)</action>\n-    <action issue=\"LANG-822\" type=\"fix\">NumberUtils#createNumber - bad behaviour for leading \"--\"</action>\n+    <action issue=\"LANG-822\" type=\"fix\">NumberUtils#createNumber - bad behavior for leading \"--\"</action>\n     <action issue=\"LANG-818\" type=\"fix\">FastDateFormat's \"z\" pattern does not respect timezone of Calendar instances passed to format()</action>\n     <action issue=\"LANG-817\" type=\"fix\">Add org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS_8</action>\n     <action issue=\"LANG-813\" type=\"fix\">StringUtils.equalsIgnoreCase doesn't check string reference equality</action>"
  },
  {
    "sha": "9e311eb7dd3f64403161f7331f8da3beef457e99",
    "filename": "src/changes/release-notes.vm",
    "status": "modified",
    "additions": 6,
    "deletions": 1,
    "changes": 7,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/changes/release-notes.vm",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/changes/release-notes.vm",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/changes/release-notes.vm?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -136,4 +136,9 @@ Historical list of changes: ${project.url}changes-report.html\n For complete information on ${project.name}, including instructions on how to submit bug reports,\n patches, or suggestions for improvement, see the Apache ${project.name} website:\n \n-${project.url}\n\\ No newline at end of file\n+${project.url}\n+\n+Download page: ${project.url}download_lang.cgi\n+\n+Have fun!\n+-Apache Commons Team"
  },
  {
    "sha": "20ba2fb4ca61553f51b9a7ccc8b0931dc0e5c600",
    "filename": "src/main/java/org/apache/commons/lang3/ArchUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArchUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArchUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ArchUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -16,12 +16,12 @@\n  */\n package org.apache.commons.lang3;\n \n-import org.apache.commons.lang3.arch.Processor;\n-\n import java.util.HashMap;\n import java.util.Map;\n import java.util.stream.Stream;\n \n+import org.apache.commons.lang3.arch.Processor;\n+\n /**\n  * An utility class for the os.arch System Property. The class defines methods for\n  * identifying the architecture of the current JVM."
  },
  {
    "sha": "2208bd902637be8f650bd491bbcab7b6aa3274f7",
    "filename": "src/main/java/org/apache/commons/lang3/ArraySorter.java",
    "status": "added",
    "additions": 141,
    "deletions": 0,
    "changes": 141,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArraySorter.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArraySorter.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ArraySorter.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+/**\n+ * Sorts and returns arrays in the fluent style.\n+ *\n+ * @since 3.12.0\n+ */\n+public class ArraySorter {\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(byte[])\n+     */\n+    public static byte[] sort(final byte[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(char[])\n+     */\n+    public static char[] sort(final char[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(double[])\n+     */\n+    public static double[] sort(final double[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(float[])\n+     */\n+    public static float[] sort(final float[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(int[])\n+     */\n+    public static int[] sort(final int[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(long[])\n+     */\n+    public static long[] sort(final long[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(short[])\n+     */\n+    public static short[] sort(final short[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param <T> the array type.\n+     * @param array the array to sort.\n+     * @return the given array.\n+     * @see Arrays#sort(Object[])\n+     */\n+    public static <T> T[] sort(final T[] array) {\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Sorts and returns the given array.\n+     *\n+     * @param <T> the array type.\n+     * @param array the array to sort.\n+     * @param comparator the comparator to determine the order of the array. A {@code null} value uses the elements'\n+     *        {@link Comparable natural ordering}.\n+     * @return the given array.\n+     * @see Arrays#sort(Object[])\n+     */\n+    public static <T> T[] sort(final T[] array, final Comparator<? super T> comparator) {\n+        Arrays.sort(array, comparator);\n+        return array;\n+    }\n+\n+}"
  },
  {
    "sha": "33acf3e74786d0c7fe20807f408b057f24e6b064",
    "filename": "src/main/java/org/apache/commons/lang3/ArrayUtils.java",
    "status": "modified",
    "additions": 440,
    "deletions": 151,
    "changes": 591,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArrayUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ArrayUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ArrayUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -41,7 +41,7 @@\n  * <p>This class tries to handle {@code null} input gracefully.\n  * An exception will not be thrown for a {@code null}\n  * array input. However, an Object array that contains a {@code null}\n- * element may throw an exception. Each method documents its behaviour.\n+ * element may throw an exception. Each method documents its behavior.\n  *\n  * <p>#ThreadSafe#\n  * @since 2.0\n@@ -100,13 +100,6 @@\n      */\n     public static final Field[] EMPTY_FIELD_ARRAY = new Field[0];\n \n-    /**\n-     * An empty immutable {@code Method} array.\n-     *\n-     * @since 3.10\n-     */\n-    public static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n-\n     /**\n      * An empty immutable {@code float} array.\n      */\n@@ -137,6 +130,13 @@\n      */\n     public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n \n+    /**\n+     * An empty immutable {@code Method} array.\n+     *\n+     * @since 3.10\n+     */\n+    public static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n+\n     /**\n      * An empty immutable {@code Object} array.\n      */\n@@ -785,7 +785,7 @@ private static Object add(final Object array, final int index, final Object elem\n      * @throws IllegalArgumentException if both arguments are null\n      */\n     public static <T> T[] add(final T[] array, final T element) {\n-        Class<?> type;\n+        final Class<?> type;\n         if (array != null) {\n             type = array.getClass().getComponentType();\n         } else if (element != null) {\n@@ -820,7 +820,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static boolean[] addAll(final boolean[] array1, final boolean... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final boolean[] joinedArray = new boolean[array1.length + array2.length];\n@@ -849,7 +850,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static byte[] addAll(final byte[] array1, final byte... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final byte[] joinedArray = new byte[array1.length + array2.length];\n@@ -878,7 +880,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static char[] addAll(final char[] array1, final char... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final char[] joinedArray = new char[array1.length + array2.length];\n@@ -907,7 +910,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static double[] addAll(final double[] array1, final double... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final double[] joinedArray = new double[array1.length + array2.length];\n@@ -936,7 +940,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static float[] addAll(final float[] array1, final float... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final float[] joinedArray = new float[array1.length + array2.length];\n@@ -965,7 +970,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static int[] addAll(final int[] array1, final int... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final int[] joinedArray = new int[array1.length + array2.length];\n@@ -994,7 +1000,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static long[] addAll(final long[] array1, final long... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final long[] joinedArray = new long[array1.length + array2.length];\n@@ -1023,7 +1030,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static short[] addAll(final short[] array1, final short... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final short[] joinedArray = new short[array1.length + array2.length];\n@@ -1059,7 +1067,8 @@ private static Object add(final Object array, final int index, final Object elem\n     public static <T> T[] addAll(final T[] array1, @SuppressWarnings(\"unchecked\") final T... array2) {\n         if (array1 == null) {\n             return clone(array2);\n-        } else if (array2 == null) {\n+        }\n+        if (array2 == null) {\n             return clone(array1);\n         }\n         final Class<?> type1 = array1.getClass().getComponentType();\n@@ -1099,9 +1108,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, true)          = [true]\n-     * ArrayUtils.add([true], false)       = [false, true]\n-     * ArrayUtils.add([true, false], true) = [true, true, false]\n+     * ArrayUtils.addFirst(null, true)          = [true]\n+     * ArrayUtils.addFirst([true], false)       = [false, true]\n+     * ArrayUtils.addFirst([true, false], true) = [true, true, false]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1128,9 +1137,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1157,9 +1166,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, '1')       = ['1']\n-     * ArrayUtils.add(['1'], '0')      = ['0', '1']\n-     * ArrayUtils.add(['1', '0'], '1') = ['1', '1', '0']\n+     * ArrayUtils.addFirst(null, '1')       = ['1']\n+     * ArrayUtils.addFirst(['1'], '0')      = ['0', '1']\n+     * ArrayUtils.addFirst(['1', '0'], '1') = ['1', '1', '0']\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1186,9 +1195,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1215,9 +1224,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1244,9 +1253,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1273,9 +1282,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1302,9 +1311,9 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, 1)   = [1]\n-     * ArrayUtils.add([1], 0)    = [0, 1]\n-     * ArrayUtils.add([1, 0], 1) = [1, 1, 0]\n+     * ArrayUtils.addFirst(null, 1)   = [1]\n+     * ArrayUtils.addFirst([1], 0)    = [0, 1]\n+     * ArrayUtils.addFirst([1, 0], 1) = [1, 1, 0]\n      * </pre>\n      *\n      * @param array the array to \"add\" the element to, may be {@code null}.\n@@ -1331,11 +1340,11 @@ private static Object add(final Object array, final int index, final Object elem\n      * </p>\n      *\n      * <pre>\n-     * ArrayUtils.add(null, null)      = IllegalArgumentException\n-     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n-     * ArrayUtils.add([\"a\"], null)     = [null, \"a\"]\n-     * ArrayUtils.add([\"a\"], \"b\")      = [\"b\", \"a\"]\n-     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"c\", \"a\", \"b\"]\n+     * ArrayUtils.addFirst(null, null)      = IllegalArgumentException\n+     * ArrayUtils.addFirst(null, \"a\")       = [\"a\"]\n+     * ArrayUtils.addFirst([\"a\"], null)     = [null, \"a\"]\n+     * ArrayUtils.addFirst([\"a\"], \"b\")      = [\"b\", \"a\"]\n+     * ArrayUtils.addFirst([\"a\", \"b\"], \"c\") = [\"c\", \"a\", \"b\"]\n      * </pre>\n      *\n      * @param <T> the component type of the array\n@@ -1655,6 +1664,33 @@ private static Object copyArrayGrow1(final Object array, final Class<?> newArray\n         return Array.newInstance(newArrayComponentType, 1);\n     }\n \n+    /**\n+     * Gets the nTh element of an array or null if the index is out of bounds or the array is null.\n+     *\n+     * @param <T> The type of array elements.\n+     * @param array The array to index.\n+     * @param index The index\n+     * @return the nTh element of an array or null if the index is out of bounds or the array is null.\n+     * @since 3.11\n+     */\n+    public static <T> T get(final T[] array, final int index) {\n+        return get(array, index, null);\n+    }\n+\n+    /**\n+     * Gets the nTh element of an array or a default value if the index is out of bounds.\n+     *\n+     * @param <T> The type of array elements.\n+     * @param array The array to index.\n+     * @param index The index\n+     * @param defaultValue The return value of the given index is out of bounds.\n+     * @return the nTh element of an array or a default value if the index is out of bounds.\n+     * @since 3.11\n+     */\n+    public static <T> T get(final T[] array, final int index, final T defaultValue) {\n+        return isArrayIndexValid(array, index) ? array[index] : defaultValue;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * <p>Returns the length of the specified array.\n@@ -2410,8 +2446,10 @@ public static int indexOf(final double[] array, final double valueToFind, int st\n         if (startIndex < 0) {\n             startIndex = 0;\n         }\n+        final boolean searchNaN = Double.isNaN(valueToFind);\n         for (int i = startIndex; i < array.length; i++) {\n-            if (valueToFind == array[i]) {\n+            final double element = array[i];\n+            if (valueToFind == element || (searchNaN && Double.isNaN(element))) {\n                 return i;\n             }\n         }\n@@ -2489,58 +2527,60 @@ public static int indexOf(final float[] array, final float valueToFind, int star\n         if (startIndex < 0) {\n             startIndex = 0;\n         }\n+        final boolean searchNaN = Float.isNaN(valueToFind);\n         for (int i = startIndex; i < array.length; i++) {\n-            if (valueToFind == array[i]) {\n+            final float element = array[i];\n+            if (valueToFind == element || (searchNaN && Float.isNaN(element))) {\n                 return i;\n             }\n         }\n         return INDEX_NOT_FOUND;\n     }\n \n-   // int IndexOf\n-//-----------------------------------------------------------------------\n-/**\n- * <p>Finds the index of the given value in the array.\n- *\n- * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n- *\n- * @param array  the array to search through for the object, may be {@code null}\n- * @param valueToFind  the value to find\n- * @return the index of the value within the array,\n- *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n- */\n-public static int indexOf(final int[] array, final int valueToFind) {\n-    return indexOf(array, valueToFind, 0);\n-}\n-\n+    // int IndexOf\n+    //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the index of the given value in the array starting at the given index.\n+     * <p>Finds the index of the given value in the array.\n      *\n      * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n      *\n-     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n-     * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).\n-     *\n      * @param array  the array to search through for the object, may be {@code null}\n      * @param valueToFind  the value to find\n-     * @param startIndex  the index to start searching at\n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n-        if (array == null) {\n-            return INDEX_NOT_FOUND;\n-        }\n-        if (startIndex < 0) {\n-            startIndex = 0;\n-        }\n-        for (int i = startIndex; i < array.length; i++) {\n-            if (valueToFind == array[i]) {\n-                return i;\n-            }\n-        }\n+    public static int indexOf(final int[] array, final int valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+   /**\n+ * <p>Finds the index of the given value in the array starting at the given index.\n+ *\n+ * <p>This method returns {@link #INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n+ *\n+ * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+ * length will return {@link #INDEX_NOT_FOUND} ({@code -1}).\n+ *\n+ * @param array  the array to search through for the object, may be {@code null}\n+ * @param valueToFind  the value to find\n+ * @param startIndex  the index to start searching at\n+ * @return the index of the value within the array,\n+ *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n+ */\n+public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n+    if (array == null) {\n         return INDEX_NOT_FOUND;\n     }\n+    if (startIndex < 0) {\n+        startIndex = 0;\n+    }\n+    for (int i = startIndex; i < array.length; i++) {\n+        if (valueToFind == array[i]) {\n+            return i;\n+        }\n+    }\n+    return INDEX_NOT_FOUND;\n+}\n \n     // long IndexOf\n     //-----------------------------------------------------------------------\n@@ -3078,18 +3118,21 @@ public static int indexOf(final short[] array, final short valueToFind, int star\n \n     /**\n      * Returns whether a given array can safely be accessed at the given index.\n+     *\n+     * <pre>\n+     * ArrayUtils.isArrayIndexValid(null, 0)       = false\n+     * ArrayUtils.isArrayIndexValid([], 0)         = false\n+     * ArrayUtils.isArrayIndexValid([\"a\"], 0)      = true\n+     * </pre>\n+     *\n      * @param <T> the component type of the array\n      * @param array the array to inspect, may be null\n      * @param index the index of the array to be inspected\n      * @return Whether the given index is safely-accessible in the given array\n      * @since 3.8\n      */\n     public static <T> boolean isArrayIndexValid(final T[] array, final int index) {\n-        if (getLength(array) == 0 || array.length <= index) {\n-            return false;\n-        }\n-\n-        return index >= 0;\n+        return index >= 0 && getLength(array) > index;\n     }\n \n     /**\n@@ -3103,9 +3146,6 @@ public static boolean isEmpty(final boolean[] array) {\n         return getLength(array) == 0;\n     }\n \n-    // IndexOf search\n-    // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Checks if an array of primitive bytes is empty or {@code null}.\n      *\n@@ -3117,6 +3157,9 @@ public static boolean isEmpty(final byte[] array) {\n         return getLength(array) == 0;\n     }\n \n+    // IndexOf search\n+    // ----------------------------------------------------------------------\n+\n     /**\n      * <p>Checks if an array of primitive chars is empty or {@code null}.\n      *\n@@ -3150,8 +3193,6 @@ public static boolean isEmpty(final float[] array) {\n         return getLength(array) == 0;\n     }\n \n-\n-\n     /**\n      * <p>Checks if an array of primitive ints is empty or {@code null}.\n      *\n@@ -3163,6 +3204,8 @@ public static boolean isEmpty(final int[] array) {\n         return getLength(array) == 0;\n     }\n \n+\n+\n     /**\n      * <p>Checks if an array of primitive longs is empty or {@code null}.\n      *\n@@ -3406,8 +3449,23 @@ public static boolean isSameLength(final long[] array1, final long[] array2) {\n         return getLength(array1) == getLength(array2);\n     }\n \n-    // Is same length\n-    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * {@code null} arrays as length {@code 0}.\n+     *\n+     * <p>Any multi-dimensional aspects of the arrays are ignored.\n+     *\n+     * @param array1 the first array, may be {@code null}\n+     * @param array2 the second array, may be {@code null}\n+     * @return {@code true} if length of arrays matches, treating\n+     *  {@code null} as an empty array\n+     * @since 3.11\n+     */\n+    public static boolean isSameLength(final Object array1, final Object array2) {\n+        return getLength(array1) == getLength(array2);\n+    }\n+\n+\n     /**\n      * <p>Checks whether two arrays are the same length, treating\n      * {@code null} arrays as length {@code 0}.\n@@ -3663,7 +3721,7 @@ public static boolean isSorted(final short[] array) {\n      * @since 3.4\n      */\n     public static <T extends Comparable<? super T>> boolean isSorted(final T[] array) {\n-        return isSorted(array, (o1, o2) -> o1.compareTo(o2));\n+        return isSorted(array, Comparable::compareTo);\n     }\n \n     /**\n@@ -3732,7 +3790,8 @@ public static int lastIndexOf(final boolean[] array, final boolean valueToFind,\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -3777,7 +3836,8 @@ public static int lastIndexOf(final byte[] array, final byte valueToFind, int st\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -3824,7 +3884,8 @@ public static int lastIndexOf(final char[] array, final char valueToFind, int st\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -3886,7 +3947,8 @@ public static int lastIndexOf(final double[] array, final double valueToFind, in\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -3920,7 +3982,8 @@ public static int lastIndexOf(final double[] array, final double valueToFind, in\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         final double min = valueToFind - tolerance;\n@@ -3933,7 +3996,6 @@ public static int lastIndexOf(final double[] array, final double valueToFind, in\n         return INDEX_NOT_FOUND;\n     }\n \n-\n     /**\n      * <p>Finds the last index of the given value within the array.\n      *\n@@ -3948,6 +4010,7 @@ public static int lastIndexOf(final float[] array, final float valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n+\n     /**\n      * <p>Finds the last index of the given value in the array starting at the given index.\n      *\n@@ -3968,7 +4031,8 @@ public static int lastIndexOf(final float[] array, final float valueToFind, int\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -4013,7 +4077,8 @@ public static int lastIndexOf(final int[] array, final int valueToFind, int star\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -4058,7 +4123,8 @@ public static int lastIndexOf(final long[] array, final long valueToFind, int st\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -4103,7 +4169,8 @@ public static int lastIndexOf(final Object[] array, final Object objectToFind, i\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         if (objectToFind == null) {\n@@ -4156,7 +4223,8 @@ public static int lastIndexOf(final short[] array, final short valueToFind, int\n         }\n         if (startIndex < 0) {\n             return INDEX_NOT_FOUND;\n-        } else if (startIndex >= array.length) {\n+        }\n+        if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n         for (int i = startIndex; i >= 0; i--) {\n@@ -4407,9 +4475,6 @@ public static int lastIndexOf(final short[] array, final short valueToFind, int\n         return array;\n     }\n \n-    // Primitive/Object array converters\n-    // ----------------------------------------------------------------------\n-\n     /**\n      * <p>Defensive programming technique to change a {@code null}\n      * reference to an empty one.\n@@ -4430,6 +4495,9 @@ public static int lastIndexOf(final short[] array, final short valueToFind, int\n         return array;\n     }\n \n+    // Primitive/Object array converters\n+    // ----------------------------------------------------------------------\n+\n     /**\n      * <p>Defensive programming technique to change a {@code null}\n      * reference to an empty one.\n@@ -5145,7 +5213,7 @@ static Object removeAll(final Object array, final BitSet indices) {\n \n         final int srcLength = getLength(array);\n         // No need to check maxIndex here, because method only currently called from removeElements()\n-        // which guarantee to generate on;y valid bit entries.\n+        // which guarantee to generate only valid bit entries.\n //        final int maxIndex = indices.length();\n //        if (maxIndex > srcLength) {\n //            throw new IndexOutOfBoundsException(\"Index: \" + (maxIndex-1) + \", Length: \" + srcLength);\n@@ -5182,8 +5250,7 @@ static Object removeAll(final Object array, final BitSet indices) {\n     static Object removeAll(final Object array, final int... indices) {\n         final int length = getLength(array);\n         int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed\n-        final int[] clonedIndices = clone(indices);\n-        Arrays.sort(clonedIndices);\n+        final int[] clonedIndices = ArraySorter.sort(clone(indices));\n \n         // identify length of result array\n         if (isNotEmpty(clonedIndices)) {\n@@ -5213,7 +5280,7 @@ static Object removeAll(final Object array, final int... indices) {\n                     final int cp = end - index - 1;\n                     dest -= cp;\n                     System.arraycopy(array, index + 1, result, dest, cp);\n-                    // Afer this copy, we still have room for dest items.\n+                    // After this copy, we still have room for dest items.\n                 }\n                 end = index;\n             }\n@@ -5302,7 +5369,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(boolean[], boolean)}\n      */\n+    @Deprecated\n     public static boolean[] removeAllOccurences(final boolean[] array, final boolean element) {\n         return (boolean[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5321,7 +5390,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(byte[], byte)}\n      */\n+    @Deprecated\n     public static byte[] removeAllOccurences(final byte[] array, final byte element) {\n         return (byte[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5340,7 +5411,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(char[], char)}\n      */\n+    @Deprecated\n     public static char[] removeAllOccurences(final char[] array, final char element) {\n         return (char[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5359,7 +5432,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(double[], double)}\n      */\n+    @Deprecated\n     public static double[] removeAllOccurences(final double[] array, final double element) {\n         return (double[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5378,7 +5453,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(float[], float)}\n      */\n+    @Deprecated\n     public static float[] removeAllOccurences(final float[] array, final float element) {\n         return (float[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5397,7 +5474,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(int[], int)}\n      */\n+    @Deprecated\n     public static int[] removeAllOccurences(final int[] array, final int element) {\n         return (int[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5416,7 +5495,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(long[], long)}\n      */\n+    @Deprecated\n     public static long[] removeAllOccurences(final long[] array, final long element) {\n         return (long[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5435,7 +5516,9 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(short[], short)}\n      */\n+    @Deprecated\n     public static short[] removeAllOccurences(final short[] array, final short element) {\n         return (short[]) removeAll((Object) array, indexesOf(array, element));\n     }\n@@ -5455,11 +5538,185 @@ static Object removeAll(final Object array, final int... indices) {\n      *\n      * @return A new array containing the existing elements except the occurrences of the specified element.\n      * @since 3.5\n+     * @deprecated Use {@link #removeAllOccurrences(Object[], Object)}\n      */\n+    @Deprecated\n     public static <T> T[] removeAllOccurences(final T[] array, final T element) {\n         return (T[]) removeAll((Object) array, indexesOf(array, element));\n     }\n \n+    /**\n+     * Removes the occurrences of the specified element from the specified boolean array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static boolean[] removeAllOccurrences(final boolean[] array, final boolean element) {\n+        return (boolean[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified byte array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static byte[] removeAllOccurrences(final byte[] array, final byte element) {\n+        return (byte[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified char array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static char[] removeAllOccurrences(final char[] array, final char element) {\n+        return (char[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified double array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static double[] removeAllOccurrences(final double[] array, final double element) {\n+        return (double[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified float array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static float[] removeAllOccurrences(final float[] array, final float element) {\n+        return (float[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified int array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static int[] removeAllOccurrences(final int[] array, final int element) {\n+        return (int[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified long array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static long[] removeAllOccurrences(final long[] array, final long element) {\n+        return (long[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified short array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static short[] removeAllOccurrences(final short[] array, final short element) {\n+        return (short[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n+    /**\n+     * Removes the occurrences of the specified element from the specified array.\n+     *\n+     * <p>\n+     * All subsequent elements are shifted to the left (subtracts one from their indices).\n+     * If the array doesn't contains such an element, no elements are removed from the array.\n+     * {@code null} will be returned if the input array is {@code null}.\n+     * </p>\n+     *\n+     * @param <T> the type of object in the array\n+     * @param element the element to remove\n+     * @param array the input array\n+     *\n+     * @return A new array containing the existing elements except the occurrences of the specified element.\n+     * @since 3.10\n+     */\n+    public static <T> T[] removeAllOccurrences(final T[] array, final T element) {\n+        return (T[]) removeAll((Object) array, indexesOf(array, element));\n+    }\n+\n     /**\n      * <p>Removes the first occurrence of the specified element from the\n      * specified array. All subsequent elements are shifted to the left\n@@ -6291,7 +6548,7 @@ public static void reverse(final boolean[] array, final int startIndexInclusive,\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         boolean tmp;\n         while (j > i) {\n@@ -6338,7 +6595,7 @@ public static void reverse(final byte[] array, final int startIndexInclusive, fi\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         byte tmp;\n         while (j > i) {\n@@ -6385,7 +6642,7 @@ public static void reverse(final char[] array, final int startIndexInclusive, fi\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         char tmp;\n         while (j > i) {\n@@ -6432,7 +6689,7 @@ public static void reverse(final double[] array, final int startIndexInclusive,\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         double tmp;\n         while (j > i) {\n@@ -6479,7 +6736,7 @@ public static void reverse(final float[] array, final int startIndexInclusive, f\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         float tmp;\n         while (j > i) {\n@@ -6526,7 +6783,7 @@ public static void reverse(final int[] array, final int startIndexInclusive, fin\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         int tmp;\n         while (j > i) {\n@@ -6573,7 +6830,7 @@ public static void reverse(final long[] array, final int startIndexInclusive, fi\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         long tmp;\n         while (j > i) {\n@@ -6585,8 +6842,6 @@ public static void reverse(final long[] array, final int startIndexInclusive, fi\n         }\n     }\n \n-    // Reverse\n-    //-----------------------------------------------------------------------\n     /**\n      * <p>Reverses the order of the given array.\n      *\n@@ -6624,7 +6879,7 @@ public static void reverse(final Object[] array, final int startIndexInclusive,\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         Object tmp;\n         while (j > i) {\n@@ -6671,7 +6926,7 @@ public static void reverse(final short[] array, final int startIndexInclusive, f\n         if (array == null) {\n             return;\n         }\n-        int i = startIndexInclusive < 0 ? 0 : startIndexInclusive;\n+        int i = Math.max(startIndexInclusive, 0);\n         int j = Math.min(array.length, endIndexExclusive) - 1;\n         short tmp;\n         while (j > i) {\n@@ -8742,7 +8997,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Boolean[] toObject(final boolean[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BOOLEAN_OBJECT_ARRAY;\n         }\n         final Boolean[] result = new Boolean[array.length];\n@@ -8763,7 +9019,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Byte[] toObject(final byte[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BYTE_OBJECT_ARRAY;\n         }\n         final Byte[] result = new Byte[array.length];\n@@ -8784,7 +9041,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Character[] toObject(final char[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_CHARACTER_OBJECT_ARRAY;\n         }\n         final Character[] result = new Character[array.length];\n@@ -8805,7 +9063,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Double[] toObject(final double[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_DOUBLE_OBJECT_ARRAY;\n         }\n         final Double[] result = new Double[array.length];\n@@ -8826,7 +9085,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Float[] toObject(final float[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_FLOAT_OBJECT_ARRAY;\n         }\n         final Float[] result = new Float[array.length];\n@@ -8847,7 +9107,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Integer[] toObject(final int[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_INTEGER_OBJECT_ARRAY;\n         }\n         final Integer[] result = new Integer[array.length];\n@@ -8868,7 +9129,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Long[] toObject(final long[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_LONG_OBJECT_ARRAY;\n         }\n         final Long[] result = new Long[array.length];\n@@ -8889,7 +9151,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static Short[] toObject(final short[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_SHORT_OBJECT_ARRAY;\n         }\n         final Short[] result = new Short[array.length];\n@@ -8913,7 +9176,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static boolean[] toPrimitive(final Boolean[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BOOLEAN_ARRAY;\n         }\n         final boolean[] result = new boolean[array.length];\n@@ -8935,7 +9199,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BOOLEAN_ARRAY;\n         }\n         final boolean[] result = new boolean[array.length];\n@@ -8960,7 +9225,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static byte[] toPrimitive(final Byte[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte[] result = new byte[array.length];\n@@ -8982,7 +9248,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_BYTE_ARRAY;\n         }\n         final byte[] result = new byte[array.length];\n@@ -9007,7 +9274,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static char[] toPrimitive(final Character[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_CHAR_ARRAY;\n         }\n         final char[] result = new char[array.length];\n@@ -9029,7 +9297,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_CHAR_ARRAY;\n         }\n         final char[] result = new char[array.length];\n@@ -9054,7 +9323,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static double[] toPrimitive(final Double[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_DOUBLE_ARRAY;\n         }\n         final double[] result = new double[array.length];\n@@ -9076,7 +9346,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_DOUBLE_ARRAY;\n         }\n         final double[] result = new double[array.length];\n@@ -9101,7 +9372,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static float[] toPrimitive(final Float[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_FLOAT_ARRAY;\n         }\n         final float[] result = new float[array.length];\n@@ -9123,7 +9395,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_FLOAT_ARRAY;\n         }\n         final float[] result = new float[array.length];\n@@ -9148,7 +9421,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static int[] toPrimitive(final Integer[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_INT_ARRAY;\n         }\n         final int[] result = new int[array.length];\n@@ -9170,7 +9444,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_INT_ARRAY;\n         }\n         final int[] result = new int[array.length];\n@@ -9195,7 +9470,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static long[] toPrimitive(final Long[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_LONG_ARRAY;\n         }\n         final long[] result = new long[array.length];\n@@ -9217,7 +9493,8 @@ public static void swap(final short[] array,  int offset1, int offset2, int len)\n     public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_LONG_ARRAY;\n         }\n         final long[] result = new long[array.length];\n@@ -9243,6 +9520,15 @@ public static Object toPrimitive(final Object array) {\n         }\n         final Class<?> ct = array.getClass().getComponentType();\n         final Class<?> pt = ClassUtils.wrapperToPrimitive(ct);\n+        if (Boolean.TYPE.equals(pt)) {\n+            return toPrimitive((Boolean[]) array);\n+        }\n+        if (Character.TYPE.equals(pt)) {\n+            return toPrimitive((Character[]) array);\n+        }\n+        if (Byte.TYPE.equals(pt)) {\n+            return toPrimitive((Byte[]) array);\n+        }\n         if (Integer.TYPE.equals(pt)) {\n             return toPrimitive((Integer[]) array);\n         }\n@@ -9275,7 +9561,8 @@ public static Object toPrimitive(final Object array) {\n     public static short[] toPrimitive(final Short[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_SHORT_ARRAY;\n         }\n         final short[] result = new short[array.length];\n@@ -9297,7 +9584,8 @@ public static Object toPrimitive(final Object array) {\n     public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_SHORT_ARRAY;\n         }\n         final short[] result = new short[array.length];\n@@ -9358,7 +9646,8 @@ public static String toString(final Object array, final String stringIfNull) {\n     public static String[] toStringArray(final Object[] array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_STRING_ARRAY;\n         }\n \n@@ -9384,7 +9673,8 @@ public static String toString(final Object array, final String stringIfNull) {\n     public static String[] toStringArray(final Object[] array, final String valueForNullElements) {\n         if (null == array) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return EMPTY_STRING_ARRAY;\n         }\n \n@@ -9405,6 +9695,5 @@ public static String toString(final Object array, final String stringIfNull) {\n      * to operate.\n      */\n     public ArrayUtils() {\n-      super();\n     }\n }"
  },
  {
    "sha": "5b566a3313171442e47fd19138e94c0f94a3d7a2",
    "filename": "src/main/java/org/apache/commons/lang3/BooleanUtils.java",
    "status": "modified",
    "additions": 515,
    "deletions": 502,
    "changes": 1017,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/BooleanUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/BooleanUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/BooleanUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -23,86 +23,136 @@\n  *\n  * <p>This class tries to handle {@code null} input gracefully.\n  * An exception will not be thrown for a {@code null} input.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * <p>#ThreadSafe#</p>\n  * @since 2.0\n  */\n public class BooleanUtils {\n+    /**\n+     * The false String {@code \"false\"}.\n+     *\n+     * @since 3.12.0\n+     */\n+    public static final String FALSE = \"false\";\n \n     /**\n-     * <p>{@code BooleanUtils} instances should NOT be constructed in standard programming.\n-     * Instead, the class should be used as {@code BooleanUtils.negate(true);}.</p>\n+     * The no String {@code \"no\"}.\n      *\n-     * <p>This constructor is public to permit tools that require a JavaBean instance\n-     * to operate.</p>\n+     * @since 3.12.0\n      */\n-    public BooleanUtils() {\n-      super();\n-    }\n+    public static final String NO = \"no\";\n \n-    // Boolean utilities\n-    //--------------------------------------------------------------------------\n     /**\n-     * <p>Negates the specified boolean.</p>\n+     * The off String {@code \"off\"}.\n      *\n-     * <p>If {@code null} is passed in, {@code null} will be returned.</p>\n+     * @since 3.12.0\n+     */\n+    public static final String OFF = \"off\";\n+\n+    /**\n+     * The on String {@code \"on\"}.\n      *\n-     * <p>NOTE: This returns {@code null} and will throw a {@code NullPointerException}\n-     * if unboxed to a boolean. </p>\n+     * @since 3.12.0\n+     */\n+    public static final String ON = \"on\";\n+\n+    /**\n+     * The true String {@code \"true\"}.\n+     *\n+     * @since 3.12.0\n+     */\n+    public static final String TRUE = \"true\";\n+\n+    /**\n+     * The yes String {@code \"yes\"}.\n+     *\n+     * @since 3.12.0\n+     */\n+    public static final String YES = \"yes\";\n+\n+    /**\n+     * <p>Performs an 'and' operation on a set of booleans.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n-     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n-     *   BooleanUtils.negate(null)          = null;\n+     *   BooleanUtils.and(true, true)         = true\n+     *   BooleanUtils.and(false, false)       = false\n+     *   BooleanUtils.and(true, false)        = false\n+     *   BooleanUtils.and(true, true, false)  = false\n+     *   BooleanUtils.and(true, true, true)   = true\n      * </pre>\n      *\n-     * @param bool  the Boolean to negate, may be null\n-     * @return the negated Boolean, or {@code null} if {@code null} input\n+     * @param array  an array of {@code boolean}s\n+     * @return the result of the logical 'and' operation. That is {@code false}\n+     * if any of the parameters is {@code false} and {@code true} otherwise.\n+     * @throws NullPointerException if {@code array} is {@code null}\n+     * @throws IllegalArgumentException if {@code array} is empty.\n+     * @since 3.0.1\n      */\n-    public static Boolean negate(final Boolean bool) {\n-        if (bool == null) {\n-            return null;\n+    public static boolean and(final boolean... array) {\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n+        for (final boolean element : array) {\n+            if (!element) {\n+                return false;\n+            }\n         }\n-        return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;\n+        return true;\n     }\n \n-    // boolean Boolean methods\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if a {@code Boolean} value is {@code true},\n-     * handling {@code null} by returning {@code false}.</p>\n+     * <p>Performs an 'and' operation on an array of Booleans.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n-     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n-     *   BooleanUtils.isTrue(null)          = false\n+     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE)                 = Boolean.TRUE\n+     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE)               = Boolean.FALSE\n+     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE)                = Boolean.FALSE\n+     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)   = Boolean.TRUE\n+     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE) = Boolean.FALSE\n+     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)  = Boolean.FALSE\n      * </pre>\n      *\n-     * @param bool the boolean to check, {@code null} returns {@code false}\n-     * @return {@code true} only if the input is non-null and true\n-     * @since 2.1\n+     * @param array  an array of {@code Boolean}s\n+     * @return the result of the logical 'and' operation. That is {@code false}\n+     * if any of the parameters is {@code false} and {@code true} otherwise.\n+     * @throws NullPointerException if {@code array} is {@code null}\n+     * @throws IllegalArgumentException if {@code array} is empty.\n+     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n+     * @since 3.0.1\n      */\n-    public static boolean isTrue(final Boolean bool) {\n-        return Boolean.TRUE.equals(bool);\n+    public static Boolean and(final Boolean... array) {\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n+        try {\n+            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n+            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n+        } catch (final NullPointerException ex) {\n+            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n+        }\n     }\n \n     /**\n-     * <p>Checks if a {@code Boolean} value is <i>not</i> {@code true},\n-     * handling {@code null} by returning {@code true}.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n-     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n-     *   BooleanUtils.isNotTrue(null)          = true\n-     * </pre>\n+     * Returns a new array of possible values (like an enum would).\n+     * @return a new array of possible values (like an enum would).\n+     * @since 3.12.0\n+     */\n+    public static Boolean[] booleanValues() {\n+        return new Boolean[] {Boolean.FALSE, Boolean.TRUE};\n+    }\n+\n+    /**\n+     * <p>Compares two {@code boolean} values. This is the same functionality as provided in Java 7.</p>\n      *\n-     * @param bool  the boolean to check, null returns {@code true}\n-     * @return {@code true} if the input is null or false\n-     * @since 2.3\n+     * @param x the first {@code boolean} to compare\n+     * @param y the second {@code boolean} to compare\n+     * @return the value {@code 0} if {@code x == y};\n+     *         a value less than {@code 0} if {@code !x && y}; and\n+     *         a value greater than {@code 0} if {@code x && !y}\n+     * @since 3.4\n      */\n-    public static boolean isNotTrue(final Boolean bool) {\n-        return !isTrue(bool);\n+    public static int compare(final boolean x, final boolean y) {\n+        if (x == y) {\n+            return 0;\n+        }\n+        return x ? 1 : -1;\n     }\n \n     /**\n@@ -141,109 +191,165 @@ public static boolean isNotFalse(final Boolean bool) {\n         return !isFalse(bool);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts a Boolean to a boolean handling {@code null}\n-     * by returning {@code false}.</p>\n+     * <p>Checks if a {@code Boolean} value is <i>not</i> {@code true},\n+     * handling {@code null} by returning {@code true}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n-     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n-     *   BooleanUtils.toBoolean(null)          = false\n+     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n+     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n+     *   BooleanUtils.isNotTrue(null)          = true\n      * </pre>\n      *\n-     * @param bool  the boolean to convert\n-     * @return {@code true} or {@code false}, {@code null} returns {@code false}\n+     * @param bool  the boolean to check, null returns {@code true}\n+     * @return {@code true} if the input is null or false\n+     * @since 2.3\n      */\n-    public static boolean toBoolean(final Boolean bool) {\n-        return bool != null && bool.booleanValue();\n+    public static boolean isNotTrue(final Boolean bool) {\n+        return !isTrue(bool);\n     }\n \n     /**\n-     * <p>Converts a Boolean to a boolean handling {@code null}.</p>\n+     * <p>Checks if a {@code Boolean} value is {@code true},\n+     * handling {@code null} by returning {@code false}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false)  = true\n-     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true)   = true\n-     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true)  = false\n-     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false) = false\n-     *   BooleanUtils.toBooleanDefaultIfNull(null, true)           = true\n-     *   BooleanUtils.toBooleanDefaultIfNull(null, false)          = false\n+     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n+     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n+     *   BooleanUtils.isTrue(null)          = false\n      * </pre>\n      *\n-     * @param bool  the boolean object to convert to primitive\n-     * @param valueIfNull  the boolean value to return if the parameter {@code bool} is {@code null}\n-     * @return {@code true} or {@code false}\n+     * @param bool the boolean to check, {@code null} returns {@code false}\n+     * @return {@code true} only if the input is non-null and true\n+     * @since 2.1\n      */\n-    public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {\n+    public static boolean isTrue(final Boolean bool) {\n+        return Boolean.TRUE.equals(bool);\n+    }\n+\n+    /**\n+     * <p>Negates the specified boolean.</p>\n+     *\n+     * <p>If {@code null} is passed in, {@code null} will be returned.</p>\n+     *\n+     * <p>NOTE: This returns {@code null} and will throw a {@code NullPointerException}\n+     * if unboxed to a boolean. </p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n+     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n+     *   BooleanUtils.negate(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to negate, may be null\n+     * @return the negated Boolean, or {@code null} if {@code null} input\n+     */\n+    public static Boolean negate(final Boolean bool) {\n         if (bool == null) {\n-            return valueIfNull;\n+            return null;\n         }\n-        return bool.booleanValue();\n+        return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;\n     }\n-\n-    // Integer to Boolean methods\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts an int to a boolean using the convention that {@code zero}\n-     * is {@code false}, everything else is {@code true}.</p>\n+     * <p>Performs an 'or' operation on a set of booleans.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(0) = false\n-     *   BooleanUtils.toBoolean(1) = true\n-     *   BooleanUtils.toBoolean(2) = true\n+     *   BooleanUtils.or(true, true)          = true\n+     *   BooleanUtils.or(false, false)        = false\n+     *   BooleanUtils.or(true, false)         = true\n+     *   BooleanUtils.or(true, true, false)   = true\n+     *   BooleanUtils.or(true, true, true)    = true\n+     *   BooleanUtils.or(false, false, false) = false\n      * </pre>\n      *\n-     * @param value  the int to convert\n-     * @return {@code true} if non-zero, {@code false}\n-     *  if zero\n+     * @param array  an array of {@code boolean}s\n+     * @return {@code true} if any of the arguments is {@code true}, and it returns {@code false} otherwise.\n+     * @throws NullPointerException if {@code array} is {@code null}\n+     * @throws IllegalArgumentException if {@code array} is empty.\n+     * @since 3.0.1\n      */\n-    public static boolean toBoolean(final int value) {\n-        return value != 0;\n+    public static boolean or(final boolean... array) {\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n+        for (final boolean element : array) {\n+            if (element) {\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n \n     /**\n-     * <p>Converts an int to a Boolean using the convention that {@code zero}\n-     * is {@code false}, everything else is {@code true}.</p>\n+     * <p>Performs an 'or' operation on an array of Booleans.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n-     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n-     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE)                  = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE)                = Boolean.FALSE\n+     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE)                 = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)    = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE)  = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)   = Boolean.TRUE\n+     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE) = Boolean.FALSE\n      * </pre>\n      *\n-     * @param value  the int to convert\n-     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n-     *  {@code null} if {@code null}\n+     * @param array  an array of {@code Boolean}s\n+     * @return {@code true} if any of the arguments is {@code true}, and it returns {@code false} otherwise.\n+     * @throws NullPointerException if {@code array} is {@code null}\n+     * @throws IllegalArgumentException if {@code array} is empty.\n+     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n+     * @since 3.0.1\n      */\n-    public static Boolean toBooleanObject(final int value) {\n-        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    public static Boolean or(final Boolean... array) {\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n+        try {\n+            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n+            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n+        } catch (final NullPointerException ex) {\n+            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n+        }\n     }\n \n     /**\n-     * <p>Converts an Integer to a Boolean using the convention that {@code zero}\n-     * is {@code false}, every other numeric value is {@code true}.</p>\n+     * Returns a new array of possible values (like an enum would).\n+     * @return a new array of possible values (like an enum would).\n+     * @since 3.12.0\n+     */\n+    public static boolean[] primitiveValues() {\n+        return new boolean[] {false, true};\n+    }\n+\n+    /**\n+     * <p>Converts a Boolean to a boolean handling {@code null}\n+     * by returning {@code false}.</p>\n      *\n-     * <p>{@code null} will be converted to {@code null}.</p>\n+     * <pre>\n+     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n+     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n+     *   BooleanUtils.toBoolean(null)          = false\n+     * </pre>\n      *\n-     * <p>NOTE: This method may return {@code null} and may throw a {@code NullPointerException}\n-     * if unboxed to a {@code boolean}.</p>\n+     * @param bool  the boolean to convert\n+     * @return {@code true} or {@code false}, {@code null} returns {@code false}\n+     */\n+    public static boolean toBoolean(final Boolean bool) {\n+        return bool != null && bool.booleanValue();\n+    }\n+\n+    /**\n+     * <p>Converts an int to a boolean using the convention that {@code zero}\n+     * is {@code false}, everything else is {@code true}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(Integer.valueOf(0))    = Boolean.FALSE\n-     *   BooleanUtils.toBoolean(Integer.valueOf(1))    = Boolean.TRUE\n-     *   BooleanUtils.toBoolean(Integer.valueOf(null)) = null\n+     *   BooleanUtils.toBoolean(0) = false\n+     *   BooleanUtils.toBoolean(1) = true\n+     *   BooleanUtils.toBoolean(2) = true\n      * </pre>\n      *\n-     * @param value  the Integer to convert\n-     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n-     *  {@code null} if {@code null} input\n+     * @param value  the int to convert\n+     * @return {@code true} if non-zero, {@code false}\n+     *  if zero\n      */\n-    public static Boolean toBooleanObject(final Integer value) {\n-        if (value == null) {\n-            return null;\n-        }\n-        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    public static boolean toBoolean(final int value) {\n+        return value != 0;\n     }\n \n     /**\n@@ -310,6 +416,112 @@ public static boolean toBoolean(final Integer value, final Integer trueValue, fi\n         throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n     }\n \n+    /**\n+     * <p>Converts a String to a boolean (optimised for performance).</p>\n+     *\n+     * <p>{@code 'true'}, {@code 'on'}, {@code 'y'}, {@code 't'} or {@code 'yes'}\n+     * (case insensitive) will return {@code true}. Otherwise,\n+     * {@code false} is returned.</p>\n+     *\n+     * <p>This method performs 4 times faster (JDK1.4) than\n+     * {@code Boolean.valueOf(String)}. However, this method accepts\n+     * 'on' and 'yes', 't', 'y' as true values.\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(null)    = false\n+     *   BooleanUtils.toBoolean(\"true\")  = true\n+     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n+     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n+     *   BooleanUtils.toBoolean(\"on\")    = true\n+     *   BooleanUtils.toBoolean(\"yes\")   = true\n+     *   BooleanUtils.toBoolean(\"false\") = false\n+     *   BooleanUtils.toBoolean(\"x gti\") = false\n+     *   BooleanUtils.toBoolean(\"y\") = true\n+     *   BooleanUtils.toBoolean(\"n\") = false\n+     *   BooleanUtils.toBoolean(\"t\") = true\n+     *   BooleanUtils.toBoolean(\"f\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the boolean value of the string, {@code false} if no match or the String is null\n+     */\n+    public static boolean toBoolean(final String str) {\n+        return toBooleanObject(str) == Boolean.TRUE;\n+    }\n+\n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n+     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for {@code true} (case sensitive), may be {@code null}\n+     * @param falseString  the String to match for {@code false} (case sensitive), may be {@code null}\n+     * @return the boolean value of the string\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static boolean toBoolean(final String str, final String trueString, final String falseString) {\n+        if (str == trueString) {\n+            return true;\n+        }\n+        if (str == falseString) {\n+            return false;\n+        }\n+        if (str != null) {\n+            if (str.equals(trueString)) {\n+                return true;\n+            }\n+            if (str.equals(falseString)) {\n+                return false;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The String did not match either specified value\");\n+    }\n+\n+    /**\n+     * <p>Converts a Boolean to a boolean handling {@code null}.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false)  = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true)   = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true)  = false\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false) = false\n+     *   BooleanUtils.toBooleanDefaultIfNull(null, true)           = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(null, false)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean object to convert to primitive\n+     * @param valueIfNull  the boolean value to return if the parameter {@code bool} is {@code null}\n+     * @return {@code true} or {@code false}\n+     */\n+    public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {\n+        if (bool == null) {\n+            return valueIfNull;\n+        }\n+        return bool.booleanValue();\n+    }\n+\n+    /**\n+     * <p>Converts an int to a Boolean using the convention that {@code zero}\n+     * is {@code false}, everything else is {@code true}.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  {@code null} if {@code null}\n+     */\n+    public static Boolean toBooleanObject(final int value) {\n+        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n     /**\n      * <p>Converts an int to a Boolean specifying the conversion values.</p>\n      *\n@@ -348,6 +560,32 @@ public static Boolean toBooleanObject(final int value, final int trueValue, fina\n         throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n     }\n \n+    /**\n+     * <p>Converts an Integer to a Boolean using the convention that {@code zero}\n+     * is {@code false}, every other numeric value is {@code true}.</p>\n+     *\n+     * <p>{@code null} will be converted to {@code null}.</p>\n+     *\n+     * <p>NOTE: This method may return {@code null} and may throw a {@code NullPointerException}\n+     * if unboxed to a {@code boolean}.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(Integer.valueOf(0))    = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(Integer.valueOf(1))    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(Integer.valueOf(null)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  {@code null} if {@code null} input\n+     */\n+    public static Boolean toBooleanObject(final Integer value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n     /**\n      * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n      *\n@@ -394,148 +632,13 @@ public static Boolean toBooleanObject(final Integer value, final Integer trueVal\n         throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n     }\n \n-    // Boolean to Integer methods\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Converts a boolean to an int using the convention that\n-     * {@code true} is {@code 1} and {@code false} is {@code 0}.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toInteger(true)  = 1\n-     *   BooleanUtils.toInteger(false) = 0\n-     * </pre>\n-     *\n-     * @param bool  the boolean to convert\n-     * @return one if {@code true}, zero if {@code false}\n-     */\n-    public static int toInteger(final boolean bool) {\n-        return bool ? 1 : 0;\n-    }\n-\n-    /**\n-     * <p>Converts a boolean to an Integer using the convention that\n-     * {@code true} is {@code 1} and {@code false} is {@code 0}.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toIntegerObject(true)  = Integer.valueOf(1)\n-     *   BooleanUtils.toIntegerObject(false) = Integer.valueOf(0)\n-     * </pre>\n-     *\n-     * @param bool  the boolean to convert\n-     * @return one if {@code true}, zero if {@code false}\n-     */\n-    public static Integer toIntegerObject(final boolean bool) {\n-        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n-    }\n-\n-    /**\n-     * <p>Converts a Boolean to a Integer using the convention that\n-     * {@code zero} is {@code false}.</p>\n-     *\n-     * <p>{@code null} will be converted to {@code null}.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toIntegerObject(Boolean.TRUE)  = Integer.valueOf(1)\n-     *   BooleanUtils.toIntegerObject(Boolean.FALSE) = Integer.valueOf(0)\n-     * </pre>\n-     *\n-     * @param bool  the Boolean to convert\n-     * @return one if Boolean.TRUE, zero if Boolean.FALSE, {@code null} if {@code null}\n-     */\n-    public static Integer toIntegerObject(final Boolean bool) {\n-        if (bool == null) {\n-            return null;\n-        }\n-        return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n-    }\n-\n-    /**\n-     * <p>Converts a boolean to an int specifying the conversion values.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n-     *   BooleanUtils.toInteger(false, 1, 0) = 0\n-     * </pre>\n-     *\n-     * @param bool  the to convert\n-     * @param trueValue  the value to return if {@code true}\n-     * @param falseValue  the value to return if {@code false}\n-     * @return the appropriate value\n-     */\n-    public static int toInteger(final boolean bool, final int trueValue, final int falseValue) {\n-        return bool ? trueValue : falseValue;\n-    }\n-\n-    /**\n-     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n-     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n-     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n-     * </pre>\n-     *\n-     * @param bool  the Boolean to convert\n-     * @param trueValue  the value to return if {@code true}\n-     * @param falseValue  the value to return if {@code false}\n-     * @param nullValue  the value to return if {@code null}\n-     * @return the appropriate value\n-     */\n-    public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {\n-        if (bool == null) {\n-            return nullValue;\n-        }\n-        return bool.booleanValue() ? trueValue : falseValue;\n-    }\n-\n-    /**\n-     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toIntegerObject(true, Integer.valueOf(1), Integer.valueOf(0))  = Integer.valueOf(1)\n-     *   BooleanUtils.toIntegerObject(false, Integer.valueOf(1), Integer.valueOf(0)) = Integer.valueOf(0)\n-     * </pre>\n-     *\n-     * @param bool  the to convert\n-     * @param trueValue  the value to return if {@code true}, may be {@code null}\n-     * @param falseValue  the value to return if {@code false}, may be {@code null}\n-     * @return the appropriate value\n-     */\n-    public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) {\n-        return bool ? trueValue : falseValue;\n-    }\n-\n-    /**\n-     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toIntegerObject(Boolean.TRUE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))  = Integer.valueOf(1)\n-     *   BooleanUtils.toIntegerObject(Boolean.FALSE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2)) = Integer.valueOf(0)\n-     *   BooleanUtils.toIntegerObject(null, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))          = Integer.valueOf(2)\n-     * </pre>\n-     *\n-     * @param bool  the Boolean to convert\n-     * @param trueValue  the value to return if {@code true}, may be {@code null}\n-     * @param falseValue  the value to return if {@code false}, may be {@code null}\n-     * @param nullValue  the value to return if {@code null}, may be {@code null}\n-     * @return the appropriate value\n-     */\n-    public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n-        if (bool == null) {\n-            return nullValue;\n-        }\n-        return bool.booleanValue() ? trueValue : falseValue;\n-    }\n-\n-    // String to Boolean methods\n-    //-----------------------------------------------------------------------\n     /**\n      * <p>Converts a String to a Boolean.</p>\n      *\n-     * <p>{@code 'true'}, {@code 'on'}, {@code 'y'}, {@code 't'} or {@code 'yes'}\n-     * (case insensitive) will return {@code true}.\n-     * {@code 'false'}, {@code 'off'}, {@code 'n'}, {@code 'f'} or {@code 'no'}\n-     * (case insensitive) will return {@code false}.\n+     * <p>{@code 'true'}, {@code 'on'}, {@code 'y'}, {@code 't'}, {@code 'yes'}\n+     * or {@code '1'} (case insensitive) will return {@code true}.\n+     * {@code 'false'}, {@code 'off'}, {@code 'n'}, {@code 'f'}, {@code 'no'}\n+     * or {@code '0'} (case insensitive) will return {@code false}.\n      * Otherwise, {@code null} is returned.</p>\n      *\n      * <p>NOTE: This method may return {@code null} and may throw a {@code NullPointerException}\n@@ -556,6 +659,8 @@ public static Integer toIntegerObject(final Boolean bool, final Integer trueValu\n      *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n      *   BooleanUtils.toBooleanObject(\"yes\")   = Boolean.TRUE\n      *   BooleanUtils.toBooleanObject(\"Y\")     = Boolean.TRUE // i.e. Y[ES]\n+     *   BooleanUtils.toBooleanObject(\"1\")     = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"0\")     = Boolean.FALSE\n      *   BooleanUtils.toBooleanObject(\"blue\")  = null\n      *   BooleanUtils.toBooleanObject(\"true \") = null // trailing space (too long)\n      *   BooleanUtils.toBooleanObject(\"ono\")   = null // does not match on or no\n@@ -571,7 +676,7 @@ public static Boolean toBooleanObject(final String str) {\n         // Optimisation provides same performance as before for interned 'true'.\n         // Similar performance for null, 'false', and other strings not length 2/3/4.\n         // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n-        if (str == \"true\") {\n+        if (str == TRUE) {\n             return Boolean.TRUE;\n         }\n         if (str == null) {\n@@ -581,11 +686,13 @@ public static Boolean toBooleanObject(final String str) {\n             case 1: {\n                 final char ch0 = str.charAt(0);\n                 if (ch0 == 'y' || ch0 == 'Y' ||\n-                    ch0 == 't' || ch0 == 'T') {\n+                    ch0 == 't' || ch0 == 'T' ||\n+                    ch0 == '1') {\n                     return Boolean.TRUE;\n                 }\n                 if (ch0 == 'n' || ch0 == 'N' ||\n-                    ch0 == 'f' || ch0 == 'F') {\n+                    ch0 == 'f' || ch0 == 'F' ||\n+                    ch0 == '0') {\n                     return Boolean.FALSE;\n                 }\n                 break;\n@@ -702,121 +809,152 @@ public static Boolean toBooleanObject(final String str, final String trueString,\n         throw new IllegalArgumentException(\"The String did not match any specified value\");\n     }\n \n-    // String to boolean methods\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts a String to a boolean (optimised for performance).</p>\n+     * <p>Converts a boolean to an int using the convention that\n+     * {@code true} is {@code 1} and {@code false} is {@code 0}.</p>\n      *\n-     * <p>{@code 'true'}, {@code 'on'}, {@code 'y'}, {@code 't'} or {@code 'yes'}\n-     * (case insensitive) will return {@code true}. Otherwise,\n-     * {@code false} is returned.</p>\n+     * <pre>\n+     *   BooleanUtils.toInteger(true)  = 1\n+     *   BooleanUtils.toInteger(false) = 0\n+     * </pre>\n      *\n-     * <p>This method performs 4 times faster (JDK1.4) than\n-     * {@code Boolean.valueOf(String)}. However, this method accepts\n-     * 'on' and 'yes', 't', 'y' as true values.\n+     * @param bool  the boolean to convert\n+     * @return one if {@code true}, zero if {@code false}\n+     */\n+    public static int toInteger(final boolean bool) {\n+        return bool ? 1 : 0;\n+    }\n+\n+    /**\n+     * <p>Converts a boolean to an int specifying the conversion values.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(null)    = false\n-     *   BooleanUtils.toBoolean(\"true\")  = true\n-     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n-     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n-     *   BooleanUtils.toBoolean(\"on\")    = true\n-     *   BooleanUtils.toBoolean(\"yes\")   = true\n-     *   BooleanUtils.toBoolean(\"false\") = false\n-     *   BooleanUtils.toBoolean(\"x gti\") = false\n-     *   BooleanUtils.toBooleanObject(\"y\") = true\n-     *   BooleanUtils.toBooleanObject(\"n\") = false\n-     *   BooleanUtils.toBooleanObject(\"t\") = true\n-     *   BooleanUtils.toBooleanObject(\"f\") = false\n+     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n+     *   BooleanUtils.toInteger(false, 1, 0) = 0\n      * </pre>\n      *\n-     * @param str  the String to check\n-     * @return the boolean value of the string, {@code false} if no match or the String is null\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if {@code true}\n+     * @param falseValue  the value to return if {@code false}\n+     * @return the appropriate value\n      */\n-    public static boolean toBoolean(final String str) {\n-        return toBooleanObject(str) == Boolean.TRUE;\n+    public static int toInteger(final boolean bool, final int trueValue, final int falseValue) {\n+        return bool ? trueValue : falseValue;\n     }\n \n     /**\n-     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n+     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n-     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n+     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n+     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n+     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n      * </pre>\n      *\n-     * @param str  the String to check\n-     * @param trueString  the String to match for {@code true} (case sensitive), may be {@code null}\n-     * @param falseString  the String to match for {@code false} (case sensitive), may be {@code null}\n-     * @return the boolean value of the string\n-     * @throws IllegalArgumentException if the String doesn't match\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if {@code true}\n+     * @param falseValue  the value to return if {@code false}\n+     * @param nullValue  the value to return if {@code null}\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+\n+    /**\n+     * <p>Converts a boolean to an Integer using the convention that\n+     * {@code true} is {@code 1} and {@code false} is {@code 0}.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true)  = Integer.valueOf(1)\n+     *   BooleanUtils.toIntegerObject(false) = Integer.valueOf(0)\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if {@code true}, zero if {@code false}\n+     */\n+    public static Integer toIntegerObject(final boolean bool) {\n+        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+\n+    /**\n+     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true, Integer.valueOf(1), Integer.valueOf(0))  = Integer.valueOf(1)\n+     *   BooleanUtils.toIntegerObject(false, Integer.valueOf(1), Integer.valueOf(0)) = Integer.valueOf(0)\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if {@code true}, may be {@code null}\n+     * @param falseValue  the value to return if {@code false}, may be {@code null}\n+     * @return the appropriate value\n      */\n-    public static boolean toBoolean(final String str, final String trueString, final String falseString) {\n-        if (str == trueString) {\n-            return true;\n-        } else if (str == falseString) {\n-            return false;\n-        } else if (str != null) {\n-            if (str.equals(trueString)) {\n-                return true;\n-            } else if (str.equals(falseString)) {\n-                return false;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"The String did not match either specified value\");\n+    public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) {\n+        return bool ? trueValue : falseValue;\n     }\n \n-    // Boolean to String methods\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts a Boolean to a String returning {@code 'true'},\n-     * {@code 'false'}, or {@code null}.</p>\n+     * <p>Converts a Boolean to a Integer using the convention that\n+     * {@code zero} is {@code false}.</p>\n+     *\n+     * <p>{@code null} will be converted to {@code null}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n-     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n-     *   BooleanUtils.toStringTrueFalse(null)          = null;\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE)  = Integer.valueOf(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE) = Integer.valueOf(0)\n      * </pre>\n      *\n-     * @param bool  the Boolean to check\n-     * @return {@code 'true'}, {@code 'false'}, or {@code null}\n+     * @param bool  the Boolean to convert\n+     * @return one if Boolean.TRUE, zero if Boolean.FALSE, {@code null} if {@code null}\n      */\n-    public static String toStringTrueFalse(final Boolean bool) {\n-        return toString(bool, \"true\", \"false\", null);\n+    public static Integer toIntegerObject(final Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n     }\n \n     /**\n-     * <p>Converts a Boolean to a String returning {@code 'on'},\n-     * {@code 'off'}, or {@code null}.</p>\n+     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n-     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n-     *   BooleanUtils.toStringOnOff(null)          = null;\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))  = Integer.valueOf(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2)) = Integer.valueOf(0)\n+     *   BooleanUtils.toIntegerObject(null, Integer.valueOf(1), Integer.valueOf(0), Integer.valueOf(2))          = Integer.valueOf(2)\n      * </pre>\n      *\n-     * @param bool  the Boolean to check\n-     * @return {@code 'on'}, {@code 'off'}, or {@code null}\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if {@code true}, may be {@code null}\n+     * @param falseValue  the value to return if {@code false}, may be {@code null}\n+     * @param nullValue  the value to return if {@code null}, may be {@code null}\n+     * @return the appropriate value\n      */\n-    public static String toStringOnOff(final Boolean bool) {\n-        return toString(bool, \"on\", \"off\", null);\n+    public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n     }\n \n     /**\n-     * <p>Converts a Boolean to a String returning {@code 'yes'},\n-     * {@code 'no'}, or {@code null}.</p>\n+     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n-     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n-     *   BooleanUtils.toStringYesNo(null)          = null;\n+     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n+     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n      * </pre>\n      *\n      * @param bool  the Boolean to check\n-     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n+     * @param trueString  the String to return if {@code true}, may be {@code null}\n+     * @param falseString  the String to return if {@code false}, may be {@code null}\n+     * @return one of the two input Strings\n      */\n-    public static String toStringYesNo(final Boolean bool) {\n-        return toString(bool, \"yes\", \"no\", null);\n+    public static String toString(final boolean bool, final String trueString, final String falseString) {\n+        return bool ? trueString : falseString;\n     }\n \n     /**\n@@ -841,24 +979,6 @@ public static String toString(final Boolean bool, final String trueString, final\n         return bool.booleanValue() ? trueString : falseString;\n     }\n \n-    // boolean to String methods\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Converts a boolean to a String returning {@code 'true'}\n-     * or {@code 'false'}.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n-     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n-     * </pre>\n-     *\n-     * @param bool  the Boolean to check\n-     * @return {@code 'true'}, {@code 'false'}, or {@code null}\n-     */\n-    public static String toStringTrueFalse(final boolean bool) {\n-        return toString(bool, \"true\", \"false\");\n-    }\n-\n     /**\n      * <p>Converts a boolean to a String returning {@code 'on'}\n      * or {@code 'off'}.</p>\n@@ -872,179 +992,90 @@ public static String toStringTrueFalse(final boolean bool) {\n      * @return {@code 'on'}, {@code 'off'}, or {@code null}\n      */\n     public static String toStringOnOff(final boolean bool) {\n-        return toString(bool, \"on\", \"off\");\n+        return toString(bool, ON, OFF);\n     }\n \n     /**\n-     * <p>Converts a boolean to a String returning {@code 'yes'}\n-     * or {@code 'no'}.</p>\n+     * <p>Converts a Boolean to a String returning {@code 'on'},\n+     * {@code 'off'}, or {@code null}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n-     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n+     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n+     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n+     *   BooleanUtils.toStringOnOff(null)          = null;\n      * </pre>\n      *\n      * @param bool  the Boolean to check\n-     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n+     * @return {@code 'on'}, {@code 'off'}, or {@code null}\n      */\n-    public static String toStringYesNo(final boolean bool) {\n-        return toString(bool, \"yes\", \"no\");\n+    public static String toStringOnOff(final Boolean bool) {\n+        return toString(bool, ON, OFF, null);\n     }\n \n     /**\n-     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n+     * <p>Converts a boolean to a String returning {@code 'true'}\n+     * or {@code 'false'}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n-     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n+     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n      * </pre>\n      *\n      * @param bool  the Boolean to check\n-     * @param trueString  the String to return if {@code true}, may be {@code null}\n-     * @param falseString  the String to return if {@code false}, may be {@code null}\n-     * @return one of the two input Strings\n-     */\n-    public static String toString(final boolean bool, final String trueString, final String falseString) {\n-        return bool ? trueString : falseString;\n-    }\n-\n-    // logical operations\n-    // ----------------------------------------------------------------------\n-    /**\n-     * <p>Performs an 'and' operation on a set of booleans.</p>\n-     *\n-     * <pre>\n-     *   BooleanUtils.and(true, true)         = true\n-     *   BooleanUtils.and(false, false)       = false\n-     *   BooleanUtils.and(true, false)        = false\n-     *   BooleanUtils.and(true, true, false)  = false\n-     *   BooleanUtils.and(true, true, true)   = true\n-     * </pre>\n-     *\n-     * @param array  an array of {@code boolean}s\n-     * @return the result of the logical 'and' operation. That is {@code false}\n-     * if any of the parameters is {@code false} and {@code true} otherwise.\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n-     * @throws IllegalArgumentException if {@code array} is empty.\n-     * @since 3.0.1\n+     * @return {@code 'true'}, {@code 'false'}, or {@code null}\n      */\n-    public static boolean and(final boolean... array) {\n-        // Validates input\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n-        for (final boolean element : array) {\n-            if (!element) {\n-                return false;\n-            }\n-        }\n-        return true;\n+    public static String toStringTrueFalse(final boolean bool) {\n+        return toString(bool, TRUE, FALSE);\n     }\n \n     /**\n-     * <p>Performs an 'and' operation on an array of Booleans.</p>\n+     * <p>Converts a Boolean to a String returning {@code 'true'},\n+     * {@code 'false'}, or {@code null}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE)                 = Boolean.TRUE\n-     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE)               = Boolean.FALSE\n-     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE)                = Boolean.FALSE\n-     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)   = Boolean.TRUE\n-     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE) = Boolean.FALSE\n-     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)  = Boolean.FALSE\n+     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n+     *   BooleanUtils.toStringTrueFalse(null)          = null;\n      * </pre>\n      *\n-     * @param array  an array of {@code Boolean}s\n-     * @return the result of the logical 'and' operation. That is {@code false}\n-     * if any of the parameters is {@code false} and {@code true} otherwise.\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n-     * @throws IllegalArgumentException if {@code array} is empty.\n-     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n-     * @since 3.0.1\n+     * @param bool  the Boolean to check\n+     * @return {@code 'true'}, {@code 'false'}, or {@code null}\n      */\n-    public static Boolean and(final Boolean... array) {\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n-        try {\n-            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n-            return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n-        } catch (final NullPointerException ex) {\n-            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n-        }\n+    public static String toStringTrueFalse(final Boolean bool) {\n+        return toString(bool, TRUE, FALSE, null);\n     }\n \n     /**\n-     * <p>Performs an 'or' operation on a set of booleans.</p>\n+     * <p>Converts a boolean to a String returning {@code 'yes'}\n+     * or {@code 'no'}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.or(true, true)          = true\n-     *   BooleanUtils.or(false, false)        = false\n-     *   BooleanUtils.or(true, false)         = true\n-     *   BooleanUtils.or(true, true, false)   = true\n-     *   BooleanUtils.or(true, true, true)    = true\n-     *   BooleanUtils.or(false, false, false) = false\n+     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n+     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n      * </pre>\n      *\n-     * @param array  an array of {@code boolean}s\n-     * @return {@code true} if any of the arguments is {@code true}, and it returns {@code false} otherwise.\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n-     * @throws IllegalArgumentException if {@code array} is empty.\n-     * @since 3.0.1\n+     * @param bool  the Boolean to check\n+     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n      */\n-    public static boolean or(final boolean... array) {\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n-        for (final boolean element : array) {\n-            if (element) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    public static String toStringYesNo(final boolean bool) {\n+        return toString(bool, YES, NO);\n     }\n \n     /**\n-     * <p>Performs an 'or' operation on an array of Booleans.</p>\n+     * <p>Converts a Boolean to a String returning {@code 'yes'},\n+     * {@code 'no'}, or {@code null}.</p>\n      *\n      * <pre>\n-     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE)                  = Boolean.TRUE\n-     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE)                = Boolean.FALSE\n-     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE)                 = Boolean.TRUE\n-     *   BooleanUtils.or(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)    = Boolean.TRUE\n-     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE)  = Boolean.TRUE\n-     *   BooleanUtils.or(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)   = Boolean.TRUE\n-     *   BooleanUtils.or(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE) = Boolean.FALSE\n+     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n+     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n+     *   BooleanUtils.toStringYesNo(null)          = null;\n      * </pre>\n      *\n-     * @param array  an array of {@code Boolean}s\n-     * @return {@code true} if any of the arguments is {@code true}, and it returns {@code false} otherwise.\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n-     * @throws IllegalArgumentException if {@code array} is empty.\n-     * @throws IllegalArgumentException if {@code array} contains a {@code null}\n-     * @since 3.0.1\n+     * @param bool  the Boolean to check\n+     * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n      */\n-    public static Boolean or(final Boolean... array) {\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n-        try {\n-            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n-            return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n-        } catch (final NullPointerException ex) {\n-            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n-        }\n+    public static String toStringYesNo(final Boolean bool) {\n+        return toString(bool, YES, NO, null);\n     }\n \n     /**\n@@ -1058,17 +1089,11 @@ public static Boolean or(final Boolean... array) {\n      *\n      * @param array  an array of {@code boolean}s\n      * @return the result of the xor operations\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n+     * @throws NullPointerException if {@code array} is {@code null}\n      * @throws IllegalArgumentException if {@code array} is empty.\n      */\n     public static boolean xor(final boolean... array) {\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n-\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n         // false if the neutral element of the xor operator\n         boolean result = false;\n         for (final boolean element : array) {\n@@ -1090,17 +1115,12 @@ public static boolean xor(final boolean... array) {\n      *\n      * @param array  an array of {@code Boolean}s\n      * @return the result of the xor operations\n-     * @throws IllegalArgumentException if {@code array} is {@code null}\n+     * @throws NullPointerException if {@code array} is {@code null}\n      * @throws IllegalArgumentException if {@code array} is empty.\n      * @throws IllegalArgumentException if {@code array} contains a {@code null}\n      */\n     public static Boolean xor(final Boolean... array) {\n-        if (array == null) {\n-            throw new IllegalArgumentException(\"The Array must not be null\");\n-        }\n-        if (array.length == 0) {\n-            throw new IllegalArgumentException(\"Array is empty\");\n-        }\n+        ObjectUtils.requireNonEmpty(array, \"array\");\n         try {\n             final boolean[] primitive = ArrayUtils.toPrimitive(array);\n             return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n@@ -1110,20 +1130,13 @@ public static Boolean xor(final Boolean... array) {\n     }\n \n     /**\n-     * <p>Compares two {@code boolean} values. This is the same functionality as provided in Java 7.</p>\n+     * <p>{@code BooleanUtils} instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as {@code BooleanUtils.negate(true);}.</p>\n      *\n-     * @param x the first {@code boolean} to compare\n-     * @param y the second {@code boolean} to compare\n-     * @return the value {@code 0} if {@code x == y};\n-     *         a value less than {@code 0} if {@code !x && y}; and\n-     *         a value greater than {@code 0} if {@code x && !y}\n-     * @since 3.4\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n      */\n-    public static int compare(final boolean x, final boolean y) {\n-        if (x == y) {\n-            return 0;\n-        }\n-        return x ? 1 : -1;\n+    public BooleanUtils() {\n     }\n \n }"
  },
  {
    "sha": "36d8595b9748c0a7bc02a7af77d3fcf0f56dbbb5",
    "filename": "src/main/java/org/apache/commons/lang3/CharRange.java",
    "status": "modified",
    "additions": 16,
    "deletions": 6,
    "changes": 22,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharRange.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharRange.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/CharRange.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -49,6 +49,9 @@\n     /** Cached toString. */\n     private transient String iToString;\n \n+    /** Empty array. */\n+    static final CharRange[] EMPTY_ARRAY = new CharRange[0];\n+\n     /**\n      * <p>Constructs a {@code CharRange} over a set of characters,\n      * optionally negating the range.</p>\n@@ -64,7 +67,6 @@\n      * @param negated  true to express everything except the range\n      */\n     private CharRange(char start, char end, final boolean negated) {\n-        super();\n         if (start > end) {\n             final char temp = start;\n             start = end;\n@@ -81,7 +83,6 @@ private CharRange(char start, char end, final boolean negated) {\n      *\n      * @param ch  only character in this range\n      * @return the new CharRange object\n-     * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n     public static CharRange is(final char ch) {\n@@ -91,9 +92,11 @@ public static CharRange is(final char ch) {\n     /**\n      * <p>Constructs a negated {@code CharRange} over a single character.</p>\n      *\n+     * <p>A negated range includes everything except that defined by the\n+     * single character.</p>\n+     *\n      * @param ch  only character in this range\n      * @return the new CharRange object\n-     * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n     public static CharRange isNot(final char ch) {\n@@ -103,10 +106,12 @@ public static CharRange isNot(final char ch) {\n     /**\n      * <p>Constructs a {@code CharRange} over a set of characters.</p>\n      *\n+     * <p>If start and end are in the wrong order, they are reversed.\n+     * Thus {@code a-e} is the same as {@code e-a}.</p>\n+     *\n      * @param start  first character, inclusive, in this range\n      * @param end  last character, inclusive, in this range\n      * @return the new CharRange object\n-     * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n     public static CharRange isIn(final char start, final char end) {\n@@ -116,10 +121,15 @@ public static CharRange isIn(final char start, final char end) {\n     /**\n      * <p>Constructs a negated {@code CharRange} over a set of characters.</p>\n      *\n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     *\n+     * <p>If start and end are in the wrong order, they are reversed.\n+     * Thus {@code a-e} is the same as {@code e-a}.</p>\n+     *\n      * @param start  first character, inclusive, in this range\n      * @param end  last character, inclusive, in this range\n      * @return the new CharRange object\n-     * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n     public static CharRange isNotIn(final char start, final char end) {\n@@ -179,7 +189,7 @@ public boolean contains(final char ch) {\n      * @throws IllegalArgumentException if {@code null} input\n      */\n     public boolean contains(final CharRange range) {\n-        Validate.isTrue(range != null, \"The Range must not be null\");\n+        Validate.notNull(range, \"range\");\n         if (negated) {\n             if (range.negated) {\n                 return start >= range.start && end <= range.end;"
  },
  {
    "sha": "b4a8d7769fb7cb9764b668458aa3f6e51be82d84",
    "filename": "src/main/java/org/apache/commons/lang3/CharSequenceUtils.java",
    "status": "modified",
    "additions": 160,
    "deletions": 79,
    "changes": 239,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -27,37 +27,50 @@\n \n     private static final int NOT_FOUND = -1;\n \n-    /**\n-     * <p>{@code CharSequenceUtils} instances should NOT be constructed in\n-     * standard programming. </p>\n-     *\n-     * <p>This constructor is public to permit tools that require a JavaBean\n-     * instance to operate.</p>\n-     */\n-    public CharSequenceUtils() {\n-        super();\n+    static final int TO_STRING_LIMIT = 16;\n+\n+    private static boolean checkLaterThan1(final CharSequence cs, final CharSequence searchChar, final int len2, final int start1) {\n+        for (int i = 1, j = len2 - 1; i <= j; i++, j--) {\n+            if (cs.charAt(start1 + i) != searchChar.charAt(i)\n+                    ||\n+                    cs.charAt(start1 + j) != searchChar.charAt(j)\n+            ) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n-     * sequence starting with the {@code char} value at the specified index.</p>\n-     *\n-     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n-     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n-     * so if {@code start == end} then an empty sequence is returned.</p>\n+     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n      *\n-     * @param cs  the specified subsequence, null returns null\n-     * @param start  the start index, inclusive, valid\n-     * @return a new subsequence, may be null\n-     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n-     *  {@code start} is greater than {@code length()}\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n      */\n-    public static CharSequence subSequence(final CharSequence cs, final int start) {\n-        return cs == null ? null : cs.subSequence(start, cs.length());\n+    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).indexOf(searchChar.toString(), start);\n+        }\n+        if (cs instanceof StringBuilder) {\n+            return ((StringBuilder) cs).indexOf(searchChar.toString(), start);\n+        }\n+        if (cs instanceof StringBuffer) {\n+            return ((StringBuffer) cs).indexOf(searchChar.toString(), start);\n+        }\n+        return cs.toString().indexOf(searchChar.toString(), start);\n+//        if (cs instanceof String && searchChar instanceof String) {\n+//            // TODO: Do we assume searchChar is usually relatively small;\n+//            //       If so then calling toString() on it is better than reverting to\n+//            //       the green implementation in the else block\n+//            return ((String) cs).indexOf((String) searchChar, start);\n+//        } else {\n+//            // TODO: Implement rather than convert to String\n+//            return cs.toString().indexOf(searchChar.toString(), start);\n+//        }\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n      * Returns the index within {@code cs} of the first occurrence of the\n      * specified character, starting the search at the specified index.\n@@ -110,6 +123,7 @@ static int indexOf(final CharSequence cs, final int searchChar, int start) {\n                     return i;\n                 }\n             }\n+            return NOT_FOUND;\n         }\n         //supplementary characters (LANG1300)\n         if (searchChar <= Character.MAX_CODE_POINT) {\n@@ -126,24 +140,78 @@ static int indexOf(final CharSequence cs, final int searchChar, int start) {\n     }\n \n     /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n      *\n      * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param searchChar the {@code CharSequence} to find\n      * @param start the start index\n      * @return the index where the search sequence was found\n      */\n-    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n-        return cs.toString().indexOf(searchChar.toString(), start);\n-//        if (cs instanceof String && searchChar instanceof String) {\n-//            // TODO: Do we assume searchChar is usually relatively small;\n-//            //       If so then calling toString() on it is better than reverting to\n-//            //       the green implementation in the else block\n-//            return ((String) cs).indexOf((String) searchChar, start);\n-//        } else {\n-//            // TODO: Implement rather than convert to String\n-//            return cs.toString().indexOf(searchChar.toString(), start);\n-//        }\n+    static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, int start) {\n+        if (searchChar == null || cs == null) {\n+            return NOT_FOUND;\n+        }\n+        if (searchChar instanceof String) {\n+            if (cs instanceof String) {\n+                return ((String) cs).lastIndexOf((String) searchChar, start);\n+            }\n+            if (cs instanceof StringBuilder) {\n+                return ((StringBuilder) cs).lastIndexOf((String) searchChar, start);\n+            }\n+            if (cs instanceof StringBuffer) {\n+                return ((StringBuffer) cs).lastIndexOf((String) searchChar, start);\n+            }\n+        }\n+\n+        final int len1 = cs.length();\n+        final int len2 = searchChar.length();\n+\n+        if (start > len1) {\n+            start = len1;\n+        }\n+\n+        if (start < 0 || len2 < 0 || len2 > len1) {\n+            return NOT_FOUND;\n+        }\n+\n+        if (len2 == 0) {\n+            return start;\n+        }\n+\n+        if (len2 <= TO_STRING_LIMIT) {\n+            if (cs instanceof String) {\n+                return ((String) cs).lastIndexOf(searchChar.toString(), start);\n+            }\n+            if (cs instanceof StringBuilder) {\n+                return ((StringBuilder) cs).lastIndexOf(searchChar.toString(), start);\n+            }\n+            if (cs instanceof StringBuffer) {\n+                return ((StringBuffer) cs).lastIndexOf(searchChar.toString(), start);\n+            }\n+        }\n+\n+        if (start + len2 > len1) {\n+            start = len1 - len2;\n+        }\n+\n+        final char char0 = searchChar.charAt(0);\n+\n+        int i = start;\n+        while (true) {\n+            while (cs.charAt(i) != char0) {\n+                i--;\n+                if (i < 0) {\n+                    return NOT_FOUND;\n+                }\n+            }\n+            if (checkLaterThan1(cs, searchChar, len2, i)) {\n+                return i;\n+            }\n+            i--;\n+            if (i < 0) {\n+                return NOT_FOUND;\n+            }\n+        }\n     }\n \n     /**\n@@ -189,6 +257,7 @@ static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {\n                     return i;\n                 }\n             }\n+            return NOT_FOUND;\n         }\n         //supplementary characters (LANG1300)\n         //NOTE - we must do a forward traversal for this to avoid duplicating code points\n@@ -209,45 +278,6 @@ static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {\n         return NOT_FOUND;\n     }\n \n-    /**\n-     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n-        return cs.toString().lastIndexOf(searchChar.toString(), start);\n-//        if (cs instanceof String && searchChar instanceof String) {\n-//            // TODO: Do we assume searchChar is usually relatively small;\n-//            //       If so then calling toString() on it is better than reverting to\n-//            //       the green implementation in the else block\n-//            return ((String) cs).lastIndexOf((String) searchChar, start);\n-//        } else {\n-//            // TODO: Implement rather than convert to String\n-//            return cs.toString().lastIndexOf(searchChar.toString(), start);\n-//        }\n-    }\n-\n-    /**\n-     * Green implementation of toCharArray.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @return the resulting char array\n-     */\n-    static char[] toCharArray(final CharSequence cs) {\n-        if (cs instanceof String) {\n-            return ((String) cs).toCharArray();\n-        }\n-        final int sz = cs.length();\n-        final char[] array = new char[cs.length()];\n-        for (int i = 0; i < sz; i++) {\n-            array[i] = cs.charAt(i);\n-        }\n-        return array;\n-    }\n-\n     /**\n      * Green implementation of regionMatches.\n      *\n@@ -294,13 +324,64 @@ static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, fi\n                 return false;\n             }\n \n-            // The same check as in String.regionMatches():\n-            if (Character.toUpperCase(c1) != Character.toUpperCase(c2)\n-                    && Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n+            // The real same check as in String.regionMatches():\n+            final char u1 = Character.toUpperCase(c1);\n+            final char u2 = Character.toUpperCase(c2);\n+            if (u1 != u2 && Character.toLowerCase(u1) != Character.toLowerCase(u2)) {\n                 return false;\n             }\n         }\n \n         return true;\n     }\n+\n+    /**\n+     * <p>Returns a new {@code CharSequence} that is a subsequence of this\n+     * sequence starting with the {@code char} value at the specified index.</p>\n+     *\n+     * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n+     * The length (in {@code char}) of the returned sequence is {@code length() - start},\n+     * so if {@code start == end} then an empty sequence is returned.</p>\n+     *\n+     * @param cs  the specified subsequence, null returns null\n+     * @param start  the start index, inclusive, valid\n+     * @return a new subsequence, may be null\n+     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n+     *  {@code start} is greater than {@code length()}\n+     */\n+    public static CharSequence subSequence(final CharSequence cs, final int start) {\n+        return cs == null ? null : cs.subSequence(start, cs.length());\n+    }\n+\n+    /**\n+     * Converts the given CharSequence to a char[].\n+     *\n+     * @param source the {@code CharSequence} to be processed.\n+     * @return the resulting char array, never null.\n+     * @since 3.11\n+     */\n+    public static char[] toCharArray(final CharSequence source) {\n+        final int len = StringUtils.length(source);\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        if (source instanceof String) {\n+            return ((String) source).toCharArray();\n+        }\n+        final char[] array = new char[len];\n+        for (int i = 0; i < len; i++) {\n+            array[i] = source.charAt(i);\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>{@code CharSequenceUtils} instances should NOT be constructed in\n+     * standard programming. </p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public CharSequenceUtils() {\n+    }\n }"
  },
  {
    "sha": "84e6c12c69094db227c922b749860def1d2f55d5",
    "filename": "src/main/java/org/apache/commons/lang3/CharSet.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSet.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSet.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/CharSet.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -174,7 +174,6 @@ public static CharSet getInstance(final String... setStrs) {\n      * @throws NullPointerException if set is {@code null}\n      */\n     protected CharSet(final String... set) {\n-        super();\n         for (final String s : set) {\n             add(s);\n         }\n@@ -225,7 +224,7 @@ protected void add(final String str) {\n // NOTE: This is no longer public as CharRange is no longer a public class.\n //       It may be replaced when CharSet moves to Range.\n     /*public*/ CharRange[] getCharRanges() {\n-        return set.toArray(new CharRange[0]);\n+        return set.toArray(CharRange.EMPTY_ARRAY);\n     }\n \n     //-----------------------------------------------------------------------"
  },
  {
    "sha": "e75a6c8cd6d55d617b7713041b5a1ec5ed4150fd",
    "filename": "src/main/java/org/apache/commons/lang3/CharSetUtils.java",
    "status": "modified",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSetUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharSetUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/CharSetUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -21,7 +21,7 @@\n  *\n  * <p>This class handles {@code null} input gracefully.\n  * An exception will not be thrown for a {@code null} input.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * <p>#ThreadSafe#</p>\n  * @see CharSet\n@@ -244,6 +244,5 @@ public static String squeeze(final String str, final String... set) {\n      * to operate.</p>\n      */\n     public CharSetUtils() {\n-      super();\n     }\n }"
  },
  {
    "sha": "b98044391c61af3857e0004227ccd10cc05e954b",
    "filename": "src/main/java/org/apache/commons/lang3/CharUtils.java",
    "status": "modified",
    "additions": 8,
    "deletions": 7,
    "changes": 15,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/CharUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/CharUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -21,7 +21,7 @@\n  *\n  * <p>This class tries to handle {@code null} input gracefully.\n  * An exception will not be thrown for a {@code null} input.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * <p>#ThreadSafe#</p>\n  * @since 2.1\n@@ -71,7 +71,6 @@\n      * to operate.</p>\n      */\n     public CharUtils() {\n-      super();\n     }\n \n     //-----------------------------------------------------------------------\n@@ -131,10 +130,10 @@ public static Character toCharacterObject(final String str) {\n      *\n      * @param ch  the character to convert\n      * @return the char value of the Character\n-     * @throws IllegalArgumentException if the Character is null\n+     * @throws NullPointerException if the Character is null\n      */\n     public static char toChar(final Character ch) {\n-        Validate.isTrue(ch != null, \"The Character must not be null\");\n+        Validate.notNull(ch, \"ch\");\n         return ch.charValue();\n     }\n \n@@ -172,10 +171,11 @@ public static char toChar(final Character ch, final char defaultValue) {\n      *\n      * @param str  the character to convert\n      * @return the char value of the first letter of the String\n+     * @throws NullPointerException if the string is null\n      * @throws IllegalArgumentException if the String is empty\n      */\n     public static char toChar(final String str) {\n-        Validate.isTrue(StringUtils.isNotEmpty(str), \"The String must not be empty\");\n+        Validate.notEmpty(str, \"The String must not be empty\");\n         return str.charAt(0);\n     }\n \n@@ -260,10 +260,11 @@ public static int toIntValue(final char ch, final int defaultValue) {\n      *\n      * @param ch  the character to convert, not null\n      * @return the int value of the character\n-     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n+     * @throws NullPointerException if the Character is null\n+     * @throws IllegalArgumentException if the Character is not ASCII numeric\n      */\n     public static int toIntValue(final Character ch) {\n-        Validate.isTrue(ch != null, \"The character must not be null\");\n+        Validate.notNull(ch, \"ch\");\n         return toIntValue(ch.charValue());\n     }\n "
  },
  {
    "sha": "a87156a08596e03b12fede41c5bc830df427fb1b",
    "filename": "src/main/java/org/apache/commons/lang3/ClassLoaderUtils.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassLoaderUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassLoaderUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ClassLoaderUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -31,7 +31,7 @@\n      * Converts the given class loader to a String calling {@link #toString(URLClassLoader)}.\n      *\n      * @param classLoader to URLClassLoader to convert.\n-     * @return the formated string.\n+     * @return the formatted string.\n      */\n     public static String toString(final ClassLoader classLoader) {\n         if (classLoader instanceof URLClassLoader) {\n@@ -45,7 +45,7 @@ public static String toString(final ClassLoader classLoader) {\n      * {@code \"URLClassLoader.toString() + [URL1, URL2, ...]\"}.\n      *\n      * @param classLoader to URLClassLoader to convert.\n-     * @return the formated string.\n+     * @return the formatted string.\n      */\n     public static String toString(final URLClassLoader classLoader) {\n         return classLoader + Arrays.toString(classLoader.getURLs());"
  },
  {
    "sha": "3e1adda9a1d2a89e4a7be3bbde438ff984a96b7d",
    "filename": "src/main/java/org/apache/commons/lang3/ClassPathUtils.java",
    "status": "modified",
    "additions": 8,
    "deletions": 9,
    "changes": 17,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassPathUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassPathUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ClassPathUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -35,7 +35,6 @@\n      * instance to operate.</p>\n      */\n     public ClassPathUtils() {\n-        super();\n     }\n \n     /**\n@@ -55,8 +54,8 @@ public ClassPathUtils() {\n      * @throws java.lang.NullPointerException if either {@code context} or {@code resourceName} is null.\n      */\n     public static String toFullyQualifiedName(final Class<?> context, final String resourceName) {\n-        Validate.notNull(context, \"Parameter '%s' must not be null!\", \"context\" );\n-        Validate.notNull(resourceName, \"Parameter '%s' must not be null!\", \"resourceName\");\n+        Validate.notNull(context, \"context\" );\n+        Validate.notNull(resourceName, \"resourceName\");\n         return toFullyQualifiedName(context.getPackage(), resourceName);\n     }\n \n@@ -77,8 +76,8 @@ public static String toFullyQualifiedName(final Class<?> context, final String r\n      * @throws java.lang.NullPointerException if either {@code context} or {@code resourceName} is null.\n      */\n     public static String toFullyQualifiedName(final Package context, final String resourceName) {\n-        Validate.notNull(context, \"Parameter '%s' must not be null!\", \"context\" );\n-        Validate.notNull(resourceName, \"Parameter '%s' must not be null!\", \"resourceName\");\n+        Validate.notNull(context, \"context\" );\n+        Validate.notNull(resourceName, \"resourceName\");\n         return context.getName() + \".\" + resourceName;\n     }\n \n@@ -99,8 +98,8 @@ public static String toFullyQualifiedName(final Package context, final String re\n      * @throws java.lang.NullPointerException if either {@code context} or {@code resourceName} is null.\n      */\n     public static String toFullyQualifiedPath(final Class<?> context, final String resourceName) {\n-        Validate.notNull(context, \"Parameter '%s' must not be null!\", \"context\" );\n-        Validate.notNull(resourceName, \"Parameter '%s' must not be null!\", \"resourceName\");\n+        Validate.notNull(context, \"context\" );\n+        Validate.notNull(resourceName, \"resourceName\");\n         return toFullyQualifiedPath(context.getPackage(), resourceName);\n     }\n \n@@ -122,8 +121,8 @@ public static String toFullyQualifiedPath(final Class<?> context, final String r\n      * @throws java.lang.NullPointerException if either {@code context} or {@code resourceName} is null.\n      */\n     public static String toFullyQualifiedPath(final Package context, final String resourceName) {\n-        Validate.notNull(context, \"Parameter '%s' must not be null!\", \"context\" );\n-        Validate.notNull(resourceName, \"Parameter '%s' must not be null!\", \"resourceName\");\n+        Validate.notNull(context, \"context\" );\n+        Validate.notNull(resourceName, \"resourceName\");\n         return context.getName().replace('.', '/') + \"/\" + resourceName;\n     }\n "
  },
  {
    "sha": "6a864efdff0dfda1caea61fce4b9fd712644583c",
    "filename": "src/main/java/org/apache/commons/lang3/ClassUtils.java",
    "status": "modified",
    "additions": 9,
    "deletions": 12,
    "changes": 21,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ClassUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ClassUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -34,7 +34,7 @@\n  * <p>Operates on classes without using reflection.</p>\n  *\n  * <p>This class handles invalid {@code null} inputs as best it can.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * <p>The notion of a {@code canonical name} includes the human\n  * readable name for the type, for example {@code int[]}. The\n@@ -161,7 +161,6 @@\n      * instance to operate.</p>\n      */\n     public ClassUtils() {\n-      super();\n     }\n \n     // Short class name\n@@ -1062,7 +1061,7 @@ public static boolean isInnerClass(final Class<?> cls) {\n     public static Class<?> getClass(\n             final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n         try {\n-            Class<?> clazz;\n+            final Class<?> clazz;\n             if (namePrimitiveMap.containsKey(className)) {\n                 clazz = namePrimitiveMap.get(className);\n             } else {\n@@ -1167,15 +1166,14 @@ public static Method getPublicMethod(final Class<?> cls, final String methodName\n             return declaredMethod;\n         }\n \n-        final List<Class<?>> candidateClasses = new ArrayList<>();\n-        candidateClasses.addAll(getAllInterfaces(cls));\n+        final List<Class<?>> candidateClasses = new ArrayList<>(getAllInterfaces(cls));\n         candidateClasses.addAll(getAllSuperclasses(cls));\n \n         for (final Class<?> candidateClass : candidateClasses) {\n             if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                 continue;\n             }\n-            Method candidateMethod;\n+            final Method candidateMethod;\n             try {\n                 candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n             } catch (final NoSuchMethodException ex) {\n@@ -1199,7 +1197,7 @@ public static Method getPublicMethod(final Class<?> cls, final String methodName\n      */\n     private static String toCanonicalName(String className) {\n         className = StringUtils.deleteWhitespace(className);\n-        Validate.notNull(className, \"className must not be null.\");\n+        Validate.notNull(className, \"className\");\n         if (className.endsWith(\"[]\")) {\n             final StringBuilder classNameBuffer = new StringBuilder();\n             while (className.endsWith(\"[]\")) {\n@@ -1230,7 +1228,8 @@ private static String toCanonicalName(String className) {\n     public static Class<?>[] toClass(final Object... array) {\n         if (array == null) {\n             return null;\n-        } else if (array.length == 0) {\n+        }\n+        if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         final Class<?>[] classes = new Class[array.length];\n@@ -1460,10 +1459,8 @@ private static String getCanonicalName(String className) {\n                 className.endsWith(\";\")\n                     ? className.length() - 1\n                     : className.length());\n-        } else {\n-            if (!className.isEmpty()) {\n-                className = reverseAbbreviationMap.get(className.substring(0, 1));\n-            }\n+        } else if (!className.isEmpty()) {\n+            className = reverseAbbreviationMap.get(className.substring(0, 1));\n         }\n         final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n         for (int i = 0; i < dim; i++) {"
  },
  {
    "sha": "e7107013152589016a7b881aac29481a81fb1778",
    "filename": "src/main/java/org/apache/commons/lang3/Conversion.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/Conversion.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/Conversion.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/Conversion.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -1534,7 +1534,7 @@ public static String byteToHex(final byte src, final int srcPos, final String ds\n         if (nBytes > 16) {\n             throw new IllegalArgumentException(\"nBytes is greater than 16\");\n         }\n-        longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);\n+        longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, Math.min(nBytes, 8));\n         if (nBytes >= 8) {\n             longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8);\n         }"
  },
  {
    "sha": "bd6f8a247c1e976f0adacaa11511944fe7e57034",
    "filename": "src/main/java/org/apache/commons/lang3/EnumUtils.java",
    "status": "modified",
    "additions": 26,
    "deletions": 4,
    "changes": 30,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/EnumUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/EnumUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/EnumUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -33,10 +33,10 @@\n  */\n public class EnumUtils {\n \n-    private static final String NULL_ELEMENTS_NOT_PERMITTED = \"null elements not permitted\";\n     private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n-    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n     private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n+    private static final String NULL_ELEMENTS_NOT_PERMITTED = \"null elements not permitted\";\n+    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n \n     /**\n      * Validate {@code enumClass}.\n@@ -116,7 +116,7 @@\n         Validate.notNull(values);\n         long total = 0;\n         for (final E constant : values) {\n-            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n+            Validate.notNull(constant, NULL_ELEMENTS_NOT_PERMITTED);\n             total |= 1L << constant.ordinal();\n         }\n         return total;\n@@ -173,7 +173,7 @@\n         Validate.notNull(values);\n         final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n         for (final E constant : values) {\n-            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n+            Validate.notNull(constant, NULL_ELEMENTS_NOT_PERMITTED);\n             condensed.add(constant);\n         }\n         final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n@@ -294,6 +294,28 @@\n         return map;\n     }\n \n+    /**\n+     * <p>\n+     * Gets the enum for the class in a system property, returning {@code defaultEnum} if not found.\n+     * </p>\n+     *\n+     * <p>\n+     * This method differs from {@link Enum#valueOf} in that it does not throw an exception for an invalid enum name.\n+     * </p>\n+     *\n+     * @param <E> the type of the enumeration\n+     * @param enumClass the class of the enum to query, not null\n+     * @param propName the system property key for the enum name, null returns default enum\n+     * @param defaultEnum the default enum\n+     * @return the enum, default enum if not found\n+     * @since 3.13.0\n+     */\n+    public static <E extends Enum<E>> E getEnumSystemProperty(final Class<E> enumClass, final String propName,\n+        final E defaultEnum) {\n+        return enumClass == null || propName == null ? defaultEnum\n+            : getEnum(enumClass, System.getProperty(propName), defaultEnum);\n+    }\n+\n     /**\n      * <p>Checks if the specified name is a valid enum for the class.</p>\n      *"
  },
  {
    "sha": "260b32758392d5698d6307bd0310f6c9aa76df4f",
    "filename": "src/main/java/org/apache/commons/lang3/Functions.java",
    "status": "modified",
    "additions": 436,
    "deletions": 278,
    "changes": 714,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/Functions.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/Functions.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/Functions.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -32,149 +32,349 @@\n import java.util.stream.Stream;\n \n import org.apache.commons.lang3.Streams.FailableStream;\n+import org.apache.commons.lang3.function.FailableBooleanSupplier;\n \n-\n-/** This class provides utility functions, and classes for working with the\n- * {@code java.util.function} package, or more generally, with Java 8\n- * lambdas.\n- * More specifically, it attempts to address the fact that lambdas are supposed\n- * not to throw Exceptions, at least not checked Exceptions, aka instances of\n- * {@link Exception}. This enforces the use of constructs like\n- * <pre>{@code\n- *   Consumer<java.lang.reflect.Method> consumer = (m) -> {\n- *       try {\n- *           m.invoke(o, args);\n- *       } catch (Throwable t) {\n- *           throw Functions.rethrow(t);\n- *       }\n- *   };\n+/**\n+ * This class provides utility functions, and classes for working with the {@code java.util.function} package, or more\n+ * generally, with Java 8 lambdas. More specifically, it attempts to address the fact that lambdas are supposed not to\n+ * throw Exceptions, at least not checked Exceptions, AKA instances of {@link Exception}. This enforces the use of\n+ * constructs like:\n+ *\n+ * <pre>\n+ * {@code\n+ *     Consumer<java.lang.reflect.Method> consumer = m -> {\n+ *         try {\n+ *             m.invoke(o, args);\n+ *         } catch (Throwable t) {\n+ *             throw Functions.rethrow(t);\n+ *         }\n+ *     };\n  * }</pre>\n- * By replacing a {@link java.util.function.Consumer Consumer&lt;O&gt;} with a\n- * {@link FailableConsumer FailableConsumer&lt;O,? extends Throwable&gt;}, this can be\n- * written like follows:\n- * <pre>{@code\n+ *\n+ * <p>\n+ * By replacing a {@link java.util.function.Consumer Consumer&lt;O&gt;} with a {@link FailableConsumer\n+ * FailableConsumer&lt;O,? extends Throwable&gt;}, this can be written like follows:\n+ * </p>\n+ *\n+ * <pre>\n+ * {@code\n  *   Functions.accept((m) -> m.invoke(o,args));\n  * }</pre>\n- * Obviously, the second version is much more concise and the spirit of\n- * Lambda expressions is met better than the second version.\n+ *\n+ * <p>\n+ * Obviously, the second version is much more concise and the spirit of Lambda expressions is met better than the second\n+ * version.\n+ * </p>\n+ * @since 3.9\n+ * @deprecated Use {@link org.apache.commons.lang3.function.Failable}.\n  */\n+@Deprecated\n public class Functions {\n \n+    /**\n+     * A functional interface like {@link BiConsumer} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <O1> Consumed type 1.\n+     * @param <O2> Consumed type 2.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableBiConsumer}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableRunnable<T extends Throwable> {\n+    public interface FailableBiConsumer<O1, O2, T extends Throwable> {\n+\n         /**\n-         * Runs the function.\n-         * @throws T if the function fails\n+         * Accepts the consumer.\n+         *\n+         * @param object1 the first parameter for the consumable to accept\n+         * @param object2 the second parameter for the consumable to accept\n+         * @throws T Thrown when the consumer fails.\n          */\n-        void run() throws T;\n+        void accept(O1 object1, O2 object2) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link BiFunction} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <O1> Input type 1.\n+     * @param <O2> Input type 2.\n+     * @param <R> Return type.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableBiFunction}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableCallable<O, T extends Throwable> {\n+    public interface FailableBiFunction<O1, O2, R, T extends Throwable> {\n+\n         /**\n-         * Calls the callable.\n-         * @return The value returned from the callable\n-         * @throws T if the callable fails\n+         * Applies this function.\n+         *\n+         * @param input1 the first input for the function\n+         * @param input2 the second input for the function\n+         * @return the result of the function\n+         * @throws T Thrown when the function fails.\n          */\n-        O call() throws T;\n+        R apply(O1 input1, O2 input2) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link BiPredicate} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <O1> Predicate type 1.\n+     * @param <O2> Predicate type 2.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableBiPredicate}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableConsumer<O, T extends Throwable> {\n+    public interface FailableBiPredicate<O1, O2, T extends Throwable> {\n+\n         /**\n-         * Accepts the consumer.\n-         * @param object the parameter for the consumable to accept\n-         * @throws T if the consumer fails\n+         * Tests the predicate.\n+         *\n+         * @param object1 the first object to test the predicate on\n+         * @param object2 the second object to test the predicate on\n+         * @return the predicate's evaluation\n+         * @throws T if the predicate fails\n          */\n-        void accept(O object) throws T;\n+        boolean test(O1 object1, O2 object2) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link java.util.concurrent.Callable} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <R> Return type.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableCallable}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableBiConsumer<O1, O2, T extends Throwable> {\n+    public interface FailableCallable<R, T extends Throwable> {\n+\n         /**\n-         * Accepts the consumer.\n-         * @param object1 the first parameter for the consumable to accept\n-         * @param object2 the second parameter for the consumable to accept\n-         * @throws T if the consumer fails\n+         * Calls the callable.\n+         *\n+         * @return The value returned from the callable\n+         * @throws T if the callable fails\n          */\n-        void accept(O1 object1, O2 object2) throws T;\n+        R call() throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link Consumer} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <O> Consumed type 1.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableConsumer}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableFunction<I, O, T extends Throwable> {\n+    public interface FailableConsumer<O, T extends Throwable> {\n+\n         /**\n-         * Apply the function.\n-         * @param input the input for the function\n-         * @return the result of the function\n-         * @throws T if the function fails\n+         * Accepts the consumer.\n+         *\n+         * @param object the parameter for the consumable to accept\n+         * @throws T Thrown when the consumer fails.\n          */\n-        O apply(I input) throws T;\n+        void accept(O object) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link Function} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <I> Input type 1.\n+     * @param <R> Return type.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableFunction}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableBiFunction<I1, I2, O, T extends Throwable> {\n+    public interface FailableFunction<I, R, T extends Throwable> {\n+\n         /**\n-         * Apply the function.\n-         * @param input1 the first input for the function\n-         * @param input2 the second input for the function\n+         * Applies this function.\n+         *\n+         * @param input the input for the function\n          * @return the result of the function\n-         * @throws T if the function fails\n+         * @throws T Thrown when the function fails.\n          */\n-        O apply(I1 input1, I2 input2) throws T;\n+        R apply(I input) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link Predicate} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <I> Predicate type 1.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailablePredicate}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailablePredicate<O, T extends Throwable> {\n+    public interface FailablePredicate<I, T extends Throwable> {\n+\n         /**\n-         * Test the predicate.\n+         * Tests the predicate.\n+         *\n          * @param object the object to test the predicate on\n          * @return the predicate's evaluation\n          * @throws T if the predicate fails\n          */\n-        boolean test(O object) throws T;\n+        boolean test(I object) throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link Runnable} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableRunnable}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableBiPredicate<O1, O2, T extends Throwable> {\n+    public interface FailableRunnable<T extends Throwable> {\n+\n         /**\n-         * Test the predicate.\n-         * @param object1 the first object to test the predicate on\n-         * @param object2 the second object to test the predicate on\n-         * @return the predicate's evaluation\n-         * @throws T if the predicate fails\n+         * Runs the function.\n+         *\n+         * @throws T Thrown when the function fails.\n          */\n-        boolean test(O1 object1, O2 object2) throws T;\n+        void run() throws T;\n     }\n \n+    /**\n+     * A functional interface like {@link Supplier} that declares a {@code Throwable}.\n+     *\n+     * <p>TODO for 4.0: Move to org.apache.commons.lang3.function.</p>\n+     *\n+     * @param <R> Return type.\n+     * @param <T> Thrown exception.\n+     * @deprecated Use {@link org.apache.commons.lang3.function.FailableSupplier}.\n+     */\n+    @Deprecated\n     @FunctionalInterface\n-    public interface FailableSupplier<O, T extends Throwable> {\n+    public interface FailableSupplier<R, T extends Throwable> {\n+\n         /**\n          * Supplies an object\n-         * @return the suppliers result\n+         *\n+         * @return a result\n          * @throws T if the supplier fails\n          */\n-        O get() throws T;\n+        R get() throws T;\n     }\n \n     /**\n-     * Converts the given {@link FailableRunnable} into a standard {@link Runnable}.\n+     * Consumes a consumer and rethrows any exception as a {@link RuntimeException}.\n      *\n-     * @param runnable a {@code FailableRunnable}\n-     * @return a standard {@code Runnable}\n+     * @param consumer the consumer to consume\n+     * @param object1 the first object to consume by {@code consumer}\n+     * @param object2 the second object to consume by {@code consumer}\n+     * @param <O1> the type of the first argument the consumer accepts\n+     * @param <O2> the type of the second argument the consumer accepts\n+     * @param <T> the type of checked exception the consumer may throw\n      */\n-    public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n-        return () -> run(runnable);\n+    public static <O1, O2, T extends Throwable> void accept(final FailableBiConsumer<O1, O2, T> consumer,\n+        final O1 object1, final O2 object2) {\n+        run(() -> consumer.accept(object1, object2));\n     }\n \n     /**\n-     * Converts the given {@link FailableConsumer} into a standard {@link Consumer}.\n+     * Consumes a consumer and rethrows any exception as a {@link RuntimeException}.\n      *\n-     * @param <I> the type used by the consumers\n-     * @param consumer a {@code FailableConsumer}\n-     * @return a standard {@code Consumer}\n+     * @param consumer the consumer to consume\n+     * @param object the object to consume by {@code consumer}\n+     * @param <O> the type the consumer accepts\n+     * @param <T> the type of checked exception the consumer may throw\n      */\n-    public static <I> Consumer<I> asConsumer(final FailableConsumer<I, ?> consumer) {\n-        return input -> accept(consumer, input);\n+    public static <O, T extends Throwable> void accept(final FailableConsumer<O, T> consumer, final O object) {\n+        run(() -> consumer.accept(object));\n+    }\n+\n+    /**\n+     * Applies a function and rethrows any exception as a {@link RuntimeException}.\n+     *\n+     * @param function the function to apply\n+     * @param input1 the first input to apply {@code function} on\n+     * @param input2 the second input to apply {@code function} on\n+     * @param <O1> the type of the first argument the function accepts\n+     * @param <O2> the type of the second argument the function accepts\n+     * @param <O> the return type of the function\n+     * @param <T> the type of checked exception the function may throw\n+     * @return the value returned from the function\n+     */\n+    public static <O1, O2, O, T extends Throwable> O apply(final FailableBiFunction<O1, O2, O, T> function,\n+        final O1 input1, final O2 input2) {\n+        return get(() -> function.apply(input1, input2));\n+    }\n+\n+    /**\n+     * Applies a function and rethrows any exception as a {@link RuntimeException}.\n+     *\n+     * @param function the function to apply\n+     * @param input the input to apply {@code function} on\n+     * @param <I> the type of the argument the function accepts\n+     * @param <O> the return type of the function\n+     * @param <T> the type of checked exception the function may throw\n+     * @return the value returned from the function\n+     */\n+    public static <I, O, T extends Throwable> O apply(final FailableFunction<I, O, T> function, final I input) {\n+        return get(() -> function.apply(input));\n+    }\n+\n+    /**\n+     * Converts the given {@link FailableBiConsumer} into a standard {@link BiConsumer}.\n+     *\n+     * @param <O1> the type of the first argument of the consumers\n+     * @param <O2> the type of the second argument of the consumers\n+     * @param consumer a failable {@code BiConsumer}\n+     * @return a standard {@code BiConsumer}\n+     * @since 3.10\n+     */\n+    public static <O1, O2> BiConsumer<O1, O2> asBiConsumer(final FailableBiConsumer<O1, O2, ?> consumer) {\n+        return (input1, input2) -> accept(consumer, input1, input2);\n+    }\n+\n+    /**\n+     * Converts the given {@link FailableBiFunction} into a standard {@link BiFunction}.\n+     *\n+     * @param <O1> the type of the first argument of the input of the functions\n+     * @param <O2> the type of the second argument of the input of the functions\n+     * @param <O> the type of the output of the functions\n+     * @param function a {@code FailableBiFunction}\n+     * @return a standard {@code BiFunction}\n+     * @since 3.10\n+     */\n+    public static <O1, O2, O> BiFunction<O1, O2, O> asBiFunction(final FailableBiFunction<O1, O2, O, ?> function) {\n+        return (input1, input2) -> apply(function, input1, input2);\n+    }\n+\n+    /**\n+     * Converts the given {@link FailableBiPredicate} into a standard {@link BiPredicate}.\n+     *\n+     * @param <O1> the type of the first argument used by the predicates\n+     * @param <O2> the type of the second argument used by the predicates\n+     * @param predicate a {@code FailableBiPredicate}\n+     * @return a standard {@code BiPredicate}\n+     * @since 3.10\n+     */\n+    public static <O1, O2> BiPredicate<O1, O2> asBiPredicate(final FailableBiPredicate<O1, O2, ?> predicate) {\n+        return (input1, input2) -> test(predicate, input1, input2);\n     }\n \n     /**\n@@ -183,21 +383,22 @@ public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n      * @param <O> the type used by the callables\n      * @param callable a {@code FailableCallable}\n      * @return a standard {@code Callable}\n+     * @since 3.10\n      */\n     public static <O> Callable<O> asCallable(final FailableCallable<O, ?> callable) {\n         return () -> call(callable);\n     }\n \n     /**\n-     * Converts the given {@link FailableBiConsumer} into a standard {@link BiConsumer}.\n+     * Converts the given {@link FailableConsumer} into a standard {@link Consumer}.\n      *\n-     * @param <I1> the type of the first argument of the consumers\n-     * @param <I2> the type of the second argument of the consumers\n-     * @param consumer a failable {@code BiConsumer}\n-     * @return a standard {@code BiConsumer}\n+     * @param <I> the type used by the consumers\n+     * @param consumer a {@code FailableConsumer}\n+     * @return a standard {@code Consumer}\n+     * @since 3.10\n      */\n-    public static <I1, I2> BiConsumer<I1, I2> asBiConsumer(final FailableBiConsumer<I1, I2, ?> consumer) {\n-        return (input1, input2) -> accept(consumer, input1, input2);\n+    public static <I> Consumer<I> asConsumer(final FailableConsumer<I, ?> consumer) {\n+        return input -> accept(consumer, input);\n     }\n \n     /**\n@@ -207,45 +408,33 @@ public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n      * @param <O> the type of the output of the functions\n      * @param function a {code FailableFunction}\n      * @return a standard {@code Function}\n+     * @since 3.10\n      */\n     public static <I, O> Function<I, O> asFunction(final FailableFunction<I, O, ?> function) {\n         return input -> apply(function, input);\n     }\n \n-    /**\n-     * Converts the given {@link FailableBiFunction} into a standard {@link BiFunction}.\n-     *\n-     * @param <I1> the type of the first argument of the input of the functions\n-     * @param <I2> the type of the second argument of the input of the functions\n-     * @param <O> the type of the output of the functions\n-     * @param function a {@code FailableBiFunction}\n-     * @return a standard {@code BiFunction}\n-     */\n-    public static <I1, I2, O> BiFunction<I1, I2, O> asBiFunction(final FailableBiFunction<I1, I2, O, ?> function) {\n-        return (input1, input2) -> apply(function, input1, input2);\n-    }\n-\n     /**\n      * Converts the given {@link FailablePredicate} into a standard {@link Predicate}.\n      *\n      * @param <I> the type used by the predicates\n      * @param predicate a {@code FailablePredicate}\n      * @return a standard {@code Predicate}\n+     * @since 3.10\n      */\n     public static <I> Predicate<I> asPredicate(final FailablePredicate<I, ?> predicate) {\n         return input -> test(predicate, input);\n     }\n \n     /**\n-     * Converts the given {@link FailableBiPredicate} into a standard {@link BiPredicate}.\n+     * Converts the given {@link FailableRunnable} into a standard {@link Runnable}.\n      *\n-     * @param <I1> the type of the first argument used by the predicates\n-     * @param <I2> the type of the second argument used by the predicates\n-     * @param predicate a {@code FailableBiPredicate}\n-     * @return a standard {@code BiPredicate}\n+     * @param runnable a {@code FailableRunnable}\n+     * @return a standard {@code Runnable}\n+     * @since 3.10\n      */\n-    public static <I1, I2> BiPredicate<I1, I2> asBiPredicate(final FailableBiPredicate<I1, I2, ?> predicate) {\n-        return (input1, input2) -> test(predicate, input1, input2);\n+    public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n+        return () -> run(runnable);\n     }\n \n     /**\n@@ -254,26 +443,15 @@ public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n      * @param <O> the type supplied by the suppliers\n      * @param supplier a {@code FailableSupplier}\n      * @return a standard {@code Supplier}\n+     * @since 3.10\n      */\n     public static <O> Supplier<O> asSupplier(final FailableSupplier<O, ?> supplier) {\n         return () -> get(supplier);\n     }\n \n-    /**\n-     * Runs a runnable and rethrows any exception as a {@link RuntimeException}.\n-     * @param runnable The runnable to run\n-     * @param <T> the type of checked exception the runnable may throw\n-     */\n-    public static <T extends Throwable> void run(final FailableRunnable<T> runnable) {\n-        try {\n-            runnable.run();\n-        } catch (final Throwable t) {\n-            throw rethrow(t);\n-        }\n-    }\n-\n     /**\n      * Calls a callable and rethrows any exception as a {@link RuntimeException}.\n+     *\n      * @param callable the callable to call\n      * @param <O> the return type of the callable\n      * @param <T> the type of checked exception the callable may throw\n@@ -284,71 +462,125 @@ public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n     }\n \n     /**\n-     * Consumes a consumer and rethrows any exception as a {@link RuntimeException}.\n-     * @param consumer the consumer to consume\n-     * @param object the object to consume by {@code consumer}\n-     * @param <O> the type the consumer accepts\n-     * @param <T> the type of checked exception the consumer may throw\n+     * Invokes a supplier, and returns the result.\n+     *\n+     * @param supplier The supplier to invoke.\n+     * @param <O> The suppliers output type.\n+     * @param <T> The type of checked exception, which the supplier can throw.\n+     * @return The object, which has been created by the supplier\n+     * @since 3.10\n      */\n-    public static <O, T extends Throwable> void accept(final FailableConsumer<O, T> consumer, final O object) {\n-        run(() -> consumer.accept(object));\n+    public static <O, T extends Throwable> O get(final FailableSupplier<O, T> supplier) {\n+        try {\n+            return supplier.get();\n+        } catch (final Throwable t) {\n+            throw rethrow(t);\n+        }\n     }\n \n     /**\n-     * Consumes a consumer and rethrows any exception as a {@link RuntimeException}.\n-     * @param consumer the consumer to consume\n-     * @param object1 the first object to consume by {@code consumer}\n-     * @param object2 the second object to consume by {@code consumer}\n-     * @param <O1> the type of the first argument the consumer accepts\n-     * @param <O2> the type of the second argument the consumer accepts\n-     * @param <T> the type of checked exception the consumer may throw\n+     * Invokes a boolean supplier, and returns the result.\n+     *\n+     * @param supplier The boolean supplier to invoke.\n+     * @param <T> The type of checked exception, which the supplier can throw.\n+     * @return The boolean, which has been created by the supplier\n      */\n-    public static <O1, O2, T extends Throwable> void accept(final FailableBiConsumer<O1, O2, T> consumer, final O1 object1, final O2 object2) {\n-        run(() -> consumer.accept(object1, object2));\n+    private static <T extends Throwable> boolean getAsBoolean(final FailableBooleanSupplier<T> supplier) {\n+        try {\n+            return supplier.getAsBoolean();\n+        } catch (final Throwable t) {\n+            throw rethrow(t);\n+        }\n     }\n \n     /**\n-     * Applies a function and rethrows any exception as a {@link RuntimeException}.\n-     * @param function the function to apply\n-     * @param input the input to apply {@code function} on\n-     * @param <I> the type of the argument the function accepts\n-     * @param <O> the return type of the function\n-     * @param <T> the type of checked exception the function may throw\n-     * @return the value returned from the function\n+     * <p>\n+     * Rethrows a {@link Throwable} as an unchecked exception. If the argument is already unchecked, namely a\n+     * {@code RuntimeException} or {@code Error} then the argument will be rethrown without modification. If the\n+     * exception is {@code IOException} then it will be wrapped into a {@code UncheckedIOException}. In every other\n+     * cases the exception will be wrapped into a {@code\n+     * UndeclaredThrowableException}\n+     * </p>\n+     *\n+     * <p>\n+     * Note that there is a declared return type for this method, even though it never returns. The reason for that is\n+     * to support the usual pattern:\n+     * </p>\n+     *\n+     * <pre>\n+     * throw rethrow(myUncheckedException);</pre>\n+     *\n+     * <p>\n+     * instead of just calling the method. This pattern may help the Java compiler to recognize that at that point an\n+     * exception will be thrown and the code flow analysis will not demand otherwise mandatory commands that could\n+     * follow the method call, like a {@code return} statement from a value returning method.\n+     * </p>\n+     *\n+     * @param throwable The throwable to rethrow ossibly wrapped into an unchecked exception\n+     * @return Never returns anything, this method never terminates normally.\n      */\n-    public static <I, O, T extends Throwable> O apply(final FailableFunction<I, O, T> function, final I input) {\n-        return get(() -> function.apply(input));\n+    public static RuntimeException rethrow(final Throwable throwable) {\n+        Objects.requireNonNull(throwable, \"throwable\");\n+        if (throwable instanceof RuntimeException) {\n+            throw (RuntimeException) throwable;\n+        }\n+        if (throwable instanceof Error) {\n+            throw (Error) throwable;\n+        }\n+        if (throwable instanceof IOException) {\n+            throw new UncheckedIOException((IOException) throwable);\n+        }\n+        throw new UndeclaredThrowableException(throwable);\n     }\n \n     /**\n-     * Applies a function and rethrows any exception as a {@link RuntimeException}.\n-     * @param function the function to apply\n-     * @param input1 the first input to apply {@code function} on\n-     * @param input2 the second input to apply {@code function} on\n-     * @param <I1> the type of the first argument the function accepts\n-     * @param <I2> the type of the second argument the function accepts\n-     * @param <O> the return type of the function\n-     * @param <T> the type of checked exception the function may throw\n-     * @return the value returned from the function\n+     * Runs a runnable and rethrows any exception as a {@link RuntimeException}.\n+     *\n+     * @param runnable The runnable to run\n+     * @param <T> the type of checked exception the runnable may throw\n      */\n-    public static <I1, I2, O, T extends Throwable> O apply(final FailableBiFunction<I1, I2, O, T> function, final I1 input1, final I2 input2) {\n-        return get(() -> function.apply(input1, input2));\n+    public static <T extends Throwable> void run(final FailableRunnable<T> runnable) {\n+        try {\n+            runnable.run();\n+        } catch (final Throwable t) {\n+            throw rethrow(t);\n+        }\n     }\n \n     /**\n-     * Tests a predicate and rethrows any exception as a {@link RuntimeException}.\n-     * @param predicate the predicate to test\n-     * @param object the input to test by {@code predicate}\n-     * @param <O> the type of argument the predicate tests\n-     * @param <T> the type of checked exception the predicate may throw\n-     * @return the boolean value returned by the predicate\n+     * Converts the given collection into a {@link FailableStream}. The {@link FailableStream} consists of the\n+     * collections elements. Shortcut for\n+     *\n+     * <pre>\n+     * Functions.stream(collection.stream());</pre>\n+     *\n+     * @param collection The collection, which is being converted into a {@link FailableStream}.\n+     * @param <O> The collections element type. (In turn, the result streams element type.)\n+     * @return The created {@link FailableStream}.\n+     * @since 3.10\n      */\n-    public static <O, T extends Throwable> boolean test(final FailablePredicate<O, T> predicate, final O object) {\n-        return get(() -> predicate.test(object));\n+    public static <O> FailableStream<O> stream(final Collection<O> collection) {\n+        return new FailableStream<>(collection.stream());\n+    }\n+\n+    /**\n+     * Converts the given stream into a {@link FailableStream}. The {@link FailableStream} consists of the same\n+     * elements, than the input stream. However, failable lambdas, like {@link FailablePredicate},\n+     * {@link FailableFunction}, and {@link FailableConsumer} may be applied, rather than {@link Predicate},\n+     * {@link Function}, {@link Consumer}, etc.\n+     *\n+     * @param stream The stream, which is being converted into a {@link FailableStream}.\n+     * @param <O> The streams element type.\n+     * @return The created {@link FailableStream}.\n+     * @since 3.10\n+     */\n+    public static <O> FailableStream<O> stream(final Stream<O> stream) {\n+        return new FailableStream<>(stream);\n     }\n \n     /**\n      * Tests a predicate and rethrows any exception as a {@link RuntimeException}.\n+     *\n      * @param predicate the predicate to test\n      * @param object1 the first input to test by {@code predicate}\n      * @param object2 the second input to test by {@code predicate}\n@@ -357,85 +589,48 @@ public static Runnable asRunnable(final FailableRunnable<?> runnable) {\n      * @param <T> the type of checked exception the predicate may throw\n      * @return the boolean value returned by the predicate\n      */\n-    public static <O1, O2, T extends Throwable> boolean test(final FailableBiPredicate<O1, O2, T> predicate, final O1 object1, final O2 object2) {\n-        return get(() -> predicate.test(object1, object2));\n+    public static <O1, O2, T extends Throwable> boolean test(final FailableBiPredicate<O1, O2, T> predicate,\n+        final O1 object1, final O2 object2) {\n+        return getAsBoolean(() -> predicate.test(object1, object2));\n     }\n \n     /**\n-     * Invokes the supplier, and returns the result.\n-     * @param supplier The supplier to invoke.\n-     * @param <O> The suppliers output type.\n-     * @param <T> The type of checked exception, which the supplier can throw.\n-     * @return The object, which has been created by the supplier\n-     */\n-    public static <O, T extends Throwable> O get(final FailableSupplier<O, T> supplier) {\n-        try {\n-            return supplier.get();\n-        } catch (final Throwable t) {\n-            throw rethrow(t);\n-        }\n-    }\n-\n-    /**\n-     * Converts the given stream into a {@link FailableStream}. The\n-     * {@link FailableStream} consists of the same elements, than the\n-     * input stream. However, failable lambdas, like\n-     * {@link FailablePredicate}, {@link FailableFunction}, and\n-     * {@link FailableConsumer} may be applied, rather than\n-     * {@link Predicate}, {@link Function}, {@link Consumer}, etc.\n-     * @param stream The stream, which is being converted into a\n-     *   {@link FailableStream}.\n-     * @param <O> The streams element type.\n-     * @return The created {@link FailableStream}.\n-     */\n-    public static <O> FailableStream<O> stream(final Stream<O> stream) {\n-        return new FailableStream<>(stream);\n-    }\n-\n-    /**\n-     * Converts the given collection into a {@link FailableStream}.\n-     * The {@link FailableStream} consists of the collections\n-     * elements. Shortcut for\n-     * <pre>\n-     *   Functions.stream(collection.stream());\n-     * </pre>\n-     * @param collection The collection, which is being converted into a\n-     *   {@link FailableStream}.\n-     * @param <O> The collections element type. (In turn, the result\n-     *   streams element type.)\n-     * @return The created {@link FailableStream}.\n+     * Tests a predicate and rethrows any exception as a {@link RuntimeException}.\n+     *\n+     * @param predicate the predicate to test\n+     * @param object the input to test by {@code predicate}\n+     * @param <O> the type of argument the predicate tests\n+     * @param <T> the type of checked exception the predicate may throw\n+     * @return the boolean value returned by the predicate\n      */\n-    public static <O> FailableStream<O> stream(final Collection<O> collection) {\n-        return new FailableStream<>(collection.stream());\n+    public static <O, T extends Throwable> boolean test(final FailablePredicate<O, T> predicate, final O object) {\n+        return getAsBoolean(() -> predicate.test(object));\n     }\n \n-\n     /**\n-     * A simple try-with-resources implementation, that can be used, if your\n-     * objects do not implement the {@link AutoCloseable} interface. The method\n-     * executes the {@code action}. The method guarantees, that <em>all</em>\n-     * the {@code resources} are being executed, in the given order, afterwards,\n-     * and regardless of success, or failure. If either the original action, or\n-     * any of the resource action fails, then the <em>first</em> failure (aka\n+     * A simple try-with-resources implementation, that can be used, if your objects do not implement the\n+     * {@link AutoCloseable} interface. The method executes the {@code action}. The method guarantees, that <em>all</em>\n+     * the {@code resources} are being executed, in the given order, afterwards, and regardless of success, or failure.\n+     * If either the original action, or any of the resource action fails, then the <em>first</em> failure (AKA\n      * {@link Throwable} is rethrown. Example use:\n-     * <pre>{@code\n-     *   final FileInputStream fis = new FileInputStream(\"my.file\");\n-     *   Functions.tryWithResources(useInputStream(fis), null, () -> fis.close());\n+     *\n+     * <pre>\n+     * {@code\n+     *     final FileInputStream fis = new FileInputStream(\"my.file\");\n+     *     Functions.tryWithResources(useInputStream(fis), null, () -> fis.close());\n      * }</pre>\n-     * @param action The action to execute. This object <em>will</em> always\n-     *   be invoked.\n-     * @param errorHandler An optional error handler, which will be invoked finally,\n-     *   if any error occurred. The error handler will receive the first\n-     *   error, aka {@link Throwable}.\n-     * @param resources The resource actions to execute. <em>All</em> resource\n-     *   actions will be invoked, in the given order. A resource action is an\n-     *   instance of {@link FailableRunnable}, which will be executed.\n+     *\n+     * @param action The action to execute. This object <em>will</em> always be invoked.\n+     * @param errorHandler An optional error handler, which will be invoked finally, if any error occurred. The error\n+     *        handler will receive the first error, AKA {@link Throwable}.\n+     * @param resources The resource actions to execute. <em>All</em> resource actions will be invoked, in the given\n+     *        order. A resource action is an instance of {@link FailableRunnable}, which will be executed.\n      * @see #tryWithResources(FailableRunnable, FailableRunnable...)\n      */\n     @SafeVarargs\n     public static void tryWithResources(final FailableRunnable<? extends Throwable> action,\n-                                            final FailableConsumer<Throwable, ? extends Throwable> errorHandler,\n-                                            final FailableRunnable<? extends Throwable>... resources) {\n+        final FailableConsumer<Throwable, ? extends Throwable> errorHandler,\n+        final FailableRunnable<? extends Throwable>... resources) {\n         final FailableConsumer<Throwable, ? extends Throwable> actualErrorHandler;\n         if (errorHandler == null) {\n             actualErrorHandler = Functions::rethrow;\n@@ -474,63 +669,26 @@ public static void tryWithResources(final FailableRunnable<? extends Throwable>\n     }\n \n     /**\n-     * A simple try-with-resources implementation, that can be used, if your\n-     * objects do not implement the {@link AutoCloseable} interface. The method\n-     * executes the {@code action}. The method guarantees, that <em>all</em>\n-     * the {@code resources} are being executed, in the given order, afterwards,\n-     * and regardless of success, or failure. If either the original action, or\n-     * any of the resource action fails, then the <em>first</em> failure (aka\n+     * A simple try-with-resources implementation, that can be used, if your objects do not implement the\n+     * {@link AutoCloseable} interface. The method executes the {@code action}. The method guarantees, that <em>all</em>\n+     * the {@code resources} are being executed, in the given order, afterwards, and regardless of success, or failure.\n+     * If either the original action, or any of the resource action fails, then the <em>first</em> failure (AKA\n      * {@link Throwable} is rethrown. Example use:\n-     * <pre>{@code\n-     *   final FileInputStream fis = new FileInputStream(\"my.file\");\n-     *   Functions.tryWithResources(useInputStream(fis), () -> fis.close());\n+     *\n+     * <pre>\n+     * {@code\n+     *     final FileInputStream fis = new FileInputStream(\"my.file\");\n+     *     Functions.tryWithResources(useInputStream(fis), () -> fis.close());\n      * }</pre>\n-     * @param action The action to execute. This object <em>will</em> always\n-     *   be invoked.\n-     * @param resources The resource actions to execute. <em>All</em> resource\n-     *   actions will be invoked, in the given order. A resource action is an\n-     *   instance of {@link FailableRunnable}, which will be executed.\n+     *\n+     * @param action The action to execute. This object <em>will</em> always be invoked.\n+     * @param resources The resource actions to execute. <em>All</em> resource actions will be invoked, in the given\n+     *        order. A resource action is an instance of {@link FailableRunnable}, which will be executed.\n      * @see #tryWithResources(FailableRunnable, FailableConsumer, FailableRunnable...)\n      */\n     @SafeVarargs\n     public static void tryWithResources(final FailableRunnable<? extends Throwable> action,\n-                                            final FailableRunnable<? extends Throwable>... resources) {\n+        final FailableRunnable<? extends Throwable>... resources) {\n         tryWithResources(action, null, resources);\n     }\n-\n-    /**\n-     * <p>Rethrows a {@link Throwable} as an unchecked exception. If the argument is\n-     * already unchecked, namely a {@code RuntimeException} or {@code Error} then\n-     * the argument will be rethrown without modification. If the exception is\n-     * {@code IOException} then it will be wrapped into a {@code UncheckedIOException}.\n-     * In every other cases the exception will be wrapped into a {@code\n-     * UndeclaredThrowableException}</p>\n-     *\n-     * <p>Note that there is a declared return type for this method, even though it\n-     * never returns. The reason for that is to support the usual pattern:</p>\n-     *\n-     * <pre>\n-     *      throw rethrow(myUncheckedException);\n-     * </pre>\n-     *\n-     * <p>instead of just calling the method. This pattern may help the Java compiler to\n-     * recognize that at that point an exception will be thrown and the code flow\n-     * analysis will not demand otherwise mandatory commands that could follow the\n-     * method call, like a {@code return} statement from a value returning method.</p>\n-     *\n-     * @param throwable The throwable to rethrow ossibly wrapped into an unchecked exception\n-     * @return Never returns anything, this method never terminates normally.\n-     */\n-    public static RuntimeException rethrow(final Throwable throwable) {\n-        Objects.requireNonNull(throwable, \"throwable\");\n-        if (throwable instanceof RuntimeException) {\n-            throw (RuntimeException) throwable;\n-        } else if (throwable instanceof Error) {\n-            throw (Error) throwable;\n-        } else if (throwable instanceof IOException) {\n-            throw new UncheckedIOException((IOException) throwable);\n-        } else {\n-            throw new UndeclaredThrowableException(throwable);\n-        }\n-    }\n }"
  },
  {
    "sha": "2e075615c55b117d78427b3ecb980c2232563521",
    "filename": "src/main/java/org/apache/commons/lang3/JavaVersion.java",
    "status": "modified",
    "additions": 75,
    "deletions": 37,
    "changes": 112,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/JavaVersion.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/JavaVersion.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/JavaVersion.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -81,40 +81,68 @@\n     JAVA_1_9(9.0f, \"9\"),\n \n     /**\n-     * Java 9\n+     * Java 9.\n      *\n      * @since 3.5\n      */\n     JAVA_9(9.0f, \"9\"),\n \n     /**\n-     * Java 10\n+     * Java 10.\n      *\n      * @since 3.7\n      */\n     JAVA_10(10.0f, \"10\"),\n \n     /**\n-     * Java 11\n+     * Java 11.\n      *\n      * @since 3.8\n      */\n     JAVA_11(11.0f, \"11\"),\n \n     /**\n-     * Java 12\n+     * Java 12.\n      *\n      * @since 3.9\n      */\n     JAVA_12(12.0f, \"12\"),\n \n     /**\n-     * Java 13\n+     * Java 13.\n      *\n      * @since 3.9\n      */\n     JAVA_13(13.0f, \"13\"),\n \n+    /**\n+     * Java 14.\n+     *\n+     * @since 3.11\n+     */\n+    JAVA_14(14.0f, \"14\"),\n+\n+    /**\n+     * Java 15.\n+     *\n+     * @since 3.11\n+     */\n+    JAVA_15(15.0f, \"15\"),\n+\n+    /**\n+     * Java 16.\n+     *\n+     * @since 3.11\n+     */\n+    JAVA_16(16.0f, \"16\"),\n+\n+    /**\n+     * Java 17.\n+     *\n+     * @since 3.12.0\n+     */\n+    JAVA_17(17.0f, \"17\"),\n+\n     /**\n      * The most recent java version. Mainly introduced to avoid to break when a new version of Java is used.\n      */\n@@ -189,53 +217,64 @@ static JavaVersion getJavaVersion(final String nom) {\n      * corresponding constant of this enumeration class. This method is used\n      * internally.\n      *\n-     * @param nom the Java version as string\n+     * @param versionStr the Java version as string\n      * @return the corresponding enumeration constant or <b>null</b> if the\n      * version is unknown\n      */\n-    static JavaVersion get(final String nom) {\n-        if (nom == null) {\n+    static JavaVersion get(final String versionStr) {\n+        if (versionStr == null) {\n             return null;\n-        } else if (\"0.9\".equals(nom)) {\n+        }\n+        switch (versionStr) {\n+        case \"0.9\":\n             return JAVA_0_9;\n-        } else if (\"1.1\".equals(nom)) {\n+        case \"1.1\":\n             return JAVA_1_1;\n-        } else if (\"1.2\".equals(nom)) {\n+        case \"1.2\":\n             return JAVA_1_2;\n-        } else if (\"1.3\".equals(nom)) {\n+        case \"1.3\":\n             return JAVA_1_3;\n-        } else if (\"1.4\".equals(nom)) {\n+        case \"1.4\":\n             return JAVA_1_4;\n-        } else if (\"1.5\".equals(nom)) {\n+        case \"1.5\":\n             return JAVA_1_5;\n-        } else if (\"1.6\".equals(nom)) {\n+        case \"1.6\":\n             return JAVA_1_6;\n-        } else if (\"1.7\".equals(nom)) {\n+        case \"1.7\":\n             return JAVA_1_7;\n-        } else if (\"1.8\".equals(nom)) {\n+        case \"1.8\":\n             return JAVA_1_8;\n-        } else if (\"9\".equals(nom)) {\n+        case \"9\":\n             return JAVA_9;\n-        } else if (\"10\".equals(nom)) {\n+        case \"10\":\n             return JAVA_10;\n-        } else if (\"11\".equals(nom)) {\n+        case \"11\":\n             return JAVA_11;\n-        } else if (\"12\".equals(nom)) {\n+        case \"12\":\n             return JAVA_12;\n-        } else if (\"13\".equals(nom)) {\n+        case \"13\":\n             return JAVA_13;\n-        }\n-        final float v = toFloatVersion(nom);\n-        if ((v - 1.) < 1.) { // then we need to check decimals > .9\n-            final int firstComma = Math.max(nom.indexOf('.'), nom.indexOf(','));\n-            final int end = Math.max(nom.length(), nom.indexOf(',', firstComma));\n-            if (Float.parseFloat(nom.substring(firstComma + 1, end)) > .9f) {\n+        case \"14\":\n+            return JAVA_14;\n+        case \"15\":\n+            return JAVA_15;\n+        case \"16\":\n+            return JAVA_16;\n+        case \"17\":\n+            return JAVA_17;\n+        default:\n+            final float v = toFloatVersion(versionStr);\n+            if ((v - 1.) < 1.) { // then we need to check decimals > .9\n+                final int firstComma = Math.max(versionStr.indexOf('.'), versionStr.indexOf(','));\n+                final int end = Math.max(versionStr.length(), versionStr.indexOf(',', firstComma));\n+                if (Float.parseFloat(versionStr.substring(firstComma + 1, end)) > .9f) {\n+                    return JAVA_RECENT;\n+                }\n+            } else if (v > 10) {\n                 return JAVA_RECENT;\n             }\n-        } else if (v > 10) {\n-            return JAVA_RECENT;\n+            return null;\n         }\n-        return null;\n     }\n \n     //-----------------------------------------------------------------------\n@@ -272,14 +311,13 @@ private static float maxVersion() {\n      */\n     private static float toFloatVersion(final String value) {\n         final int defaultReturnValue = -1;\n-        if (value.contains(\".\")) {\n-            final String[] toParse = value.split(\"\\\\.\");\n-            if (toParse.length >= 2) {\n-                return NumberUtils.toFloat(toParse[0] + '.' + toParse[1], defaultReturnValue);\n-            }\n-        } else {\n+        if (!value.contains(\".\")) {\n             return NumberUtils.toFloat(value, defaultReturnValue);\n         }\n+        final String[] toParse = value.split(\"\\\\.\");\n+        if (toParse.length >= 2) {\n+            return NumberUtils.toFloat(toParse[0] + '.' + toParse[1], defaultReturnValue);\n+        }\n         return defaultReturnValue;\n     }\n }"
  },
  {
    "sha": "b57e3c04fe6c29702c0e32c6b6416901a53cd40b",
    "filename": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
    "status": "modified",
    "additions": 195,
    "deletions": 194,
    "changes": 389,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/LocaleUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/LocaleUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/LocaleUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -31,12 +31,26 @@\n  *\n  * <p>This class tries to handle {@code null} input gracefully.\n  * An exception will not be thrown for a {@code null} input.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * @since 2.2\n  */\n public class LocaleUtils {\n \n+    // class to avoid synchronization (Init on demand)\n+    static class SyncAvoid {\n+        /** Unmodifiable list of available locales. */\n+        private static final List<Locale> AVAILABLE_LOCALE_LIST;\n+        /** Unmodifiable set of available locales. */\n+        private static final Set<Locale> AVAILABLE_LOCALE_SET;\n+\n+        static {\n+            final List<Locale> list = new ArrayList<>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n+            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\n+            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<>(list));\n+        }\n+    }\n+\n     /** Concurrent map of language locales by country. */\n     private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry =\n         new ConcurrentHashMap<>();\n@@ -46,126 +60,70 @@\n         new ConcurrentHashMap<>();\n \n     /**\n-     * <p>{@code LocaleUtils} instances should NOT be constructed in standard programming.\n-     * Instead, the class should be used as {@code LocaleUtils.toLocale(\"en_GB\");}.</p>\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n      *\n-     * <p>This constructor is public to permit tools that require a JavaBean instance\n-     * to operate.</p>\n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n      */\n-    public LocaleUtils() {\n-      super();\n+    public static List<Locale> availableLocaleList() {\n+        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Converts a String to a Locale.</p>\n-     *\n-     * <p>This method takes the string format of a locale and creates the\n-     * locale object from it.</p>\n-     *\n-     * <pre>\n-     *   LocaleUtils.toLocale(\"\")           = new Locale(\"\", \"\")\n-     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n-     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n-     *   LocaleUtils.toLocale(\"en_001\")     = new Locale(\"en\", \"001\")\n-     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n-     * </pre>\n-     *\n-     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n-     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n-     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n      *\n-     * <p>This method validates the input strictly.\n-     * The language code must be lowercase.\n-     * The country code must be uppercase.\n-     * The separator must be an underscore.\n-     * The length must be correct.\n-     * </p>\n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n      *\n-     * @param str  the locale String to convert, null returns null\n-     * @return a Locale, null if null input\n-     * @throws IllegalArgumentException if the string is an invalid format\n-     * @see Locale#forLanguageTag(String)\n+     * @return the unmodifiable set of available locales\n      */\n-    public static Locale toLocale(final String str) {\n-        if (str == null) {\n-            return null;\n-        }\n-        if (str.isEmpty()) { // LANG-941 - JDK 8 introduced an empty locale where all fields are blank\n-            return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n-        }\n-        if (str.contains(\"#\")) { // LANG-879 - Cannot handle Java 7 script & extensions\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        final int len = str.length();\n-        if (len < 2) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        final char ch0 = str.charAt(0);\n-        if (ch0 == '_') {\n-            if (len < 3) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            final char ch1 = str.charAt(1);\n-            final char ch2 = str.charAt(2);\n-            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (len == 3) {\n-                return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n-            }\n-            if (len < 5) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (str.charAt(3) != '_') {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n-        }\n-\n-        return parseLocale(str);\n+    public static Set<Locale> availableLocaleSet() {\n+        return SyncAvoid.AVAILABLE_LOCALE_SET;\n     }\n \n     /**\n-     * Tries to parse a locale from the given String.\n+     * <p>Obtains the list of countries supported for a given language.</p>\n      *\n-     * @param str the String to parse a locale from.\n-     * @return a Locale instance parsed from the given String.\n-     * @throws IllegalArgumentException if the given String can not be parsed.\n+     * <p>This method takes a language code and searches to find the\n+     * countries available for that language. Variant locales are removed.</p>\n+     *\n+     * @param languageCode  the 2 letter language code, null returns empty\n+     * @return an unmodifiable List of Locale objects, not null\n      */\n-    private static Locale parseLocale(final String str) {\n-        if (isISO639LanguageCode(str)) {\n-            return new Locale(str);\n+    public static List<Locale> countriesByLanguage(final String languageCode) {\n+        if (languageCode == null) {\n+            return Collections.emptyList();\n         }\n-\n-        final String[] segments = str.split(\"_\", -1);\n-        final String language = segments[0];\n-        if (segments.length == 2) {\n-            final String country = segments[1];\n-            if (isISO639LanguageCode(language) && isISO3166CountryCode(country) ||\n-                    isNumericAreaCode(country)) {\n-                return new Locale(language, country);\n-            }\n-        } else if (segments.length == 3) {\n-            final String country = segments[1];\n-            final String variant = segments[2];\n-            if (isISO639LanguageCode(language) &&\n-                    (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) &&\n-                    !variant.isEmpty()) {\n-                return new Locale(language, country, variant);\n+        List<Locale> countries = cCountriesByLanguage.get(languageCode);\n+        if (countries == null) {\n+            countries = new ArrayList<>();\n+            final List<Locale> locales = availableLocaleList();\n+            for (final Locale locale : locales) {\n+                if (languageCode.equals(locale.getLanguage()) &&\n+                        !locale.getCountry().isEmpty() &&\n+                    locale.getVariant().isEmpty()) {\n+                    countries.add(locale);\n+                }\n             }\n+            countries = Collections.unmodifiableList(countries);\n+            cCountriesByLanguage.putIfAbsent(languageCode, countries);\n+            countries = cCountriesByLanguage.get(languageCode);\n         }\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        return countries;\n     }\n \n     /**\n-     * Checks whether the given String is a ISO 639 compliant language code.\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n      *\n-     * @param str the String to check.\n-     * @return true, if the given String is a ISO 639 compliant language code.\n+     * @param locale the Locale object to check if it is available\n+     * @return true if the locale is a known locale\n      */\n-    private static boolean isISO639LanguageCode(final String str) {\n-        return StringUtils.isAllLowerCase(str) && (str.length() == 2 || str.length() == 3);\n+    public static boolean isAvailableLocale(final Locale locale) {\n+        return availableLocaleList().contains(locale);\n     }\n \n     /**\n@@ -178,6 +136,16 @@ private static boolean isISO3166CountryCode(final String str) {\n         return StringUtils.isAllUpperCase(str) && str.length() == 2;\n     }\n \n+    /**\n+     * Checks whether the given String is a ISO 639 compliant language code.\n+     *\n+     * @param str the String to check.\n+     * @return true, if the given String is a ISO 639 compliant language code.\n+     */\n+    private static boolean isISO639LanguageCode(final String str) {\n+        return StringUtils.isAllLowerCase(str) && (str.length() == 2 || str.length() == 3);\n+    }\n+\n     /**\n      * Checks whether the given String is a UN M.49 numeric area code.\n      *\n@@ -188,7 +156,36 @@ private static boolean isNumericAreaCode(final String str) {\n         return StringUtils.isNumeric(str) && str.length() == 3;\n     }\n \n-    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n+     * <p>This method takes a country code and searches to find the\n+     * languages available for that country. Variant locales are removed.</p>\n+     *\n+     * @param countryCode  the 2 letter country code, null returns empty\n+     * @return an unmodifiable List of Locale objects, not null\n+     */\n+    public static List<Locale> languagesByCountry(final String countryCode) {\n+        if (countryCode == null) {\n+            return Collections.emptyList();\n+        }\n+        List<Locale> langs = cLanguagesByCountry.get(countryCode);\n+        if (langs == null) {\n+            langs = new ArrayList<>();\n+            final List<Locale> locales = availableLocaleList();\n+            for (final Locale locale : locales) {\n+                if (countryCode.equals(locale.getCountry()) &&\n+                    locale.getVariant().isEmpty()) {\n+                    langs.add(locale);\n+                }\n+            }\n+            langs = Collections.unmodifiableList(langs);\n+            cLanguagesByCountry.putIfAbsent(countryCode, langs);\n+            langs = cLanguagesByCountry.get(countryCode);\n+        }\n+        return langs;\n+    }\n+\n     /**\n      * <p>Obtains the list of locales to search through when performing\n      * a locale search.</p>\n@@ -205,7 +202,6 @@ private static boolean isNumericAreaCode(final String str) {\n         return localeLookupList(locale, locale);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of locales to search through when performing\n      * a locale search.</p>\n@@ -240,121 +236,126 @@ private static boolean isNumericAreaCode(final String str) {\n         return Collections.unmodifiableList(list);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains an unmodifiable list of installed locales.</p>\n-     *\n-     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n-     * It is more efficient, as the JDK method must create a new array each\n-     * time it is called.</p>\n+     * Tries to parse a locale from the given String.\n      *\n-     * @return the unmodifiable list of available locales\n+     * @param str the String to parse a locale from.\n+     * @return a Locale instance parsed from the given String.\n+     * @throws IllegalArgumentException if the given String can not be parsed.\n      */\n-    public static List<Locale> availableLocaleList() {\n-        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n-    }\n+    private static Locale parseLocale(final String str) {\n+        if (isISO639LanguageCode(str)) {\n+            return new Locale(str);\n+        }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Obtains an unmodifiable set of installed locales.</p>\n-     *\n-     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n-     * It is more efficient, as the JDK method must create a new array each\n-     * time it is called.</p>\n-     *\n-     * @return the unmodifiable set of available locales\n-     */\n-    public static Set<Locale> availableLocaleSet() {\n-        return SyncAvoid.AVAILABLE_LOCALE_SET;\n+        final String[] segments = str.split(\"_\", -1);\n+        final String language = segments[0];\n+        if (segments.length == 2) {\n+            final String country = segments[1];\n+            if (isISO639LanguageCode(language) && isISO3166CountryCode(country) ||\n+                    isNumericAreaCode(country)) {\n+                return new Locale(language, country);\n+            }\n+        } else if (segments.length == 3) {\n+            final String country = segments[1];\n+            final String variant = segments[2];\n+            if (isISO639LanguageCode(language) &&\n+                    (country.isEmpty() || isISO3166CountryCode(country) || isNumericAreaCode(country)) &&\n+                    !variant.isEmpty()) {\n+                return new Locale(language, country, variant);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     * Returns the given locale if non-{@code null}, otherwise {@link Locale#getDefault()}.\n      *\n-     * @param locale the Locale object to check if it is available\n-     * @return true if the locale is a known locale\n+     * @param locale a locale or {@code null}.\n+     * @return the given locale if non-{@code null}, otherwise {@link Locale#getDefault()}.\n+     * @since 3.12.0\n      */\n-    public static boolean isAvailableLocale(final Locale locale) {\n-        return availableLocaleList().contains(locale);\n+    public static Locale toLocale(final Locale locale) {\n+        return locale != null ? locale : Locale.getDefault();\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the list of languages supported for a given country.</p>\n+     * <p>Converts a String to a Locale.</p>\n      *\n-     * <p>This method takes a country code and searches to find the\n-     * languages available for that country. Variant locales are removed.</p>\n+     * <p>This method takes the string format of a locale and creates the\n+     * locale object from it.</p>\n      *\n-     * @param countryCode  the 2 letter country code, null returns empty\n-     * @return an unmodifiable List of Locale objects, not null\n+     * <pre>\n+     *   LocaleUtils.toLocale(\"\")           = new Locale(\"\", \"\")\n+     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n+     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n+     *   LocaleUtils.toLocale(\"en_001\")     = new Locale(\"en\", \"001\")\n+     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n+     * </pre>\n+     *\n+     * <p>(#) The behavior of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n+     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n+     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n+     *\n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n+     *\n+     * @param str  the locale String to convert, null returns null\n+     * @return a Locale, null if null input\n+     * @throws IllegalArgumentException if the string is an invalid format\n+     * @see Locale#forLanguageTag(String)\n      */\n-    public static List<Locale> languagesByCountry(final String countryCode) {\n-        if (countryCode == null) {\n-            return Collections.emptyList();\n+    public static Locale toLocale(final String str) {\n+        if (str == null) {\n+            return null;\n         }\n-        List<Locale> langs = cLanguagesByCountry.get(countryCode);\n-        if (langs == null) {\n-            langs = new ArrayList<>();\n-            final List<Locale> locales = availableLocaleList();\n-            for (final Locale locale : locales) {\n-                if (countryCode.equals(locale.getCountry()) &&\n-                    locale.getVariant().isEmpty()) {\n-                    langs.add(locale);\n-                }\n+        if (str.isEmpty()) { // LANG-941 - JDK 8 introduced an empty locale where all fields are blank\n+            return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n+        }\n+        if (str.contains(\"#\")) { // LANG-879 - Cannot handle Java 7 script & extensions\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        final int len = str.length();\n+        if (len < 2) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        final char ch0 = str.charAt(0);\n+        if (ch0 == '_') {\n+            if (len < 3) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n-            langs = Collections.unmodifiableList(langs);\n-            cLanguagesByCountry.putIfAbsent(countryCode, langs);\n-            langs = cLanguagesByCountry.get(countryCode);\n+            final char ch1 = str.charAt(1);\n+            final char ch2 = str.charAt(2);\n+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 3) {\n+                return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n+            }\n+            if (len < 5) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (str.charAt(3) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n         }\n-        return langs;\n+\n+        return parseLocale(str);\n     }\n \n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Obtains the list of countries supported for a given language.</p>\n-     *\n-     * <p>This method takes a language code and searches to find the\n-     * countries available for that language. Variant locales are removed.</p>\n+     * <p>{@code LocaleUtils} instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as {@code LocaleUtils.toLocale(\"en_GB\");}.</p>\n      *\n-     * @param languageCode  the 2 letter language code, null returns empty\n-     * @return an unmodifiable List of Locale objects, not null\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n      */\n-    public static List<Locale> countriesByLanguage(final String languageCode) {\n-        if (languageCode == null) {\n-            return Collections.emptyList();\n-        }\n-        List<Locale> countries = cCountriesByLanguage.get(languageCode);\n-        if (countries == null) {\n-            countries = new ArrayList<>();\n-            final List<Locale> locales = availableLocaleList();\n-            for (final Locale locale : locales) {\n-                if (languageCode.equals(locale.getLanguage()) &&\n-                        !locale.getCountry().isEmpty() &&\n-                    locale.getVariant().isEmpty()) {\n-                    countries.add(locale);\n-                }\n-            }\n-            countries = Collections.unmodifiableList(countries);\n-            cCountriesByLanguage.putIfAbsent(languageCode, countries);\n-            countries = cCountriesByLanguage.get(languageCode);\n-        }\n-        return countries;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    // class to avoid synchronization (Init on demand)\n-    static class SyncAvoid {\n-        /** Unmodifiable list of available locales. */\n-        private static final List<Locale> AVAILABLE_LOCALE_LIST;\n-        /** Unmodifiable set of available locales. */\n-        private static final Set<Locale> AVAILABLE_LOCALE_SET;\n-\n-        static {\n-            final List<Locale> list = new ArrayList<>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n-            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\n-            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<>(list));\n-        }\n+    public LocaleUtils() {\n     }\n \n }"
  },
  {
    "sha": "7eb227fb3efd103065e397806d723a1c21dc9551",
    "filename": "src/main/java/org/apache/commons/lang3/ObjectUtils.java",
    "status": "modified",
    "additions": 969,
    "deletions": 814,
    "changes": 1783,
    "blob_url": "https://github.com/joeyabou/commons-lang/blob/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ObjectUtils.java",
    "raw_url": "https://github.com/joeyabou/commons-lang/raw/69c9593cc1da760bb4dbcf32f4ae755c54376b77/src/main/java/org/apache/commons/lang3/ObjectUtils.java",
    "contents_url": "https://api.github.com/repos/joeyabou/commons-lang/contents/src/main/java/org/apache/commons/lang3/ObjectUtils.java?ref=69c9593cc1da760bb4dbcf32f4ae755c54376b77",
    "patch": "@@ -21,24 +21,27 @@\n import java.lang.reflect.Array;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.time.Duration;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.TreeSet;\n import java.util.function.Supplier;\n \n import org.apache.commons.lang3.exception.CloneFailedException;\n import org.apache.commons.lang3.mutable.MutableInt;\n import org.apache.commons.lang3.text.StrBuilder;\n+import org.apache.commons.lang3.time.DurationUtils;\n \n /**\n  * <p>Operations on {@code Object}.</p>\n  *\n  * <p>This class tries to handle {@code null} input gracefully.\n  * An exception will generally not be thrown for a {@code null} input.\n- * Each method documents its behaviour in more detail.</p>\n+ * Each method documents its behavior in more detail.</p>\n  *\n  * <p>#ThreadSafe#</p>\n  * @since 1.0\n@@ -48,233 +51,127 @@\n // because it is part of the signature of deprecated methods\n public class ObjectUtils {\n \n-    private static final char AT_SIGN = '@';\n-\n+    // Null\n+    //-----------------------------------------------------------------------\n     /**\n-     * <p>Singleton used as a {@code null} placeholder where\n-     * {@code null} has another meaning.</p>\n+     * <p>Class used as a null placeholder where {@code null}\n+     * has another meaning.</p>\n      *\n      * <p>For example, in a {@code HashMap} the\n      * {@link java.util.HashMap#get(java.lang.Object)} method returns\n-     * {@code null} if the {@code Map} contains {@code null} or if there\n-     * is no matching key. The {@code Null} placeholder can be used to\n-     * distinguish between these two cases.</p>\n+     * {@code null} if the {@code Map} contains {@code null} or if there is\n+     * no matching key. The {@code Null} placeholder can be used to distinguish\n+     * between these two cases.</p>\n      *\n      * <p>Another example is {@code Hashtable}, where {@code null}\n      * cannot be stored.</p>\n-     *\n-     * <p>This instance is Serializable.</p>\n      */\n-    public static final Null NULL = new Null();\n-\n-    /**\n-     * <p>{@code ObjectUtils} instances should NOT be constructed in\n-     * standard programming. Instead, the static methods on the class should\n-     * be used, such as {@code ObjectUtils.defaultIfNull(\"a\",\"b\");}.</p>\n-     *\n-     * <p>This constructor is public to permit tools that require a JavaBean\n-     * instance to operate.</p>\n-     */\n-    public ObjectUtils() {\n-        super();\n-    }\n+    public static class Null implements Serializable {\n+        /**\n+         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n+         *\n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 7092611880189329093L;\n \n-    // Empty checks\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Checks if an Object is empty or null.</p>\n-     *\n-     * The following types are supported:\n-     * <ul>\n-     * <li>{@link CharSequence}: Considered empty if its length is zero.</li>\n-     * <li>{@code Array}: Considered empty if its length is zero.</li>\n-     * <li>{@link Collection}: Considered empty if it has zero elements.</li>\n-     * <li>{@link Map}: Considered empty if it has zero key-value mappings.</li>\n-     * </ul>\n-     *\n-     * <pre>\n-     * ObjectUtils.isEmpty(null)             = true\n-     * ObjectUtils.isEmpty(\"\")               = true\n-     * ObjectUtils.isEmpty(\"ab\")             = false\n-     * ObjectUtils.isEmpty(new int[]{})      = true\n-     * ObjectUtils.isEmpty(new int[]{1,2,3}) = false\n-     * ObjectUtils.isEmpty(1234)             = false\n-     * </pre>\n-     *\n-     * @param object  the {@code Object} to test, may be {@code null}\n-     * @return {@code true} if the object has a supported type and is empty or null,\n-     * {@code false} otherwise\n-     * @since 3.9\n-     */\n-    public static boolean isEmpty(final Object object) {\n-        if (object == null) {\n-            return true;\n-        }\n-        if (object instanceof CharSequence) {\n-            return ((CharSequence) object).length() == 0;\n-        }\n-        if (object.getClass().isArray()) {\n-            return Array.getLength(object) == 0;\n-        }\n-        if (object instanceof Collection<?>) {\n-            return ((Collection<?>) object).isEmpty();\n+        /**\n+         * Restricted constructor - singleton.\n+         */\n+        Null() {\n         }\n-        if (object instanceof Map<?, ?>) {\n-            return ((Map<?, ?>) object).isEmpty();\n+\n+        /**\n+         * <p>Ensure singleton.</p>\n+         *\n+         * @return the singleton value\n+         */\n+        private Object readResolve() {\n+            return NULL;\n         }\n-        return false;\n     }\n \n+    private static final char AT_SIGN = '@';\n+\n     /**\n-     * <p>Checks if an Object is not empty and not null.</p>\n+     * <p>Singleton used as a {@code null} placeholder where\n+     * {@code null} has another meaning.</p>\n      *\n-     * The following types are supported:\n-     * <ul>\n-     * <li>{@link CharSequence}: Considered empty if its length is zero.</li>\n-     * <li>{@code Array}: Considered empty if its length is zero.</li>\n-     * <li>{@link Collection}: Considered empty if it has zero elements.</li>\n-     * <li>{@link Map}: Considered empty if it has zero key-value mappings.</li>\n-     * </ul>\n+     * <p>For example, in a {@code HashMap} the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * {@code null} if the {@code Map} contains {@code null} or if there\n+     * is no matching key. The {@code Null} placeholder can be used to\n+     * distinguish between these two cases.</p>\n      *\n-     * <pre>\n-     * ObjectUtils.isNotEmpty(null)             = false\n-     * ObjectUtils.isNotEmpty(\"\")               = false\n-     * ObjectUtils.isNotEmpty(\"ab\")             = true\n-     * ObjectUtils.isNotEmpty(new int[]{})      = false\n-     * ObjectUtils.isNotEmpty(new int[]{1,2,3}) = true\n-     * ObjectUtils.isNotEmpty(1234)             = true\n-     * </pre>\n+     * <p>Another example is {@code Hashtable}, where {@code null}\n+     * cannot be stored.</p>\n      *\n-     * @param object  the {@code Object} to test, may be {@code null}\n-     * @return {@code true} if the object has an unsupported type or is not empty\n-     * and not null, {@code false} otherwise\n-     * @since 3.9\n+     * <p>This instance is Serializable.</p>\n      */\n-    public static boolean isNotEmpty(final Object object) {\n-        return !isEmpty(object);\n-    }\n+    public static final Null NULL = new Null();\n \n     /**\n-     * <p>Returns a default value if the object passed is {@code null}.</p>\n-     *\n-     * <pre>\n-     * ObjectUtils.defaultIfNull(null, null)      = null\n-     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n-     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n-     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n-     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n-     * </pre>\n+     * Checks if all values in the array are not {@code nulls}.\n      *\n-     * @param <T> the type of the object\n-     * @param object  the {@code Object} to test, may be {@code null}\n-     * @param defaultValue  the default value to return, may be {@code null}\n-     * @return {@code object} if it is not {@code null}, defaultValue otherwise\n-     * TODO Rename to getIfNull in 4.0\n-     */\n-    public static <T> T defaultIfNull(final T object, final T defaultValue) {\n-        return object != null ? object : defaultValue;\n-    }\n-\n-    /**\n-     * <p>Returns the first value in the array which is not {@code null}.\n-     * If all the values are {@code null} or the array is {@code null}\n-     * or empty then {@code null} is returned.</p>\n+     * <p>\n+     * If any value is {@code null} or the array is {@code null} then\n+     * {@code false} is returned. If all elements in array are not\n+     * {@code null} or the array is empty (contains no elements) {@code true}\n+     * is returned.\n+     * </p>\n      *\n      * <pre>\n-     * ObjectUtils.firstNonNull(null, null)      = null\n-     * ObjectUtils.firstNonNull(null, \"\")        = \"\"\n-     * ObjectUtils.firstNonNull(null, null, \"\")  = \"\"\n-     * ObjectUtils.firstNonNull(null, \"zz\")      = \"zz\"\n-     * ObjectUtils.firstNonNull(\"abc\", *)        = \"abc\"\n-     * ObjectUtils.firstNonNull(null, \"xyz\", *)  = \"xyz\"\n-     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE\n-     * ObjectUtils.firstNonNull()                = null\n+     * ObjectUtils.allNotNull(*)             = true\n+     * ObjectUtils.allNotNull(*, *)          = true\n+     * ObjectUtils.allNotNull(null)          = false\n+     * ObjectUtils.allNotNull(null, null)    = false\n+     * ObjectUtils.allNotNull(null, *)       = false\n+     * ObjectUtils.allNotNull(*, null)       = false\n+     * ObjectUtils.allNotNull(*, *, null, *) = false\n      * </pre>\n      *\n-     * @param <T> the component type of the array\n      * @param values  the values to test, may be {@code null} or empty\n-     * @return the first value from {@code values} which is not {@code null},\n-     *  or {@code null} if there are no non-null values\n-     * @since 3.0\n+     * @return {@code false} if there is at least one {@code null} value in the array or the array is {@code null},\n+     * {@code true} if all values in the array are not {@code null}s or array contains no elements.\n+     * @since 3.5\n      */\n-    @SafeVarargs\n-    public static <T> T firstNonNull(final T... values) {\n-        if (values != null) {\n-            for (final T val : values) {\n-                if (val != null) {\n-                    return val;\n-                }\n-            }\n+    public static boolean allNotNull(final Object... values) {\n+        if (values == null) {\n+            return false;\n         }\n-        return null;\n-    }\n \n-    /**\n-     * <p>Executes the given suppliers in order and returns the first return\n-     * value where a value other than {@code null} is returned.\n-     * Once a non-{@code null} value is obtained, all following suppliers are\n-     * not executed anymore.\n-     * If all the return values are {@code null} or no suppliers are provided\n-     * then {@code null} is returned.</p>\n-     *\n-     * <pre>\n-     * ObjectUtils.firstNonNullLazy(null, () -&gt; null) = null\n-     * ObjectUtils.firstNonNullLazy(() -&gt; null, () -&gt; \"\") = \"\"\n-     * ObjectUtils.firstNonNullLazy(() -&gt; \"\", () -&gt; throw new IllegalStateException()) = \"\"\n-     * ObjectUtils.firstNonNullLazy(() -&gt; null, () -&gt; \"zz) = \"zz\"\n-     * ObjectUtils.firstNonNullLazy() = null\n-     * </pre>\n-     *\n-     * @param <T> the type of the return values\n-     * @param suppliers  the suppliers returning the values to test.\n-     *                   {@code null} values are ignored.\n-     *                   Suppliers may return {@code null} or a value of type @{code T}\n-     * @return the first return value from {@code suppliers} which is not {@code null},\n-     *  or {@code null} if there are no non-null values\n-     * @since 3.10\n-     */\n-    @SafeVarargs\n-    public static <T> T getFirstNonNull(final Supplier<T>... suppliers) {\n-        if (suppliers != null) {\n-            for (final Supplier<T> supplier : suppliers) {\n-                if (supplier != null) {\n-                    final T value = supplier.get();\n-                    if (value != null) {\n-                        return value;\n-                    }\n-                }\n+        for (final Object val : values) {\n+            if (val == null) {\n+                return false;\n             }\n         }\n-        return null;\n+\n+        return true;\n     }\n \n     /**\n-     * <p>\n-     * Returns the given {@code object} is it is non-null, otherwise returns the Supplier's {@link Supplier#get()}\n-     * value.\n-     * </p>\n+     * Checks if all values in the given array are {@code null}.\n      *\n      * <p>\n-     * The caller responsible for thread-safety and exception handling of default value supplier.\n+     * If all the values are {@code null} or the array is {@code null}\n+     * or empty, then {@code true} is returned, otherwise {@code false} is returned.\n      * </p>\n      *\n      * <pre>\n-     * ObjectUtils.getIfNull(null, () -&gt; null)     = null\n-     * ObjectUtils.getIfNull(null, null)              = null\n-     * ObjectUtils.getIfNull(null, () -&gt; \"\")       = \"\"\n-     * ObjectUtils.getIfNull(null, () -&gt; \"zz\")     = \"zz\"\n-     * ObjectUtils.getIfNull(\"abc\", *)                = \"abc\"\n-     * ObjectUtils.getIfNull(Boolean.TRUE, *)         = Boolean.TRUE\n+     * ObjectUtils.allNull(*)                = false\n+     * ObjectUtils.allNull(*, null)          = false\n+     * ObjectUtils.allNull(null, *)          = false\n+     * ObjectUtils.allNull(null, null, *, *) = false\n+     * ObjectUtils.allNull(null)             = true\n+     * ObjectUtils.allNull(null, null)       = true\n      * </pre>\n      *\n-     * @param <T> the type of the object\n-     * @param object the {@code Object} to test, may be {@code null}\n-     * @param defaultSupplier the default value to return, may be {@code null}\n-     * @return {@code object} if it is not {@code null}, {@code defaultValueSupplier.get()} otherwise\n-     * @since 3.10\n+     * @param values  the values to test, may be {@code null} or empty\n+     * @return {@code true} if all values in the array are {@code null}s,\n+     * {@code false} if there is at least one non-null value in the array.\n+     * @since 3.11\n      */\n-    public static <T> T getIfNull(final T object, final Supplier<T> defaultSupplier) {\n-        return object != null ? object : defaultSupplier == null ? null : defaultSupplier.get();\n+    public static boolean allNull(final Object... values) {\n+        return !anyNotNull(values);\n     }\n \n     /**\n@@ -305,626 +202,731 @@ public static boolean anyNotNull(final Object... values) {\n     }\n \n     /**\n-     * Checks if all values in the array are not {@code nulls}.\n+     * Checks if any value in the given array is {@code null}.\n      *\n      * <p>\n-     * If any value is {@code null} or the array is {@code null} then\n-     * {@code false} is returned. If all elements in array are not\n-     * {@code null} or the array is empty (contains no elements) {@code true}\n-     * is returned.\n+     * If any of the values are {@code null} or the array is {@code null},\n+     * then {@code true} is returned, otherwise {@code false} is returned.\n      * </p>\n      *\n      * <pre>\n-     * ObjectUtils.allNotNull(*)             = true\n-     * ObjectUtils.allNotNull(*, *)          = true\n-     * ObjectUtils.allNotNull(null)          = false\n-     * ObjectUtils.allNotNull(null, null)    = false\n-     * ObjectUtils.allNotNull(null, *)       = false\n-     * ObjectUtils.allNotNull(*, null)       = false\n-     * ObjectUtils.allNotNull(*, *, null, *) = false\n+     * ObjectUtils.anyNull(*)             = false\n+     * ObjectUtils.anyNull(*, *)          = false\n+     * ObjectUtils.anyNull(null)          = true\n+     * ObjectUtils.anyNull(null, null)    = true\n+     * ObjectUtils.anyNull(null, *)       = true\n+     * ObjectUtils.anyNull(*, null)       = true\n+     * ObjectUtils.anyNull(*, *, null, *) = true\n      * </pre>\n      *\n      * @param values  the values to test, may be {@code null} or empty\n-     * @return {@code false} if there is at least one {@code null} value in the array or the array is {@code null},\n-     * {@code true} if all values in the array are not {@code null}s or array contains no elements.\n-     * @since 3.5\n+     * @return {@code true} if there is at least one {@code null} value in the array,\n+     * {@code false} if all the values are non-null.\n+     * If the array is {@code null} or empty, {@code true} is also returned.\n+     * @since 3.11\n      */\n-    public static boolean allNotNull(final Object... values) {\n-        if (values == null) {\n-            return false;\n-        }\n-\n-        for (final Object val : values) {\n-            if (val == null) {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n+    public static boolean anyNull(final Object... values) {\n+        return !allNotNull(values);\n     }\n \n-    // Null-safe equals/hashCode\n+    // cloning\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Compares two objects for equality, where either one or both\n-     * objects may be {@code null}.</p>\n-     *\n-     * <pre>\n-     * ObjectUtils.equals(null, null)                  = true\n-     * ObjectUtils.equals(null, \"\")                    = false\n-     * ObjectUtils.equals(\"\", null)                    = false\n-     * ObjectUtils.equals(\"\", \"\")                      = true\n-     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n-     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n-     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n-     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n-     * </pre>\n+     * <p>Clone an object.</p>\n      *\n-     * @param object1  the first object, may be {@code null}\n-     * @param object2  the second object, may be {@code null}\n-     * @return {@code true} if the values of both objects are the same\n-     * @deprecated this method has been replaced by {@code java.util.Objects.equals(Object, Object)} in Java 7 and will\n-     * be removed from future releases.\n+     * @param <T> the type of the object\n+     * @param obj  the object to clone, null returns null\n+     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n+     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n+     * @since 3.0\n      */\n-    @Deprecated\n-    public static boolean equals(final Object object1, final Object object2) {\n-        if (object1 == object2) {\n-            return true;\n-        }\n-        if (object1 == null || object2 == null) {\n-            return false;\n+    public static <T> T clone(final T obj) {\n+        if (obj instanceof Cloneable) {\n+            final Object result;\n+            if (obj.getClass().isArray()) {\n+                final Class<?> componentType = obj.getClass().getComponentType();\n+                if (componentType.isPrimitive()) {\n+                    int length = Array.getLength(obj);\n+                    result = Array.newInstance(componentType, length);\n+                    while (length-- > 0) {\n+                        Array.set(result, length, Array.get(obj, length));\n+                    }\n+                } else {\n+                    result = ((Object[]) obj).clone();\n+                }\n+            } else {\n+                try {\n+                    final Method clone = obj.getClass().getMethod(\"clone\");\n+                    result = clone.invoke(obj);\n+                } catch (final NoSuchMethodException e) {\n+                    throw new CloneFailedException(\"Cloneable type \"\n+                        + obj.getClass().getName()\n+                        + \" has no clone method\", e);\n+                } catch (final IllegalAccessException e) {\n+                    throw new CloneFailedException(\"Cannot clone Cloneable type \"\n+                        + obj.getClass().getName(), e);\n+                } catch (final InvocationTargetException e) {\n+                    throw new CloneFailedException(\"Exception cloning Cloneable type \"\n+                        + obj.getClass().getName(), e.getCause());\n+                }\n+            }\n+            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n+            final T checked = (T) result;\n+            return checked;\n         }\n-        return object1.equals(object2);\n+\n+        return null;\n     }\n \n     /**\n-     * <p>Compares two objects for inequality, where either one or both\n-     * objects may be {@code null}.</p>\n+     * <p>Clone an object if possible.</p>\n      *\n-     * <pre>\n-     * ObjectUtils.notEqual(null, null)                  = false\n-     * ObjectUtils.notEqual(null, \"\")                    = true\n-     * ObjectUtils.notEqual(\"\", null)                    = true\n-     * ObjectUtils.notEqual(\"\", \"\")                      = false\n-     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true\n-     * ObjectUtils.notEqual(Boolean.TRUE, \"true\")        = true\n-     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false\n-     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true\n-     * </pre>\n+     * <p>This method is similar to {@link #clone(Object)}, but will return the provided\n+     * instance as the return value instead of {@code null} if the instance\n+     * is not cloneable. This is more convenient if the caller uses different\n+     * implementations (e.g. of a service) and some of the implementations do not allow concurrent\n+     * processing or have state. In such cases the implementation can simply provide a proper\n+     * clone implementation and the caller's code does not have to change.</p>\n      *\n-     * @param object1  the first object, may be {@code null}\n-     * @param object2  the second object, may be {@code null}\n-     * @return {@code false} if the values of both objects are the same\n+     * @param <T> the type of the object\n+     * @param obj  the object to clone, null returns null\n+     * @return the clone if the object implements {@link Cloneable} otherwise the object itself\n+     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n+     * @since 3.0\n      */\n-    public static boolean notEqual(final Object object1, final Object object2) {\n-        return !equals(object1, object2);\n+    public static <T> T cloneIfPossible(final T obj) {\n+        final T clone = clone(obj);\n+        return clone == null ? obj : clone;\n     }\n \n     /**\n-     * <p>Gets the hash code of an object returning zero when the\n-     * object is {@code null}.</p>\n-     *\n-     * <pre>\n-     * ObjectUtils.hashCode(null)   = 0\n-     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n-     * </pre>\n+     * <p>Null safe comparison of Comparables.\n+     * {@code null} is assumed to be less than a non-{@code null} value.</p>\n      *\n-     * @param obj  the object to obtain the hash code of, may be {@code null}\n-     * @return the hash code of the object, or zero if null\n-     * @since 2.1\n-     * @deprecated this method has been replaced by {@code java.util.Objects.hashCode(Object)} in Java 7 and will be\n-     * removed in future releases\n+     * @param <T> type of the values processed by this method\n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @return a negative value if c1 &lt; c2, zero if c1 = c2\n+     *  and a positive value if c1 &gt; c2\n      */\n-    @Deprecated\n-    public static int hashCode(final Object obj) {\n-        // hashCode(Object) retained for performance, as hash code is often critical\n-        return obj == null ? 0 : obj.hashCode();\n+    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n+        return compare(c1, c2, false);\n     }\n \n     /**\n-     * <p>Gets the hash code for multiple objects.</p>\n-     *\n-     * <p>This allows a hash code to be rapidly calculated for a number of objects.\n-     * The hash code for a single object is the <em>not</em> same as {@link #hashCode(Object)}.\n-     * The hash code for multiple objects is the same as that calculated by an\n-     * {@code ArrayList} containing the specified objects.</p>\n-     *\n-     * <pre>\n-     * ObjectUtils.hashCodeMulti()                 = 1\n-     * ObjectUtils.hashCodeMulti((Object[]) null)  = 1\n-     * ObjectUtils.hashCodeMulti(a)                = 31 + a.hashCode()\n-     * ObjectUtils.hashCodeMulti(a,b)              = (31 + a.hashCode()) * 31 + b.hashCode()\n-     * ObjectUtils.hashCodeMulti(a,b,c)            = ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode()\n-     * </pre>\n+     * <p>Null safe comparison of Comparables.</p>\n      *\n-     * @param objects  the objects to obtain the hash code of, may be {@code null}\n-     * @return the hash code of the objects, or zero if null\n-     * @since 3.0\n-     * @deprecated this method has been replaced by {@code java.util.Objects.hash(Object...)} in Java 7 and will be\n-     * removed in future releases.\n+     * @param <T> type of the values processed by this method\n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @param nullGreater if true {@code null} is considered greater\n+     *  than a non-{@code null} value or if false {@code null} is\n+     *  considered less than a Non-{@code null} value\n+     * @return a negative value if c1 &lt; c2, zero if c1 = c2\n+     *  and a positive value if c1 &gt; c2\n+     * @see java.util.Comparator#compare(Object, Object)\n      */\n-    @Deprecated\n-    public static int hashCodeMulti(final Object... objects) {\n-        int hash = 1;\n-        if (objects != null) {\n-            for (final Object object : objects) {\n-                final int tmpHash = hashCode(object);\n-                hash = hash * 31 + tmpHash;\n-            }\n+    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n+        if (c1 == c2) {\n+            return 0;\n         }\n-        return hash;\n+        if (c1 == null) {\n+            return nullGreater ? 1 : -1;\n+        }\n+        if (c2 == null) {\n+            return nullGreater ? -1 : 1;\n+        }\n+        return c1.compareTo(c2);\n     }\n \n-    // Identity ToString\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Gets the toString that would be produced by {@code Object}\n-     * if a class did not override toString itself. {@code null}\n-     * will return {@code null}.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.identityToString(null)         = null\n-     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n-     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     *     public final static boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n      * </pre>\n      *\n-     * @param object  the object to create a toString for, may be\n-     *  {@code null}\n-     * @return the default toString text, or {@code null} if\n-     *  {@code null} passed in\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the boolean value to return\n+     * @return the boolean v, unchanged\n+     * @since 3.2\n      */\n-    public static String identityToString(final Object object) {\n-        if (object == null) {\n-            return null;\n-        }\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        final StringBuilder builder = new StringBuilder(name.length() + 1 + hexString.length());\n-        // @formatter:off\n-        builder.append(name)\n-              .append(AT_SIGN)\n-              .append(hexString);\n-        // @formatter:off\n-        return builder.toString();\n+    public static boolean CONST(final boolean v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Appends the toString that would be produced by {@code Object}\n-     * if a class did not override toString itself. {@code null}\n-     * will throw a NullPointerException for either of the two parameters. </p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.identityToString(appendable, \"\")            = appendable.append(\"java.lang.String@1e23\"\n-     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append(\"java.lang.Boolean@7fa\"\n-     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append(\"java.lang.Boolean@7fa\")\n+     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST((byte) 127);\n      * </pre>\n      *\n-     * @param appendable  the appendable to append to\n-     * @param object  the object to create a toString for\n-     * @throws IOException if an I/O error occurs\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the byte value to return\n+     * @return the byte v, unchanged\n      * @since 3.2\n      */\n-    public static void identityToString(final Appendable appendable, final Object object) throws IOException {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\");\n-        appendable.append(object.getClass().getName())\n-              .append(AT_SIGN)\n-              .append(Integer.toHexString(System.identityHashCode(object)));\n+    public static byte CONST(final byte v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Appends the toString that would be produced by {@code Object}\n-     * if a class did not override toString itself. {@code null}\n-     * will throw a NullPointerException for either of the two parameters. </p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\"\n-     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\"\n-     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n+     *     public final static char MAGIC_CHAR = ObjectUtils.CONST('a');\n      * </pre>\n      *\n-     * @param builder  the builder to append to\n-     * @param object  the object to create a toString for\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the char value to return\n+     * @return the char v, unchanged\n      * @since 3.2\n-     * @deprecated as of 3.6, because StrBuilder was moved to commons-text,\n-     *  use one of the other {@code identityToString} methods instead\n      */\n-    @Deprecated\n-    public static void identityToString(final StrBuilder builder, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\");\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        builder.ensureCapacity(builder.length() +  name.length() + 1 + hexString.length());\n-        builder.append(name)\n-              .append(AT_SIGN)\n-              .append(hexString);\n+    public static char CONST(final char v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Appends the toString that would be produced by {@code Object}\n-     * if a class did not override toString itself. {@code null}\n-     * will throw a NullPointerException for either of the two parameters. </p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n-     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n-     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n+     *     public final static double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n      * </pre>\n      *\n-     * @param buffer  the buffer to append to\n-     * @param object  the object to create a toString for\n-     * @since 2.4\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the double value to return\n+     * @return the double v, unchanged\n+     * @since 3.2\n      */\n-    public static void identityToString(final StringBuffer buffer, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\");\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        buffer.ensureCapacity(buffer.length() + name.length() + 1 + hexString.length());\n-        buffer.append(name)\n-              .append(AT_SIGN)\n-              .append(hexString);\n+    public static double CONST(final double v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Appends the toString that would be produced by {@code Object}\n-     * if a class did not override toString itself. {@code null}\n-     * will throw a NullPointerException for either of the two parameters. </p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\"\n-     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\"\n-     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n+     *     public final static float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n      * </pre>\n      *\n-     * @param builder  the builder to append to\n-     * @param object  the object to create a toString for\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the float value to return\n+     * @return the float v, unchanged\n      * @since 3.2\n      */\n-    public static void identityToString(final StringBuilder builder, final Object object) {\n-        Validate.notNull(object, \"Cannot get the toString of a null object\");\n-        final String name = object.getClass().getName();\n-        final String hexString = Integer.toHexString(System.identityHashCode(object));\n-        builder.ensureCapacity(builder.length() +  name.length() + 1 + hexString.length());\n-        builder.append(name)\n-              .append(AT_SIGN)\n-              .append(hexString);\n+    public static float CONST(final float v) {\n+        return v;\n     }\n \n-    // ToString\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Gets the {@code toString} of an {@code Object} returning\n-     * an empty string (\"\") if {@code null} input.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.toString(null)         = \"\"\n-     * ObjectUtils.toString(\"\")           = \"\"\n-     * ObjectUtils.toString(\"bat\")        = \"bat\"\n-     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n+     *     public final static int MAGIC_INT = ObjectUtils.CONST(123);\n      * </pre>\n      *\n-     * @see StringUtils#defaultString(String)\n-     * @see String#valueOf(Object)\n-     * @param obj  the Object to {@code toString}, may be null\n-     * @return the passed in Object's toString, or {@code \"\"} if {@code null} input\n-     * @since 2.0\n-     * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object)} in Java 7 and will be\n-     * removed in future releases. Note however that said method will return \"null\" for null references, while this\n-     * method returns an empty String. To preserve behavior use {@code java.util.Objects.toString(myObject, \"\")}\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the int value to return\n+     * @return the int v, unchanged\n+     * @since 3.2\n      */\n-    @Deprecated\n-    public static String toString(final Object obj) {\n-        return obj == null ? StringUtils.EMPTY : obj.toString();\n+    public static int CONST(final int v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Gets the {@code toString} of an {@code Object} returning\n-     * a specified text if {@code null} input.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n      * <pre>\n-     * ObjectUtils.toString(null, null)           = null\n-     * ObjectUtils.toString(null, \"null\")         = \"null\"\n-     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n-     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n-     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n+     *     public final static long MAGIC_LONG = ObjectUtils.CONST(123L);\n      * </pre>\n      *\n-     * @see StringUtils#defaultString(String,String)\n-     * @see String#valueOf(Object)\n-     * @param obj  the Object to {@code toString}, may be null\n-     * @param nullStr  the String to return if {@code null} input, may be null\n-     * @return the passed in Object's toString, or {@code nullStr} if {@code null} input\n-     * @since 2.0\n-     * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object, String)} in Java 7 and\n-     * will be removed in future releases.\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the long value to return\n+     * @return the long v, unchanged\n+     * @since 3.2\n      */\n-    @Deprecated\n-    public static String toString(final Object obj, final String nullStr) {\n-        return obj == null ? nullStr : obj.toString();\n+    public static long CONST(final long v) {\n+        return v;\n     }\n \n-    // Comparable\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Null safe comparison of Comparables.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n-     * @param <T> type of the values processed by this method\n-     * @param values the set of comparable values, may be null\n-     * @return\n-     *  <ul>\n-     *   <li>If any objects are non-null and unequal, the lesser object.\n-     *   <li>If all objects are non-null and equal, the first.\n-     *   <li>If any of the comparables are null, the lesser of the non-null objects.\n-     *   <li>If all the comparables are null, null is returned.\n-     *  </ul>\n+     * <pre>\n+     *     public final static short MAGIC_SHORT = ObjectUtils.CONST((short) 123);\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the short value to return\n+     * @return the short v, unchanged\n+     * @since 3.2\n      */\n-    @SafeVarargs\n-    public static <T extends Comparable<? super T>> T min(final T... values) {\n-        T result = null;\n-        if (values != null) {\n-            for (final T value : values) {\n-                if (compare(value, result, true) < 0) {\n-                    result = value;\n-                }\n-            }\n-        }\n-        return result;\n+    public static short CONST(final short v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Null safe comparison of Comparables.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n-     * @param <T> type of the values processed by this method\n-     * @param values the set of comparable values, may be null\n-     * @return\n-     *  <ul>\n-     *   <li>If any objects are non-null and unequal, the greater object.\n-     *   <li>If all objects are non-null and equal, the first.\n-     *   <li>If any of the comparables are null, the greater of the non-null objects.\n-     *   <li>If all the comparables are null, null is returned.\n-     *  </ul>\n+     * <pre>\n+     *     public final static String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param <T> the Object type\n+     * @param v the genericized Object value to return (typically a String).\n+     * @return the genericized Object v, unchanged (typically a String).\n+     * @since 3.2\n      */\n-    @SafeVarargs\n-    public static <T extends Comparable<? super T>> T max(final T... values) {\n-        T result = null;\n-        if (values != null) {\n-            for (final T value : values) {\n-                if (compare(value, result, false) > 0) {\n-                    result = value;\n-                }\n-            }\n-        }\n-        return result;\n+    public static <T> T CONST(final T v) {\n+        return v;\n     }\n \n     /**\n-     * <p>Null safe comparison of Comparables.\n-     * {@code null} is assumed to be less than a non-{@code null} value.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n-     * @param <T> type of the values processed by this method\n-     * @param c1  the first comparable, may be null\n-     * @param c2  the second comparable, may be null\n-     * @return a negative value if c1 &lt; c2, zero if c1 = c2\n-     *  and a positive value if c1 &gt; c2\n+     * <pre>\n+     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the byte literal (as an int) value to return\n+     * @throws IllegalArgumentException if the value passed to v\n+     *         is larger than a byte, that is, smaller than -128 or\n+     *         larger than 127.\n+     * @return the byte v, unchanged\n+     * @since 3.2\n      */\n-    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n-        return compare(c1, c2, false);\n+    public static byte CONST_BYTE(final int v) {\n+        if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n+        }\n+        return (byte) v;\n     }\n \n     /**\n-     * <p>Null safe comparison of Comparables.</p>\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n      *\n-     * @param <T> type of the values processed by this method\n-     * @param c1  the first comparable, may be null\n-     * @param c2  the second comparable, may be null\n-     * @param nullGreater if true {@code null} is considered greater\n-     *  than a non-{@code null} value or if false {@code null} is\n-     *  considered less than a Non-{@code null} value\n-     * @return a negative value if c1 &lt; c2, zero if c1 = c2\n-     *  and a positive value if c1 &gt; c2\n-     * @see java.util.Comparator#compare(Object, Object)\n+     * <pre>\n+     *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the short literal (as an int) value to return\n+     * @throws IllegalArgumentException if the value passed to v\n+     *         is larger than a short, that is, smaller than -32768 or\n+     *         larger than 32767.\n+     * @return the byte v, unchanged\n+     * @since 3.2\n      */\n-    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n-        if (c1 == c2) {\n-            return 0;\n-        } else if (c1 == null) {\n-            return nullGreater ? 1 : -1;\n-        } else if (c2 == null) {\n-            return nullGreater ? -1 : 1;\n+    public static short CONST_SHORT(final int v) {\n+        if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n         }\n-        return c1.compareTo(c2);\n+        return (short) v;\n     }\n \n     /**\n-     * Find the \"best guess\" middle value among comparables. If there is an even\n-     * number of total values, the lower of the two middle values will be returned.\n-     * @param <T> type of values processed by this method\n-     * @param items to compare\n-     * @return T at middle position\n-     * @throws NullPointerException if items is {@code null}\n-     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n-     * @since 3.0.1\n+     * <p>Returns a default value if the object passed is {@code null}.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.defaultIfNull(null, null)      = null\n+     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n+     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param <T> the type of the object\n+     * @param object  the {@code Object} to test, may be {@code null}\n+     * @param defaultValue  the default value to return, may be {@code null}\n+     * @return {@code object} if it is not {@code null}, defaultValue otherwise\n+     * TODO Rename to getIfNull in 4.0\n      */\n-    @SafeVarargs\n-    public static <T extends Comparable<? super T>> T median(final T... items) {\n-        Validate.notEmpty(items);\n-        Validate.noNullElements(items);\n-        final TreeSet<T> sort = new TreeSet<>();\n-        Collections.addAll(sort, items);\n-        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n-        final T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n-        return result;\n+    public static <T> T defaultIfNull(final T object, final T defaultValue) {\n+        return object != null ? object : defaultValue;\n     }\n \n+    // Null-safe equals/hashCode\n+    //-----------------------------------------------------------------------\n     /**\n-     * Find the \"best guess\" middle value among comparables. If there is an even\n-     * number of total values, the lower of the two middle values will be returned.\n-     * @param <T> type of values processed by this method\n-     * @param comparator to use for comparisons\n-     * @param items to compare\n-     * @return T at middle position\n-     * @throws NullPointerException if items or comparator is {@code null}\n-     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n-     * @since 3.0.1\n+     * <p>Compares two objects for equality, where either one or both\n+     * objects may be {@code null}.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.equals(null, null)                  = true\n+     * ObjectUtils.equals(null, \"\")                    = false\n+     * ObjectUtils.equals(\"\", null)                    = false\n+     * ObjectUtils.equals(\"\", \"\")                      = true\n+     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n+     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n+     * </pre>\n+     *\n+     * @param object1  the first object, may be {@code null}\n+     * @param object2  the second object, may be {@code null}\n+     * @return {@code true} if the values of both objects are the same\n+     * @deprecated this method has been replaced by {@code java.util.Objects.equals(Object, Object)} in Java 7 and will\n+     * be removed from future releases.\n      */\n-    @SafeVarargs\n-    public static <T> T median(final Comparator<T> comparator, final T... items) {\n-        Validate.notEmpty(items, \"null/empty items\");\n-        Validate.noNullElements(items);\n-        Validate.notNull(comparator, \"null comparator\");\n-        final TreeSet<T> sort = new TreeSet<>(comparator);\n-        Collections.addAll(sort, items);\n-        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n-        final\n-        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n-        return result;\n+    @Deprecated\n+    public static boolean equals(final Object object1, final Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if (object1 == null || object2 == null) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n     }\n \n-    // Mode\n-    //-----------------------------------------------------------------------\n     /**\n-     * Find the most frequently occurring item.\n+     * <p>Returns the first value in the array which is not {@code null}.\n+     * If all the values are {@code null} or the array is {@code null}\n+     * or empty then {@code null} is returned.</p>\n      *\n-     * @param <T> type of values processed by this method\n-     * @param items to check\n-     * @return most populous T, {@code null} if non-unique or no items supplied\n-     * @since 3.0.1\n+     * <pre>\n+     * ObjectUtils.firstNonNull(null, null)      = null\n+     * ObjectUtils.firstNonNull(null, \"\")        = \"\"\n+     * ObjectUtils.firstNonNull(null, null, \"\")  = \"\"\n+     * ObjectUtils.firstNonNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.firstNonNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.firstNonNull(null, \"xyz\", *)  = \"xyz\"\n+     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * ObjectUtils.firstNonNull()                = null\n+     * </pre>\n+     *\n+     * @param <T> the component type of the array\n+     * @param values  the values to test, may be {@code null} or empty\n+     * @return the first value from {@code values} which is not {@code null},\n+     *  or {@code null} if there are no non-null values\n+     * @since 3.0\n      */\n     @SafeVarargs\n-    public static <T> T mode(final T... items) {\n-        if (ArrayUtils.isNotEmpty(items)) {\n-            final HashMap<T, MutableInt> occurrences = new HashMap<>(items.length);\n-            for (final T t : items) {\n-                final MutableInt count = occurrences.get(t);\n-                if (count == null) {\n-                    occurrences.put(t, new MutableInt(1));\n-                } else {\n-                    count.increment();\n+    public static <T> T firstNonNull(final T... values) {\n+        if (values != null) {\n+            for (final T val : values) {\n+                if (val != null) {\n+                    return val;\n                 }\n             }\n-            T result = null;\n-            int max = 0;\n-            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n-                final int cmp = e.getValue().intValue();\n-                if (cmp == max) {\n-                    result = null;\n-                } else if (cmp > max) {\n-                    max = cmp;\n-                    result = e.getKey();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Executes the given suppliers in order and returns the first return\n+     * value where a value other than {@code null} is returned.\n+     * Once a non-{@code null} value is obtained, all following suppliers are\n+     * not executed anymore.\n+     * If all the return values are {@code null} or no suppliers are provided\n+     * then {@code null} is returned.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.firstNonNullLazy(null, () -&gt; null) = null\n+     * ObjectUtils.firstNonNullLazy(() -&gt; null, () -&gt; \"\") = \"\"\n+     * ObjectUtils.firstNonNullLazy(() -&gt; \"\", () -&gt; throw new IllegalStateException()) = \"\"\n+     * ObjectUtils.firstNonNullLazy(() -&gt; null, () -&gt; \"zz) = \"zz\"\n+     * ObjectUtils.firstNonNullLazy() = null\n+     * </pre>\n+     *\n+     * @param <T> the type of the return values\n+     * @param suppliers  the suppliers returning the values to test.\n+     *                   {@code null} values are ignored.\n+     *                   Suppliers may return {@code null} or a value of type @{code T}\n+     * @return the first return value from {@code suppliers} which is not {@code null},\n+     *  or {@code null} if there are no non-null values\n+     * @since 3.10\n+     */\n+    @SafeVarargs\n+    public static <T> T getFirstNonNull(final Supplier<T>... suppliers) {\n+        if (suppliers != null) {\n+            for (final Supplier<T> supplier : suppliers) {\n+                if (supplier != null) {\n+                    final T value = supplier.get();\n+                    if (value != null) {\n+                        return value;\n+                    }\n                 }\n             }\n-            return result;\n         }\n         return null;\n     }\n \n-    // cloning\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Clone an object.</p>\n+     * <p>\n+     * Returns the given {@code object} is it is non-null, otherwise returns the Supplier's {@link Supplier#get()}\n+     * value.\n+     * </p>\n+     *\n+     * <p>\n+     * The caller responsible for thread-safety and exception handling of default value supplier.\n+     * </p>\n+     *\n+     * <pre>\n+     * ObjectUtils.getIfNull(null, () -&gt; null)     = null\n+     * ObjectUtils.getIfNull(null, null)              = null\n+     * ObjectUtils.getIfNull(null, () -&gt; \"\")       = \"\"\n+     * ObjectUtils.getIfNull(null, () -&gt; \"zz\")     = \"zz\"\n+     * ObjectUtils.getIfNull(\"abc\", *)                = \"abc\"\n+     * ObjectUtils.getIfNull(Boolean.TRUE, *)         = Boolean.TRUE\n+     * </pre>\n      *\n      * @param <T> the type of the object\n-     * @param obj  the object to clone, null returns null\n-     * @return the clone if the object implements {@link Cloneable} otherwise {@code null}\n-     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n+     * @param object the {@code Object} to test, may be {@code null}\n+     * @param defaultSupplier the default value to return, may be {@code null}\n+     * @return {@code object} if it is not {@code null}, {@code defaultValueSupplier.get()} otherwise\n+     * @since 3.10\n+     */\n+    public static <T> T getIfNull(final T object, final Supplier<T> defaultSupplier) {\n+        return object != null ? object : defaultSupplier == null ? null : defaultSupplier.get();\n+    }\n+\n+    /**\n+     * <p>Gets the hash code of an object returning zero when the\n+     * object is {@code null}.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.hashCode(null)   = 0\n+     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n+     * </pre>\n+     *\n+     * @param obj  the object to obtain the hash code of, may be {@code null}\n+     * @return the hash code of the object, or zero if null\n+     * @since 2.1\n+     * @deprecated this method has been replaced by {@code java.util.Objects.hashCode(Object)} in Java 7 and will be\n+     * removed in future releases\n+     */\n+    @Deprecated\n+    public static int hashCode(final Object obj) {\n+        // hashCode(Object) retained for performance, as hash code is often critical\n+        return obj == null ? 0 : obj.hashCode();\n+    }\n+\n+    /**\n+     * <p>Gets the hash code for multiple objects.</p>\n+     *\n+     * <p>This allows a hash code to be rapidly calculated for a number of objects.\n+     * The hash code for a single object is the <em>not</em> same as {@link #hashCode(Object)}.\n+     * The hash code for multiple objects is the same as that calculated by an\n+     * {@code ArrayList} containing the specified objects.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.hashCodeMulti()                 = 1\n+     * ObjectUtils.hashCodeMulti((Object[]) null)  = 1\n+     * ObjectUtils.hashCodeMulti(a)                = 31 + a.hashCode()\n+     * ObjectUtils.hashCodeMulti(a,b)              = (31 + a.hashCode()) * 31 + b.hashCode()\n+     * ObjectUtils.hashCodeMulti(a,b,c)            = ((31 + a.hashCode()) * 31 + b.hashCode()) * 31 + c.hashCode()\n+     * </pre>\n+     *\n+     * @param objects  the objects to obtain the hash code of, may be {@code null}\n+     * @return the hash code of the objects, or zero if null\n      * @since 3.0\n+     * @deprecated this method has been replaced by {@code java.util.Objects.hash(Object...)} in Java 7 and will be\n+     * removed in future releases.\n      */\n-    public static <T> T clone(final T obj) {\n-        if (obj instanceof Cloneable) {\n-            final Object result;\n-            if (obj.getClass().isArray()) {\n-                final Class<?> componentType = obj.getClass().getComponentType();\n-                if (componentType.isPrimitive()) {\n-                    int length = Array.getLength(obj);\n-                    result = Array.newInstance(componentType, length);\n-                    while (length-- > 0) {\n-                        Array.set(result, length, Array.get(obj, length));\n-                    }\n-                } else {\n-                    result = ((Object[]) obj).clone();\n-                }\n-            } else {\n-                try {\n-                    final Method clone = obj.getClass().getMethod(\"clone\");\n-                    result = clone.invoke(obj);\n-                } catch (final NoSuchMethodException e) {\n-                    throw new CloneFailedException(\"Cloneable type \"\n-                        + obj.getClass().getName()\n-                        + \" has no clone method\", e);\n-                } catch (final IllegalAccessException e) {\n-                    throw new CloneFailedException(\"Cannot clone Cloneable type \"\n-                        + obj.getClass().getName(), e);\n-                } catch (final InvocationTargetException e) {\n-                    throw new CloneFailedException(\"Exception cloning Cloneable type \"\n-                        + obj.getClass().getName(), e.getCause());\n-                }\n+    @Deprecated\n+    public static int hashCodeMulti(final Object... objects) {\n+        int hash = 1;\n+        if (objects != null) {\n+            for (final Object object : objects) {\n+                final int tmpHash = hashCode(object);\n+                hash = hash * 31 + tmpHash;\n             }\n-            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n-            final T checked = (T) result;\n-            return checked;\n         }\n+        return hash;\n+    }\n \n-        return null;\n+    /**\n+     * <p>Appends the toString that would be produced by {@code Object}\n+     * if a class did not override toString itself. {@code null}\n+     * will throw a NullPointerException for either of the two parameters. </p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(appendable, \"\")            = appendable.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(appendable, Boolean.TRUE)  = appendable.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n+     *\n+     * @param appendable  the appendable to append to\n+     * @param object  the object to create a toString for\n+     * @throws IOException if an I/O error occurs.\n+     * @since 3.2\n+     */\n+    public static void identityToString(final Appendable appendable, final Object object) throws IOException {\n+        Validate.notNull(object, \"object\");\n+        appendable.append(object.getClass().getName())\n+              .append(AT_SIGN)\n+              .append(Integer.toHexString(System.identityHashCode(object)));\n+    }\n+\n+    // Identity ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the toString that would be produced by {@code Object}\n+     * if a class did not override toString itself. {@code null}\n+     * will return {@code null}.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(null)         = null\n+     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     * </pre>\n+     *\n+     * @param object  the object to create a toString for, may be\n+     *  {@code null}\n+     * @return the default toString text, or {@code null} if\n+     *  {@code null} passed in\n+     */\n+    public static String identityToString(final Object object) {\n+        if (object == null) {\n+            return null;\n+        }\n+        final String name = object.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(object));\n+        final StringBuilder builder = new StringBuilder(name.length() + 1 + hexString.length());\n+        // @formatter:off\n+        builder.append(name)\n+              .append(AT_SIGN)\n+              .append(hexString);\n+        // @formatter:on\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * <p>Appends the toString that would be produced by {@code Object}\n+     * if a class did not override toString itself. {@code null}\n+     * will throw a NullPointerException for either of the two parameters. </p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n+     *\n+     * @param builder  the builder to append to\n+     * @param object  the object to create a toString for\n+     * @since 3.2\n+     * @deprecated as of 3.6, because StrBuilder was moved to commons-text,\n+     *  use one of the other {@code identityToString} methods instead\n+     */\n+    @Deprecated\n+    public static void identityToString(final StrBuilder builder, final Object object) {\n+        Validate.notNull(object, \"object\");\n+        final String name = object.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(object));\n+        builder.ensureCapacity(builder.length() +  name.length() + 1 + hexString.length());\n+        builder.append(name)\n+              .append(AT_SIGN)\n+              .append(hexString);\n     }\n \n     /**\n-     * <p>Clone an object if possible.</p>\n+     * <p>Appends the toString that would be produced by {@code Object}\n+     * if a class did not override toString itself. {@code null}\n+     * will throw a NullPointerException for either of the two parameters. </p>\n      *\n-     * <p>This method is similar to {@link #clone(Object)}, but will return the provided\n-     * instance as the return value instead of {@code null} if the instance\n-     * is not cloneable. This is more convenient if the caller uses different\n-     * implementations (e.g. of a service) and some of the implementations do not allow concurrent\n-     * processing or have state. In such cases the implementation can simply provide a proper\n-     * clone implementation and the caller's code does not have to change.</p>\n+     * <pre>\n+     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n      *\n-     * @param <T> the type of the object\n-     * @param obj  the object to clone, null returns null\n-     * @return the clone if the object implements {@link Cloneable} otherwise the object itself\n-     * @throws CloneFailedException if the object is cloneable and the clone operation fails\n-     * @since 3.0\n+     * @param buffer  the buffer to append to\n+     * @param object  the object to create a toString for\n+     * @since 2.4\n      */\n-    public static <T> T cloneIfPossible(final T obj) {\n-        final T clone = clone(obj);\n-        return clone == null ? obj : clone;\n+    public static void identityToString(final StringBuffer buffer, final Object object) {\n+        Validate.notNull(object, \"object\");\n+        final String name = object.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(object));\n+        buffer.ensureCapacity(buffer.length() + name.length() + 1 + hexString.length());\n+        buffer.append(name)\n+              .append(AT_SIGN)\n+              .append(hexString);\n     }\n \n-    // Null\n-    //-----------------------------------------------------------------------\n     /**\n-     * <p>Class used as a null placeholder where {@code null}\n-     * has another meaning.</p>\n+     * <p>Appends the toString that would be produced by {@code Object}\n+     * if a class did not override toString itself. {@code null}\n+     * will throw a NullPointerException for either of the two parameters. </p>\n      *\n-     * <p>For example, in a {@code HashMap} the\n-     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n-     * {@code null} if the {@code Map} contains {@code null} or if there is\n-     * no matching key. The {@code Null} placeholder can be used to distinguish\n-     * between these two cases.</p>\n+     * <pre>\n+     * ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n      *\n-     * <p>Another example is {@code Hashtable}, where {@code null}\n-     * cannot be stored.</p>\n+     * @param builder  the builder to append to\n+     * @param object  the object to create a toString for\n+     * @since 3.2\n      */\n-    public static class Null implements Serializable {\n-        /**\n-         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n-         *\n-         * @see java.io.Serializable\n-         */\n-        private static final long serialVersionUID = 7092611880189329093L;\n-\n-        /**\n-         * Restricted constructor - singleton.\n-         */\n-        Null() {\n-            super();\n-        }\n-\n-        /**\n-         * <p>Ensure singleton.</p>\n-         *\n-         * @return the singleton value\n-         */\n-        private Object readResolve() {\n-            return NULL;\n-        }\n+    public static void identityToString(final StringBuilder builder, final Object object) {\n+        Validate.notNull(object, \"object\");\n+        final String name = object.getClass().getName();\n+        final String hexString = Integer.toHexString(System.identityHashCode(object));\n+        builder.ensureCapacity(builder.length() +  name.length() + 1 + hexString.length());\n+        builder.append(name)\n+              .append(AT_SIGN)\n+              .append(hexString);\n     }\n \n \n@@ -949,249 +951,402 @@ their constant using one of the CONST() utility methods, instead:\n      */\n \n \n+    // Empty checks\n+    //-----------------------------------------------------------------------\n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Checks if an Object is empty or null.</p>\n+     *\n+     * The following types are supported:\n+     * <ul>\n+     * <li>{@link CharSequence}: Considered empty if its length is zero.</li>\n+     * <li>{@code Array}: Considered empty if its length is zero.</li>\n+     * <li>{@link Collection}: Considered empty if it has zero elements.</li>\n+     * <li>{@link Map}: Considered empty if it has zero key-value mappings.</li>\n+     * </ul>\n      *\n      * <pre>\n-     *     public final static boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n+     * ObjectUtils.isEmpty(null)             = true\n+     * ObjectUtils.isEmpty(\"\")               = true\n+     * ObjectUtils.isEmpty(\"ab\")             = false\n+     * ObjectUtils.isEmpty(new int[]{})      = true\n+     * ObjectUtils.isEmpty(new int[]{1,2,3}) = false\n+     * ObjectUtils.isEmpty(1234)             = false\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the boolean value to return\n-     * @return the boolean v, unchanged\n-     * @since 3.2\n+     * @param object  the {@code Object} to test, may be {@code null}\n+     * @return {@code true} if the object has a supported type and is empty or null,\n+     * {@code false} otherwise\n+     * @since 3.9\n      */\n-    public static boolean CONST(final boolean v) {\n-        return v;\n+    public static boolean isEmpty(final Object object) {\n+        if (object == null) {\n+            return true;\n+        }\n+        if (object instanceof CharSequence) {\n+            return ((CharSequence) object).length() == 0;\n+        }\n+        if (object.getClass().isArray()) {\n+            return Array.getLength(object) == 0;\n+        }\n+        if (object instanceof Collection<?>) {\n+            return ((Collection<?>) object).isEmpty();\n+        }\n+        if (object instanceof Map<?, ?>) {\n+            return ((Map<?, ?>) object).isEmpty();\n+        }\n+        return false;\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Checks if an Object is not empty and not null.</p>\n+     *\n+     * The following types are supported:\n+     * <ul>\n+     * <li>{@link CharSequence}: Considered empty if its length is zero.</li>\n+     * <li>{@code Array}: Considered empty if its length is zero.</li>\n+     * <li>{@link Collection}: Considered empty if it has zero elements.</li>\n+     * <li>{@link Map}: Considered empty if it has zero key-value mappings.</li>\n+     * </ul>\n      *\n      * <pre>\n-     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST((byte) 127);\n+     * ObjectUtils.isNotEmpty(null)             = false\n+     * ObjectUtils.isNotEmpty(\"\")               = false\n+     * ObjectUtils.isNotEmpty(\"ab\")             = true\n+     * ObjectUtils.isNotEmpty(new int[]{})      = false\n+     * ObjectUtils.isNotEmpty(new int[]{1,2,3}) = true\n+     * ObjectUtils.isNotEmpty(1234)             = true\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n+     * @param object  the {@code Object} to test, may be {@code null}\n+     * @return {@code true} if the object has an unsupported type or is not empty\n+     * and not null, {@code false} otherwise\n+     * @since 3.9\n+     */\n+    public static boolean isNotEmpty(final Object object) {\n+        return !isEmpty(object);\n+    }\n+\n+    /**\n+     * <p>Null safe comparison of Comparables.</p>\n      *\n-     * @param v the byte value to return\n-     * @return the byte v, unchanged\n-     * @since 3.2\n+     * @param <T> type of the values processed by this method\n+     * @param values the set of comparable values, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If any objects are non-null and unequal, the greater object.\n+     *   <li>If all objects are non-null and equal, the first.\n+     *   <li>If any of the comparables are null, the greater of the non-null objects.\n+     *   <li>If all the comparables are null, null is returned.\n+     *  </ul>\n+     */\n+    @SafeVarargs\n+    public static <T extends Comparable<? super T>> T max(final T... values) {\n+        T result = null;\n+        if (values != null) {\n+            for (final T value : values) {\n+                if (compare(value, result, false) > 0) {\n+                    result = value;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Find the \"best guess\" middle value among comparables. If there is an even\n+     * number of total values, the lower of the two middle values will be returned.\n+     * @param <T> type of values processed by this method\n+     * @param comparator to use for comparisons\n+     * @param items to compare\n+     * @return T at middle position\n+     * @throws NullPointerException if items or comparator is {@code null}\n+     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n+     * @since 3.0.1\n+     */\n+    @SafeVarargs\n+    public static <T> T median(final Comparator<T> comparator, final T... items) {\n+        Validate.notEmpty(items, \"null/empty items\");\n+        Validate.noNullElements(items);\n+        Validate.notNull(comparator, \"comparator\");\n+        final TreeSet<T> sort = new TreeSet<>(comparator);\n+        Collections.addAll(sort, items);\n+        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n+        final\n+        T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n+        return result;\n+    }\n+\n+    /**\n+     * Find the \"best guess\" middle value among comparables. If there is an even\n+     * number of total values, the lower of the two middle values will be returned.\n+     * @param <T> type of values processed by this method\n+     * @param items to compare\n+     * @return T at middle position\n+     * @throws NullPointerException if items is {@code null}\n+     * @throws IllegalArgumentException if items is empty or contains {@code null} values\n+     * @since 3.0.1\n+     */\n+    @SafeVarargs\n+    public static <T extends Comparable<? super T>> T median(final T... items) {\n+        Validate.notEmpty(items);\n+        Validate.noNullElements(items);\n+        final TreeSet<T> sort = new TreeSet<>();\n+        Collections.addAll(sort, items);\n+        @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n+        final T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n+        return result;\n+    }\n+\n+    // Comparable\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Null safe comparison of Comparables.</p>\n+     *\n+     * @param <T> type of the values processed by this method\n+     * @param values the set of comparable values, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If any objects are non-null and unequal, the lesser object.\n+     *   <li>If all objects are non-null and equal, the first.\n+     *   <li>If any of the comparables are null, the lesser of the non-null objects.\n+     *   <li>If all the comparables are null, null is returned.\n+     *  </ul>\n      */\n-    public static byte CONST(final byte v) {\n-        return v;\n+    @SafeVarargs\n+    public static <T extends Comparable<? super T>> T min(final T... values) {\n+        T result = null;\n+        if (values != null) {\n+            for (final T value : values) {\n+                if (compare(value, result, true) < 0) {\n+                    result = value;\n+                }\n+            }\n+        }\n+        return result;\n     }\n \n+\n+    // Mode\n+    //-----------------------------------------------------------------------\n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n-     *\n-     * <pre>\n-     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);\n-     * </pre>\n-     *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n+     * Find the most frequently occurring item.\n      *\n-     * @param v the byte literal (as an int) value to return\n-     * @throws IllegalArgumentException if the value passed to v\n-     *         is larger than a byte, that is, smaller than -128 or\n-     *         larger than 127.\n-     * @return the byte v, unchanged\n-     * @since 3.2\n+     * @param <T> type of values processed by this method\n+     * @param items to check\n+     * @return most populous T, {@code null} if non-unique or no items supplied\n+     * @since 3.0.1\n      */\n-    public static byte CONST_BYTE(final int v) {\n-        if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {\n-            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n+    @SafeVarargs\n+    public static <T> T mode(final T... items) {\n+        if (ArrayUtils.isNotEmpty(items)) {\n+            final HashMap<T, MutableInt> occurrences = new HashMap<>(items.length);\n+            for (final T t : items) {\n+                final MutableInt count = occurrences.get(t);\n+                if (count == null) {\n+                    occurrences.put(t, new MutableInt(1));\n+                } else {\n+                    count.increment();\n+                }\n+            }\n+            T result = null;\n+            int max = 0;\n+            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n+                final int cmp = e.getValue().intValue();\n+                if (cmp == max) {\n+                    result = null;\n+                } else if (cmp > max) {\n+                    max = cmp;\n+                    result = e.getKey();\n+                }\n+            }\n+            return result;\n         }\n-        return (byte) v;\n+        return null;\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Compares two objects for inequality, where either one or both\n+     * objects may be {@code null}.</p>\n      *\n      * <pre>\n-     *     public final static char MAGIC_CHAR = ObjectUtils.CONST('a');\n+     * ObjectUtils.notEqual(null, null)                  = false\n+     * ObjectUtils.notEqual(null, \"\")                    = true\n+     * ObjectUtils.notEqual(\"\", null)                    = true\n+     * ObjectUtils.notEqual(\"\", \"\")                      = false\n+     * ObjectUtils.notEqual(Boolean.TRUE, null)          = true\n+     * ObjectUtils.notEqual(Boolean.TRUE, \"true\")        = true\n+     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.TRUE)  = false\n+     * ObjectUtils.notEqual(Boolean.TRUE, Boolean.FALSE) = true\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the char value to return\n-     * @return the char v, unchanged\n-     * @since 3.2\n+     * @param object1  the first object, may be {@code null}\n+     * @param object2  the second object, may be {@code null}\n+     * @return {@code false} if the values of both objects are the same\n      */\n-    public static char CONST(final char v) {\n-        return v;\n+    public static boolean notEqual(final Object object1, final Object object2) {\n+        return !equals(object1, object2);\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * Checks that the specified object reference is not {@code null} or empty per {@link #isEmpty(Object)}. Use this\n+     * method for validation, for example:\n+     *\n+     * <blockquote>\n      *\n      * <pre>\n-     *     public final static short MAGIC_SHORT = ObjectUtils.CONST((short) 123);\n+     * public Foo(Bar bar) {\n+     *     this.bar = Objects.requireNonEmpty(bar);\n+     * }\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n+     * </blockquote>\n      *\n-     * @param v the short value to return\n-     * @return the short v, unchanged\n-     * @since 3.2\n+     * @param <T> the type of the reference.\n+     * @param obj the object reference to check for nullity.\n+     * @return {@code obj} if not {@code null}.\n+     * @throws NullPointerException     if {@code obj} is {@code null}.\n+     * @throws IllegalArgumentException if {@code obj} is empty per {@link #isEmpty(Object)}.\n+     * @see #isEmpty(Object)\n+     * @since 3.12.0\n      */\n-    public static short CONST(final short v) {\n-        return v;\n+    public static <T> T  requireNonEmpty(final T obj) {\n+        return requireNonEmpty(obj, \"object\");\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * Checks that the specified object reference is not {@code null} or empty per {@link #isEmpty(Object)}. Use this\n+     * method for validation, for example:\n+     *\n+     * <blockquote>\n      *\n      * <pre>\n-     *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);\n+     * public Foo(Bar bar) {\n+     *     this.bar = Objects.requireNonEmpty(bar, \"bar\");\n+     * }\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n+     * </blockquote>\n      *\n-     * @param v the short literal (as an int) value to return\n-     * @throws IllegalArgumentException if the value passed to v\n-     *         is larger than a short, that is, smaller than -32768 or\n-     *         larger than 32767.\n-     * @return the byte v, unchanged\n-     * @since 3.2\n+     * @param <T> the type of the reference.\n+     * @param obj the object reference to check for nullity.\n+     * @param message the exception message.\n+     * @return {@code obj} if not {@code null}.\n+     * @throws NullPointerException     if {@code obj} is {@code null}.\n+     * @throws IllegalArgumentException if {@code obj} is empty per {@link #isEmpty(Object)}.\n+     * @see #isEmpty(Object)\n+     * @since 3.12.0\n      */\n-    public static short CONST_SHORT(final int v) {\n-        if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {\n-            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n+    public static <T> T requireNonEmpty(final T obj, final String message) {\n+        // check for null first to give the most precise exception.\n+        Objects.requireNonNull(obj, message);\n+        if (isEmpty(obj)) {\n+            throw new IllegalArgumentException(message);\n         }\n-        return (short) v;\n+        return obj;\n     }\n \n-\n+    // ToString\n+    //-----------------------------------------------------------------------\n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Gets the {@code toString} of an {@code Object} returning\n+     * an empty string (\"\") if {@code null} input.</p>\n      *\n      * <pre>\n-     *     public final static int MAGIC_INT = ObjectUtils.CONST(123);\n+     * ObjectUtils.toString(null)         = \"\"\n+     * ObjectUtils.toString(\"\")           = \"\"\n+     * ObjectUtils.toString(\"bat\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the int value to return\n-     * @return the int v, unchanged\n-     * @since 3.2\n+     * @see StringUtils#defaultString(String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to {@code toString}, may be null\n+     * @return the passed in Object's toString, or {@code \"\"} if {@code null} input\n+     * @since 2.0\n+     * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object)} in Java 7 and will be\n+     * removed in future releases. Note however that said method will return \"null\" for null references, while this\n+     * method returns an empty String. To preserve behavior use {@code java.util.Objects.toString(myObject, \"\")}\n      */\n-    public static int CONST(final int v) {\n-        return v;\n+    @Deprecated\n+    public static String toString(final Object obj) {\n+        return obj == null ? StringUtils.EMPTY : obj.toString();\n     }\n-\n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Gets the {@code toString} of an {@code Object} returning\n+     * a specified text if {@code null} input.</p>\n      *\n      * <pre>\n-     *     public final static long MAGIC_LONG = ObjectUtils.CONST(123L);\n+     * ObjectUtils.toString(null, null)           = null\n+     * ObjectUtils.toString(null, \"null\")         = \"null\"\n+     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n+     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the long value to return\n-     * @return the long v, unchanged\n-     * @since 3.2\n+     * @see StringUtils#defaultString(String,String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to {@code toString}, may be null\n+     * @param nullStr  the String to return if {@code null} input, may be null\n+     * @return the passed in Object's toString, or {@code nullStr} if {@code null} input\n+     * @since 2.0\n+     * @deprecated this method has been replaced by {@code java.util.Objects.toString(Object, String)} in Java 7 and\n+     * will be removed in future releases.\n      */\n-    public static long CONST(final long v) {\n-        return v;\n+    @Deprecated\n+    public static String toString(final Object obj, final String nullStr) {\n+        return obj == null ? nullStr : obj.toString();\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n+     * <p>Gets the {@code toString} of an {@code Object} returning\n+     * a specified text if {@code null} input.</p>\n      *\n      * <pre>\n-     *     public final static float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n+     * ObjectUtils.toString(obj, () -&gt; expensive())\n+     * </pre>\n+     * <pre>\n+     * ObjectUtils.toString(null, () -&gt; expensive())         = result of expensive()\n+     * ObjectUtils.toString(null, () -&gt; expensive())         = result of expensive()\n+     * ObjectUtils.toString(\"\", () -&gt; expensive())           = \"\"\n+     * ObjectUtils.toString(\"bat\", () -&gt; expensive())        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE, () -&gt; expensive()) = \"true\"\n      * </pre>\n      *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the float value to return\n-     * @return the float v, unchanged\n-     * @since 3.2\n+     * @param obj  the Object to {@code toString}, may be null\n+     * @param supplier  the Supplier of String used on {@code null} input, may be null\n+     * @return the passed in Object's toString, or {@code nullStr} if {@code null} input\n+     * @since 3.11\n      */\n-    public static float CONST(final float v) {\n-        return v;\n+    public static String toString(final Object obj, final Supplier<String> supplier) {\n+        return obj == null ? supplier == null ? null : supplier.get() : obj.toString();\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n-     *\n-     * <pre>\n-     *     public final static double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n-     * </pre>\n-     *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n-     *\n-     * @param v the double value to return\n-     * @return the double v, unchanged\n-     * @since 3.2\n+     * Calls {@link Object#wait(long, int)} for the given Duration.\n+     *\n+     * @param obj The receiver of the wait call.\n+     * @param duration How long to wait.\n+     * @throws IllegalArgumentException if the timeout duration is negative.\n+     * @throws IllegalMonitorStateException if the current thread is not the owner of the {@code obj}'s monitor.\n+     * @throws InterruptedException if any thread interrupted the current thread before or while the current thread was\n+     *         waiting for a notification. The <em>interrupted status</em> of the current thread is cleared when this\n+     *         exception is thrown.\n+     * @see Object#wait(long, int)\n+     * @since 3.12.0\n      */\n-    public static double CONST(final double v) {\n-        return v;\n+    public static void wait(final Object obj, final Duration duration) throws InterruptedException {\n+        DurationUtils.accept(obj::wait, DurationUtils.zeroIfNull(duration));\n     }\n \n     /**\n-     * This method returns the provided value unchanged.\n-     * This can prevent javac from inlining a constant\n-     * field, e.g.,\n-     *\n-     * <pre>\n-     *     public final static String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n-     * </pre>\n-     *\n-     * This way any jars that refer to this field do not\n-     * have to recompile themselves if the field's value\n-     * changes at some future date.\n+     * <p>{@code ObjectUtils} instances should NOT be constructed in\n+     * standard programming. Instead, the static methods on the class should\n+     * be used, such as {@code ObjectUtils.defaultIfNull(\"a\",\"b\");}.</p>\n      *\n-     * @param <T> the Object type\n-     * @param v the genericized Object value to return (typically a String).\n-     * @return the genericized Object v, unchanged (typically a String).\n-     * @since 3.2\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n      */\n-    public static <T> T CONST(final T v) {\n-        return v;\n+    public ObjectUtils() {\n     }\n \n }"
  }
]
