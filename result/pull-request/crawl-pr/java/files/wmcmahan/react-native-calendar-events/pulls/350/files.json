[
  {
    "sha": "0bec05f85b97d23f555990702ee58a8d295dc00a",
    "filename": "ios/RNCalendarEvents.m",
    "status": "modified",
    "additions": 48,
    "deletions": 51,
    "changes": 99,
    "blob_url": "https://github.com/wmcmahan/react-native-calendar-events/blob/970933e30c39996267d9d70be784f5aa1a5077c7/ios/RNCalendarEvents.m",
    "raw_url": "https://github.com/wmcmahan/react-native-calendar-events/raw/970933e30c39996267d9d70be784f5aa1a5077c7/ios/RNCalendarEvents.m",
    "contents_url": "https://api.github.com/repos/wmcmahan/react-native-calendar-events/contents/ios/RNCalendarEvents.m?ref=970933e30c39996267d9d70be784f5aa1a5077c7",
    "patch": "@@ -778,15 +778,18 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         return;\n     }\n \n+    __weak RNCalendarEvents *weakSelf = self;\n+    dispatch_async(serialQueue, ^{\n     @try {\n-        NSArray* calendars = [self.eventStore calendarsForEntityType:EKEntityTypeEvent];\n+    RNCalendarEvents *strongSelf = weakSelf;\n+        NSArray* calendars = [strongSelf.eventStore calendarsForEntityType:EKEntityTypeEvent];\n \n         if (!calendars) {\n             reject(@\"error\", @\"error finding calendars\", nil);\n         } else {\n             NSMutableArray *eventCalendars = [[NSMutableArray alloc] init];\n             for (EKCalendar *calendar in calendars) {\n-                BOOL isPrimary = [calendar isEqual:[self.eventStore defaultCalendarForNewEvents]];\n+                BOOL isPrimary = [calendar isEqual:[strongSelf.eventStore defaultCalendarForNewEvents]];\n                 [eventCalendars addObject:@{\n                                             @\"id\": calendar.calendarIdentifier,\n                                             @\"title\": calendar.title ? calendar.title : @\"\",\n@@ -803,27 +806,30 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n     @catch (NSException *exception) {\n         reject(@\"error\", @\"saveCalendar error\", [self exceptionToError:exception]);\n     }\n+    });\n }\n \n RCT_EXPORT_METHOD(saveCalendar:(NSDictionary *)options resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n {\n     if (![self isCalendarAccessGranted]) {\n         return reject(@\"error\", @\"unauthorized to access calendar\", nil);\n     }\n-    \n+    __weak RNCalendarEvents *weakSelf = self;\n+    dispatch_async(serialQueue, ^{\n     @try {\n+        RNCalendarEvents *strongSelf = weakSelf;\n         EKCalendar *calendar = nil;\n         EKSource *calendarSource = nil;\n         NSString *title = [RCTConvert NSString:options[@\"title\"]];\n         NSNumber *color = [RCTConvert NSNumber:options[@\"color\"]];\n         NSString *type = [RCTConvert NSString:options[@\"entityType\"]];\n \n         // First: Check if the user has an iCloud source set-up.\n-        for (EKSource *source in self.eventStore.sources) {\n+        for (EKSource *source in strongSelf.eventStore.sources) {\n             if (source.sourceType == EKSourceTypeCalDAV && [source.title isEqualToString:@\"iCloud\"]) {\n                 calendarSource = source;\n                 break;\n-           }\n+            }\n         }\n \n         // Second: If no iCloud source is set-up / utilised, then fall back and use the local source.\n@@ -846,9 +852,9 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         }\n \n         if ([type isEqualToString:@\"event\"]) {\n-        calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:self.eventStore];\n+        calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:strongSelf.eventStore];\n         } else if ([type isEqualToString:@\"reminder\"]) {\n-          calendar = [EKCalendar calendarForEntityType:EKEntityTypeReminder eventStore:self.eventStore];\n+          calendar = [EKCalendar calendarForEntityType:EKEntityTypeReminder eventStore:strongSelf.eventStore];\n         } else {\n             return reject(@\"error\",\n                  [NSString stringWithFormat:@\"Calendar entityType %@ is not supported\", type],\n@@ -867,7 +873,7 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         }\n \n         NSError *error = nil;\n-        BOOL success = [self.eventStore saveCalendar:calendar commit:YES error:&error];\n+        BOOL success = [strongSelf.eventStore saveCalendar:calendar commit:YES error:&error];\n         if (success) {\n             return resolve(calendar.calendarIdentifier);\n         }\n@@ -877,6 +883,7 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n     @catch (NSException *exception) {\n         reject(@\"error\", @\"saveCalendar error\", [self exceptionToError:exception]);\n     }\n+    });\n }\n \n RCT_EXPORT_METHOD(removeCalendar:(NSString *)calendarId resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)\n@@ -886,13 +893,14 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         return;\n     }\n \n-\n+    __weak RNCalendarEvents *weakSelf = self;\n     dispatch_async(serialQueue, ^{\n-        @try {\n-            EKCalendar *calendar = (EKCalendar *)[self.eventStore calendarWithIdentifier:calendarId];\n+    @try {\n+    RNCalendarEvents *strongSelf = weakSelf;\n+            EKCalendar *calendar = (EKCalendar *)[strongSelf.eventStore calendarWithIdentifier:calendarId];\n             NSError *error = nil;\n \n-            BOOL success = [self.eventStore removeCalendar:calendar commit:YES error:&error];\n+            BOOL success = [strongSelf.eventStore removeCalendar:calendar commit:YES error:&error];\n             if (error) {\n                 return reject(@\"error\", [error.userInfo valueForKey:@\"NSLocalizedDescription\"], nil);\n             }\n@@ -910,12 +918,15 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         reject(@\"error\", @\"unauthorized to access calendar\", nil);\n         return;\n     }\n-\n+    __weak RNCalendarEvents *weakSelf = self;\n+    dispatch_async(serialQueue, ^{\n+    @try {\n+    RNCalendarEvents *strongSelf = weakSelf;\n     NSMutableArray *eventCalendars;\n \n     if (calendars.count) {\n         eventCalendars = [[NSMutableArray alloc] init];\n-        NSArray *deviceCalendars = [self.eventStore calendarsForEntityType:EKEntityTypeEvent];\n+        NSArray *deviceCalendars = [strongSelf.eventStore calendarsForEntityType:EKEntityTypeEvent];\n \n         for (EKCalendar *calendar in deviceCalendars) {\n             if ([calendars containsObject:calendar.calendarIdentifier]) {\n@@ -924,14 +935,10 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         }\n     }\n \n-    NSPredicate *predicate = [self.eventStore predicateForEventsWithStartDate:startDate\n+    NSPredicate *predicate = [strongSelf.eventStore predicateForEventsWithStartDate:startDate\n                                                                       endDate:endDate\n                                                                     calendars:eventCalendars];\n \n-    __weak RNCalendarEvents *weakSelf = self;\n-    dispatch_async(serialQueue, ^{\n-        @try {\n-            RNCalendarEvents *strongSelf = weakSelf;\n             NSArray *calendarEvents = [[strongSelf.eventStore eventsMatchingPredicate:predicate] sortedArrayUsingSelector:@selector(compareStartDateWithEvent:)];\n             if (calendarEvents) {\n                 resolve([strongSelf serializeCalendarEvents:calendarEvents]);\n@@ -956,10 +963,10 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n \n     __weak RNCalendarEvents *weakSelf = self;\n     dispatch_async(serialQueue, ^{\n-        @try {\n-            RNCalendarEvents *strongSelf = weakSelf;\n+    @try {\n+    RNCalendarEvents *strongSelf = weakSelf;\n \n-            EKEvent *calendarEvent = (EKEvent *)[self.eventStore calendarItemWithIdentifier:eventId];\n+            EKEvent *calendarEvent = (EKEvent *)[strongSelf.eventStore calendarItemWithIdentifier:eventId];\n             if (calendarEvent) {\n                 resolve([strongSelf serializeCalendarEvent:calendarEvent]);\n             } else {\n@@ -982,14 +989,14 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         reject(@\"error\", @\"unauthorized to access calendar\", nil);\n         return;\n     }\n-\n-    NSMutableDictionary *details = [NSMutableDictionary dictionaryWithDictionary:settings];\n-    [details setValue:title forKey:_title];\n-\n+    \n     __weak RNCalendarEvents *weakSelf = self;\n     dispatch_async(serialQueue, ^{\n-        @try {\n-            RNCalendarEvents *strongSelf = weakSelf;\n+    @try {\n+    RNCalendarEvents *strongSelf = weakSelf;\n+    \n+    NSMutableDictionary *details = [NSMutableDictionary dictionaryWithDictionary:settings];\n+    [details setValue:title forKey:_title];\n \n             NSDictionary *response = [strongSelf buildAndSaveEvent:details options:options];\n \n@@ -1011,7 +1018,12 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n         reject(@\"error\", @\"unauthorized to access calendar\", nil);\n         return;\n     }\n-\n+    \n+    __weak RNCalendarEvents *weakSelf = self;\n+    dispatch_async(serialQueue, ^{\n+    @try {\n+    RNCalendarEvents *strongSelf = weakSelf;\n+    \n     Boolean futureEvents = [RCTConvert BOOL:options[@\"futureEvents\"]];\n     NSDate *exceptionDate = [RCTConvert NSDate:options[@\"exceptionDate\"]];\n \n@@ -1022,14 +1034,10 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n                                     toDate:exceptionDate\n                                    options:0];\n \n-      NSPredicate *predicate = [self.eventStore predicateForEventsWithStartDate:exceptionDate\n+      NSPredicate *predicate = [strongSelf.eventStore predicateForEventsWithStartDate:exceptionDate\n                                                                         endDate:endDate\n                                                                       calendars:nil];\n \n-        __weak RNCalendarEvents *weakSelf = self;\n-        dispatch_async(serialQueue, ^{\n-            @try {\n-                RNCalendarEvents *strongSelf = weakSelf;\n                 NSArray *calendarEvents = [strongSelf.eventStore eventsMatchingPredicate:predicate];\n                 EKEvent *eventInstance;\n                 BOOL success;\n@@ -1058,36 +1066,25 @@ - (NSDictionary *)serializeCalendarEvent:(EKEvent *)event\n                 }\n \n                 return resolve(@(success));\n-            }\n-            @catch (NSException *exception) {\n-                reject(@\"error\", @\"removeEvent error\", [self exceptionToError:exception]);\n-            }\n-        });\n     } else {\n-      __weak RNCalendarEvents *weakSelf = self;\n-      dispatch_async(serialQueue, ^{\n-          @try {\n-              RNCalendarEvents *strongSelf = weakSelf;\n-              \n-              EKEvent *calendarEvent = (EKEvent *)[self.eventStore calendarItemWithIdentifier:eventId];\n+              EKEvent *calendarEvent = (EKEvent *)[strongSelf.eventStore calendarItemWithIdentifier:eventId];\n               NSError *error = nil;\n               EKSpan eventSpan = EKSpanThisEvent;\n \n               if (futureEvents) {\n                   eventSpan = EKSpanFutureEvents;\n               }\n \n-              BOOL success = [self.eventStore removeEvent:calendarEvent span:eventSpan commit:YES error:&error];\n+              BOOL success = [strongSelf.eventStore removeEvent:calendarEvent span:eventSpan commit:YES error:&error];\n               if (error) {\n                   return reject(@\"error\", [error.userInfo valueForKey:@\"NSLocalizedDescription\"], nil);\n               }\n               return resolve(@(success));\n-              }\n-          @catch (NSException *exception) {\n-              reject(@\"error\", @\"removeEvent error\", [self exceptionToError:exception]);\n-          }\n-      });\n     }\n+    } @catch (NSException *exception) {\n+        reject(@\"error\", @\"removeEvent error\", [self exceptionToError:exception]);\n+    }\n+});\n }\n \n @end"
  }
]
