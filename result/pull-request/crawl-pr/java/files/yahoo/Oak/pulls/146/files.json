[
  {
    "sha": "d9f4e17931d2088a6b317570953731802b052c2b",
    "filename": "benchmarks/synchrobench/src/main/java/com/yahoo/oak/OffHeapList.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/benchmarks/synchrobench/src/main/java/com/yahoo/oak/OffHeapList.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/benchmarks/synchrobench/src/main/java/com/yahoo/oak/OffHeapList.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/benchmarks/synchrobench/src/main/java/com/yahoo/oak/OffHeapList.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -98,8 +98,8 @@ public void putOak(K key, V value) {\n         Cell prevValue = skipListMap.putIfAbsent(newCell, newCell);\n \n         if (prevValue == null) {\n-            ScopedReadBuffer keybb = new ScopedReadBuffer(new Slice());\n-            ScopedReadBuffer valuebb = new ScopedReadBuffer(new Slice());\n+            ScopedReadBuffer keybb = new ScopedReadBuffer(new SliceSyncRecycle());\n+            ScopedReadBuffer valuebb = new ScopedReadBuffer(new SliceSyncRecycle());\n             allocator.allocate(keybb.getSlice(), key.calculateSerializedSize());\n             keybb.getSlice().duplicateBuffer();\n             ScopedWriteBuffer.serialize(keybb.getSlice(), key, MyBuffer.DEFAULT_SERIALIZER);\n@@ -112,7 +112,7 @@ public void putOak(K key, V value) {\n             }\n         } else {\n             if (prevValue.value.get() == null) {\n-                ScopedReadBuffer valuebb = new ScopedReadBuffer(new Slice());\n+                ScopedReadBuffer valuebb = new ScopedReadBuffer(new SliceSyncRecycle());\n                 allocator.allocate(valuebb.getSlice(), value.calculateSerializedSize());\n                 valuebb.getSlice().duplicateBuffer();\n                 ScopedWriteBuffer.serialize(valuebb.getSlice(), value, MyBuffer.DEFAULT_SERIALIZER);\n@@ -135,8 +135,8 @@ public boolean putIfAbsentOak(K key, V value) {\n         newCell.key.set(key);\n         Cell prevValue = skipListMap.putIfAbsent(newCell, newCell);\n         if (prevValue == null) {\n-            ScopedReadBuffer keybb = new ScopedReadBuffer(new Slice());\n-            ScopedReadBuffer valuebb = new ScopedReadBuffer(new Slice());\n+            ScopedReadBuffer keybb = new ScopedReadBuffer(new SliceSyncRecycle());\n+            ScopedReadBuffer valuebb = new ScopedReadBuffer(new SliceSyncRecycle());\n             allocator.allocate(keybb.getSlice(), key.calculateSerializedSize());\n             keybb.getSlice().duplicateBuffer();\n             ScopedWriteBuffer.serialize(keybb.getSlice(), key, MyBuffer.DEFAULT_SERIALIZER);\n@@ -239,7 +239,7 @@ public void putIfAbsentComputeIfPresentOak(K key, V value) {\n             Cell prevValue = (Cell) prevValueO;\n             // cell is in map but maybe not initialized yet\n             if (prevValue.value.get() == null) {\n-                ScopedReadBuffer valuebb = new ScopedReadBuffer(new Slice());\n+                ScopedReadBuffer valuebb = new ScopedReadBuffer(new SliceSyncRecycle());\n                 allocator.allocate(valuebb.getSlice(), value.calculateSerializedSize());\n                 valuebb.getSlice().duplicateBuffer();\n                 ScopedWriteBuffer.serialize(valuebb.getSlice(), value, MyBuffer.DEFAULT_SERIALIZER);\n@@ -267,8 +267,8 @@ public void putIfAbsentComputeIfPresentOak(K key, V value) {\n \n         // If we only added and didnt do any compute, still have to init cell\n         if (retval.value.get() == null) {\n-            ScopedReadBuffer keybb = new ScopedReadBuffer(new Slice());\n-            ScopedReadBuffer valuebb = new ScopedReadBuffer(new Slice());\n+            ScopedReadBuffer keybb = new ScopedReadBuffer(new SliceSyncRecycle());\n+            ScopedReadBuffer valuebb = new ScopedReadBuffer(new SliceSyncRecycle());\n             allocator.allocate(keybb.getSlice(), key.calculateSerializedSize());\n             keybb.getSlice().duplicateBuffer();\n             ScopedWriteBuffer.serialize(keybb.getSlice(), key, MyBuffer.DEFAULT_SERIALIZER);"
  },
  {
    "sha": "b3f2c26ac5cf9e9181a04a8554d660fd776685d2",
    "filename": "core/src/main/java/com/yahoo/oak/NativeMemoryAllocator.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/NativeMemoryAllocator.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/NativeMemoryAllocator.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/NativeMemoryAllocator.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -92,7 +92,7 @@ public boolean allocate(Slice s, int size) {\n                 if (stats != null) {\n                     stats.reclaim(size);\n                 }\n-                s.copyFrom(bestFit);\n+                s.copyForAllocation(bestFit);\n                 return true;\n             }\n         }"
  },
  {
    "sha": "fcbbc22f315ba944a49486403343f3f2c5808e0d",
    "filename": "core/src/main/java/com/yahoo/oak/OakMap.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/OakMap.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/OakMap.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/OakMap.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -54,7 +54,7 @@\n         this.keysMemoryManager = kMM;\n         this.comparator = oakComparator;\n         this.internalOakMap = new InternalOakMap<>(minKey, keySerializer, valueSerializer, oakComparator,\n-                this.valuesMemoryManager, kMM, chunkMaxItems, new ValueUtilsImpl());\n+                this.valuesMemoryManager, kMM, chunkMaxItems, new ValueUtils());\n \n         this.fromKey = null;\n         this.fromInclusive = false;"
  },
  {
    "sha": "d5ef69af9ffa3efe6a2f2ed39bf571d0aefdf80c",
    "filename": "core/src/main/java/com/yahoo/oak/ReferenceCodecSeqExpand.java",
    "status": "modified",
    "additions": 11,
    "deletions": 10,
    "changes": 21,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ReferenceCodecSeqExpand.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ReferenceCodecSeqExpand.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/ReferenceCodecSeqExpand.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -7,8 +7,8 @@\n package com.yahoo.oak;\n \n /**\n- * A direct reference doesn't impose any memory manager related actions upon any access.\n- * A direct reference is composed of 3 parameters:\n+ * A Sequential-Expanding reference doesn't impose any memory manager related actions upon any access.\n+ * A Sequential-Expanding reference is composed of 3 parameters:\n  *\n  * block ID (first), offset (second) and length (third)\n  *\n@@ -23,11 +23,12 @@\n  * Total memory 64GB\n  *\n  *\n- * The direct reference codec encodes the reference of the unmanaged slices into a single long primitive (64 bit).\n- * For the default block size (256MB), we need 28 bits to encode the offset\n+ * The Sequential-Expanding reference codec encodes the reference of the Sequential-Expanding slices\n+ * into a single long primitive (64 bit).\n+ * For example, for the block size 256MB, we need 28 bits to encode the offset\n  * and additional 28 bits to encode the length.\n  * So, the remaining 8 bits can encode the block id, which will limit the maximal number of blocks to 256.\n- * Thus, the key/value reference encoding when using the default block size (256MB) will be as follows:\n+ * Thus, the key/value reference encoding when using this block size (256MB) will be as follows:\n  *\n  *    LSB                                       MSB\n  *     |     offset     |     length     | block |\n@@ -38,7 +39,7 @@\n  * Note: these limitations will change for different block sizes. */\n \n class ReferenceCodecSeqExpand extends ReferenceCodec {\n-    private static final long INVALID_DIRECT_REFERENCE = 0;\n+    private static final long INVALID_SEQ_EXP_REFERENCE = 0;\n     /**\n      * Initialize the codec with size block-size and value length limits.\n      * These limits will inflict a limit on the maximal number of blocks (the remaining bits).\n@@ -86,7 +87,7 @@ protected long getThirdForDelete(long reference) {\n \n     @Override\n     protected void setAll(Slice s, long blockID, long offset, long length, long reference) {\n-        s.associateReferenceDecodingNoFree((int) blockID, (int) offset, (int) length, reference);\n+        s.associateReferenceDecoding((int) blockID, (int) offset, (int) length, reference);\n     }\n \n     @Override\n@@ -101,10 +102,10 @@ boolean isReferenceConsistent(long reference) {\n \n     @Override\n     boolean isReferenceValid(long reference) {\n-        return reference != INVALID_DIRECT_REFERENCE;\n+        return reference != INVALID_SEQ_EXP_REFERENCE;\n     }\n \n-    long getInvalidReference() {\n-        return INVALID_DIRECT_REFERENCE;\n+    static long getInvalidReference() {\n+        return INVALID_SEQ_EXP_REFERENCE;\n     }\n }"
  },
  {
    "sha": "7e48aee4cdec9626d4bae82e04f27016acea418b",
    "filename": "core/src/main/java/com/yahoo/oak/ReferenceCodecSyncRecycle.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ReferenceCodecSyncRecycle.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ReferenceCodecSyncRecycle.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/ReferenceCodecSyncRecycle.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -7,8 +7,8 @@\n package com.yahoo.oak;\n \n /**\n- * A reference that is involved in memory management is composed of 3 parameters:\n- * block ID, offset and version.\n+ * A reference that is involved in synchronized and recycling memory management is composed of\n+ * 3 parameters:block ID, offset and version.\n  *\n  * 0...            ...42 | 43... ...63\n  * block ID   |  offset  | version\n@@ -61,7 +61,7 @@ protected long getSecond(Slice s) {\n \n     @Override\n     protected long getThird(Slice s) {\n-        int ver = s.getVersion();\n+        int ver = ((SliceSyncRecycle) s).getVersion(); // other ideas?\n         return (long) ver;\n     }\n \n@@ -85,7 +85,7 @@ protected long getThirdForDelete(long reference) {\n \n     @Override\n     protected void setAll(Slice s, long blockID, long offset, long version, long reference) {\n-        s.associateReferenceDecodingNative(\n+        s.associateReferenceDecoding(\n             (int) blockID, (int) offset, (int) version, reference);\n     }\n \n@@ -116,7 +116,7 @@ boolean isReferenceValidAndNotDeleted(long reference) {\n             (reference & REFERENCE_DELETE_BIT_MASK) == INVALID_MM_REFERENCE );\n     }\n \n-    long getInvalidReference() {\n+    static long getInvalidReference() {\n         return INVALID_MM_REFERENCE;\n     }\n }"
  },
  {
    "sha": "4211e6a75a3026b5fa763f6b3431221ca8e16e0f",
    "filename": "core/src/main/java/com/yahoo/oak/SeqExpandMemoryManager.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SeqExpandMemoryManager.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SeqExpandMemoryManager.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/SeqExpandMemoryManager.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -131,7 +131,7 @@ public boolean isReferenceConsistent(long reference) {\n \n     @Override\n     public Slice getEmptySlice() {\n-        return new Slice(0, rcd.getInvalidReference(), null);\n+        return new SliceSeqExpand();\n     }\n \n     @Override public int getHeaderSize() {"
  },
  {
    "sha": "41078fb57d720719aac8db212c7422e6e319c9fb",
    "filename": "core/src/main/java/com/yahoo/oak/Slice.java",
    "status": "modified",
    "additions": 50,
    "deletions": 154,
    "changes": 204,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/Slice.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/Slice.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/Slice.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -10,60 +10,36 @@\n \n import java.nio.ByteBuffer;\n \n-// Slice represents an data about an off-heap cut: a portion of a bigger block,\n-// which is part of the underlying managed off-heap memory.\n+// An abstract Slice represents an data about an off-heap cut: a portion of a bigger block,\n+// which is part of the underlying managed off-heap memory. Concrete implementation adapts\n+// the abstract Slice to a specific memory manager.\n // Slice is allocated only via memory manager, and can be de-allocated later.\n // Slice can be either empty or associated with an off-heap cut,\n // which is the aforementioned portion of an off-heap memory.\n-class Slice implements OakUnsafeDirectBuffer, Comparable<Slice> {\n+abstract class Slice implements OakUnsafeDirectBuffer, Comparable<Slice> {\n     static final int UNDEFINED_LENGTH_OR_OFFSET = -1;\n \n-    /**\n-     * An allocated off-heap cut might have reserved space for meta-data, i.e., a header.\n-     * The header size is defined externally by memory-manager at the slice construction.\n-     */\n-    private final int headerSize;\n-    private final SyncRecycleMMHeader header;\n-\n     /** The fields describing the associated off-heap cut, they are set when slice is not empty **/\n-    private long reference;\n-    private final long invalidReferenceValue; // used for invalidation\n-    private int blockID = NativeMemoryAllocator.INVALID_BLOCK_ID;\n-    private int offset  = UNDEFINED_LENGTH_OR_OFFSET;\n+    protected long reference;\n+    protected int blockID = NativeMemoryAllocator.INVALID_BLOCK_ID;\n+    protected int offset  = UNDEFINED_LENGTH_OR_OFFSET;\n \n     // The entire length of the off-heap cut, including the header!\n-    private int length = UNDEFINED_LENGTH_OR_OFFSET;\n-    private int version;    // Allocation time version\n-    private ByteBuffer buffer = null;\n+    protected int length = UNDEFINED_LENGTH_OR_OFFSET;\n+    protected int version;    // Allocation time version\n+    protected ByteBuffer buffer = null;\n \n     // true if slice is associated with an off-heap slice of memory\n     // if associated is false the Slice is empty\n-    private boolean associated = false;\n+    protected boolean associated = false;\n \n     /* ------------------------------------------------------------------------------------\n-     * Constructors\n+     * No Constructors, only for concrete implementations\n      * ------------------------------------------------------------------------------------*/\n-    // Should be used only by Memory Manager (within Memory Manager package)\n-    Slice(int headerSize, long invalidReferenceValue, SyncRecycleMMHeader header) {\n-        this.headerSize = headerSize;\n-        this.invalidReferenceValue = invalidReferenceValue;\n-        this.header = header;\n-        invalidate();\n-    }\n-\n-    // Should be used only for testing\n-    @VisibleForTesting\n-    Slice() {\n-        this(0, 0, null);\n-    }\n \n     // Used to duplicate the allocation state. Does not duplicate the underlying memory buffer itself.\n     // Should be used when ThreadContext's internal Slice needs to be exported to the user.\n-    Slice getDuplicatedSlice() {\n-        Slice newSlice = new Slice(this.headerSize, this.invalidReferenceValue, this.header);\n-        newSlice.copyFrom(this);\n-        return newSlice;\n-    }\n+    abstract Slice getDuplicatedSlice();\n \n     // Used only in testing to make each slice reference different buffer object,\n     // but the same off-heap memory\n@@ -76,21 +52,28 @@ void duplicateBuffer() {\n      * Allocation info and metadata setters\n      * ------------------------------------------------------------------------------------*/\n     // Reset all not final fields to invalid state\n-    void invalidate() {\n-        blockID     = NativeMemoryAllocator.INVALID_BLOCK_ID;\n-        reference   = invalidReferenceValue;\n-        length      = UNDEFINED_LENGTH_OR_OFFSET;\n-        offset      = UNDEFINED_LENGTH_OR_OFFSET;\n-        buffer      = null;\n-        associated  = false;\n-    }\n+    abstract void invalidate();\n \n     // initialize dummy for allocation\n     void initializeLookupDummy(int l) {\n         invalidate();\n         length = l;\n     }\n \n+    // Copy the block allocation information from another block allocation.\n+    void copyForAllocation(Slice other) {\n+        if (other == this) {\n+            // No need to do anything if the input is this object\n+            return;\n+        }\n+        this.blockID = other.blockID;\n+        this.offset = other.offset;\n+        this.length = other.length;\n+        this.buffer = other.buffer;\n+        this.reference = other.reference;\n+        this.associated = other.associated;\n+    }\n+\n     /*\n      * Sets everything related to allocation of an off-heap cut: a portion of a bigger block.\n      * Turns empty slice to an associated slice upon allocation.\n@@ -103,48 +86,17 @@ void associateBlockAllocation(int blockID, int offset, int length, ByteBuffer bu\n         this.buffer  = buffer;\n         this.associated = true;\n \n-        // reference and (maybe) version are yet to be set by associateMMAllocation\n-    }\n-\n-    /*\n-     * Updates everything that can be extracted with reference decoding of \"NoFree\" type,\n-     * including reference itself. The separation by reference decoding type is temporary!\n-     * This is not the full setting of the association, therefore 'associated' flag remains false\n-     */\n-    void associateReferenceDecodingNoFree(int blockID, int offset, int length, long reference) {\n-        // length can remain undefined until requested, but if given length should include the header\n-        assert length != UNDEFINED_LENGTH_OR_OFFSET && headerSize <= length;\n-        setBlockIdOffsetAndLength(blockID, offset, length);\n-        this.reference = reference;\n-        associated   = false;\n+        // more Slice's properties are yet to be set by associateMMAllocation\n     }\n \n     /*\n-     * Updates everything that can be extracted with reference decoding of \"Native\" type,\n-     * including reference itself. The separation by reference decoding type is temporary!\n-     * This is not the full setting of the association, therefore 'associated' flag remains false\n+     * Updates everything that can be extracted with reference decoding,\n+     * including reference itself. This is not the full setting of the association\n      */\n-    void associateReferenceDecodingNative(int blockID, int offset, int version, long reference) {\n-        setBlockIdOffsetAndLength(blockID, offset, UNDEFINED_LENGTH_OR_OFFSET);\n-        this.reference = reference;\n-        this.version = version;\n-        associated   = false;\n-    }\n+    abstract void associateReferenceDecoding(int blockID, int offset, int arg, long reference);\n \n     // Copy the block allocation information from another block allocation.\n-    void copyFrom(Slice other) {\n-        if (other == this) {\n-            // No need to do anything if the input is this object\n-            return;\n-        }\n-        this.blockID = other.blockID;\n-        this.offset = other.offset;\n-        this.length = other.length;\n-        this.version = other.version;\n-        this.buffer = other.buffer;\n-        this.reference = other.reference;\n-        this.associated = other.associated;\n-    }\n+    abstract <T extends Slice> void copyFrom(T other);\n \n     // Set the internal buffer.\n     // This method should be used only within Memory Management package.\n@@ -155,35 +107,21 @@ void setBuffer(ByteBuffer buffer) {\n     }\n \n     /*\n-     * Upon allocstion, sets everything related to memory management of an off-heap cut:\n+     * Upon allocation, sets everything related to memory management of an off-heap cut:\n      * a portion of a bigger block.\n      * Used only within Memory Manager package.\n      */\n-    void associateMMAllocation(int version, long reference) {\n-        this.version = version;\n-        this.reference = reference;\n-    }\n+    abstract void associateMMAllocation(int version, long reference);\n \n     // used only in case of iterations when the rest of the slice's data should remain the same\n     // in this case once the offset is set the the slice is associated\n-    void updateOnSameBlock(int offset, int length) {\n-        this.offset = offset;\n-        this.length = length;\n-        assert buffer != null;\n-        this.associated = true;\n-    }\n+    abstract void updateOnSameBlock(int offset, int length);\n \n     // the method has no effect if length is already set\n-    protected void prefetchDataLength() {\n-        if (length == UNDEFINED_LENGTH_OR_OFFSET) {\n-            // the length kept in header is the length of the data only!\n-            // add header size\n-            this.length = header.getDataLength(getMetadataAddress()) + headerSize;\n-        }\n-    }\n+    protected abstract void prefetchDataLength();\n \n     // simple setter, frequently internally used, to save code duplication\n-    private void setBlockIdOffsetAndLength(int blockID, int offset, int length) {\n+    protected void setBlockIdOffsetAndLength(int blockID, int offset, int length) {\n         this.blockID = blockID;\n         this.offset = offset;\n         this.length = length;\n@@ -209,20 +147,11 @@ int getAllocatedOffset() {\n         return offset;\n     }\n \n-    int getAllocatedLength() {\n-        assert associated;\n-        // prefetchDataLength() prefetches the length from header only if Slice's length is undefined\n-        prefetchDataLength();\n-        return length;\n-    }\n+    abstract int getAllocatedLength();\n \n     /* ------------------------------------------------------------------------------------\n      * Metadata getters\n      * ------------------------------------------------------------------------------------*/\n-    int getVersion() {\n-        return version;\n-    }\n-\n     long getMetadataAddress() {\n         assert associated;\n         return ((DirectBuffer) buffer).address() + offset;\n@@ -237,27 +166,18 @@ public ByteBuffer getByteBuffer() {\n     }\n \n     @Override\n-    public int getOffset() {\n-        assert associated;\n-        return offset + headerSize;\n-    }\n+    public abstract int getOffset();\n \n     @Override\n-    public int getLength() {\n-        // prefetchDataLength() prefetches the length from header only if Slice's length is undefined\n-        prefetchDataLength();\n-        return length - headerSize;\n-    }\n+    public abstract int getLength();\n \n     @Override\n     public long getAddress() {\n         return ((DirectBuffer) buffer).address() + getOffset();\n     }\n \n     @Override\n-    public String toString() {\n-        return String.format(\"Slice(blockID=%d, offset=%,d, length=%,d, version=%d)\", blockID, offset, length, version);\n-    }\n+    public abstract String toString();\n \n     /*-------------- Comparable<Slice> --------------*/\n \n@@ -291,10 +211,7 @@ public int compareTo(Slice o) {\n      * {@code RETRY} if the header/off-heap-cut was moved, or the version of the off-heap header\n      * does not match {@code version}.\n      */\n-    ValueUtils.ValueResult lockRead(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.lockRead(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult lockRead();\n \n     /**\n      * Releases a read lock\n@@ -303,10 +220,7 @@ public int compareTo(Slice o) {\n      * {@code FALSE} if the value is marked as deleted\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      */\n-    ValueUtils.ValueResult unlockRead(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.unlockRead(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult unlockRead();\n \n     /**\n      * Acquires a write lock\n@@ -315,10 +229,7 @@ public int compareTo(Slice o) {\n      * {@code FALSE} if the value is marked as deleted\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      */\n-    ValueUtils.ValueResult lockWrite(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.lockWrite(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult lockWrite();\n \n     /**\n      * Releases a write lock\n@@ -327,10 +238,7 @@ public int compareTo(Slice o) {\n      * {@code FALSE} if the value is marked as deleted\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      */\n-    ValueUtils.ValueResult unlockWrite(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.unlockWrite(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult unlockWrite();\n \n     /**\n      * Marks the associated off-heap cut as deleted only if the version of that value matches {@code version}.\n@@ -339,10 +247,7 @@ public int compareTo(Slice o) {\n      * {@code FALSE} if the value is already marked as deleted\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      */\n-    ValueUtils.ValueResult logicalDelete(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.logicalDelete(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult logicalDelete();\n \n     /**\n      * Is the associated off-heap cut marked as logically deleted\n@@ -351,27 +256,18 @@ public int compareTo(Slice o) {\n      * {@code FALSE} if the value is not marked\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      */\n-    ValueUtils.ValueResult isDeleted(){\n-        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n-        return header.isLogicallyDeleted(version, getMetadataAddress());\n-    }\n+    abstract ValueUtils.ValueResult isDeleted();\n \n     /**\n      * Marks the header of the associated off-heap cut as moved, just write (without CAS)\n      * The write lock must be held (asserted inside the header)\n      */\n-    void markAsMoved() {\n-        assert associated;\n-        header.markAsMoved(getMetadataAddress());\n-    }\n+    abstract void markAsMoved();\n \n     /**\n      * Marks the header of the associated off-heap cut as deleted, just write (without CAS)\n      * The write lock must be held (asserted inside the header).\n      * It is similar to logicalDelete() but used when locking and marking don't happen in one CAS\n      */\n-    void markAsDeleted() {\n-        assert associated;\n-        header.markAsDeleted(getMetadataAddress());\n-    }\n+    abstract void markAsDeleted();\n }"
  },
  {
    "sha": "1ea6c9d9c77c7e46f17c5d5786c1527d6239de12",
    "filename": "core/src/main/java/com/yahoo/oak/SliceSeqExpand.java",
    "status": "added",
    "additions": 221,
    "deletions": 0,
    "changes": 221,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SliceSeqExpand.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SliceSeqExpand.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/SliceSeqExpand.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright 2020, Verizon Media.\n+ * Licensed under the terms of the Apache 2.0 license.\n+ * Please see LICENSE file in the project root for terms.\n+ */\n+\n+package com.yahoo.oak;\n+\n+// SliceSeqExpand represents an data about an off-heap cut: a portion of a bigger block,\n+// which is part of the underlying managed off-heap memory, which is managed for sequential\n+// access and without memory recycling.\n+// SliceSeqExpand is allocated only via SeqExpandMemoryManager, and can be de-allocated later.\n+// Any slice can be either empty or associated with an off-heap cut,\n+// which is the aforementioned portion of an off-heap memory.\n+class SliceSeqExpand extends Slice {\n+    static final int UNDEFINED_LENGTH_OR_OFFSET = -1;\n+\n+    private final long invalidReferenceValue; // used for invalidation\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Constructors\n+     * ------------------------------------------------------------------------------------*/\n+    // Should be used only by Memory Manager (within Memory Manager package)\n+    SliceSeqExpand() {\n+        super();\n+        this.invalidReferenceValue = ReferenceCodecSeqExpand.getInvalidReference();\n+        invalidate();\n+    }\n+\n+    // Used to duplicate the allocation state. Does not duplicate the underlying memory buffer itself.\n+    // Should be used when ThreadContext's internal Slice needs to be exported to the user.\n+    SliceSeqExpand getDuplicatedSlice() {\n+        SliceSeqExpand newSlice = new SliceSeqExpand();\n+        newSlice.copyFrom(this);\n+        return newSlice;\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Allocation info and metadata setters\n+     * ------------------------------------------------------------------------------------*/\n+    // Reset all not final fields to invalid state\n+    void invalidate() {\n+        blockID     = NativeMemoryAllocator.INVALID_BLOCK_ID;\n+        reference   = invalidReferenceValue;\n+        length      = UNDEFINED_LENGTH_OR_OFFSET;\n+        offset      = UNDEFINED_LENGTH_OR_OFFSET;\n+        buffer      = null;\n+        associated  = false;\n+    }\n+\n+    /*\n+     * Updates everything that can be extracted with reference decoding of \"SeqExpand\" type,\n+     * including reference itself.\n+     * This is not the full setting of the association, therefore 'associated' flag remains false\n+     */\n+    void associateReferenceDecoding(int blockID, int offset, int length, long reference){\n+        // length can remain undefined until requested, but if given length should include the header\n+        assert length != UNDEFINED_LENGTH_OR_OFFSET;\n+        setBlockIdOffsetAndLength(blockID, offset, length);\n+        this.reference = reference;\n+        associated   = false;\n+    }\n+\n+    // Copy the block allocation information from another block allocation.\n+    <T extends Slice> void copyFrom(T other){\n+        if (other instanceof SliceSeqExpand) { //TODO: any other ideas?\n+            if (other == this) {\n+                // No need to do anything if the input is this object\n+                return;\n+            }\n+            this.blockID = other.blockID;\n+            this.offset = other.offset;\n+            this.length = other.length;\n+            this.buffer = other.buffer;\n+            this.reference = other.reference;\n+            this.associated = other.associated;\n+        } else {\n+            throw new IllegalStateException(\"Must provide SliceSeqExpand other Slice\");\n+        }\n+    }\n+\n+    /*\n+     * Upon allocation, sets everything related to Sequential-Expending memory management of\n+     * an off-heap cut: a portion of a bigger block.\n+     * Used only within Memory Manager package.\n+     */\n+    void associateMMAllocation(int arg, long reference) {\n+        this.reference = reference;\n+    }\n+\n+    // used only in case of iterations when the rest of the slice's data should remain the same\n+    // in this case once the offset is set the the slice is associated\n+    void updateOnSameBlock(int offset, int length) {\n+        this.offset = offset;\n+        this.length = length;\n+        assert buffer != null;\n+        this.associated = true;\n+    }\n+\n+    // the method has no effect for SliceSeqExpand\n+    protected void prefetchDataLength() {\n+        return;\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Allocation info getters\n+     * ------------------------------------------------------------------------------------*/\n+    int getAllocatedLength() {\n+        assert associated;\n+        return length;\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Metadata getters\n+     * ------------------------------------------------------------------------------------*/\n+\n+\n+    /*-------------- OakUnsafeDirectBuffer --------------*/\n+    @Override\n+    public int getOffset() {\n+        assert associated;\n+        return offset;\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"SliceSeqExpand(blockID=%d, offset=%,d, length=%,d)\",\n+            blockID, offset, length);\n+    }\n+\n+    /*-------------- Off-heap header operations: locking and logical delete --------------*/\n+\n+    /**\n+     * Acquires a read lock\n+     *\n+     * @return {@code TRUE} if the read lock was acquires successfully\n+     * {@code FALSE} if the header/off-heap-cut is marked as deleted\n+     * {@code RETRY} if the header/off-heap-cut was moved, or the version of the off-heap header\n+     * does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult lockRead(){\n+        throw new UnsupportedOperationException(\"Sequential Slice doesn't support synchronization\");\n+    }\n+\n+    /**\n+     * Releases a read lock\n+     *\n+     * @return {@code TRUE} if the read lock was released successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult unlockRead(){\n+        throw new UnsupportedOperationException(\"Sequential Slice doesn't support synchronization\");\n+    }\n+\n+    /**\n+     * Acquires a write lock\n+     *\n+     * @return {@code TRUE} if the write lock was acquires successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult lockWrite(){\n+        throw new UnsupportedOperationException(\"Sequential Slice doesn't support synchronization\");\n+    }\n+\n+    /**\n+     * Releases a write lock\n+     *\n+     * @return {@code TRUE} if the write lock was released successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult unlockWrite(){\n+        throw new UnsupportedOperationException(\"Sequential Slice doesn't support synchronization\");\n+    }\n+\n+    /**\n+     * Marks the associated off-heap cut as deleted only if the version of that value matches {@code version}.\n+     *\n+     * @return {@code TRUE} if the value was marked successfully\n+     * {@code FALSE} if the value is already marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult logicalDelete(){\n+        throw new UnsupportedOperationException(\"Expand-only Slice doesn't support deletion\");\n+    }\n+\n+    /**\n+     * Is the associated off-heap cut marked as logically deleted\n+     *\n+     * @return {@code TRUE} if the value is marked\n+     * {@code FALSE} if the value is not marked\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult isDeleted(){\n+        return ValueUtils.ValueResult.FALSE;\n+    }\n+\n+    /**\n+     * Marks the header of the associated off-heap cut as moved, just write (without CAS)\n+     * The write lock must be held (asserted inside the header)\n+     */\n+    void markAsMoved() {\n+        throw new UnsupportedOperationException(\"Expand-only Slice doesn't support moving\");\n+    }\n+\n+    /**\n+     * Marks the header of the associated off-heap cut as deleted, just write (without CAS)\n+     * The write lock must be held (asserted inside the header).\n+     * It is similar to logicalDelete() but used when locking and marking don't happen in one CAS\n+     */\n+    void markAsDeleted() {\n+        throw new UnsupportedOperationException(\"Expand-only Slice doesn't support deletion\");\n+    }\n+}"
  },
  {
    "sha": "5d986139b3db452ed8198e102423b28e2e263fbd",
    "filename": "core/src/main/java/com/yahoo/oak/SliceSyncRecycle.java",
    "status": "added",
    "additions": 250,
    "deletions": 0,
    "changes": 250,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SliceSyncRecycle.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SliceSyncRecycle.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/SliceSyncRecycle.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright 2020, Verizon Media.\n+ * Licensed under the terms of the Apache 2.0 license.\n+ * Please see LICENSE file in the project root for terms.\n+ */\n+\n+package com.yahoo.oak;\n+\n+// SliceSyncRecycle represents an data about an off-heap cut: a portion of a bigger block,\n+// which is part of the underlying (recycling and synchronized) managed off-heap memory.\n+// SliceSyncRecycle is allocated only via SyncRecycleMemoryManager, and can be de-allocated later.\n+// Any slice can be either empty or associated with an off-heap cut,\n+// which is the aforementioned portion of an off-heap memory.\n+class SliceSyncRecycle extends Slice {\n+    static final int UNDEFINED_LENGTH_OR_OFFSET = -1;\n+\n+    /**\n+     * An allocated by SyncRecycleMemoryManager off-heap cut have reserved space for meta-data, i.e., a header.\n+     * The header size is defined externally by memory-manager at the slice construction.\n+     */\n+    private final int headerSize;\n+    private final SyncRecycleMMHeader header;\n+\n+    private final long invalidReferenceValue; // used for invalidation\n+\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Constructors\n+     * ------------------------------------------------------------------------------------*/\n+    // Should be used only by Memory Manager (within Memory Manager package)\n+    SliceSyncRecycle(int headerSize, SyncRecycleMMHeader header) {\n+        super();\n+        this.headerSize = headerSize;\n+        this.invalidReferenceValue = ReferenceCodecSyncRecycle.getInvalidReference();\n+        this.header = header;\n+        invalidate();\n+    }\n+\n+    // Should be used only for testing\n+    @VisibleForTesting SliceSyncRecycle() {\n+        this(0, null);\n+    }\n+\n+    // Used to duplicate the allocation state. Does not duplicate the underlying memory buffer itself.\n+    // Should be used when ThreadContext's internal Slice needs to be exported to the user.\n+    SliceSyncRecycle getDuplicatedSlice() {\n+        SliceSyncRecycle newSlice = new SliceSyncRecycle(this.headerSize, this.header);\n+        newSlice.copyFrom(this);\n+        return newSlice;\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Allocation info and metadata setters\n+     * ------------------------------------------------------------------------------------*/\n+    // Reset all not final fields to invalid state\n+    void invalidate() {\n+        blockID     = NativeMemoryAllocator.INVALID_BLOCK_ID;\n+        reference   = invalidReferenceValue;\n+        length      = UNDEFINED_LENGTH_OR_OFFSET;\n+        offset      = UNDEFINED_LENGTH_OR_OFFSET;\n+        buffer      = null;\n+        associated  = false;\n+    }\n+\n+    /*\n+     * Updates everything that can be extracted with reference decoding of \"SyncRecycle\" type,\n+     * including reference itself. The separation by reference decoding type is temporary!\n+     * This is not the full setting of the association, therefore 'associated' flag remains false\n+     */\n+    void associateReferenceDecoding(int blockID, int offset, int version, long reference) {\n+        setBlockIdOffsetAndLength(blockID, offset, UNDEFINED_LENGTH_OR_OFFSET);\n+        this.reference = reference;\n+        this.version = version;\n+        associated   = false;\n+    }\n+\n+    // Copy the block allocation information from another block allocation.\n+    <T extends Slice> void copyFrom(T other) {\n+        if (other instanceof SliceSyncRecycle) { //TODO: any other ideas?\n+            if (other == this) {\n+                // No need to do anything if the input is this object\n+                return;\n+            }\n+            this.blockID = other.blockID;\n+            this.offset = other.offset;\n+            this.length = other.length;\n+            this.version = other.version;\n+            this.buffer = other.buffer;\n+            this.reference = other.reference;\n+            this.associated = other.associated;\n+        } else {\n+            throw new IllegalStateException(\"Must provide SliceSyncRecycle other Slice\");\n+        }\n+    }\n+\n+    /*\n+     * Upon allocation, sets everything related to Synchronizing-Recycling memory management of\n+     * an off-heap cut: a portion of a bigger block.\n+     * Used only within Memory Manager package.\n+     */\n+    void associateMMAllocation(int version, long reference) {\n+        this.version = version;\n+        this.reference = reference;\n+    }\n+\n+    void updateOnSameBlock(int offset, int length) {\n+        throw new IllegalStateException(\"SliceSyncRecycle cannot be partially updated\");\n+    }\n+\n+    // the method has no effect if length is already set\n+    protected void prefetchDataLength() {\n+        if (length == UNDEFINED_LENGTH_OR_OFFSET) {\n+            // the length kept in header is the length of the data only!\n+            // add header size\n+            this.length = header.getDataLength(getMetadataAddress()) + headerSize;\n+        }\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Allocation info getters\n+     * ------------------------------------------------------------------------------------*/\n+    int getAllocatedLength() {\n+        assert associated;\n+        // prefetchDataLength() prefetches the length from header only if Slice's length is undefined\n+        prefetchDataLength();\n+        return length;\n+    }\n+\n+    /* ------------------------------------------------------------------------------------\n+     * Metadata getters\n+     * ------------------------------------------------------------------------------------*/\n+    int getVersion() {\n+        return version;\n+    }\n+\n+\n+    /*-------------- OakUnsafeDirectBuffer --------------*/\n+    @Override\n+    public int getOffset() {\n+        assert associated;\n+        return offset + headerSize;\n+    }\n+\n+    @Override\n+    public int getLength() {\n+        // prefetchDataLength() prefetches the length from header only if Slice's length is undefined\n+        prefetchDataLength();\n+        return length - headerSize;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"SliceSyncRecycle(blockID=%d, offset=%,d, length=%,d, version=%d)\",\n+            blockID, offset, length, version);\n+    }\n+\n+    /*-------------- Off-heap header operations: locking and logical delete --------------*/\n+\n+    /**\n+     * Acquires a read lock\n+     *\n+     * @return {@code TRUE} if the read lock was acquires successfully\n+     * {@code FALSE} if the header/off-heap-cut is marked as deleted\n+     * {@code RETRY} if the header/off-heap-cut was moved, or the version of the off-heap header\n+     * does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult lockRead(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.lockRead(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Releases a read lock\n+     *\n+     * @return {@code TRUE} if the read lock was released successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult unlockRead(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.unlockRead(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Acquires a write lock\n+     *\n+     * @return {@code TRUE} if the write lock was acquires successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult lockWrite(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.lockWrite(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Releases a write lock\n+     *\n+     * @return {@code TRUE} if the write lock was released successfully\n+     * {@code FALSE} if the value is marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult unlockWrite(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.unlockWrite(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Marks the associated off-heap cut as deleted only if the version of that value matches {@code version}.\n+     *\n+     * @return {@code TRUE} if the value was marked successfully\n+     * {@code FALSE} if the value is already marked as deleted\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult logicalDelete(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.logicalDelete(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Is the associated off-heap cut marked as logically deleted\n+     *\n+     * @return {@code TRUE} if the value is marked\n+     * {@code FALSE} if the value is not marked\n+     * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n+     */\n+    ValueUtils.ValueResult isDeleted(){\n+        assert version != ReferenceCodecSyncRecycle.INVALID_VERSION;\n+        return header.isLogicallyDeleted(version, getMetadataAddress());\n+    }\n+\n+    /**\n+     * Marks the header of the associated off-heap cut as moved, just write (without CAS)\n+     * The write lock must be held (asserted inside the header)\n+     */\n+    void markAsMoved() {\n+        assert associated;\n+        header.markAsMoved(getMetadataAddress());\n+    }\n+\n+    /**\n+     * Marks the header of the associated off-heap cut as deleted, just write (without CAS)\n+     * The write lock must be held (asserted inside the header).\n+     * It is similar to logicalDelete() but used when locking and marking don't happen in one CAS\n+     */\n+    void markAsDeleted() {\n+        assert associated;\n+        header.markAsDeleted(getMetadataAddress());\n+    }\n+}"
  },
  {
    "sha": "1f5e49dd33118227e54275b6d52615e511a9aff8",
    "filename": "core/src/main/java/com/yahoo/oak/SyncRecycleMemoryManager.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SyncRecycleMemoryManager.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/SyncRecycleMemoryManager.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/SyncRecycleMemoryManager.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -57,6 +57,7 @@ int getCurrentVersion() {\n     }\n \n     /**\n+     * Information from reference to slice\n      * @param s         the memory slice to update with the info decoded from the reference\n      * @param reference the reference to decode\n      * @return true if the given allocation reference is valid, otherwise the slice is invalidated\n@@ -120,7 +121,7 @@ public boolean isReferenceConsistent(long reference) {\n \n     @Override\n     public Slice getEmptySlice() {\n-        return new Slice(OFF_HEAP_HEADER_SIZE, rcmm.getInvalidReference(), HEADER);\n+        return new SliceSyncRecycle(OFF_HEAP_HEADER_SIZE, HEADER);\n     }\n \n     @VisibleForTesting"
  },
  {
    "sha": "3619d986571aa8fc55e8c36c568dba6f90d13045",
    "filename": "core/src/main/java/com/yahoo/oak/ValueUtils.java",
    "status": "modified",
    "additions": 147,
    "deletions": 9,
    "changes": 156,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ValueUtils.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/main/java/com/yahoo/oak/ValueUtils.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/ValueUtils.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -8,7 +8,7 @@\n \n import java.util.function.Consumer;\n \n-interface ValueUtils {\n+class ValueUtils {\n \n     enum ValueResult {\n         TRUE, FALSE, RETRY\n@@ -28,14 +28,68 @@\n      * {@code RETRY} if the value was moved, or the version of the off-heap value does not match {@code version}.\n      * In case of {@code TRUE}, the read value is stored in the returned Result, otherwise, the value is {@code null}.\n      */\n-    <T> Result transform(Result result, ValueBuffer value, OakTransformer<T> transformer);\n+    <T> Result transform(Result result, ValueBuffer value, OakTransformer<T> transformer) {\n+        ValueResult ret = value.s.lockRead();\n+        if (ret != ValueResult.TRUE) {\n+            return result.withFlag(ret);\n+        }\n+\n+        try {\n+            T transformation = transformer.apply(value);\n+            return result.withValue(transformation);\n+        } finally {\n+            value.s.unlockRead();\n+        }\n+    }\n \n     /**\n      * @see #exchange(Chunk, ThreadContext, Object, OakTransformer, OakSerializer, InternalOakMap)\n      * Does not return the value previously written off-heap\n      */\n     <V> ValueResult put(Chunk<?, V> chunk, ThreadContext ctx, V newVal, OakSerializer<V> serializer,\n-        InternalOakMap internalOakMap);\n+        InternalOakMap internalOakMap) {\n+\n+        ValueResult result = ctx.value.s.lockWrite();\n+        if (result != ValueResult.TRUE) {\n+            return result;\n+        }\n+        result = innerPut(chunk, ctx, newVal, serializer, internalOakMap);\n+        // in case move happened: ctx.valueSlice might be set to a new slice.\n+        // Alternatively, if returned result is RETRY, a rebalance might be needed\n+        // or the entry might be updated by someone else, need to retry\n+        ctx.value.s.unlockWrite();\n+        return result;\n+    }\n+\n+    private <V> ValueResult innerPut(Chunk<?, V> chunk, ThreadContext ctx, V newVal, OakSerializer<V> serializer,\n+        InternalOakMap internalOakMap) {\n+        int capacity = serializer.calculateSize(newVal);\n+        if (capacity > ctx.value.getLength()) {\n+            return moveValue(chunk, ctx, internalOakMap, newVal);\n+        }\n+        ScopedWriteBuffer.serialize(ctx.value.s, newVal, serializer);\n+        return ValueResult.TRUE;\n+    }\n+\n+    private <V> ValueResult moveValue(\n+        Chunk<?, V> chunk, ThreadContext ctx, InternalOakMap internalOakMap, V newVal) {\n+\n+        boolean moved = internalOakMap.overwriteExistingValueForMove(ctx, newVal, chunk);\n+        if (!moved) {\n+            // rebalance was needed or the entry was updated by someone else, need to retry\n+            return ValueResult.RETRY;\n+        }\n+        // The value was moved, the header of the old slice needs to me marked as moved\n+        // Couldn't release the write lock on the old slice or mark it as moved, before the new one is updated!\n+        // Marking the old slide as moved now, the write lock is still held\n+        ctx.value.s.markAsMoved();\n+        // currently the slices which value was moved aren't going to be released, to keep the MOVED mark\n+        // They need to be released when the target slice is released (moved to free list)\n+        // TODO: deal with the reallocation of the moved memory\n+\n+        ctx.value.copyFrom(ctx.newValue);\n+        return ValueResult.TRUE;\n+    }\n \n     /**\n      * @param value    the value's off-heap Slice object\n@@ -44,7 +98,20 @@\n      * {@code FAILURE} if the value is deleted,\n      * {@code RETRY} if the value was moved.\n      */\n-    ValueResult compute(ValueBuffer value, Consumer<OakScopedWriteBuffer> computer);\n+    ValueResult compute(ValueBuffer value, Consumer<OakScopedWriteBuffer> computer) {\n+        ValueResult result = value.s.lockWrite();\n+        if (result != ValueResult.TRUE) {\n+            return result;\n+        }\n+\n+        try {\n+            ScopedWriteBuffer.compute(value.s, computer);\n+        } finally {\n+            value.s.unlockWrite();\n+        }\n+\n+        return ValueResult.TRUE;\n+    }\n \n     /**\n      * Marks a value as deleted and frees its slice (whether the header is freed or not is implementation dependant).\n@@ -59,7 +126,42 @@\n      * In case of success, the value of the returned Result is the value which was written in the off-heap before the\n      * removal (if {@code transformer} is not null), otherwise, it is {@code null}.\n      */\n-    <V> Result remove(ThreadContext ctx, V oldValue, OakTransformer<V> transformer);\n+    <V> Result remove(ThreadContext ctx, V oldValue, OakTransformer<V> transformer) {\n+        // Not a conditional remove, so we can delete immediately\n+        if (oldValue == null) {\n+            // try to delete\n+            ValueResult result = ctx.value.s.logicalDelete();\n+            if (result != ValueResult.TRUE) {\n+                return ctx.result.withFlag(result);\n+            }\n+            // Now the value is deleted, and all other threads will treat it as deleted,\n+            // but it is not yet freed, so this thread can read from it.\n+            // read the old value (the slice is not reclaimed yet)\n+            V v = transformer != null ? transformer.apply(ctx.value) : null;\n+            // return TRUE with the old value\n+            return ctx.result.withValue(v);\n+        } else {\n+            // This is a conditional remove, so we first have to check whether the current value matches the expected\n+            // one.\n+            // We start by acquiring a write lock for reading since we do not want concurrent reads.\n+            ValueResult result = ctx.value.s.lockWrite();\n+            if (result != ValueResult.TRUE) {\n+                return ctx.result.withFlag(result);\n+            }\n+            V v = transformer.apply(ctx.value);\n+            // This is where we check the equality between the expected value and the actual value\n+            if (!oldValue.equals(v)) {\n+                ctx.value.s.unlockWrite();\n+                return ctx.result.withFlag(ValueResult.FALSE);\n+            }\n+            // both values match so the value is marked as deleted.\n+            // No need for a CAS since a write lock is exclusive\n+            ctx.value.s.markAsDeleted();\n+            // delete the value in the entry happens next and the slice will be released as part of it\n+            // slice can be released only after the entry is marked appropriately\n+            return ctx.result.withValue(v);\n+        }\n+    }\n \n     /**\n      * Replaces the value written in the Slice referenced by {@code ctx} with {@code value}.\n@@ -80,8 +182,25 @@\n      * Along side the flag of the result, in case the exchange succeeded, it also returns the value that\n      * was written before the exchange.\n      */\n-    <V> Result exchange(Chunk<?, V> chunk, ThreadContext ctx, V value, OakTransformer<V> valueDeserializeTransformer,\n-        OakSerializer<V> serializer, InternalOakMap internalOakMap);\n+    <V> Result exchange(\n+        Chunk<?, V> chunk, ThreadContext ctx, V value, OakTransformer<V> valueDeserializeTransformer,\n+        OakSerializer<V> serializer, InternalOakMap internalOakMap) {\n+\n+        ValueResult result = ctx.value.s.lockWrite();\n+        if (result != ValueResult.TRUE) {\n+            return ctx.result.withFlag(result);\n+        }\n+        V oldValue = null;\n+        if (valueDeserializeTransformer != null) {\n+            oldValue = valueDeserializeTransformer.apply(ctx.value);\n+        }\n+        result = innerPut(chunk, ctx, value, serializer, internalOakMap);\n+        // in case move happened: ctx.value might be set to a new slice.\n+        // Alternatively, if returned result is RETRY, a rebalance might be needed\n+        // or the entry might be updated by someone else, need to retry\n+        ctx.value.s.unlockWrite();\n+        return result == ValueResult.TRUE ? ctx.result.withValue(oldValue) : ctx.result.withFlag(ValueResult.RETRY);\n+    }\n \n     /**\n      * @param expected       the old value to which we compare the current value\n@@ -92,6 +211,25 @@\n      * {@code RETRY} for the same reasons as exchange\n      * @see #exchange(Chunk, ThreadContext, Object, OakTransformer, OakSerializer, InternalOakMap)\n      */\n-    <V> ValueResult compareExchange(Chunk<?, V> chunk, ThreadContext ctx, V expected, V value,\n-        OakTransformer<V> valueDeserializeTransformer, OakSerializer<V> serializer, InternalOakMap internalOakMap);\n+    <V> ValueResult compareExchange(\n+        Chunk<?, V> chunk, ThreadContext ctx, V expected, V value,\n+        OakTransformer<V> valueDeserializeTransformer, OakSerializer<V> serializer,\n+        InternalOakMap internalOakMap) {\n+\n+        ValueResult result = ctx.value.s.lockWrite();\n+        if (result != ValueResult.TRUE) {\n+            return result;\n+        }\n+        V oldValue = valueDeserializeTransformer.apply(ctx.value);\n+        if (!oldValue.equals(expected)) {\n+            ctx.value.s.unlockWrite();\n+            return ValueResult.FALSE;\n+        }\n+        result = innerPut(chunk, ctx, value, serializer, internalOakMap);\n+        // in case move happened: ctx.value might be set to a new allocation.\n+        // Alternatively, if returned result is RETRY, a rebalance might be needed\n+        // or the entry might be updated by someone else, need to retry\n+        ctx.value.s.unlockWrite();\n+        return result;\n+    }\n }"
  },
  {
    "sha": "dd437ee90a41cb7720e77a4d9b00a9aeb2254424",
    "filename": "core/src/main/java/com/yahoo/oak/ValueUtilsImpl.java",
    "status": "removed",
    "additions": 0,
    "deletions": 167,
    "changes": 167,
    "blob_url": "https://github.com/yahoo/Oak/blob/60fa7ce6020eebcb2eeddbbe6b4ccc2fbbb9881f/core/src/main/java/com/yahoo/oak/ValueUtilsImpl.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/60fa7ce6020eebcb2eeddbbe6b4ccc2fbbb9881f/core/src/main/java/com/yahoo/oak/ValueUtilsImpl.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/main/java/com/yahoo/oak/ValueUtilsImpl.java?ref=60fa7ce6020eebcb2eeddbbe6b4ccc2fbbb9881f",
    "patch": "@@ -1,167 +0,0 @@\n-/*\n- * Copyright 2020, Verizon Media.\n- * Licensed under the terms of the Apache 2.0 license.\n- * Please see LICENSE file in the project root for terms.\n- */\n-\n-package com.yahoo.oak;\n-\n-import java.util.function.Consumer;\n-\n-class ValueUtilsImpl implements ValueUtils {\n-\n-    /*-----------------------------------------------------------------------*/\n-    @Override\n-    public <T> Result transform(Result result, ValueBuffer value, OakTransformer<T> transformer) {\n-        ValueResult ret = value.s.lockRead();\n-        if (ret != ValueResult.TRUE) {\n-            return result.withFlag(ret);\n-        }\n-\n-        try {\n-            T transformation = transformer.apply(value);\n-            return result.withValue(transformation);\n-        } finally {\n-            value.s.unlockRead();\n-        }\n-    }\n-\n-    @Override\n-    public <V> ValueResult put(Chunk<?, V> chunk, ThreadContext ctx, V newVal, OakSerializer<V> serializer,\n-        InternalOakMap internalOakMap) {\n-        ValueResult result = ctx.value.s.lockWrite();\n-        if (result != ValueResult.TRUE) {\n-            return result;\n-        }\n-        result = innerPut(chunk, ctx, newVal, serializer, internalOakMap);\n-        // in case move happened: ctx.valueSlice might be set to a new slice.\n-        // Alternatively, if returned result is RETRY, a rebalance might be needed\n-        // or the entry might be updated by someone else, need to retry\n-        ctx.value.s.unlockWrite();\n-        return result;\n-    }\n-\n-    private <V> ValueResult innerPut(Chunk<?, V> chunk, ThreadContext ctx, V newVal, OakSerializer<V> serializer,\n-        InternalOakMap internalOakMap) {\n-        int capacity = serializer.calculateSize(newVal);\n-        if (capacity > ctx.value.getLength()) {\n-            return moveValue(chunk, ctx, internalOakMap, newVal);\n-        }\n-        ScopedWriteBuffer.serialize(ctx.value.s, newVal, serializer);\n-        return ValueResult.TRUE;\n-    }\n-\n-    private <V> ValueResult moveValue(\n-        Chunk<?, V> chunk, ThreadContext ctx, InternalOakMap internalOakMap, V newVal) {\n-\n-        boolean moved = internalOakMap.overwriteExistingValueForMove(ctx, newVal, chunk);\n-        if (!moved) {\n-            // rebalance was needed or the entry was updated by someone else, need to retry\n-            return ValueResult.RETRY;\n-        }\n-        // The value was moved, the header of the old slice needs to me marked as moved\n-        // Couldn't release the write lock on the old slice or mark it as moved, before the new one is updated!\n-        // Marking the old slide as moved now, the write lock is still held\n-        ctx.value.s.markAsMoved();\n-        // currently the slices which value was moved aren't going to be released, to keep the MOVED mark\n-        // They need to be released when the target slice is released (moved to free list)\n-        // TODO: deal with the reallocation of the moved memory\n-\n-        ctx.value.copyFrom(ctx.newValue);\n-        return ValueResult.TRUE;\n-    }\n-\n-    @Override\n-    public ValueResult compute(ValueBuffer value, Consumer<OakScopedWriteBuffer> computer) {\n-        ValueResult result = value.s.lockWrite();\n-        if (result != ValueResult.TRUE) {\n-            return result;\n-        }\n-\n-        try {\n-            ScopedWriteBuffer.compute(value.s, computer);\n-        } finally {\n-            value.s.unlockWrite();\n-        }\n-\n-        return ValueResult.TRUE;\n-    }\n-\n-    @Override\n-    public <V> Result remove(ThreadContext ctx, V oldValue, OakTransformer<V> transformer) {\n-        // Not a conditional remove, so we can delete immediately\n-        if (oldValue == null) {\n-            // try to delete\n-            ValueResult result = ctx.value.s.logicalDelete();\n-            if (result != ValueResult.TRUE) {\n-                return ctx.result.withFlag(result);\n-            }\n-            // Now the value is deleted, and all other threads will treat it as deleted,\n-            // but it is not yet freed, so this thread can read from it.\n-            // read the old value (the slice is not reclaimed yet)\n-            V v = transformer != null ? transformer.apply(ctx.value) : null;\n-            // return TRUE with the old value\n-            return ctx.result.withValue(v);\n-        } else {\n-            // This is a conditional remove, so we first have to check whether the current value matches the expected\n-            // one.\n-            // We start by acquiring a write lock for reading since we do not want concurrent reads.\n-            ValueResult result = ctx.value.s.lockWrite();\n-            if (result != ValueResult.TRUE) {\n-                return ctx.result.withFlag(result);\n-            }\n-            V v = transformer.apply(ctx.value);\n-            // This is where we check the equality between the expected value and the actual value\n-            if (!oldValue.equals(v)) {\n-                ctx.value.s.unlockWrite();\n-                return ctx.result.withFlag(ValueResult.FALSE);\n-            }\n-            // both values match so the value is marked as deleted.\n-            // No need for a CAS since a write lock is exclusive\n-            ctx.value.s.markAsDeleted();\n-            // delete the value in the entry happens next and the slice will be released as part of it\n-            // slice can be released only after the entry is marked appropriately\n-            return ctx.result.withValue(v);\n-        }\n-    }\n-\n-    @Override\n-    public <V> Result exchange(Chunk<?, V> chunk, ThreadContext ctx, V value,\n-        OakTransformer<V> valueDeserializeTransformer, OakSerializer<V> serializer,\n-        InternalOakMap internalOakMap) {\n-        ValueResult result = ctx.value.s.lockWrite();\n-        if (result != ValueResult.TRUE) {\n-            return ctx.result.withFlag(result);\n-        }\n-        V oldValue = null;\n-        if (valueDeserializeTransformer != null) {\n-            oldValue = valueDeserializeTransformer.apply(ctx.value);\n-        }\n-        result = innerPut(chunk, ctx, value, serializer, internalOakMap);\n-        // in case move happened: ctx.value might be set to a new slice.\n-        // Alternatively, if returned result is RETRY, a rebalance might be needed\n-        // or the entry might be updated by someone else, need to retry\n-        ctx.value.s.unlockWrite();\n-        return result == ValueResult.TRUE ? ctx.result.withValue(oldValue) : ctx.result.withFlag(ValueResult.RETRY);\n-    }\n-\n-    @Override\n-    public <V> ValueResult compareExchange(Chunk<?, V> chunk, ThreadContext ctx, V expected, V value,\n-        OakTransformer<V> valueDeserializeTransformer, OakSerializer<V> serializer, InternalOakMap internalOakMap) {\n-        ValueResult result = ctx.value.s.lockWrite();\n-        if (result != ValueResult.TRUE) {\n-            return result;\n-        }\n-        V oldValue = valueDeserializeTransformer.apply(ctx.value);\n-        if (!oldValue.equals(expected)) {\n-            ctx.value.s.unlockWrite();\n-            return ValueResult.FALSE;\n-        }\n-        result = innerPut(chunk, ctx, value, serializer, internalOakMap);\n-        // in case move happened: ctx.value might be set to a new allocation.\n-        // Alternatively, if returned result is RETRY, a rebalance might be needed\n-        // or the entry might be updated by someone else, need to retry\n-        ctx.value.s.unlockWrite();\n-        return result;\n-    }\n-}"
  },
  {
    "sha": "0f7f5b3e6a2fe8da72520a0148d7688ab9e44bef",
    "filename": "core/src/test/java/com/yahoo/oak/InternalOakMapTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/InternalOakMapTest.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/InternalOakMapTest.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/test/java/com/yahoo/oak/InternalOakMapTest.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -30,7 +30,7 @@ public void setUp() {\n \n         testMap = new InternalOakMap<>(Integer.MIN_VALUE, OakCommonBuildersFactory.DEFAULT_INT_SERIALIZER,\n                 OakCommonBuildersFactory.DEFAULT_INT_SERIALIZER, OakCommonBuildersFactory.DEFAULT_INT_COMPARATOR,\n-                memoryManager, seqExpandMemoryManager, chunkMaxItems, new ValueUtilsImpl());\n+                memoryManager, seqExpandMemoryManager, chunkMaxItems, new ValueUtils());\n     }\n \n "
  },
  {
    "sha": "e51b914ec7802bc61ca260f92f172afd9c44330c",
    "filename": "core/src/test/java/com/yahoo/oak/NativeMemoryAllocatorTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/NativeMemoryAllocatorTest.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/NativeMemoryAllocatorTest.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/test/java/com/yahoo/oak/NativeMemoryAllocatorTest.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -34,7 +34,7 @@ static int calcExpectedSize(int keyCount, int valueCount) {\n     private static final MemoryManager VALUE_MEMORY_MANAGER = new SyncRecycleMemoryManager(null);\n \n     Slice allocate(NativeMemoryAllocator allocator, int size) {\n-        Slice s = new Slice();\n+        Slice s = new SliceSyncRecycle();\n         allocator.allocate(s, size);\n         return s;\n     }\n@@ -289,7 +289,7 @@ public void checkFreelistOrdering() {\n         int[] sizes = new int[]{4, 16, 8, 32};\n         List<Slice> allocated = Arrays.stream(sizes)\n                 .mapToObj(curSize -> {\n-                    Slice s = new Slice();\n+                    Slice s = new SliceSyncRecycle();\n                     allocator.allocate(s, curSize);\n                     return s;\n                 }).collect(Collectors.toList());"
  },
  {
    "sha": "5a12032c05f23a0eea1bf0a40a36af59d65d5c17",
    "filename": "core/src/test/java/com/yahoo/oak/SeqExpandMemoryManagerTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/SeqExpandMemoryManagerTest.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/SeqExpandMemoryManagerTest.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/test/java/com/yahoo/oak/SeqExpandMemoryManagerTest.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -24,7 +24,7 @@ public void setUp() {\n \n     @Test\n     public void allocate() {\n-        Slice s = new Slice();\n+        Slice s = new SliceSeqExpand();\n         ByteBuffer bb;\n \n         seqExpandMemoryManager.allocate(s, 4, false);"
  },
  {
    "sha": "9832b8d6c6e7dc64ec5e4594ad00ca66e48a3bee",
    "filename": "core/src/test/java/com/yahoo/oak/ValueUtilsTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/yahoo/Oak/blob/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/ValueUtilsTest.java",
    "raw_url": "https://github.com/yahoo/Oak/raw/ff011e6a2ade0c1ad7ea003df78bc2b83817d72b/core/src/test/java/com/yahoo/oak/ValueUtilsTest.java",
    "contents_url": "https://api.github.com/repos/yahoo/Oak/contents/core/src/test/java/com/yahoo/oak/ValueUtilsTest.java?ref=ff011e6a2ade0c1ad7ea003df78bc2b83817d72b",
    "patch": "@@ -17,7 +17,7 @@\n public class ValueUtilsTest {\n     private SyncRecycleMemoryManager valuesMemoryManager;\n     private SeqExpandMemoryManager keysMemoryManager;\n-    private final ValueUtils valueOperator = new ValueUtilsImpl();\n+    private final ValueUtils valueOperator = new ValueUtils();\n     private ThreadContext ctx;\n     private ValueBuffer s;\n "
  }
]
