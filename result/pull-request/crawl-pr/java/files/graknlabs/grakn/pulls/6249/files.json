[
  {
    "sha": "6a011c590953e06e314489f7381f1b2ec3de2ae6",
    "filename": "concept/BUILD",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/concept/BUILD",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/concept/BUILD",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/concept/BUILD?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -50,6 +50,7 @@ native_java_libraries(\n         \"@maven//:com_google_code_findbugs_jsr305\",\n     ],\n     native_libraries_deps = [\n+        \"//pattern:pattern\", # TODO review this is ok\n         \"//traversal:traversal\",\n     ],\n     tags = [\"maven_coordinates=io.grakn.core:grakn-concept:{pom_version}\"],"
  },
  {
    "sha": "2db6ce7cfc97310af75264eeba7805064455017c",
    "filename": "concept/answer/ConceptMap.java",
    "status": "modified",
    "additions": 59,
    "deletions": 3,
    "changes": 62,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/concept/answer/ConceptMap.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/concept/answer/ConceptMap.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/concept/answer/ConceptMap.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -25,14 +25,17 @@\n import grakn.core.concept.Concept;\n import grakn.core.concept.thing.Thing;\n import grakn.core.concept.type.Type;\n+import grakn.core.pattern.Conjunction;\n import grakn.core.traversal.common.Identifier;\n import grakn.core.traversal.common.Identifier.Variable.Retrievable;\n import graql.lang.pattern.variable.Reference;\n import graql.lang.pattern.variable.UnboundVariable;\n \n+import javax.annotation.Nullable;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.Optional;\n import java.util.Set;\n import java.util.function.BiConsumer;\n import java.util.function.Function;\n@@ -45,15 +48,21 @@\n public class ConceptMap implements Answer {\n \n     private final Map<Retrievable, ? extends Concept> concepts;\n+    private final Set<Explainable> explainables;\n     private final int hash;\n \n     public ConceptMap() {\n         this(new HashMap<>());\n     }\n \n     public ConceptMap(Map<Retrievable, ? extends Concept> concepts) {\n+        this(concepts, null);\n+    }\n+\n+    public ConceptMap(Map<Retrievable, ? extends Concept> concepts, @Nullable Set<Explainable> explainables) {\n         this.concepts = concepts;\n-        this.hash = Objects.hash(this.concepts);\n+        this.explainables = explainables;\n+        this.hash = Objects.hash(this.concepts, this.explainables);\n     }\n \n     public FunctionalIterator<Pair<Retrievable, Concept>> iterator() {\n@@ -95,7 +104,7 @@ public ConceptMap filter(Set<? extends Retrievable> vars) {\n         Map<Retrievable, ? extends Concept> filtered = concepts.entrySet().stream()\n                 .filter(e -> vars.contains(e.getKey()))\n                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return new ConceptMap(filtered);\n+        return new ConceptMap(filtered, null);\n     }\n \n     public void forEach(BiConsumer<Retrievable, Concept> consumer) {\n@@ -116,6 +125,10 @@ public void forEach(BiConsumer<Retrievable, Concept> consumer) {\n         return map;\n     }\n \n+    public Optional<Set<Explainable>> explainables() {\n+        return Optional.ofNullable(explainables);\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConceptMap{\" + concepts + '}';\n@@ -126,11 +139,54 @@ public boolean equals(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n         ConceptMap that = (ConceptMap) o;\n-        return concepts.equals(that.concepts);\n+        return concepts.equals(that.concepts) && Objects.equals(explainables, that.explainables);\n     }\n \n     @Override\n     public int hashCode() {\n         return hash;\n     }\n+\n+    public static class Explainable {\n+\n+        public static long NOT_IDENTIFIED = -1L;\n+\n+        private final Conjunction conjunction;\n+        private long explainableId;\n+\n+        private Explainable(Conjunction conjunction, long explainableId) {\n+            this.conjunction = conjunction;\n+            this.explainableId = explainableId;\n+        }\n+\n+        public static Explainable unidentified(Conjunction conjunction) {\n+            return new Explainable(conjunction, NOT_IDENTIFIED);\n+        }\n+\n+        public void setId(long explainableId) {\n+            this.explainableId = explainableId;\n+        }\n+\n+        public Conjunction conjunction() {\n+            return conjunction;\n+        }\n+\n+        public long explainableId() {\n+            return explainableId;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Explainable that = (Explainable) o;\n+            return Objects.equals(conjunction, that.conjunction); // exclude ID as it changes\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(conjunction); // exclude ID as it changes\n+        }\n+    }\n+\n }"
  },
  {
    "sha": "55906e80596b4087480986020dd69e6d2767d50e",
    "filename": "concept/thing/Thing.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/concept/thing/Thing.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/concept/thing/Thing.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/concept/thing/Thing.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -116,6 +116,13 @@\n      */\n     Stream<? extends Attribute> getHas(AttributeType... attributeType);\n \n+    /**\n+     *\n+     * @param attribute\n+     * @return\n+     */\n+    boolean isHasInferred(Attribute attribute);\n+\n     /**\n      * Get all {@code RoleType} types that this {@code Thing} plays in a {@code Relation}.\n      *\n@@ -152,4 +159,5 @@\n      * Validates and throws an exception if there is any violation.\n      */\n     void validate();\n+\n }"
  },
  {
    "sha": "2c8f7f9532c632c0088981c00e04eef96be4789c",
    "filename": "concept/thing/impl/ThingImpl.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/concept/thing/impl/ThingImpl.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/concept/thing/impl/ThingImpl.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/concept/thing/impl/ThingImpl.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -32,6 +32,7 @@\n import grakn.core.graph.iid.PrefixIID;\n import grakn.core.graph.vertex.AttributeVertex;\n import grakn.core.graph.vertex.ThingVertex;\n+import grakn.core.graph.vertex.impl.ThingVertexImpl;\n \n import java.util.Arrays;\n import java.util.List;\n@@ -176,6 +177,11 @@ public void unsetHas(Attribute attribute) {\n         }\n     }\n \n+    @Override\n+    public boolean isHasInferred(Attribute attribute) {\n+        return vertex.outs().edge(HAS, ((ThingImpl) attribute).vertex).isInferred();\n+    }\n+\n     @Override\n     public Stream<? extends RoleType> getPlays() {\n         return vertex.outs().edge(PLAYING).to().map(ThingVertex::type).map(v -> RoleTypeImpl.of(vertex.graphs(), v)).stream();"
  },
  {
    "sha": "5484948707d415c4b69eb6c2ba386a47d5ebb90b",
    "filename": "logic/Rule.java",
    "status": "modified",
    "additions": 41,
    "deletions": 4,
    "changes": 45,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/logic/Rule.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/logic/Rule.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/logic/Rule.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -56,6 +56,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n \n@@ -93,8 +94,8 @@\n \n     private Rule(LogicManager logicMgr, RuleStructure structure) {\n         this.structure = structure;\n-        this.when = whenPattern(structure.when(), logicMgr);\n         this.then = thenPattern(structure.then(), logicMgr);\n+        this.when = whenPattern(structure.when(), structure.then(), logicMgr);\n         pruneThenResolvedTypes();\n         this.conclusion = Conclusion.create(this);\n         this.condition = Condition.create(this);\n@@ -103,8 +104,8 @@ private Rule(LogicManager logicMgr, RuleStructure structure) {\n     private Rule(GraphManager graphMgr, LogicManager logicMgr, String label,\n                  graql.lang.pattern.Conjunction<? extends Pattern> when, graql.lang.pattern.variable.ThingVariable<?> then) {\n         this.structure = graphMgr.schema().rules().create(label, when, then);\n-        this.when = whenPattern(structure.when(), logicMgr);\n         this.then = thenPattern(structure.then(), logicMgr);\n+        this.when = whenPattern(structure.when(), structure.then(), logicMgr);\n         pruneThenResolvedTypes();\n         validateSatisfiable();\n         validateInsertable(logicMgr);\n@@ -204,8 +205,9 @@ private void pruneThenResolvedTypes() {\n                 });\n     }\n \n-    private Conjunction whenPattern(graql.lang.pattern.Conjunction<? extends Pattern> conjunction, LogicManager logicMgr) {\n-        Disjunction when = Disjunction.create(conjunction.normalise());\n+    private Conjunction whenPattern(graql.lang.pattern.Conjunction<? extends Pattern> conjunction,\n+                                    graql.lang.pattern.variable.ThingVariable<?> then, LogicManager logicMgr) {\n+        Disjunction when = Disjunction.create(conjunction.normalise(), VariableRegistry.createFromThings(list(then)));\n         assert when.conjunctions().size() == 1;\n \n         if (iterate(when.conjunctions().get(0).negations()).filter(neg -> neg.disjunction().conjunctions().size() != 1).hasNext()) {\n@@ -287,6 +289,23 @@ public Rule rule() {\n                     });\n         }\n \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Condition that = (Condition) o;\n+            return Objects.equals(rule, that.rule);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return rule.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Rule[\" + rule.getLabel() + \"] Condition \" + rule.when;\n+        }\n     }\n \n     public static abstract class Conclusion {\n@@ -392,6 +411,24 @@ public Value asValue() {\n             ValueConstraint<?> value();\n         }\n \n+        @Override\n+        public String toString() {\n+            return \"Rule[\" + rule.getLabel() + \"] Conclusion \" + rule.then;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            final Conclusion that = (Conclusion) o;\n+            return Objects.equals(rule, that.rule);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return rule.hashCode();\n+        }\n+\n         public static class Relation extends Conclusion implements Isa {\n \n             private final RelationConstraint relation;"
  },
  {
    "sha": "95d601fe2685550b0914e32c2773fa13720d1368",
    "filename": "logic/resolvable/Concludable.java",
    "status": "modified",
    "additions": 29,
    "deletions": 0,
    "changes": 29,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/logic/resolvable/Concludable.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/logic/resolvable/Concludable.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/logic/resolvable/Concludable.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -21,7 +21,11 @@\n import grakn.core.common.iterator.FunctionalIterator;\n import grakn.core.common.iterator.Iterators;\n import grakn.core.common.parameters.Label;\n+import grakn.core.concept.Concept;\n import grakn.core.concept.ConceptManager;\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.concept.thing.Attribute;\n+import grakn.core.concept.thing.Thing;\n import grakn.core.concept.type.RoleType;\n import grakn.core.concept.type.Type;\n import grakn.core.graph.common.Encoding;\n@@ -120,6 +124,8 @@ public Concludable asConcludable() {\n \n     abstract FunctionalIterator<Unifier> unify(Rule.Conclusion conclusion, ConceptManager conceptMgr);\n \n+    public abstract boolean isInferredAnswer(ConceptMap conceptMap);\n+\n     public abstract AlphaEquivalence alphaEquals(Concludable that);\n \n     public boolean isRelation() { return false; }\n@@ -271,6 +277,7 @@ protected void addConstantValueRequirements(Unifier.Builder unifierBuilder, Set<\n         }\n     }\n \n+\n     /**\n      * Relation handles these concludable patterns, where `$role` and `$relation` could be labelled, and there could\n      * be any number of rolePlayers:\n@@ -327,6 +334,11 @@ public RelationConstraint relation() {\n             return Iterators.empty();\n         }\n \n+        @Override\n+        public boolean isInferredAnswer(ConceptMap conceptMap) {\n+            return conceptMap.get(generating().get().id()).asThing().isInferred();\n+        }\n+\n         public FunctionalIterator<Unifier> unify(Rule.Conclusion.Relation relationConclusion, ConceptManager conceptMgr) {\n             if (this.relation().players().size() > relationConclusion.relation().players().size())\n                 return Iterators.empty();\n@@ -509,6 +521,13 @@ public HasConstraint has() {\n             return Iterators.empty();\n         }\n \n+        @Override\n+        public boolean isInferredAnswer(ConceptMap conceptMap) {\n+            Thing owner = conceptMap.get(has.owner().id()).asThing();\n+            grakn.core.concept.thing.Attribute attribute = conceptMap.get(has.attribute().id()).asAttribute();\n+            return owner.isHasInferred(attribute);\n+        }\n+\n         public FunctionalIterator<Unifier> unify(Rule.Conclusion.Has hasConclusion, ConceptManager conceptMgr) {\n             Unifier.Builder unifierBuilder = Unifier.builder();\n             if (unificationSatisfiable(has().owner(), hasConclusion.has().owner())) {\n@@ -623,6 +642,11 @@ public IsaConstraint isa() {\n             return Iterators.empty();\n         }\n \n+        @Override\n+        public boolean isInferredAnswer(ConceptMap conceptMap) {\n+            return conceptMap.get(generating().get().id()).asThing().isInferred();\n+        }\n+\n         FunctionalIterator<Unifier> unify(Rule.Conclusion.Isa isa, ConceptManager conceptMgr) {\n             Unifier.Builder unifierBuilder = Unifier.builder();\n             if (unificationSatisfiable(isa().owner(), isa.isa().owner())) {\n@@ -734,6 +758,11 @@ public static Attribute of(ThingVariable attribute, Set<ValueConstraint<?>> valu\n             return Iterators.empty();\n         }\n \n+        @Override\n+        public boolean isInferredAnswer(ConceptMap conceptMap) {\n+            return conceptMap.get(generating().get().id()).asThing().isInferred();\n+        }\n+\n         FunctionalIterator<Unifier> unify(Rule.Conclusion.Value value) {\n             assert iterate(values).filter(ValueConstraint::isVariable).toSet().size() == 0;\n             Unifier.Builder unifierBuilder = Unifier.builder();"
  },
  {
    "sha": "7eab62525a3c9cf88530743baa1ca52bab36a312",
    "filename": "logic/resolvable/Unifier.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/logic/resolvable/Unifier.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/logic/resolvable/Unifier.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/logic/resolvable/Unifier.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -307,6 +307,8 @@ private Constraint duplicate() {\n             }\n         }\n \n+        // TODO we only need this for Type variables with their labels (labeled vars)\n+        // because we can now do\n         public static class Instance {\n \n             Map<Retrievable, ? extends Concept> requireCompatible;"
  },
  {
    "sha": "1835fd2dd5b806eb2e20ea528631ce18da4c3535",
    "filename": "pattern/variable/Variable.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/pattern/variable/Variable.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/pattern/variable/Variable.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/pattern/variable/Variable.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -98,7 +98,7 @@ public void retainResolvedTypes(Set<Label> labels) {\n \n     @Override\n     public String toString() {\n-        return reference().toString();\n+        return identifier.toString();\n     }\n \n     @Override"
  },
  {
    "sha": "0dbebd8d2467114576d52feaebee5ba1ef0272e6",
    "filename": "query/BUILD",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/query/BUILD",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/query/BUILD",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/query/BUILD?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -40,6 +40,7 @@ native_java_libraries(\n         \"@graknlabs_common//:common\",\n         \"@graknlabs_grabl_tracing//client:client\",\n         \"@graknlabs_graql//java/common:common\",\n+        \"@graknlabs_graql//java:graql\",\n         \"@graknlabs_graql//java/pattern:pattern\",\n         \"@graknlabs_graql//java/query:query\",\n "
  },
  {
    "sha": "1591381ca65dba989f0a0d4a9e5ea7d16232be2d",
    "filename": "query/QueryManager.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/query/QueryManager.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/query/QueryManager.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/query/QueryManager.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -28,7 +28,11 @@\n import grakn.core.concept.answer.Numeric;\n import grakn.core.concept.answer.NumericGroup;\n import grakn.core.logic.LogicManager;\n+import grakn.core.pattern.Conjunction;\n import grakn.core.reasoner.Reasoner;\n+import grakn.core.reasoner.resolution.answer.Explanation;\n+import graql.lang.Graql;\n+import graql.lang.pattern.Conjunctable;\n import graql.lang.query.GraqlDefine;\n import graql.lang.query.GraqlDelete;\n import graql.lang.query.GraqlInsert;\n@@ -74,6 +78,10 @@ public QueryManager(ConceptManager conceptMgr, LogicManager logicMgr, Reasoner r\n         }\n     }\n \n+    public FunctionalIterator<Explanation> explain(long explainableId, ConceptMap bounds) {\n+        return reasoner.explain(explainableId, bounds, defaultContext);\n+    }\n+\n     public Numeric match(GraqlMatch.Aggregate query) {\n         return match(query, defaultContext);\n     }"
  },
  {
    "sha": "82a2a18fa3a41a79779a99690b1d9f4696bc41c2",
    "filename": "reasoner/ExplanationProducer.java",
    "status": "added",
    "additions": 149,
    "deletions": 0,
    "changes": 149,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/ExplanationProducer.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/ExplanationProducer.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/ExplanationProducer.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner;\n+\n+import grakn.core.common.parameters.Options;\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.concurrent.actor.Actor;\n+import grakn.core.concurrent.common.Executors;\n+import grakn.core.concurrent.producer.Producer;\n+import grakn.core.pattern.Conjunction;\n+import grakn.core.reasoner.resolution.ResolverRegistry;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Compound.Root;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Top.Explain;\n+import grakn.core.reasoner.resolution.answer.AnswerStateImpl;\n+import grakn.core.reasoner.resolution.answer.Explanation;\n+import grakn.core.reasoner.resolution.framework.Request;\n+import grakn.core.reasoner.resolution.framework.ResolutionTracer;\n+import grakn.core.reasoner.resolution.resolver.RootResolver;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class ExplanationProducer implements Producer<Explanation> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ExplanationProducer.class);\n+\n+    private final Explanations explanations;\n+    private final Options.Query options;\n+    private final Actor.Driver<RootResolver.Explain> explainer;\n+    private final Request explainRequest;\n+    private final int computeSize;\n+    private final AtomicInteger required;\n+    private final AtomicInteger processing;\n+    private int iteration;\n+    private boolean requiresReiteration;\n+    private boolean done;\n+\n+    private Queue<Explanation> queue;\n+\n+    public ExplanationProducer(Conjunction conjunction, ConceptMap bounds, Options.Query options,\n+                               ResolverRegistry registry, Explanations explanations) {\n+        this.explanations = explanations;\n+        this.options = options;\n+        this.queue = null;\n+        this.iteration = 0;\n+        this.requiresReiteration = false;\n+        this.done = false;\n+        this.required = new AtomicInteger();\n+        this.processing = new AtomicInteger();\n+        this.computeSize = options.parallel() ? Executors.PARALLELISATION_FACTOR : 1;\n+        this.explainer = registry.explainer(conjunction, this::requestAnswered, this::requestFailed, this::exception);\n+        Root.Explain downstream = new AnswerStateImpl.TopImpl.ExplainImpl.InitialImpl(bounds, explainer, false).toDownstream();\n+        this.explainRequest = Request.create(explainer, downstream);\n+        if (options.traceInference()) ResolutionTracer.initialise(options.logsDir());\n+    }\n+\n+    @Override\n+    public synchronized void produce(Queue<Explanation> queue, int request, ExecutorService executor) {\n+        assert this.queue == null || this.queue == queue;\n+        this.queue = queue;\n+        this.required.addAndGet(request);\n+        int canRequest = computeSize - processing.get();\n+        int toRequest = Math.min(canRequest, request);\n+        for (int i = 0; i < toRequest; i++) {\n+            requestExplanation();\n+        }\n+        processing.addAndGet(toRequest);\n+    }\n+\n+    private void requestExplanation() {\n+        if (options.traceInference()) ResolutionTracer.get().start();\n+        explainer.execute(explainer -> explainer.receiveRequest(explainRequest, iteration));\n+    }\n+\n+    // note: root resolver calls this single-threaded, so is threads safe\n+    private void requestAnswered(Explain.Finished explainedAnswer) {\n+        if (options.traceInference()) ResolutionTracer.get().finish();\n+        if (explainedAnswer.requiresReiteration()) requiresReiteration = true;\n+        Explanation explanation = explainedAnswer.explanation();\n+        explanations.setAndRecordExplainableIds(explanation.conditionAnswer());\n+        queue.put(explanation);\n+        if (required.decrementAndGet() > 0) requestExplanation();\n+        else processing.decrementAndGet();\n+    }\n+\n+    // note: root resolver calls this single-threaded, so is threads safe\n+    private void requestFailed(int iteration) {\n+        LOG.trace(\"Failed to find answer to request in iteration: \" + iteration);\n+        if (options.traceInference()) ResolutionTracer.get().finish();\n+        if (!done && iteration == this.iteration && !mustReiterate()) {\n+            // query is completely terminated\n+            done = true;\n+            queue.done();\n+            required.set(0);\n+            return;\n+        }\n+\n+        if (!done) {\n+            if (iteration == this.iteration) prepareNextIteration();\n+            assert iteration < this.iteration;\n+            retryInNewIteration();\n+        }\n+    }\n+\n+    private boolean mustReiterate() {\n+        return  requiresReiteration;\n+    }\n+\n+    private void prepareNextIteration() {\n+        iteration++;\n+        requiresReiteration = false;\n+    }\n+\n+    private void retryInNewIteration() {\n+        requestExplanation();\n+    }\n+\n+    private void exception(Throwable e) {\n+        if (options.traceInference()) ResolutionTracer.get().finish();\n+        if (!done) {\n+            done = true;\n+            required.set(0);\n+            queue.done(e);\n+        }\n+    }\n+\n+\n+    @Override\n+    public void recycle() {\n+\n+    }\n+}"
  },
  {
    "sha": "60804689a7479b25ac1853b270a0a4f831df51c9",
    "filename": "reasoner/Explanations.java",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/Explanations.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/Explanations.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/Explanations.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner;\n+\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.pattern.Conjunction;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static grakn.core.concept.answer.ConceptMap.Explainable.NOT_IDENTIFIED;\n+\n+public class Explanations {\n+\n+    private AtomicLong explainableId;\n+    private ConcurrentMap<Long, ConceptMap.Explainable> explainableRegistry;\n+\n+    public Explanations() {\n+        this.explainableId = new AtomicLong(NOT_IDENTIFIED + 1);\n+        this.explainableRegistry = new ConcurrentHashMap<>();\n+    }\n+\n+    public void setAndRecordExplainableIds(ConceptMap explainableAnswer) {\n+        assert explainableAnswer.explainables().isPresent();\n+        explainableAnswer.explainables().get().forEach(explainable -> {\n+            long nextId = explainableId.getAndIncrement();\n+            explainable.setId(nextId);\n+            explainableRegistry.put(nextId, explainable);\n+        });\n+    }\n+\n+    public Conjunction getExplainableConjunction(long explainableId) {\n+        return explainableRegistry.get(explainableId).conjunction();\n+    }\n+}"
  },
  {
    "sha": "752755cb732e237f42e815deeeb909795d1ff6d6",
    "filename": "reasoner/Reasoner.java",
    "status": "modified",
    "additions": 19,
    "deletions": 9,
    "changes": 28,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/Reasoner.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/Reasoner.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/Reasoner.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -22,22 +22,23 @@\n import grakn.core.common.exception.GraknException;\n import grakn.core.common.iterator.FunctionalIterator;\n import grakn.core.common.iterator.Iterators;\n+import grakn.core.common.parameters.Arguments;\n import grakn.core.common.parameters.Context;\n import grakn.core.common.parameters.Label;\n import grakn.core.common.parameters.Options;\n import grakn.core.concept.ConceptManager;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.concept.thing.Thing;\n import grakn.core.concept.type.Type;\n-import grakn.core.concurrent.actor.Actor;\n import grakn.core.concurrent.producer.Producer;\n+import grakn.core.concurrent.producer.Producers;\n import grakn.core.logic.LogicManager;\n import grakn.core.pattern.Conjunction;\n import grakn.core.pattern.Disjunction;\n import grakn.core.pattern.Negation;\n import grakn.core.pattern.variable.Variable;\n-import grakn.core.reasoner.resolution.ResolutionRecorder;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n+import grakn.core.reasoner.resolution.answer.Explanation;\n import grakn.core.traversal.TraversalEngine;\n import grakn.core.traversal.common.Identifier;\n import graql.lang.pattern.variable.UnboundVariable;\n@@ -49,23 +50,25 @@\n import java.util.List;\n import java.util.Set;\n \n+import static grakn.common.collection.Collections.list;\n import static grakn.common.collection.Collections.set;\n import static grakn.core.common.exception.ErrorMessage.Pattern.UNSATISFIABLE_PATTERN;\n import static grakn.core.common.iterator.Iterators.iterate;\n import static grakn.core.common.parameters.Arguments.Query.Producer.EXHAUSTIVE;\n import static grakn.core.concurrent.common.Executors.PARALLELISATION_FACTOR;\n-import static grakn.core.concurrent.common.Executors.async1;\n import static grakn.core.concurrent.common.Executors.actor;\n+import static grakn.core.concurrent.common.Executors.async1;\n import static grakn.core.concurrent.producer.Producers.produce;\n \n public class Reasoner {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(Reasoner.class);\n \n     private final TraversalEngine traversalEng;\n     private final ConceptManager conceptMgr;\n     private final LogicManager logicMgr;\n     private final ResolverRegistry resolverRegistry;\n-    private final Actor.Driver<ResolutionRecorder> resolutionRecorder; // for explanations\n+    private final Explanations explanations;\n     private final Context.Query defaultContext;\n \n     public Reasoner(ConceptManager conceptMgr, LogicManager logicMgr,\n@@ -75,9 +78,8 @@ public Reasoner(ConceptManager conceptMgr, LogicManager logicMgr,\n         this.logicMgr = logicMgr;\n         this.defaultContext = new Context.Query(context, new Options.Query());\n         this.defaultContext.producer(Either.first(EXHAUSTIVE));\n-        this.resolutionRecorder = Actor.driver(ResolutionRecorder::new, actor());\n-        this.resolverRegistry = new ResolverRegistry(actor(), resolutionRecorder, traversalEng, conceptMgr,\n-                                                     logicMgr, this.defaultContext.options().traceInference());\n+        this.resolverRegistry = new ResolverRegistry(actor(), traversalEng, conceptMgr, logicMgr, defaultContext.options().traceInference());\n+        this.explanations = new Explanations();\n     }\n \n     public ResolverRegistry resolverRegistry() {\n@@ -136,8 +138,8 @@ private boolean hasRule(Label type) {\n     private FunctionalIterator<ConceptMap> executeReasoner(Disjunction disjunction, GraqlMatch.Modifiers modifiers,\n                                                            Context.Query context) {\n         ReasonerProducer producer = disjunction.conjunctions().size() == 1\n-                ? new ReasonerProducer(disjunction.conjunctions().get(0), resolverRegistry, modifiers, context.options())\n-                : new ReasonerProducer(disjunction, resolverRegistry, modifiers, context.options());\n+                ? new ReasonerProducer(disjunction.conjunctions().get(0), modifiers, context.options(), resolverRegistry, explanations)\n+                : new ReasonerProducer(disjunction, modifiers, context.options(), resolverRegistry, explanations);\n         return produce(producer, context.producer(), async1());\n     }\n \n@@ -192,4 +194,12 @@ private Conjunction bound(Conjunction conjunction, ConceptMap bounds) {\n         return newClone;\n     }\n \n+    public FunctionalIterator<Explanation> explain(long explainableId, ConceptMap bounds, Context.Query defaultContext) {\n+        Conjunction explainableConjunction = explanations.getExplainableConjunction(explainableId);\n+        return Producers.produce(\n+                list(new ExplanationProducer(explainableConjunction, bounds, defaultContext.options(), resolverRegistry, explanations)),\n+                Either.first(Arguments.Query.Producer.INCREMENTAL),\n+                async1()\n+        );\n+    }\n }"
  },
  {
    "sha": "3745556813aba166ad789278d1af570babde8120",
    "filename": "reasoner/ReasonerProducer.java",
    "status": "modified",
    "additions": 33,
    "deletions": 27,
    "changes": 60,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/ReasonerProducer.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/ReasonerProducer.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/ReasonerProducer.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -17,7 +17,6 @@\n \n package grakn.core.reasoner;\n \n-import grakn.core.common.exception.GraknException;\n import grakn.core.common.parameters.Options;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.concurrent.actor.Actor;\n@@ -26,8 +25,9 @@\n import grakn.core.pattern.Conjunction;\n import grakn.core.pattern.Disjunction;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Identity;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Top;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Compound.Root;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Top.Match.Finished;\n+import grakn.core.reasoner.resolution.answer.AnswerStateImpl.TopImpl.MatchImpl.InitialImpl;\n import grakn.core.reasoner.resolution.framework.Request;\n import grakn.core.reasoner.resolution.framework.ResolutionTracer;\n import grakn.core.reasoner.resolution.framework.Resolver;\n@@ -43,7 +43,6 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.atomic.AtomicInteger;\n \n-import static grakn.core.common.exception.ErrorMessage.Reasoner.RESOLUTION_TERMINATED;\n import static grakn.core.common.iterator.Iterators.iterate;\n \n @ThreadSafe\n@@ -55,45 +54,47 @@\n     private final AtomicInteger required;\n     private final AtomicInteger processing;\n     private final Options.Query options;\n+    private final Explanations explanations;\n     private final Request resolveRequest;\n-    private final boolean recordExplanations = false; // TODO: make settable\n     private final int computeSize;\n     private boolean requiresReiteration;\n     private boolean done;\n     private int iteration;\n     private Queue<ConceptMap> queue;\n \n-    // TODO: this class should be be a Producer implement a different async processing mechanism\n-    public ReasonerProducer(Conjunction conjunction, ResolverRegistry resolverRegistry, GraqlMatch.Modifiers modifiers,\n-                            Options.Query options) {\n-        if (options.traceInference()) ResolutionTracer.initialise(options.logsDir());\n-        this.rootResolver = resolverRegistry.root(conjunction, this::requestAnswered, this::requestFailed, this::exception);\n+    // TODO: this class should not be a Producer, it implements a different async processing mechanism\n+    public ReasonerProducer(Conjunction conjunction, GraqlMatch.Modifiers modifiers, Options.Query options,\n+                            ResolverRegistry resolverRegistry, Explanations explanations) {\n         this.options = options;\n-        Identity downstream = Top.initial(filter(modifiers.filter()), recordExplanations, this.rootResolver).toDownstream();\n-        this.computeSize = options.parallel() ? Executors.PARALLELISATION_FACTOR * 2 : 1;\n-        assert computeSize > 0;\n-        this.resolveRequest = Request.create(rootResolver, downstream);\n+        this.explanations = explanations;\n         this.queue = null;\n         this.iteration = 0;\n         this.done = false;\n         this.required = new AtomicInteger();\n         this.processing = new AtomicInteger();\n-    }\n-\n-    public ReasonerProducer(Disjunction disjunction, ResolverRegistry resolverRegistry, GraqlMatch.Modifiers modifiers,\n-                            Options.Query options) {\n-        if (options.traceInference()) ResolutionTracer.initialise(options.logsDir());\n-        this.rootResolver = resolverRegistry.root(disjunction, this::requestAnswered, this::requestFailed, this::exception);\n-        this.options = options;\n-        Identity downstream = Top.initial(filter(modifiers.filter()), recordExplanations, this.rootResolver).toDownstream();\n+        this.rootResolver = resolverRegistry.root(conjunction, this::requestAnswered, this::requestFailed, this::exception);\n         this.computeSize = options.parallel() ? Executors.PARALLELISATION_FACTOR * 2 : 1;\n         assert computeSize > 0;\n+        Root downstream = InitialImpl.create(filter(modifiers.filter()), new ConceptMap(), this.rootResolver, options.explain()).toDownstream();\n         this.resolveRequest = Request.create(rootResolver, downstream);\n+        if (options.traceInference()) ResolutionTracer.initialise(options.logsDir());\n+    }\n+\n+    public ReasonerProducer(Disjunction disjunction, GraqlMatch.Modifiers modifiers, Options.Query options,\n+                            ResolverRegistry resolverRegistry, Explanations explanations) {\n+        this.options = options;\n+        this.explanations = explanations;\n         this.queue = null;\n         this.iteration = 0;\n         this.done = false;\n         this.required = new AtomicInteger();\n         this.processing = new AtomicInteger();\n+        this.rootResolver = resolverRegistry.root(disjunction, this::requestAnswered, this::requestFailed, this::exception);\n+        this.computeSize = options.parallel() ? Executors.PARALLELISATION_FACTOR * 2 : 1;\n+        assert computeSize > 0;\n+        Root downstream = InitialImpl.create(filter(modifiers.filter()), new ConceptMap(), this.rootResolver, options.explain()).toDownstream();\n+        this.resolveRequest = Request.create(rootResolver, downstream);\n+        if (options.traceInference()) ResolutionTracer.initialise(options.logsDir());\n     }\n \n     @Override\n@@ -116,11 +117,15 @@ public void recycle() {}\n         return iterate(filter).map(v -> Identifier.Variable.of(v.reference().asName())).toSet();\n     }\n \n-    // note: root resolver calls this single-threaded, so is threads safe\n-    private void requestAnswered(Top resolutionAnswer) {\n+    // note: root resolver calls this single-threaded, so is thread safe\n+    private void requestAnswered(Finished answer) {\n         if (options.traceInference()) ResolutionTracer.get().finish();\n-        if (resolutionAnswer.requiresReiteration()) requiresReiteration = true;\n-        queue.put(resolutionAnswer.conceptMap());\n+        if (answer.requiresReiteration()) requiresReiteration = true;\n+        ConceptMap conceptMap = answer.conceptMap();\n+        if (options.explain() && conceptMap.explainables().isPresent()) {\n+            explanations.setAndRecordExplainableIds(conceptMap);\n+        }\n+        queue.put(conceptMap);\n         if (required.decrementAndGet() > 0) requestAnswer();\n         else processing.decrementAndGet();\n     }\n@@ -168,7 +173,8 @@ private boolean mustReiterate() {\n         counter example: $x isa $type; -> unifies with then { (friend: $y) isa friendship; }\n         Without reiteration we will miss $x = instance, $type = relation/thing\n          */\n-        return requiresReiteration;\n+        return iteration < 5;\n+//        return requiresReiteration;\n     }\n \n     private void retryInNewIteration() {"
  },
  {
    "sha": "319415be273604038fbdee103855e25a471471f7",
    "filename": "reasoner/resolution/ResolutionRecorder.java",
    "status": "removed",
    "additions": 0,
    "deletions": 123,
    "changes": 123,
    "blob_url": "https://github.com/graknlabs/grakn/blob/5762344f3c493d0666fa011a331682c6b34ebb87/reasoner/resolution/ResolutionRecorder.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/5762344f3c493d0666fa011a331682c6b34ebb87/reasoner/resolution/ResolutionRecorder.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/ResolutionRecorder.java?ref=5762344f3c493d0666fa011a331682c6b34ebb87",
    "patch": "@@ -1,123 +0,0 @@\n-/*\n- * Copyright (C) 2021 Grakn Labs\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Affero General Public License as\n- * published by the Free Software Foundation, either version 3 of the\n- * License, or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU Affero General Public License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n- *\n- */\n-\n-package grakn.core.reasoner.resolution;\n-\n-import grakn.core.common.exception.GraknException;\n-import grakn.core.concept.answer.ConceptMap;\n-import grakn.core.concurrent.actor.Actor;\n-import grakn.core.reasoner.resolution.answer.AnswerState;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Derivation;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n-import grakn.core.reasoner.resolution.framework.Resolver;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static grakn.core.common.exception.ErrorMessage.Internal.UNIMPLEMENTED;\n-\n-public class ResolutionRecorder extends Actor<ResolutionRecorder> {\n-    private static final Logger LOG = LoggerFactory.getLogger(ResolutionRecorder.class);\n-\n-    private final Map<Driver<? extends Resolver<?>>, Integer> actorIndices;\n-    private final Map<AnswerIndex, Partial<?>> answers;\n-\n-    public ResolutionRecorder(Driver<ResolutionRecorder> driver) {\n-        super(driver, \"ResolutionRecorder\");\n-        answers = new HashMap<>();\n-        actorIndices = new HashMap<>();\n-    }\n-\n-    @Override\n-    protected void exception(Throwable e) {\n-        LOG.error(\"Actor exception\", e);\n-    }\n-\n-    public void record(AnswerState answer) {\n-        throw GraknException.of(UNIMPLEMENTED);\n-//        merge(answer);\n-    }\n-\n-    /**\n-     * Recursively merge derivation tree nodes into the existing derivation nodes that are recorded in the\n-     * answer index. Always keep the pre-existing derivation node, and merge the new ones into the existing node.\n-     *\n-     * @param newAnswer\n-     * @return\n-     */\n-    private Partial<?> merge(Partial<?> newAnswer) {\n-        Derivation newDerivation = newAnswer.derivation();\n-        Map<Driver<? extends Resolver<?>>, Partial<?>> subAnswers = newDerivation.answers();\n-\n-        Map<Driver<? extends Resolver<?>>, Partial<?>> mergedSubAnswers = new HashMap<>();\n-        for (Driver<? extends Resolver<?>> key : subAnswers.keySet()) {\n-            Partial<?> subAnswer = subAnswers.get(key);\n-            Partial<?> mergedSubAnswer = merge(subAnswer);\n-            mergedSubAnswers.put(key, mergedSubAnswer);\n-        }\n-        newDerivation.replace(mergedSubAnswers);\n-\n-        int actorIndex = actorIndices.computeIfAbsent(newAnswer.resolvedBy(), key -> actorIndices.size());\n-        LOG.debug(\"actor index for \" + newAnswer.resolvedBy() + \": \" + actorIndex);\n-        AnswerIndex newAnswerIndex = new AnswerIndex(actorIndex, newAnswer.conceptMap());\n-        if (answers.containsKey(newAnswerIndex)) {\n-            Partial<?> existingAnswer = answers.get(newAnswerIndex);\n-            Derivation existingDerivation = existingAnswer.derivation();\n-            existingDerivation.update(newDerivation.answers());\n-            return existingAnswer;\n-        } else {\n-            answers.put(newAnswerIndex, newAnswer);\n-            return newAnswer;\n-        }\n-    }\n-\n-    static class AnswerIndex {\n-        private final int actorIndex;\n-        private final ConceptMap conceptMap;\n-\n-        public AnswerIndex(int actorIndex, ConceptMap conceptMap) {\n-            this.actorIndex = actorIndex;\n-            this.conceptMap = conceptMap;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            AnswerIndex that = (AnswerIndex) o;\n-            return actorIndex == that.actorIndex &&\n-                    Objects.equals(conceptMap, that.conceptMap);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(actorIndex, conceptMap);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"AnswerIndex{\" +\n-                    \"actorIndex=\" + actorIndex +\n-                    \", conceptMap=\" + conceptMap +\n-                    '}';\n-        }\n-    }\n-}"
  },
  {
    "sha": "29c5ed5e82fbdc1e52683cc8f5cc5069b7383d2e",
    "filename": "reasoner/resolution/ResolverRegistry.java",
    "status": "modified",
    "additions": 86,
    "deletions": 55,
    "changes": 141,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/ResolverRegistry.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/ResolverRegistry.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/ResolverRegistry.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -25,14 +25,13 @@\n import grakn.core.concurrent.common.ConcurrentSet;\n import grakn.core.logic.LogicManager;\n import grakn.core.logic.Rule;\n-import grakn.core.logic.resolvable.Concludable;\n import grakn.core.logic.resolvable.Negated;\n import grakn.core.logic.resolvable.Resolvable;\n-import grakn.core.logic.resolvable.Retrievable;\n import grakn.core.pattern.Conjunction;\n import grakn.core.pattern.Disjunction;\n import grakn.core.pattern.equivalence.AlphaEquivalence;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Top;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Top.Explain;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Top.Match;\n import grakn.core.reasoner.resolution.framework.Resolver;\n import grakn.core.reasoner.resolution.resolver.ConcludableResolver;\n import grakn.core.reasoner.resolution.resolver.ConclusionResolver;\n@@ -43,6 +42,7 @@\n import grakn.core.reasoner.resolution.resolver.RetrievableResolver;\n import grakn.core.reasoner.resolution.resolver.RootResolver;\n import grakn.core.traversal.TraversalEngine;\n+import grakn.core.traversal.common.Identifier;\n import grakn.core.traversal.common.Identifier.Variable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -68,23 +68,20 @@\n \n     private final ConceptManager conceptMgr;\n     private final LogicManager logicMgr;\n-    private final Map<Concludable, Actor.Driver<ConcludableResolver>> concludableResolvers;\n+    private final Map<grakn.core.logic.resolvable.Concludable, Actor.Driver<ConcludableResolver>> concludableResolvers;\n     private final ConcurrentMap<Rule, Actor.Driver<ConditionResolver>> ruleConditions;\n     private final ConcurrentMap<Rule, Actor.Driver<ConclusionResolver>> ruleConclusions; // by Rule not Rule.Conclusion because well defined equality exists\n     private final Set<Actor.Driver<? extends Resolver<?>>> resolvers;\n-    private final Actor.Driver<ResolutionRecorder> resolutionRecorder;\n     private final TraversalEngine traversalEngine;\n     private final Planner planner;\n     private final boolean resolutionTracing;\n     private ActorExecutorGroup executorService;\n     private AtomicBoolean terminated;\n     private boolean explanations;\n \n-    public ResolverRegistry(ActorExecutorGroup executorService, Actor.Driver<ResolutionRecorder> resolutionRecorder,\n-                            TraversalEngine traversalEngine, ConceptManager conceptMgr, LogicManager logicMgr,\n-                            boolean resolutionTracing) {\n+    public ResolverRegistry(ActorExecutorGroup executorService, TraversalEngine traversalEngine, ConceptManager conceptMgr,\n+                            LogicManager logicMgr, boolean resolutionTracing) {\n         this.executorService = executorService;\n-        this.resolutionRecorder = resolutionRecorder;\n         this.traversalEngine = traversalEngine;\n         this.conceptMgr = conceptMgr;\n         this.logicMgr = logicMgr;\n@@ -105,39 +102,39 @@ public void terminateResolvers(Throwable cause) {\n         }\n     }\n \n-    public Actor.Driver<RootResolver.Conjunction> root(Conjunction conjunction, Consumer<Top> onAnswer,\n+    public Actor.Driver<RootResolver.Conjunction> root(Conjunction conjunction, Consumer<Match.Finished> onAnswer,\n                                                        Consumer<Integer> onFail, Consumer<Throwable> onException) {\n         LOG.debug(\"Creating Root.Conjunction for: '{}'\", conjunction);\n         Actor.Driver<RootResolver.Conjunction> resolver = Actor.driver(driver -> new RootResolver.Conjunction(\n-                driver, conjunction, onAnswer, onFail, onException, resolutionRecorder, this,\n+                driver, conjunction, onAnswer, onFail, onException, this,\n                 traversalEngine, conceptMgr, logicMgr, planner, resolutionTracing\n         ), executorService);\n         resolvers.add(resolver);\n         if (terminated.get()) throw GraknException.of(RESOLUTION_TERMINATED); // guard races without synchronized\n         return resolver;\n     }\n \n-    public Actor.Driver<RootResolver.Disjunction> root(Disjunction disjunction, Consumer<Top> onAnswer,\n+    public Actor.Driver<RootResolver.Disjunction> root(Disjunction disjunction, Consumer<Match.Finished> onAnswer,\n                                                        Consumer<Integer> onExhausted, Consumer<Throwable> onException) {\n         LOG.debug(\"Creating Root.Disjunction for: '{}'\", disjunction);\n         Actor.Driver<RootResolver.Disjunction> resolver = Actor.driver(driver -> new RootResolver.Disjunction(\n                 driver, disjunction, onAnswer, onExhausted, onException,\n-                resolutionRecorder, this, traversalEngine, conceptMgr, resolutionTracing\n+                this, traversalEngine, conceptMgr, resolutionTracing\n         ), executorService);\n         resolvers.add(resolver);\n         if (terminated.get()) throw GraknException.of(RESOLUTION_TERMINATED); // guard races without synchronized\n         return resolver;\n     }\n \n-    public ResolverView.Filtered negated(Negated negated, Conjunction upstream) {\n+    public ResolverView.FilteredNegation negated(Negated negated, Conjunction upstream) {\n         LOG.debug(\"Creating Negation resolver for : {}\", negated);\n         Actor.Driver<NegationResolver> negatedResolver = Actor.driver(driver -> new NegationResolver(\n-                driver, negated, this, traversalEngine, conceptMgr, resolutionRecorder, resolutionTracing\n+                driver, negated, this, traversalEngine, conceptMgr, resolutionTracing\n         ), executorService);\n         resolvers.add(negatedResolver);\n         if (terminated.get()) throw GraknException.of(RESOLUTION_TERMINATED); // guard races without synchronized\n         Set<Variable.Retrievable> filter = filter(upstream, negated);\n-        return ResolverView.filtered(negatedResolver, filter);\n+        return ResolverView.negation(negatedResolver, filter);\n     }\n \n     private Set<Variable.Retrievable> filter(Conjunction scope, Negated inner) {\n@@ -150,7 +147,7 @@ public void terminateResolvers(Throwable cause) {\n     public Actor.Driver<ConditionResolver> registerCondition(Rule.Condition ruleCondition) {\n         LOG.debug(\"Register retrieval for rule condition actor: '{}'\", ruleCondition);\n         Actor.Driver<ConditionResolver> resolver = ruleConditions.computeIfAbsent(ruleCondition.rule(), (r) -> Actor.driver(\n-                driver -> new ConditionResolver(driver, ruleCondition, resolutionRecorder, this, traversalEngine,\n+                driver -> new ConditionResolver(driver, ruleCondition, this, traversalEngine,\n                                                 conceptMgr, logicMgr, planner, resolutionTracing), executorService\n         ));\n         resolvers.add(resolver);\n@@ -162,7 +159,7 @@ public void terminateResolvers(Throwable cause) {\n     public Actor.Driver<ConclusionResolver> registerConclusion(Rule.Conclusion conclusion) {\n         LOG.debug(\"Register retrieval for rule conclusion actor: '{}'\", conclusion);\n         Actor.Driver<ConclusionResolver> resolver = ruleConclusions.computeIfAbsent(conclusion.rule(), r -> Actor.driver(\n-                driver -> new ConclusionResolver(driver, conclusion, this, resolutionRecorder,\n+                driver -> new ConclusionResolver(driver, conclusion, this,\n                                                  traversalEngine, conceptMgr, resolutionTracing), executorService\n         ));\n         resolvers.add(resolver);\n@@ -179,40 +176,40 @@ public ResolverView registerResolvable(Resolvable<?> resolvable) {\n         } else throw GraknException.of(ILLEGAL_STATE);\n     }\n \n-    private ResolverView.Filtered registerRetrievable(Retrievable retrievable) {\n+    private ResolverView.FilteredRetrievable registerRetrievable(grakn.core.logic.resolvable.Retrievable retrievable) {\n         LOG.debug(\"Register RetrievableResolver: '{}'\", retrievable.pattern());\n         Actor.Driver<RetrievableResolver> resolver = Actor.driver(driver -> new RetrievableResolver(\n                 driver, retrievable, this, traversalEngine, conceptMgr, resolutionTracing\n         ), executorService);\n         resolvers.add(resolver);\n         if (terminated.get()) throw GraknException.of(RESOLUTION_TERMINATED); // guard races without synchronized\n-        return ResolverView.filtered(resolver, retrievable.retrieves());\n+        return ResolverView.retrievable(resolver, retrievable.retrieves());\n     }\n \n     // note: must be thread safe. We could move to a ConcurrentHashMap if we create an alpha-equivalence wrapper\n-    private synchronized ResolverView.Mapped registerConcludable(Concludable concludable) {\n+    private synchronized ResolverView.MappedConcludable registerConcludable(grakn.core.logic.resolvable.Concludable concludable) {\n         LOG.debug(\"Register ConcludableResolver: '{}'\", concludable.pattern());\n-        for (Map.Entry<Concludable, Actor.Driver<ConcludableResolver>> c : concludableResolvers.entrySet()) {\n+        for (Map.Entry<grakn.core.logic.resolvable.Concludable, Actor.Driver<ConcludableResolver>> c : concludableResolvers.entrySet()) {\n             // TODO: This needs to be optimised from a linear search to use an alpha hash\n             AlphaEquivalence alphaEquality = concludable.alphaEquals(c.getKey());\n             if (alphaEquality.isValid()) {\n-                return ResolverView.mapped(c.getValue(), alphaEquality.asValid().idMapping());\n+                return ResolverView.concludable(c.getValue(), alphaEquality.asValid().idMapping());\n             }\n         }\n         Actor.Driver<ConcludableResolver> resolver = Actor.driver(driver -> new ConcludableResolver(\n-                driver, concludable, resolutionRecorder, this, traversalEngine,\n+                driver, concludable, this, traversalEngine,\n                 conceptMgr, logicMgr, resolutionTracing\n         ), executorService);\n         concludableResolvers.put(concludable, resolver);\n         resolvers.add(resolver);\n         if (terminated.get()) throw GraknException.of(RESOLUTION_TERMINATED); // guard races without synchronized\n-        return ResolverView.mapped(resolver, identity(concludable));\n+        return ResolverView.concludable(resolver, identity(concludable));\n     }\n \n     public Actor.Driver<ConjunctionResolver.Nested> nested(Conjunction conjunction) {\n         LOG.debug(\"Creating Conjunction resolver for : {}\", conjunction);\n         Actor.Driver<ConjunctionResolver.Nested> resolver = Actor.driver(driver -> new ConjunctionResolver.Nested(\n-                driver, conjunction, resolutionRecorder, this, traversalEngine,\n+                driver, conjunction, this, traversalEngine,\n                 conceptMgr, logicMgr, planner, resolutionTracing\n         ), executorService);\n         resolvers.add(resolver);\n@@ -223,47 +220,64 @@ public ResolverView registerResolvable(Resolvable<?> resolvable) {\n     public Actor.Driver<DisjunctionResolver.Nested> nested(Disjunction disjunction) {\n         LOG.debug(\"Creating Disjunction resolver for : {}\", disjunction);\n         return Actor.driver(driver -> new DisjunctionResolver.Nested(\n-                driver, disjunction, resolutionRecorder, this, traversalEngine, conceptMgr, resolutionTracing\n+                driver, disjunction, this, traversalEngine, conceptMgr, resolutionTracing\n         ), executorService);\n     }\n \n     private Map<Variable.Retrievable, Variable.Retrievable> identity(Resolvable<Conjunction> conjunctionResolvable) {\n         return conjunctionResolvable.retrieves().stream().collect(toMap(Function.identity(), Function.identity()));\n     }\n \n+    public Actor.Driver<RootResolver.Explain> explainer(Conjunction conjunction, Consumer<Explain.Finished> requestAnswered,\n+                                                        Consumer<Integer> requestFailed, Consumer<Throwable> exception) {\n+        return Actor.driver(driver -> new RootResolver.Explain(driver, conjunction, requestAnswered, requestFailed, exception,\n+                                                               this, traversalEngine, conceptMgr, logicMgr, planner, resolutionTracing\n+        ), executorService);\n+    }\n+\n     public void setExecutorService(ActorExecutorGroup executorService) {\n         this.executorService = executorService;\n     }\n \n     public static abstract class ResolverView {\n \n-        public static Mapped mapped(Actor.Driver<ConcludableResolver> resolver, Map<Variable.Retrievable, Variable.Retrievable> mapping) {\n-            return new Mapped(resolver, mapping);\n+        public static MappedConcludable concludable(Actor.Driver<ConcludableResolver> resolver, Map<Variable.Retrievable, Variable.Retrievable> mapping) {\n+            return new MappedConcludable(resolver, mapping);\n+        }\n+\n+        public static FilteredNegation negation(Actor.Driver<NegationResolver> resolver, Set<Variable.Retrievable> filter) {\n+            return new FilteredNegation(resolver, filter);\n         }\n \n-        public static Filtered filtered(Actor.Driver<? extends Resolver<?>> resolver, Set<Variable.Retrievable> filter) {\n-            return new Filtered(resolver, filter);\n+        public static FilteredRetrievable retrievable(Actor.Driver<RetrievableResolver> resolver, Set<Variable.Retrievable> filter) {\n+            return new FilteredRetrievable(resolver, filter);\n         }\n \n-        public abstract boolean isMapped();\n+        public boolean isMappedConcludable() { return false; }\n+\n+        public boolean isFilteredNegation() { return false; }\n \n-        public abstract boolean isFiltered();\n+        public boolean isFilteredRetrievable() { return false; }\n+\n+        public MappedConcludable asMappedConcludable() {\n+            throw GraknException.of(ILLEGAL_CAST, getClass(), MappedConcludable.class);\n+        }\n \n-        public Mapped asMapped() {\n-            throw GraknException.of(ILLEGAL_CAST, getClass(), Mapped.class);\n+        public FilteredNegation asFilteredNegation() {\n+            throw GraknException.of(ILLEGAL_CAST, getClass(), FilteredNegation.class);\n         }\n \n-        public Filtered asFiltered() {\n-            throw GraknException.of(ILLEGAL_CAST, getClass(), Mapped.class);\n+        public FilteredRetrievable asFilteredRetrievable() {\n+            throw GraknException.of(ILLEGAL_CAST, getClass(), FilteredRetrievable.class);\n         }\n \n         public abstract Actor.Driver<? extends Resolver<?>> resolver();\n \n-        public static class Mapped extends ResolverView {\n+        public static class MappedConcludable extends ResolverView {\n             private final Actor.Driver<ConcludableResolver> resolver;\n             private final Map<Variable.Retrievable, Variable.Retrievable> mapping;\n \n-            public Mapped(Actor.Driver<ConcludableResolver> resolver, Map<Variable.Retrievable, Variable.Retrievable> mapping) {\n+            public MappedConcludable(Actor.Driver<ConcludableResolver> resolver, Map<Variable.Retrievable, Variable.Retrievable> mapping) {\n                 this.resolver = resolver;\n                 this.mapping = mapping;\n             }\n@@ -273,17 +287,12 @@ public Mapped(Actor.Driver<ConcludableResolver> resolver, Map<Variable.Retrievab\n             }\n \n             @Override\n-            public boolean isMapped() {\n+            public boolean isMappedConcludable() {\n                 return true;\n             }\n \n             @Override\n-            public boolean isFiltered() {\n-                return false;\n-            }\n-\n-            @Override\n-            public Mapped asMapped() {\n+            public MappedConcludable asMappedConcludable() {\n                 return this;\n             }\n \n@@ -293,11 +302,11 @@ public Mapped asMapped() {\n             }\n         }\n \n-        public static class Filtered extends ResolverView {\n-            private final Actor.Driver<? extends Resolver<?>> resolver;\n+        public static class FilteredNegation extends ResolverView {\n+            private final Actor.Driver<NegationResolver> resolver;\n             private final Set<Variable.Retrievable> filter;\n \n-            public Filtered(Actor.Driver<? extends Resolver<?>> resolver, Set<Variable.Retrievable> filter) {\n+            public FilteredNegation(Actor.Driver<NegationResolver> resolver, Set<Variable.Retrievable> filter) {\n                 this.resolver = resolver;\n                 this.filter = filter;\n             }\n@@ -307,22 +316,44 @@ public Filtered(Actor.Driver<? extends Resolver<?>> resolver, Set<Variable.Retri\n             }\n \n             @Override\n-            public boolean isMapped() {\n-                return false;\n+            public boolean isFilteredNegation() {\n+                return true;\n             }\n \n             @Override\n-            public boolean isFiltered() {\n-                return true;\n+            public FilteredNegation asFilteredNegation() {\n+                return this;\n+            }\n+\n+            @Override\n+            public Actor.Driver<? extends Resolver<?>> resolver() {\n+                return resolver;\n+            }\n+        }\n+\n+        public static class FilteredRetrievable extends ResolverView {\n+            private final Actor.Driver<RetrievableResolver> resolver;\n+            private Set<Variable.Retrievable> filter;\n+\n+            public FilteredRetrievable(Actor.Driver<RetrievableResolver> resolver, Set<Variable.Retrievable> filter) {\n+                this.resolver = resolver;\n+                this.filter = filter;\n+            }\n+\n+            public Set<Variable.Retrievable> filter() {\n+                return filter;\n             }\n \n             @Override\n-            public Filtered asFiltered() {\n+            public boolean isFilteredRetrievable() { return true; }\n+\n+            @Override\n+            public FilteredRetrievable asFilteredRetrievable() {\n                 return this;\n             }\n \n             @Override\n-            public Actor.Driver<? extends Resolver<?>> resolver() {\n+            public Actor.Driver<RetrievableResolver> resolver() {\n                 return resolver;\n             }\n         }"
  },
  {
    "sha": "b0cca5f85ebe4c7e754d2388e710aa15fa318ef9",
    "filename": "reasoner/resolution/answer/AnswerState.java",
    "status": "modified",
    "additions": 302,
    "deletions": 404,
    "changes": 706,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerState.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerState.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/AnswerState.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -17,545 +17,443 @@\n \n package grakn.core.reasoner.resolution.answer;\n \n-import grakn.common.collection.Pair;\n import grakn.core.common.exception.GraknException;\n import grakn.core.concept.Concept;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.concurrent.actor.Actor;\n+import grakn.core.logic.Rule;\n import grakn.core.logic.resolvable.Unifier;\n-import grakn.core.logic.resolvable.Unifier.Requirements.Instance;\n+import grakn.core.pattern.Conjunction;\n import grakn.core.reasoner.resolution.framework.Resolver;\n-import grakn.core.reasoner.resolution.resolver.ConclusionResolver;\n import grakn.core.traversal.common.Identifier;\n \n-import javax.annotation.Nullable;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n \n-import static grakn.common.collection.Collections.map;\n import static grakn.common.util.Objects.className;\n-import static grakn.core.common.exception.ErrorMessage.Internal.ILLEGAL_STATE;\n+import static grakn.core.common.exception.ErrorMessage.Internal.ILLEGAL_CAST;\n import static grakn.core.common.exception.ErrorMessage.Pattern.INVALID_CASTING;\n \n-public abstract class AnswerState {\n-    final ConceptMap conceptMap;\n-    private final boolean recordExplanations;\n-    private final Derivation derivation;\n-    private final Actor.Driver<? extends Resolver<?>> root;\n-    final boolean requiresReiteration;\n-\n-    AnswerState(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration,\n-                @Nullable Derivation derivation, boolean recordExplanations) {\n-        this.conceptMap = conceptMap;\n-        this.root = root;\n-        this.requiresReiteration = requiresReiteration;\n-        this.derivation = derivation;\n-        this.recordExplanations = recordExplanations;\n-    }\n+public interface AnswerState {\n \n-    public boolean recordExplanations() {\n-        return recordExplanations;\n-    }\n+    interface Explainable {\n \n-    public abstract ConceptMap conceptMap();\n+        boolean explainable();\n \n-    public Derivation derivation() {\n-        return derivation;\n     }\n \n-    public boolean requiresReiteration() {\n-        return requiresReiteration;\n-    }\n+    ConceptMap conceptMap();\n \n-    public boolean isIdentity() { return false; }\n+    boolean requiresReiteration();\n \n-    public Partial.Identity asIdentity() {\n-        throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Identity.class));\n-    }\n+    Actor.Driver<? extends Resolver<?>> root();\n \n-    public boolean isTop() { return false; }\n+    default boolean isTop() { return false; }\n \n-    public Top asTop() {\n-        throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Identity.class));\n-    }\n+    default Top asTop() { throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Top.class)); }\n \n-    public boolean isPartial() { return false; }\n+    default boolean isPartial() { return false; }\n \n-    public Partial<?> asPartial() {\n-        throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Filtered.class));\n-    }\n+    default Partial<?> asPartial() { throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.class)); }\n \n-    public Actor.Driver<? extends Resolver<?>> root() {\n-        return root;\n-    }\n+    interface Top extends AnswerState {\n \n-    public static class Top extends AnswerState {\n+        default boolean isTop() { return true; }\n \n-        private final Set<Identifier.Variable.Name> getFilter;\n-        private final int hash;\n+        default Top asTop() { return this; }\n \n-        Top(ConceptMap conceptMap, @Nullable Set<Identifier.Variable.Name> getFilter,\n-            Actor.Driver<? extends Resolver<?>> root, boolean recordExplanations, boolean requiresReiteration,\n-            @Nullable Derivation derivation) {\n-            super(conceptMap, root, requiresReiteration, derivation, recordExplanations);\n-            this.getFilter = getFilter;\n-            this.hash = Objects.hash(root, conceptMap, getFilter);\n-        }\n+        default boolean isMatch() { return false; }\n \n-        public static Top initial(Set<Identifier.Variable.Name> getFilter, boolean recordExplanations,\n-                                  Actor.Driver<? extends Resolver<?>> root) {\n-            Derivation derivation = recordExplanations ? Derivation.EMPTY : null;\n-            return new Top(new ConceptMap(), getFilter, root, recordExplanations, false, derivation);\n-        }\n+        default Match asMatch() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.class); }\n \n-        public Partial.Identity toDownstream() {\n-            return Partial.Identity.identity(conceptMap(), this, root(), root(), recordExplanations());\n-        }\n+        default boolean isExplain() { return false; }\n \n-        Top with(ConceptMap conceptMap, boolean requiresReiteration, @Nullable Derivation derivation) {\n-            return new Top(conceptMap, getFilter, root(), recordExplanations(), requiresReiteration, derivation);\n-        }\n+        default Explain asExplain() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Explain.class); }\n \n-        @Override\n-        public String toString() {\n-            return \"AnswerState.Top{\" +\n-                    \"root=\" + root() +\n-                    \", conceptMap=\" + conceptMap() +\n-                    \", filter=\" + getFilter +\n-                    '}';\n-        }\n+        interface Match extends Top, Explainable {\n \n-        @Override\n-        public ConceptMap conceptMap() {\n-            return conceptMap.filter(getFilter);\n-        }\n+            Set<Identifier.Variable.Name> getFilter();\n \n-        public boolean isTop() { return true; }\n+            @Override\n+            default boolean isMatch() {\n+                return true;\n+            }\n \n-        public Top asTop() {\n-            return this;\n-        }\n+            @Override\n+            default Match asMatch() {\n+                return this;\n+            }\n \n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            Top top = (Top) o;\n-            return Objects.equals(root(), top.root()) &&\n-                    Objects.equals(conceptMap, top.conceptMap) &&\n-                    Objects.equals(getFilter, top.getFilter);\n-        }\n+            default boolean isFinished() { return false; }\n \n-        @Override\n-        public int hashCode() {\n-            return hash;\n-        }\n-    }\n+            default Finished asFinished() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Finished.class); }\n \n-    public static abstract class Partial<Parent extends AnswerState> extends AnswerState {\n+            interface Initial extends Match {\n \n-        protected final Parent parent;\n-        private final Actor.Driver<? extends Resolver<?>> resolver; // resolver extending this answer state (eg the receiver)\n+                Partial.Compound.Root.Root.Match toDownstream();\n \n-        public Partial(ConceptMap partialAnswer, Parent parent, Actor.Driver<? extends Resolver<?>> resolver,\n-                       Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, @Nullable Derivation derivation,\n-                       boolean recordExplanations) {\n-            super(partialAnswer, root, requiresReiteration, derivation, recordExplanations);\n-            this.parent = parent;\n-            this.resolver = resolver;\n-        }\n+                Finished finish(ConceptMap conceptMap, boolean requiresReiteration);\n \n-        abstract Partial<?> with(ConceptMap conceptMap, boolean requiresReiteration, Actor.Driver<? extends Resolver<?>> derivedBy,\n-                                 @Nullable Partial<?> extensionState);\n+            }\n \n-        // note: can be any of retrievable, negation, nested disjunction/conjunction...\n-        public Partial.Filtered filterToDownstream(Set<Identifier.Variable.Retrievable> filter, Actor.Driver<? extends Resolver<?>> nextResolver) {\n-            return Filtered.filter(this, filter, nextResolver, root(), recordExplanations());\n-        }\n+            interface Finished extends Match {\n \n-        public Partial.Mapped mapToDownstream(Mapping mapping, Actor.Driver<? extends Resolver<?>> nextResolver) {\n-            return Mapped.map(this, mapping, nextResolver, root(), recordExplanations());\n-        }\n+                @Override\n+                default boolean isFinished() { return true; }\n \n-        public Optional<Partial.Unified> unifyToDownstream(Unifier unifier, Actor.Driver<ConclusionResolver> nextResolver) {\n-            return Unified.unify(this, unifier, nextResolver, root(), recordExplanations());\n-        }\n+                @Override\n+                default Finished asFinished() { return this; }\n \n-        public ConceptMap conceptMap() {\n-            return conceptMap;\n-        }\n+            }\n \n-        protected Parent parent() {\n-            return parent;\n         }\n \n-        public Actor.Driver<? extends Resolver<?>> resolvedBy() {\n-            return resolver;\n+        interface Explain extends Top {\n+\n+            @Override\n+            default boolean isExplain() { return true; }\n+\n+            @Override\n+            default Explain asExplain() { return this; }\n+\n+            default boolean isFinished() { return false; }\n+\n+            default Finished asFinished() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Finished.class); }\n+\n+            interface Initial extends Explain {\n+\n+                Partial.Compound.Root.Explain toDownstream();\n+\n+                Finished finish(ConceptMap conceptMap, boolean requiresReiteration, Explanation explanation);\n+\n+            }\n+\n+            interface Finished extends Explain {\n+\n+                Explanation explanation();\n+\n+                @Override\n+                default boolean isFinished() { return true; }\n+\n+                @Override\n+                default Finished asFinished() { return this; }\n+\n+            }\n         }\n+    }\n+\n+    interface Partial<PARENT extends AnswerState> extends AnswerState {\n+\n+        PARENT parent();\n \n         @Override\n-        public boolean isPartial() { return true; }\n+        default boolean isPartial() { return true; }\n \n         @Override\n-        public Partial<?> asPartial() {\n-            return this;\n-        }\n+        default Partial<?> asPartial() { return this; }\n \n-        public boolean isFiltered() { return false; }\n+        default boolean isCompound() { return false; }\n \n-        public boolean isMapped() { return false; }\n+        default boolean isConcludable() { return false; }\n \n-        public boolean isUnified() { return false; }\n+        default boolean isConclusion() { return false; }\n \n-        public Filtered asFiltered() {\n-            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Filtered.class));\n-        }\n+        default boolean isRetrievable() { return false; }\n \n-        public Partial.Mapped asMapped() {\n-            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Mapped.class));\n+        default Compound<?, ?> asCompound() {\n+            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Compound.class));\n         }\n \n-        public Partial.Unified asUnified() {\n-            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Unified.class));\n+        default Concludable<?> asConcludable() {\n+            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Concludable.class));\n         }\n \n-        protected Optional<AnswerState.Derivation> extendDerivation(Actor.Driver<? extends Resolver<?>> childDeriver, Partial<?> childPartial) {\n-            if (recordExplanations()) return Optional.of(derivation().withAnswer(childDeriver, childPartial));\n-            return Optional.empty();\n+        default Conclusion<?, ?> asConclusion() {\n+            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Conclusion.class));\n         }\n \n-        protected ConceptMap extendAnswer(ConceptMap extension) {\n-            /*\n-            We MUST retain initial concepts, and add derived answers afterward. It's possible, and correct,\n-            that the derived answers overlap but are different: for example, when a subtype is found\n-            by the derived answer, but the initial already uses the supertype.\n-             */\n-            Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>(extension.concepts());\n-            // add the initial concept map second, to make sure we override and retain all of these\n-            concepts.putAll(conceptMap().concepts());\n-            return new ConceptMap(concepts);\n+        default Retrievable<?> asRetrievable() {\n+            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Retrievable.class));\n         }\n \n-        public static class Identity extends Partial<Top> {\n+        interface Compound<SLF extends Compound<SLF, PRNT>, PRNT extends AnswerState> extends Partial<PRNT> {\n \n-            private final int hash;\n+            // TODo does everyone have to implement this? It's used for receiving from a NonRoot\n+            SLF with(ConceptMap extension, boolean requiresReiteration);\n \n-            private Identity(ConceptMap partialAnswer, Top parent, Actor.Driver<? extends Resolver<?>> resolver, Actor.Driver<? extends Resolver<?>> root,\n-                             boolean requiresReiteration, @Nullable Derivation derivation, boolean recordExplanations) {\n-                super(partialAnswer, parent, resolver, root, requiresReiteration, derivation, recordExplanations);\n-                this.hash = Objects.hash(root, resolver, conceptMap, parent);\n-            }\n+            // note: this is only used by Explain, can't get generics for asMatch() casting to work to do this transparently\n+            SLF with(ConceptMap extension, boolean requiresReiteration, Conjunction source);\n \n-            static Identity identity(ConceptMap conceptMap, Top parent, Actor.Driver<? extends Resolver<?>> resolver, Actor.Driver<? extends Resolver<?>> root,\n-                                     boolean recordExplanations) {\n-                Derivation derivation = recordExplanations ? new AnswerState.Derivation(new HashMap<>()) : null;\n-                return new Identity(conceptMap, parent, resolver, root, false, derivation, recordExplanations);\n-            }\n+            Concludable<SLF> toDownstream(Mapping mapping, Conjunction concludableConjunction);\n+\n+            Nestable filterToNestable(Set<Identifier.Variable.Retrievable> filter);\n+\n+            Retrievable<SLF> filterToRetrievable(Set<Identifier.Variable.Retrievable> filter);\n \n             @Override\n-            Partial<?> with(ConceptMap extension, boolean requiresReiteration, Actor.Driver<? extends Resolver<?>> extendedBy,\n-                            @Nullable Partial<?> extensionState) {\n-                Optional<Derivation> extendedDerivation = extendDerivation(extendedBy, extensionState);\n-                return new Identity(extendAnswer(extension), parent(), resolvedBy(), root(), requiresReiteration, extendedDerivation.orElse(null),\n-                                    recordExplanations());\n-            }\n+            default boolean isCompound() { return true; }\n \n-            public Top toTop() {\n-                return parent().asTop().with(conceptMap(), requiresReiteration || parent().requiresReiteration(),\n-                                             derivation());\n-            }\n+            @Override\n+            default Compound<?, PRNT> asCompound() { return this; }\n \n-            public boolean isIdentity() { return true; }\n+            default boolean isRoot() { return false; }\n \n-            public Identity asIdentity() {\n-                return this;\n-            }\n+            default Root<?, ?> asRoot() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Root.class); }\n \n-            @Override\n-            public boolean equals(Object o) {\n-                if (this == o) return true;\n-                if (o == null || getClass() != o.getClass()) return false;\n-                Identity identity = (Identity) o;\n-                return Objects.equals(root(), identity.root()) &&\n-                        Objects.equals(resolvedBy(), identity.resolvedBy()) &&\n-                        Objects.equals(conceptMap, identity.conceptMap) &&\n-                        Objects.equals(parent, identity.parent);\n-            }\n+            default boolean isCondition() { return false; }\n \n-            @Override\n-            public int hashCode() {\n-                return hash;\n-            }\n-        }\n+            default Condition<?, ?> asCondition() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Condition.class); }\n \n-        public static class Filtered extends Partial<Partial<?>> {\n+            default boolean isNestable() { return false; }\n \n-            private final Set<Identifier.Variable.Retrievable> filter;\n-            private final int hash;\n+            default Nestable asNestable() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Nestable.class); }\n \n-            private Filtered(ConceptMap filteredConceptMap, Partial<?> parent, Set<Identifier.Variable.Retrievable> filter,\n-                             Actor.Driver<? extends Resolver<?>> resolver, Actor.Driver<? extends Resolver<?>> root,\n-                             boolean requiresReiteration, @Nullable Derivation derivation, boolean recordExplanations) {\n-                super(filteredConceptMap, parent, resolver, root, requiresReiteration, derivation, recordExplanations);\n-                this.filter = filter;\n-                this.hash = Objects.hash(root, resolver, conceptMap, parent, filter);\n-            }\n+            default boolean isExplain() { return false; }\n \n-            static Filtered filter(Partial<?> parent, Set<Identifier.Variable.Retrievable> filter, Actor.Driver<? extends Resolver<?>> resolver,\n-                                   Actor.Driver<? extends Resolver<?>> root, boolean recordExplanations) {\n-                Derivation derivation = recordExplanations ? new AnswerState.Derivation(new HashMap<>()) : null;\n-                return new Filtered(parent.conceptMap().filter(filter), parent, filter, resolver, root, false,\n-                                    derivation, recordExplanations);\n-            }\n+            default boolean isMatch() { return false; }\n \n-            public Partial<?> toUpstream() {\n-                if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n-                return parent().with(conceptMap().filter(filter), requiresReiteration || parent().requiresReiteration(),\n-                                     resolvedBy(), this);\n-            }\n+            interface Nestable extends Compound<Nestable, Compound<?, ?>> {\n \n-            public Partial<?> aggregateToUpstream(ConceptMap conceptMap) {\n-                if (conceptMap.concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n-                return parent().with(conceptMap.filter(filter), requiresReiteration || parent().requiresReiteration(),\n-                                     resolvedBy(), this);\n-            }\n+                Set<Identifier.Variable.Retrievable> filter();\n \n-            @Override\n-            Filtered with(ConceptMap extension, boolean requiresReiteration, Actor.Driver<? extends Resolver<?>> extendedBy,\n-                          Partial<?> extensionState) {\n-                Optional<Derivation> extendedDerivation = extendDerivation(extendedBy, extensionState);\n-                return new Filtered(extendAnswer(extension), parent(), filter, resolvedBy(), root(), requiresReiteration,\n-                                    extendedDerivation.orElse(null), recordExplanations());\n-            }\n+                Partial.Compound<?, ?> toUpstream();\n \n-            @Override\n-            public boolean isFiltered() { return true; }\n+                @Override\n+                default Nestable with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+                    return with(extension, requiresReiteration);\n+                }\n \n-            @Override\n-            public Filtered asFiltered() { return this; }\n+                @Override\n+                Concludable.Match<Nestable> toDownstream(Mapping mapping, Conjunction concludableConjunction);\n \n-            @Override\n-            public String toString() {\n-                return \"AnswerState.Partial.Filtered{\" +\n-                        \"root=\" + root() +\n-                        \"resolver=\" + resolvedBy() +\n-                        \", conceptMap=\" + conceptMap() +\n-                        \", filter=\" + filter +\n-                        '}';\n-            }\n+                @Override\n+                default boolean isNestable() { return true; }\n \n-            @Override\n-            public boolean equals(Object o) {\n-                if (this == o) return true;\n-                if (o == null || getClass() != o.getClass()) return false;\n-                Filtered filtered = (Filtered) o;\n-                return Objects.equals(root(), filtered.root()) &&\n-                        Objects.equals(resolvedBy(), filtered.resolvedBy()) &&\n-                        Objects.equals(conceptMap, filtered.conceptMap) &&\n-                        Objects.equals(parent, filtered.parent) &&\n-                        Objects.equals(filter, filtered.filter);\n-            }\n+                @Override\n+                default Nestable asNestable() { return this; }\n \n-            @Override\n-            public int hashCode() {\n-                return hash;\n             }\n-        }\n \n-        public static class Mapped extends Partial<Partial<?>> {\n+            interface Root<S extends Root<S, P>, P extends AnswerState> extends Compound<S, P> {\n \n-            private final Mapping mapping;\n-            private final int hash;\n+                @Override\n+                default boolean isRoot() { return true; }\n \n-            private Mapped(ConceptMap mappedConceptMap, Partial<?> parent, Mapping mapping,\n-                           Actor.Driver<? extends Resolver<?>> resolver, Actor.Driver<? extends Resolver<?>> root,\n-                           boolean requiresReiteration, @Nullable Derivation derivation, boolean recordExplanations) {\n-                super(mappedConceptMap, parent, resolver, root, requiresReiteration, derivation, recordExplanations);\n-                this.mapping = mapping;\n-                this.hash = Objects.hash(root, resolver, conceptMap, mapping, parent);\n-            }\n+                @Override\n+                default Root<?, P> asRoot() { return this; }\n \n-            static Mapped map(Partial<?> parent, Mapping mapping, Actor.Driver<? extends Resolver<?>> resolver,\n-                              Actor.Driver<? extends Resolver<?>> root, boolean recordExplanations) {\n-                ConceptMap mappedConceptMap = mapping.transform(parent.conceptMap());\n-                Derivation derivation = recordExplanations ? new AnswerState.Derivation(new HashMap<>()) : null;\n-                return new Mapped(mappedConceptMap, parent, mapping, resolver, root, false, derivation,\n-                                  recordExplanations);\n-            }\n+                default Match asMatch() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.class); }\n \n-            public Partial<?> aggregateToUpstream(ConceptMap additionalConcepts) {\n-                return parent().with(mapping.unTransform(additionalConcepts), requiresReiteration || parent().requiresReiteration(),\n-                                     resolvedBy(), this);\n-            }\n+                default Explain asExplain() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Explain.class); }\n \n-            public Partial<?> toUpstream() {\n-                return parent().with(mapping.unTransform(this.conceptMap()), requiresReiteration || parent().requiresReiteration(),\n-                                     resolvedBy(), this);\n+                interface Match extends Root<Match, Top.Match.Initial>, Explainable {\n+\n+                    @Override\n+                    Concludable.Match<Match> toDownstream(Mapping mapping, Conjunction concludableConjunction);\n+\n+                    Top.Match.Finished toFinishedTop(Conjunction conjunctionAnswered);\n+\n+                    @Override\n+                    default boolean isMatch() { return true; }\n+\n+                    @Override\n+                    default Match asMatch() { return this; }\n+\n+                }\n+\n+                interface Explain extends Root<Explain, Top.Explain.Initial> {\n+\n+                    Explain with(ConceptMap extension, boolean requiresReiteration, Explanation explanation);\n+\n+                    @Override\n+                    Concludable.Explain toDownstream(Mapping mapping, Conjunction concludableConjunction);\n+\n+                    Top.Explain.Finished toFinishedTop();\n+\n+                    @Override\n+                    default Explain with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+                        return with(extension, requiresReiteration);\n+                    }\n+\n+                    @Override\n+                    default boolean isExplain() { return true; }\n+\n+                    @Override\n+                    default Explain asExplain() { return this; }\n+\n+                }\n             }\n \n-            @Override\n-            protected Mapped with(ConceptMap extension, boolean requiresReiteration, Actor.Driver<? extends Resolver<?>> extendedBy,\n-                                  @Nullable Partial<?> extensionState) {\n-                Optional<Derivation> derivation = extendDerivation(extendedBy, extensionState);\n-                return new Mapped(extendAnswer(extension), parent(), mapping, resolvedBy(), root(), requiresReiteration,\n-                                  derivation.orElse(null), recordExplanations());\n+            interface Condition<S extends Condition<S, P>, P extends Conclusion<P, ?>> extends Compound<S, P> {\n+\n+                // merge point where Match and Explain all become Match states\n+                Concludable.Match<S> toDownstream(Mapping mapping, Conjunction concludableConjunction);\n+\n+                @Override\n+                default boolean isCondition() { return true; }\n+\n+                @Override\n+                default Condition<?, P> asCondition() { return this; }\n+\n+                default Match asMatch() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Root.Match.class); }\n+\n+                default Explain asExplain() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Root.Explain.class); }\n+\n+                interface Match extends Condition<Match, Conclusion.Match> {\n+\n+                    Conclusion.Match toUpstream();\n+\n+                    @Override\n+                    default Match with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+                        return with(extension, requiresReiteration);\n+                    }\n+\n+                    @Override\n+                    default boolean isMatch() { return true; }\n+\n+                    @Override\n+                    default Match asMatch() { return this; }\n+\n+                }\n+\n+                interface Explain extends Condition<Explain, Conclusion.Explain> {\n+\n+                    Conclusion.Explain toUpstream(Conjunction conditionConjunction);\n+\n+                    @Override\n+                    default boolean isExplain() { return true; }\n+\n+                    @Override\n+                    default Explain asExplain() { return this; }\n+\n+                }\n+\n             }\n \n-            @Override\n-            public boolean isMapped() { return true; }\n+        }\n \n-            @Override\n-            public Mapped asMapped() { return this; }\n+        interface Concludable<PRNT extends Compound<PRNT, ?>> extends Partial<PRNT> {\n+\n+            Mapping mapping();\n+\n+            PRNT toUpstreamInferred();\n+\n+            Optional<? extends Conclusion<?, ?>> toDownstream(Unifier unifier, Rule rule);\n \n             @Override\n-            public String toString() {\n-                return \"AnswerState.Partial.Mapped{\" +\n-                        \"root=\" + root() +\n-                        \"resolver=\" + resolvedBy() +\n-                        \", conceptMap=\" + conceptMap() +\n-                        \", mapping=\" + mapping +\n-                        '}';\n-            }\n+            default boolean isConcludable() { return true; }\n \n             @Override\n-            public boolean equals(Object o) {\n-                if (this == o) return true;\n-                if (o == null || getClass() != o.getClass()) return false;\n-                Mapped mapped = (Mapped) o;\n-                return Objects.equals(root(), mapped.root()) &&\n-                        Objects.equals(resolvedBy(), mapped.resolvedBy()) &&\n-                        Objects.equals(conceptMap, mapped.conceptMap) &&\n-                        Objects.equals(parent, mapped.parent) &&\n-                        Objects.equals(mapping, mapped.mapping);\n+            default Concludable<?> asConcludable() { return this; }\n+\n+            default boolean isMatch() { return false; }\n+\n+            default Match<?> asMatch() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.class); }\n+\n+            default boolean isExplain() { return false; }\n+\n+            default Explain asExplain() { throw GraknException.of(ILLEGAL_CAST, this.getClass(), Explain.class); }\n+\n+            interface Match<P extends Compound<P, ?>> extends Concludable<P>, Explainable {\n+\n+                @Override\n+                Optional<Conclusion.Match> toDownstream(Unifier unifier, Rule rule);\n+\n+                Match<P> with(ConceptMap extension, boolean requiresReiteration);\n+\n+                P toUpstreamLookup(ConceptMap additionalConcepts, boolean isInferredConclusion);\n+\n+                @Override\n+                default boolean isMatch() { return true; }\n+\n+                @Override\n+                default Match<?> asMatch() { return this; }\n+\n             }\n \n-            @Override\n-            public int hashCode() {\n-                return hash;\n+            interface Explain extends Concludable<Compound.Root.Explain> {\n+\n+                @Override\n+                Optional<Conclusion.Explain> toDownstream(Unifier unifier, Rule rule);\n+\n+                Explain with(ConceptMap extension, boolean requiresReiteration, ConclusionAnswer conclusionAnswer);\n+\n+                ConclusionAnswer conclusionAnswer();\n+\n+                @Override\n+                default boolean isExplain() {\n+                    return true;\n+                }\n+\n+                @Override\n+                default Explain asExplain() { return this; }\n+\n             }\n+\n         }\n \n-        public static class Unified extends Partial<Partial<?>> {\n+        interface Conclusion<SLF extends Conclusion<SLF, PRNT>, PRNT extends Concludable<?>> extends Partial<PRNT> {\n \n-            private final Unifier unifier;\n-            private final Instance instanceRequirements;\n-            private final int hash;\n+            Rule rule();\n \n-            private Unified(ConceptMap unifiedConceptMap, Partial<?> parent, Unifier unifier,\n-                            Instance instanceRequirements, Actor.Driver<? extends Resolver<?>> resolver,\n-                            Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration,\n-                            @Nullable Derivation derivation, boolean recordExplanations) {\n-                super(unifiedConceptMap, parent, resolver, root, requiresReiteration, derivation, recordExplanations);\n-                this.unifier = unifier;\n-                this.instanceRequirements = instanceRequirements;\n-                this.hash = Objects.hash(root, resolver, conceptMap, unifier, instanceRequirements, parent);\n-            }\n+            Unifier unifier();\n \n-            static Optional<Partial.Unified> unify(Partial<?> parent, Unifier unifier, Actor.Driver<ConclusionResolver> resolver,\n-                                                   Actor.Driver<? extends Resolver<?>> root, boolean recordExplanations) {\n-                Optional<Pair<ConceptMap, Instance>> unified = unifier.unify(parent.conceptMap());\n-                Derivation derivation = recordExplanations ? new AnswerState.Derivation(new HashMap<>()) : null;\n-                return unified.map(unification -> new Partial.Unified(\n-                        unification.first(), parent, unifier, unification.second(), resolver, root, false,\n-                        derivation, recordExplanations));\n+            Unifier.Requirements.Instance instanceRequirements();\n \n-            }\n+            Optional<? extends PRNT> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts);\n \n-            public Optional<Partial<?>> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts) {\n-                Optional<ConceptMap> unUnified = unifier.unUnify(concepts, instanceRequirements);\n-                return unUnified.map(ans -> parent().with(ans, true, resolvedBy(), this));\n-            }\n+            SLF extend(ConceptMap ans);\n \n-            @Override\n-            public boolean isUnified() { return true; }\n+            Compound<?, SLF> toDownstream(Set<Identifier.Variable.Retrievable> filter);\n \n             @Override\n-            public Unified asUnified() { return this; }\n+            default boolean isConclusion() { return true; }\n \n             @Override\n-            Unified with(ConceptMap extension, boolean requiresReiteration, Actor.Driver<? extends Resolver<?>> extendedBy,\n-                         @Nullable Partial<?> extensionState) {\n-                Optional<Derivation> extendeDerivation = extendDerivation(extendedBy, extensionState);\n-                return new Unified(extendAnswer(extension), parent(), unifier, instanceRequirements, resolvedBy(), root(), requiresReiteration,\n-                                   extendeDerivation.orElse(null), recordExplanations());\n-            }\n+            default Conclusion<?, ?> asConclusion() { return this; }\n \n-            public Unified extend(ConceptMap ans) {\n-                Map<Identifier.Variable.Retrievable, Concept> extended = new HashMap<>();\n-                extended.putAll(ans.concepts());\n-                extended.putAll(conceptMap.concepts());\n-                return new Unified(new ConceptMap(extended), parent(), unifier, instanceRequirements, resolvedBy(), root(),\n-                                   requiresReiteration, derivation(), recordExplanations());\n-            }\n+            interface Match extends Conclusion<Match, Concludable.Match<?>>, Explainable {\n \n-            @Override\n-            public String toString() {\n-                return \"AnswerState.Partial.Unified{\" +\n-                        \"root=\" + root() +\n-                        \"resolver=\" + resolvedBy() +\n-                        \", conceptMap=\" + conceptMap() +\n-                        \", unifier=\" + unifier +\n-                        \", instanceRequirements=\" + instanceRequirements +\n-                        '}';\n-            }\n+                @Override\n+                Optional<Concludable.Match<?>> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts);\n \n-            @Override\n-            public boolean equals(Object o) {\n-                if (this == o) return true;\n-                if (o == null || getClass() != o.getClass()) return false;\n-                Unified unified = (Unified) o;\n-                return Objects.equals(root(), unified.root()) &&\n-                        Objects.equals(resolvedBy(), unified.resolvedBy()) &&\n-                        Objects.equals(conceptMap, unified.conceptMap) &&\n-                        Objects.equals(parent, unified.parent) &&\n-                        Objects.equals(unifier, unified.unifier) &&\n-                        Objects.equals(instanceRequirements, unified.instanceRequirements);\n-            }\n+                Match with(ConceptMap extension, boolean requiresReiteration);\n+\n+                @Override\n+                Compound.Root.Condition.Match toDownstream(Set<Identifier.Variable.Retrievable> filter);\n \n-            @Override\n-            public int hashCode() {\n-                return hash;\n             }\n-        }\n-    }\n \n-    public static class Derivation {\n-        public static final Derivation EMPTY = new Derivation(map());\n+            interface Explain extends Conclusion<Explain, Concludable.Explain> {\n \n-        private Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> answers;\n+                ConceptMap conditionAnswer();\n \n-        public Derivation(Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> answers) {\n-            this.answers = map(answers);\n-        }\n+                Explain with(ConceptMap conditionAnswer, boolean requiresReiteration);\n \n-        public Derivation withAnswer(Actor.Driver<? extends Resolver<?>> resolver, Partial<?> answer) {\n-            Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> copiedResolution = new HashMap<>(answers);\n-            copiedResolution.put(resolver, answer);\n-            return new Derivation(copiedResolution);\n-        }\n+                @Override\n+                Optional<Concludable.Explain> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts);\n \n-        public void update(Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> newResolutions) {\n-            assert answers.keySet().stream().noneMatch(key -> answers.containsKey(key)) :\n-                    \"Cannot overwrite any derivations during an update\";\n-            Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> copiedResolutions = new HashMap<>(answers);\n-            copiedResolutions.putAll(newResolutions);\n-            this.answers = copiedResolutions;\n-        }\n+                @Override\n+                Compound.Condition.Explain toDownstream(Set<Identifier.Variable.Retrievable> filter);\n \n-        public void replace(Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> newResolutions) {\n-            this.answers = map(newResolutions);\n-        }\n+            }\n \n-        public Map<Actor.Driver<? extends Resolver<?>>, Partial<?>> answers() {\n-            return this.answers;\n         }\n \n-        @Override\n-        public String toString() {\n-            return \"Derivation{\" + \"answers=\" + answers + '}';\n+        interface Retrievable<P extends Compound<P, ?>> extends Partial<P> {\n+\n+            P aggregateToUpstream(ConceptMap concepts);\n+\n+            @Override\n+            default boolean isRetrievable() { return true; }\n+\n+            @Override\n+            default Retrievable<?> asRetrievable() { return this; }\n+\n         }\n+\n     }\n+\n }\n+"
  },
  {
    "sha": "ed9f3cc59f2b9f71489436ad9b18db93b7c84460",
    "filename": "reasoner/resolution/answer/AnswerStateImpl.java",
    "status": "added",
    "additions": 984,
    "deletions": 0,
    "changes": 984,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateImpl.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateImpl.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/AnswerStateImpl.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,984 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner.resolution.answer;\n+\n+import grakn.common.collection.Pair;\n+import grakn.core.common.exception.GraknException;\n+import grakn.core.concept.Concept;\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.concurrent.actor.Actor;\n+import grakn.core.logic.Rule;\n+import grakn.core.logic.resolvable.Unifier;\n+import grakn.core.pattern.Conjunction;\n+import grakn.core.reasoner.resolution.framework.Resolver;\n+import grakn.core.traversal.common.Identifier;\n+\n+import javax.annotation.Nullable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static grakn.core.common.exception.ErrorMessage.Internal.ILLEGAL_STATE;\n+import static grakn.core.common.iterator.Iterators.iterate;\n+\n+public abstract class AnswerStateImpl implements AnswerState {\n+\n+    private final Actor.Driver<? extends Resolver<?>> root;\n+    private final ConceptMap conceptMap;\n+    private final boolean requiresReiteration;\n+\n+    AnswerStateImpl(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+        this.conceptMap = conceptMap;\n+        this.root = root;\n+        this.requiresReiteration = requiresReiteration;\n+    }\n+\n+    @Override\n+    public ConceptMap conceptMap() {\n+        return conceptMap;\n+    }\n+\n+    @Override\n+    public boolean requiresReiteration() {\n+        return requiresReiteration;\n+    }\n+\n+    @Override\n+    public Actor.Driver<? extends Resolver<?>> root() {\n+        return root;\n+    }\n+\n+    protected ConceptMap extendAnswer(ConceptMap extension) {\n+        return extendAnswer(extension, conceptMap().explainables().isPresent() ? conceptMap.explainables().get() : null);\n+    }\n+\n+    protected ConceptMap extendAnswer(ConceptMap extension, Set<ConceptMap.Explainable> explainables) {\n+        /*\n+        We MUST retain initial concepts, and add derived answers afterward. It's possible, and correct,\n+        that the derived answers overlap but are different: for example, when a subtype is found\n+        by the derived answer, but the initial already uses the supertype.\n+         */\n+        Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>(extension.concepts());\n+        // add the initial concept map second, to make sure we override and retain all of these\n+        concepts.putAll(conceptMap().concepts());\n+        return new ConceptMap(concepts, explainables);\n+    }\n+\n+    public static abstract class TopImpl extends AnswerStateImpl implements Top {\n+\n+        TopImpl(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+            super(conceptMap, root, requiresReiteration);\n+        }\n+\n+        public static abstract class MatchImpl extends TopImpl implements Match {\n+\n+            private final Set<Identifier.Variable.Name> getFilter;\n+            private final boolean explainable;\n+            private final int hash;\n+\n+            MatchImpl(Set<Identifier.Variable.Name> getFilter, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root,\n+                      boolean requiresReiteration, boolean explainable) {\n+                super(conceptMap, root, requiresReiteration);\n+                this.getFilter = getFilter;\n+                this.explainable = explainable;\n+                this.hash = Objects.hash(root(), conceptMap(), requiresReiteration(), getFilter(), explainable());\n+            }\n+\n+            @Override\n+            public Set<Identifier.Variable.Name> getFilter() {\n+                return getFilter;\n+            }\n+\n+            @Override\n+            public boolean explainable() {\n+                return explainable;\n+            }\n+\n+            @Override\n+            public boolean equals(Object o) {\n+                if (this == o) return true;\n+                if (o == null || getClass() != o.getClass()) return false;\n+                AnswerStateImpl.TopImpl.MatchImpl that = (AnswerStateImpl.TopImpl.MatchImpl) o;\n+                return Objects.equals(root(), that.root()) &&\n+                        Objects.equals(conceptMap(), that.conceptMap()) &&\n+                        requiresReiteration() == that.requiresReiteration() &&\n+                        Objects.equals(getFilter(), that.getFilter()) &&\n+                        explainable() == that.explainable();\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return hash;\n+            }\n+\n+            public static class InitialImpl extends MatchImpl implements Initial {\n+\n+                private InitialImpl(Set<Identifier.Variable.Name> getFilter, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, boolean explainable) {\n+                    super(getFilter, conceptMap, root, requiresReiteration, explainable);\n+                    assert explainable == conceptMap.explainables().isPresent();\n+                }\n+\n+                public static InitialImpl create(Set<Identifier.Variable.Name> getFilter, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean explainable) {\n+                    ConceptMap initialAns = conceptMap;\n+                    if (explainable) initialAns = new ConceptMap(initialAns.concepts(), new HashSet<>());\n+                    else initialAns = conceptMap.filter(getFilter);\n+                    return new InitialImpl(getFilter, initialAns, root, false, explainable);\n+                }\n+\n+                @Override\n+                public PartialImpl.CompoundImpl.RootImpl.MatchImpl toDownstream() {\n+                    return PartialImpl.CompoundImpl.RootImpl.MatchImpl.childOf(this);\n+                }\n+\n+                @Override\n+                public FinishedImpl finish(ConceptMap conceptMap, boolean requiresReiteration) {\n+                    ConceptMap answer;\n+                    if (explainable()) answer = conceptMap;\n+                    else answer = conceptMap.filter(getFilter());\n+                    return FinishedImpl.create(getFilter(), answer, root(), requiresReiteration, explainable());\n+                }\n+\n+            }\n+\n+            public static class FinishedImpl extends MatchImpl implements Finished {\n+\n+                private FinishedImpl(Set<Identifier.Variable.Name> getFilter, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, boolean explainable) {\n+                    super(getFilter, conceptMap, root, requiresReiteration, explainable);\n+                }\n+\n+                public static FinishedImpl create(Set<Identifier.Variable.Name> getFilter, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, boolean explainable) {\n+                    ConceptMap initialAns = conceptMap;\n+                    if (!explainable) initialAns = conceptMap.filter(getFilter);\n+                    return new FinishedImpl(getFilter, initialAns, root, requiresReiteration, explainable);\n+                }\n+            }\n+        }\n+\n+        public static abstract class ExplainImpl extends TopImpl implements Explain {\n+\n+            ExplainImpl(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                super(conceptMap, root, requiresReiteration);\n+            }\n+\n+            public static class InitialImpl extends ExplainImpl implements Initial {\n+\n+                private final int hash;\n+\n+                public InitialImpl(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(conceptMap, root, requiresReiteration);\n+                    this.hash = Objects.hash(root(), conceptMap(), requiresReiteration());\n+                }\n+\n+                @Override\n+                public Partial.Compound.Root.Explain toDownstream() {\n+                    return PartialImpl.CompoundImpl.RootImpl.ExplainImpl.childOf(this);\n+                }\n+\n+                @Override\n+                public Finished finish(ConceptMap conceptMap, boolean requiresReiteration, Explanation explanation) {\n+                    return new FinishedImpl(explanation, extendAnswer(conceptMap), root(), requiresReiteration);\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    TopImpl.ExplainImpl.InitialImpl that = (TopImpl.ExplainImpl.InitialImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            requiresReiteration() == that.requiresReiteration();\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+\n+            }\n+\n+            public static class FinishedImpl extends ExplainImpl implements Finished {\n+\n+                private final Explanation explanation;\n+                private final int hash;\n+\n+                FinishedImpl(Explanation explanation, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(conceptMap, root, requiresReiteration);\n+                    assert explanation != null;\n+                    this.explanation = explanation;\n+                    this.hash = Objects.hash(root(), conceptMap(), requiresReiteration(), explanation());\n+                }\n+\n+                @Override\n+                public Explanation explanation() {\n+                    return explanation;\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    TopImpl.ExplainImpl.FinishedImpl that = (TopImpl.ExplainImpl.FinishedImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            Objects.equals(explanation(), that.explanation());\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static abstract class PartialImpl<PARENT extends AnswerState>\n+            extends AnswerStateImpl implements Partial<PARENT> {\n+\n+        private final PARENT parent;\n+\n+        PartialImpl(PARENT parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+            super(conceptMap, root, requiresReiteration);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public PARENT parent() {\n+            return parent;\n+        }\n+\n+        public static abstract class CompoundImpl<SLF extends Compound<SLF, PRNT>, PRNT extends AnswerState>\n+                extends PartialImpl<PRNT> implements Compound<SLF, PRNT> {\n+\n+            CompoundImpl(PRNT prnt, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                super(prnt, conceptMap, root, requiresReiteration);\n+            }\n+\n+            @Override\n+            public Nestable filterToNestable(Set<Identifier.Variable.Retrievable> filter) {\n+                return NestableImpl.childOf(filter, this);\n+            }\n+\n+            @Override\n+            public Retrievable<SLF> filterToRetrievable(Set<Identifier.Variable.Retrievable> filter) {\n+                return PartialImpl.PartialImpl.ConcludableImpl.RetrievableImpl.childOf(filter, getThis());\n+            }\n+\n+            abstract SLF getThis();\n+\n+            public static class NestableImpl extends CompoundImpl<Nestable, Compound<?, ?>> implements Nestable {\n+\n+                private final Set<Identifier.Variable.Retrievable> filter;\n+                private final int hash;\n+\n+                NestableImpl(Set<Identifier.Variable.Retrievable> filter, Compound<?, ?> parent,\n+                             ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(parent, conceptMap, root, requiresReiteration);\n+                    this.filter = filter;\n+                    this.hash = Objects.hash(root(), parent(), conceptMap(), requiresReiteration(), filter());\n+                }\n+\n+                static NestableImpl childOf(Set<Identifier.Variable.Retrievable> filter, Compound<?, ?> parent) {\n+                    return new NestableImpl(filter, parent, parent.conceptMap().filter(filter), parent.root(), parent.requiresReiteration());\n+                }\n+\n+                @Override\n+                public Set<Identifier.Variable.Retrievable> filter() {\n+                    return filter;\n+                }\n+\n+                @Override\n+                public Nestable with(ConceptMap extension, boolean requiresReiteration) {\n+                    return new NestableImpl(filter(), parent(), extendAnswer(extension), root(), requiresReiteration);\n+                }\n+\n+                @Override\n+                public Concludable.Match<Nestable> toDownstream(Mapping mapping, Conjunction concludableConjunction) {\n+                    return ConcludableImpl.MatchImpl.childOf(mapping, concludableConjunction, this, false);\n+                }\n+\n+                @Override\n+                public Compound<?, ?> toUpstream() {\n+                    if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+                    return parent().with(conceptMap().filter(filter), requiresReiteration() || parent().requiresReiteration());\n+                }\n+\n+\n+                @Override\n+                Nestable getThis() {\n+                    return this;\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    NestableImpl that = (NestableImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(parent(), that.parent()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            Objects.equals(filter(), that.filter());\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+            }\n+\n+            public static abstract class RootImpl<S extends Root<S, P>, P extends AnswerState> extends CompoundImpl<S, P> implements Root<S, P> {\n+\n+                RootImpl(P parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(parent, conceptMap, root, requiresReiteration);\n+                }\n+\n+                public static class MatchImpl extends RootImpl<Match, Top.Match.Initial> implements Match {\n+\n+                    private final boolean explainable;\n+                    private final int hash;\n+\n+                    MatchImpl(Top.Match.Initial parent, ConceptMap conceptMap,\n+                              Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, boolean explainable) {\n+                        super(parent, conceptMap, root, requiresReiteration);\n+                        this.explainable = explainable;\n+                        assert explainable == conceptMap.explainables().isPresent();\n+                        this.hash = Objects.hash(root, parent, conceptMap, requiresReiteration(), explainable); //note: NOT including explainables\n+                    }\n+\n+                    static MatchImpl childOf(Top.Match.Initial parent) {\n+                        return new MatchImpl(parent, parent.conceptMap(), parent.root(), parent.requiresReiteration(), parent.explainable());\n+                    }\n+\n+                    @Override\n+                    public boolean explainable() { return explainable; }\n+\n+                    @Override\n+                    public Match with(ConceptMap extension, boolean requiresReiteration) {\n+                        return new MatchImpl(parent(), extendAnswer(extension), root(), requiresReiteration, explainable());\n+                    }\n+\n+                    @Override\n+                    public Match with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+                        Set<ConceptMap.Explainable> explainablesExtended;\n+                        if (explainable()) {\n+                            assert conceptMap().explainables().isPresent();\n+                            Set<ConceptMap.Explainable> explainables = conceptMap().explainables().get();\n+                            explainablesExtended = new HashSet<>(explainables);\n+                            explainablesExtended.add(ConceptMap.Explainable.unidentified(source));\n+                        } else {\n+                            explainablesExtended = null;\n+                        }\n+                        return new MatchImpl(parent(), extendAnswer(extension, explainablesExtended), root(), requiresReiteration, explainable());\n+                    }\n+\n+                    @Override\n+                    public Concludable.Match<Match> toDownstream(Mapping mapping, Conjunction concludableConjunction) {\n+                        return ConcludableImpl.MatchImpl.childOf(mapping, concludableConjunction, this, explainable());\n+                    }\n+\n+                    @Override\n+                    public Top.Match.Finished toFinishedTop(Conjunction compoundConjunction) {\n+                        return parent().finish(conceptMap(), requiresReiteration());\n+                    }\n+\n+                    @Override\n+                    Match getThis() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (this == o) return true;\n+                        if (o == null || getClass() != o.getClass()) return false;\n+                        MatchImpl that = (MatchImpl) o;\n+                        return Objects.equals(root(), that.root()) &&\n+                                Objects.equals(parent(), that.parent()) &&\n+                                Objects.equals(conceptMap(), that.conceptMap()) &&\n+                                requiresReiteration() == that.requiresReiteration() &&\n+                                explainable() == that.explainable();\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        return hash;\n+                    }\n+                }\n+\n+                public static class ExplainImpl extends RootImpl<Explain, Top.Explain.Initial> implements Explain {\n+\n+                    private final Explanation explanation;\n+                    private final int hash;\n+\n+                    private ExplainImpl(Explanation explanation, Top.Explain.Initial parent, ConceptMap conceptMap,\n+                                        Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                        super(parent, conceptMap, root, requiresReiteration);\n+                        this.explanation = explanation;\n+                        this.hash = Objects.hash(root(), parent(), conceptMap(), requiresReiteration(), explanation);\n+                    }\n+\n+                    static ExplainImpl childOf(Top.Explain.Initial parent) {\n+                        return new ExplainImpl(null, parent, parent.conceptMap(), parent.root(), parent.requiresReiteration());\n+                    }\n+\n+                    @Override\n+                    public Explain with(ConceptMap extension, boolean requiresReiteration) {\n+                        // note: we never receive answers from negations or (if in a disjunction) from a nested conjunction\n+                        throw GraknException.of(ILLEGAL_STATE);\n+                    }\n+\n+                    @Override\n+                    public Explain with(ConceptMap extension, boolean requiresReiteration, Explanation explanation) {\n+                        assert this.explanation == null;\n+                        return new ExplainImpl(explanation, parent(), extendAnswer(extension), root(), requiresReiteration());\n+                    }\n+\n+                    @Override\n+                    public Concludable.Explain toDownstream(Mapping mapping, Conjunction concludableConjunction) {\n+                        // note: we implement the method to conform to API, but do not use the conjunction when explaining\n+                        return ConcludableImpl.ExplainImpl.childOf(mapping, this);\n+                    }\n+\n+                    @Override\n+                    public Top.Explain.Finished toFinishedTop() {\n+                        assert explanation != null;\n+                        return parent().finish(conceptMap(), requiresReiteration(), explanation);\n+                    }\n+\n+                    @Override\n+                    Explain getThis() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (this == o) return true;\n+                        if (o == null || getClass() != o.getClass()) return false;\n+                        ExplainImpl that = (ExplainImpl) o;\n+                        return Objects.equals(root(), that.root()) &&\n+                                Objects.equals(parent(), that.parent()) &&\n+                                Objects.equals(conceptMap(), that.conceptMap()) &&\n+                                requiresReiteration() == that.requiresReiteration() &&\n+                                Objects.equals(explanation, that.explanation);\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        return hash;\n+                    }\n+                }\n+            }\n+\n+\n+            public static abstract class ConditionImpl<S extends Condition<S, P>, P extends Conclusion<P, ?>> extends CompoundImpl<S, P>\n+                    implements Condition<S, P> {\n+\n+                ConditionImpl(P parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(parent, conceptMap, root, requiresReiteration);\n+                }\n+\n+\n+                public static class MatchImpl extends ConditionImpl<Match, Conclusion.Match> implements Match {\n+\n+                    private final Set<Identifier.Variable.Retrievable> filter;\n+                    private final int hash;\n+\n+                    private MatchImpl(Set<Identifier.Variable.Retrievable> filter, Conclusion.Match parent, ConceptMap conceptMap,\n+                                      Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                        super(parent, conceptMap, root, requiresReiteration);\n+                        this.filter = filter;\n+                        this.hash = Objects.hash(parent(), root(), conceptMap(), requiresReiteration(), filter);\n+                    }\n+\n+                    static MatchImpl childOf(Set<Identifier.Variable.Retrievable> filter, Conclusion.Match parent) {\n+                        return new MatchImpl(filter, parent, parent.conceptMap().filter(filter), parent.root(), false);\n+                    }\n+\n+                    @Override\n+                    public Match with(ConceptMap extension, boolean requiresReiteration) {\n+                        return new MatchImpl(filter, parent(), extendAnswer(extension), root(), requiresReiteration);\n+                    }\n+\n+                    @Override\n+                    public Conclusion.Match toUpstream() {\n+                        if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+                        return parent().with(conceptMap().filter(filter), requiresReiteration() || parent().requiresReiteration());\n+                    }\n+\n+                    @Override\n+                    public Concludable.Match<Match> toDownstream(Mapping mapping, Conjunction concludableConjunction) {\n+                        return ConcludableImpl.MatchImpl.childOf(mapping, concludableConjunction, this, false);\n+                    }\n+\n+                    @Override\n+                    Match getThis() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (this == o) return true;\n+                        if (o == null || getClass() != o.getClass()) return false;\n+                        MatchImpl that = (MatchImpl) o;\n+                        return Objects.equals(root(), that.root()) &&\n+                                Objects.equals(conceptMap(), that.conceptMap()) &&\n+                                Objects.equals(parent(), that.parent()) &&\n+                                requiresReiteration() == that.requiresReiteration() &&\n+                                Objects.equals(filter, that.filter);\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        return hash;\n+                    }\n+                }\n+\n+                public static class ExplainImpl extends ConditionImpl<Explain, Conclusion.Explain> implements Explain {\n+\n+                    private final Set<Identifier.Variable.Retrievable> filter;\n+                    private final int hash;\n+\n+                    private ExplainImpl(Set<Identifier.Variable.Retrievable> filter, Conclusion.Explain parent,\n+                                        ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root,\n+                                        boolean requiresReiteration) {\n+                        super(parent, conceptMap, root, requiresReiteration);\n+                        this.filter = filter;\n+                        this.hash = Objects.hash(root(), parent(), conceptMap(), requiresReiteration(), filter);\n+                    }\n+\n+                    static ExplainImpl childOf(Set<Identifier.Variable.Retrievable> filter, Conclusion.Explain parent) {\n+                        return new ExplainImpl(filter, parent,\n+                                               new ConceptMap(parent.conceptMap().filter(filter).concepts(), new HashSet<>()),\n+                                               parent.root(), false);\n+                    }\n+\n+                    @Override\n+                    public Explain with(ConceptMap extension, boolean requiresReiteration) {\n+                        return new ExplainImpl(filter, parent(), extendAnswer(extension), root(), requiresReiteration);\n+                    }\n+\n+                    @Override\n+                    public Explain with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+                        assert conceptMap().explainables().isPresent();\n+                        Set<ConceptMap.Explainable> explainables = conceptMap().explainables().get();\n+                        Set<ConceptMap.Explainable> explainablesExtended = new HashSet<>(explainables);\n+                        explainablesExtended.add(ConceptMap.Explainable.unidentified(source));\n+                        return new ExplainImpl(filter, parent(), extendAnswer(extension, explainablesExtended), root(), requiresReiteration);\n+                    }\n+\n+                    @Override\n+                    public Conclusion.Explain toUpstream(Conjunction conditionConjunction) {\n+                        if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+                        return parent().with(conceptMap(), requiresReiteration() || parent().requiresReiteration());\n+                    }\n+\n+                    @Override\n+                    public Concludable.Match<Explain> toDownstream(Mapping mapping, Conjunction concludableConjunction) {\n+                        return ConcludableImpl.MatchImpl.childOf(mapping, concludableConjunction, this, true); // record recursive explanations\n+                    }\n+\n+                    @Override\n+                    Explain getThis() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    public boolean equals(Object o) {\n+                        if (this == o) return true;\n+                        if (o == null || getClass() != o.getClass()) return false;\n+                        ExplainImpl that = (ExplainImpl) o;\n+                        return Objects.equals(root(), that.root()) &&\n+                                Objects.equals(conceptMap(), that.conceptMap()) &&\n+                                Objects.equals(parent(), that.parent()) &&\n+                                requiresReiteration() == that.requiresReiteration() &&\n+                                Objects.equals(filter, that.filter);\n+                    }\n+\n+                    @Override\n+                    public int hashCode() {\n+                        return hash;\n+                    }\n+                }\n+            }\n+        }\n+\n+        public static abstract class ConcludableImpl<PRNT extends Compound<PRNT, ?>>\n+                extends PartialImpl<PRNT> implements Concludable<PRNT> {\n+\n+            private final Mapping mapping;\n+\n+            ConcludableImpl(Mapping mapping, PRNT parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                super(parent, conceptMap, root, requiresReiteration);\n+                this.mapping = mapping;\n+            }\n+\n+            @Override\n+            public Mapping mapping() {\n+                return mapping;\n+            }\n+\n+            public static class MatchImpl<P extends Compound<P, ?>> extends ConcludableImpl<P> implements Match<P> {\n+\n+                private final Conjunction conjunction;\n+                private final boolean explainable;\n+                private final int hash;\n+\n+                private MatchImpl(Mapping mapping, Conjunction conjunction, P parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root,\n+                                  boolean requiresReiteration, boolean explainable) {\n+                    super(mapping, parent, conceptMap, root, requiresReiteration);\n+                    this.conjunction = conjunction;\n+                    this.explainable = explainable;\n+                    this.hash = Objects.hash(root(), parent(), conceptMap(), requiresReiteration(), explainable(), mapping());\n+                }\n+\n+                static <P extends Compound<P, ?>> MatchImpl<P> childOf(Mapping mapping, Conjunction conjunction, P parent, boolean explainable) {\n+                    return new MatchImpl<>(mapping, conjunction, parent, mapping.transform(parent.conceptMap()),\n+                                           parent.root(), parent.requiresReiteration(), explainable);\n+                }\n+\n+                @Override\n+                public boolean explainable() {\n+                    return explainable;\n+                }\n+\n+                @Override\n+                public Match<P> with(ConceptMap extension, boolean requiresReiteration) {\n+                    return new MatchImpl<>(mapping(), conjunction, parent(), extendAnswer(extension), root(), requiresReiteration, explainable());\n+                }\n+\n+                @Override\n+                public P toUpstreamInferred() {\n+                    boolean requiresReiteration = requiresReiteration() || parent().requiresReiteration();\n+                    return parent().with(mapping().unTransform(conceptMap()), requiresReiteration, conjunction);\n+                }\n+\n+                @Override\n+                public P toUpstreamLookup(ConceptMap additionalConcepts, boolean isInferredConclusion) {\n+                    boolean requiresReiteration = requiresReiteration() || parent().requiresReiteration();\n+                    if (isInferredConclusion) {\n+                        return parent().with(mapping().unTransform(additionalConcepts), requiresReiteration, conjunction);\n+                    } else {\n+                        return parent().with(mapping().unTransform(additionalConcepts), requiresReiteration);\n+                    }\n+                }\n+\n+                @Override\n+                public Optional<Conclusion.Match> toDownstream(Unifier unifier, Rule rule) {\n+                    return ConclusionImpl.MatchImpl.childOf(unifier, rule, this);\n+                }\n+\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    MatchImpl that = (MatchImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            Objects.equals(parent(), that.parent()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            explainable == that.explainable &&\n+                            Objects.equals(mapping(), that.mapping());\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+            }\n+\n+            public static class ExplainImpl extends ConcludableImpl<Compound.Root.Explain> implements Explain {\n+\n+                private final ConclusionAnswer conclusionAnswer;\n+                private final int hash;\n+\n+                ExplainImpl(@Nullable ConclusionAnswer conclusionAnswer, Mapping mapping, Compound.Root.Explain parent, ConceptMap conceptMap,\n+                            Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(mapping, parent, conceptMap, root, requiresReiteration);\n+                    this.conclusionAnswer = conclusionAnswer;\n+                    this.hash = Objects.hash(root(), parent(), conceptMap(), mapping(), requiresReiteration(), conclusionAnswer);\n+                }\n+\n+                static ExplainImpl childOf(Mapping mapping, Compound.Root.Explain parent) {\n+                    return new ExplainImpl(null, mapping, parent, mapping.transform(parent.conceptMap()), parent.root(), parent.requiresReiteration());\n+                }\n+\n+                @Override\n+                public Explain with(ConceptMap extension, boolean requiresReiteration, ConclusionAnswer conclusionAnswer) {\n+                    assert this.conclusionAnswer() == null;\n+                    return new ExplainImpl(conclusionAnswer, mapping(), parent(), extendAnswer(extension), root(), requiresReiteration);\n+                }\n+\n+                @Override\n+                public Compound.Root.Explain toUpstreamInferred() {\n+                    boolean requiresReiteration = requiresReiteration() || parent().requiresReiteration();\n+                    Explanation explanation = new Explanation(conclusionAnswer().rule(), mapping(), conclusionAnswer(), conclusionAnswer().conditionAnswer());\n+                    return parent().with(mapping().unTransform(this.conceptMap()), requiresReiteration, explanation);\n+                }\n+\n+                @Override\n+                public Optional<Conclusion.Explain> toDownstream(Unifier unifier, Rule rule) {\n+                    return ConclusionImpl.ExplainImpl.childOf(unifier, rule, this);\n+                }\n+\n+                @Override\n+                public ConclusionAnswer conclusionAnswer() {\n+                    return conclusionAnswer;\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    ExplainImpl that = (ExplainImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(parent(), that.parent()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            Objects.equals(mapping(), that.mapping()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            Objects.equals(conclusionAnswer, that.conclusionAnswer);\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+\n+                }\n+            }\n+        }\n+\n+        public static abstract class ConclusionImpl<SLF extends Conclusion<SLF, PRNT>, PRNT extends Concludable<?>>\n+                extends PartialImpl<PRNT> implements Conclusion<SLF, PRNT> {\n+\n+            private final Rule rule;\n+            private final Unifier unifier;\n+            private final Unifier.Requirements.Instance instanceRequirements;\n+\n+            ConclusionImpl(Rule rule, Unifier unifier, Unifier.Requirements.Instance instanceRequirements,\n+                           PRNT prnt, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                super(prnt, conceptMap, root, requiresReiteration);\n+                this.rule = rule;\n+                this.unifier = unifier;\n+                this.instanceRequirements = instanceRequirements;\n+            }\n+\n+            @Override\n+            public Rule rule() {\n+                return rule;\n+            }\n+\n+            @Override\n+            public Unifier unifier() {\n+                return unifier;\n+            }\n+\n+            @Override\n+            public Unifier.Requirements.Instance instanceRequirements() {\n+                return instanceRequirements;\n+            }\n+\n+            public static class MatchImpl extends ConclusionImpl<Match, Concludable.Match<?>> implements Match {\n+\n+                private final boolean explainable;\n+                private final int hash;\n+\n+                private MatchImpl(Rule rule, Unifier unifier, Unifier.Requirements.Instance instanceRequirements, Concludable.Match<?> parent,\n+                                  ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration,\n+                                  boolean explainable) {\n+                    super(rule, unifier, instanceRequirements, parent, conceptMap, root, requiresReiteration);\n+                    this.explainable = explainable;\n+                    this.hash = Objects.hash(root(), parent(), conceptMap(), rule(), unifier(), instanceRequirements(), requiresReiteration(), explainable());\n+                }\n+\n+                static Optional<Match> childOf(Unifier unifier, Rule rule, Concludable.Match<?> parent) {\n+                    Optional<Pair<ConceptMap, Unifier.Requirements.Instance>> unified = unifier.unify(parent.conceptMap());\n+                    return unified.map(unification -> new MatchImpl(\n+                            rule, unifier, unification.second(), parent, unification.first(), parent.root(), false, parent.explainable()\n+                    ));\n+                }\n+\n+                @Override\n+                public Match with(ConceptMap extension, boolean requiresReiteration) {\n+                    return new MatchImpl(rule(), unifier(), instanceRequirements(), parent(), extendAnswer(extension), root(), requiresReiteration, explainable());\n+                }\n+\n+                @Override\n+                public Match extend(ConceptMap ans) {\n+                    return new MatchImpl(rule(), unifier(), instanceRequirements(), parent(), extendAnswer(ans), root(), requiresReiteration(), explainable());\n+                }\n+\n+                @Override\n+                public Compound.Root.Condition.Match toDownstream(Set<Identifier.Variable.Retrievable> filter) {\n+                    return CompoundImpl.ConditionImpl.MatchImpl.childOf(filter, this);\n+                }\n+\n+                @Override\n+                public Optional<Concludable.Match<?>> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts) {\n+                    Optional<ConceptMap> unUnified = unifier().unUnify(concepts, instanceRequirements());\n+                    return unUnified.map(ans -> parent().with(ans, true));\n+                }\n+\n+                @Override\n+                public boolean explainable() {\n+                    return explainable;\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    MatchImpl that = (MatchImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(parent(), that.parent()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            Objects.equals(rule(), that.rule()) &&\n+                            Objects.equals(unifier(), that.unifier()) &&\n+                            Objects.equals(instanceRequirements(), that.instanceRequirements()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            explainable() == that.explainable();\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+            }\n+\n+            public static class ExplainImpl extends ConclusionImpl<Explain, Concludable.Explain> implements Explain {\n+\n+                private final ConceptMap conditionAnswer;\n+                private final int hash;\n+\n+                private ExplainImpl(ConceptMap conditionAnswer, Rule rule, Unifier unifier, Unifier.Requirements.Instance instanceRequirements,\n+                                    ConceptMap conceptMap, Concludable.Explain parent, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                    super(rule, unifier, instanceRequirements, parent, conceptMap, root, requiresReiteration);\n+                    this.conditionAnswer = conditionAnswer;\n+                    this.hash = Objects.hash(root(), parent(), conceptMap(), rule(), unifier(), instanceRequirements(), requiresReiteration(), conditionAnswer());\n+                }\n+\n+                static Optional<Explain> childOf(Unifier unifier, Rule rule, Concludable.Explain parent) {\n+                    Optional<Pair<ConceptMap, Unifier.Requirements.Instance>> unified = unifier.unify(parent.conceptMap());\n+                    return unified.map(unification -> new ExplainImpl(\n+                            null, rule, unifier, unification.second(), unification.first(), parent, parent.root(), false\n+                    ));\n+                }\n+\n+                @Override\n+                public Compound.Condition.Explain toDownstream(Set<Identifier.Variable.Retrievable> filter) {\n+                    return CompoundImpl.ConditionImpl.ExplainImpl.childOf(filter, this);\n+                }\n+\n+                @Override\n+                public Explain extend(ConceptMap ans) {\n+                    return new ExplainImpl(conditionAnswer(), rule(), unifier(), instanceRequirements(), extendAnswer(ans), parent(), root(), requiresReiteration());\n+                }\n+\n+                @Override\n+                public Explain with(ConceptMap conditionAnswer, boolean requiresReiteration) {\n+                    assert this.conditionAnswer() == null;\n+                    // note: we add more concepts to the conclusion answer than there are variables to preserve uniqueness of multiple explanations\n+                    return new ExplainImpl(conditionAnswer, rule(), unifier(), instanceRequirements(), extendAnswer(conditionAnswer), parent(), root(), requiresReiteration);\n+                }\n+\n+                @Override\n+                public Optional<Concludable.Explain> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts) {\n+                    Optional<ConceptMap> unUnified = unifier().unUnify(concepts, instanceRequirements());\n+                    return unUnified.map(ans -> {\n+                        ConclusionAnswer conclusionAnswer = new ConclusionAnswer(rule(), toConceptMap(concepts), unifier(), conditionAnswer());\n+                        return parent().with(ans, true, conclusionAnswer);\n+                    });\n+                }\n+\n+                private ConceptMap toConceptMap(Map<Identifier.Variable, Concept> concepts) {\n+                    Map<Identifier.Variable.Retrievable, Concept> filteredMap = new HashMap<>();\n+                    iterate(concepts.entrySet()).filter(entry -> entry.getKey().isRetrievable())\n+                            .forEachRemaining(entry -> filteredMap.put(entry.getKey().asRetrievable(), entry.getValue()));\n+                    return new ConceptMap(filteredMap);\n+                }\n+\n+                @Override\n+                public ConceptMap conditionAnswer() {\n+                    return conditionAnswer;\n+                }\n+\n+                @Override\n+                public boolean equals(Object o) {\n+                    if (this == o) return true;\n+                    if (o == null || getClass() != o.getClass()) return false;\n+                    ExplainImpl that = (ExplainImpl) o;\n+                    return Objects.equals(root(), that.root()) &&\n+                            Objects.equals(parent(), that.parent()) &&\n+                            Objects.equals(conceptMap(), that.conceptMap()) &&\n+                            Objects.equals(rule(), that.rule()) &&\n+                            Objects.equals(unifier(), that.unifier()) &&\n+                            Objects.equals(instanceRequirements(), that.instanceRequirements()) &&\n+                            requiresReiteration() == that.requiresReiteration() &&\n+                            Objects.equals(conditionAnswer(), that.conditionAnswer());\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return hash;\n+                }\n+            }\n+        }\n+\n+        public static class RetrievableImpl<P extends Compound<P, ?>> extends PartialImpl<P> implements Retrievable<P> {\n+\n+            private final Set<Identifier.Variable.Retrievable> filter;\n+            private final int hash;\n+\n+            private RetrievableImpl(Set<Identifier.Variable.Retrievable> filter, P parent, ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+                super(parent, conceptMap, root, requiresReiteration);\n+                this.filter = filter;\n+                this.hash = Objects.hash(root(), parent(), conceptMap(), requiresReiteration(), filter);\n+            }\n+\n+            static <P extends Compound<P, ?>> RetrievableImpl<P> childOf(Set<Identifier.Variable.Retrievable> filter, P parent) {\n+                return new RetrievableImpl<>(filter, parent, parent.conceptMap().filter(filter), parent.root(), parent.requiresReiteration());\n+            }\n+\n+            @Override\n+            public P aggregateToUpstream(ConceptMap concepts) {\n+                assert concepts.concepts().keySet().containsAll(conceptMap().concepts().keySet()) && filter.containsAll(concepts.concepts().keySet());\n+                if (concepts.concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+                return parent().with(concepts, parent().requiresReiteration());\n+            }\n+\n+            @Override\n+            public boolean equals(Object o) {\n+                if (this == o) return true;\n+                if (o == null || getClass() != o.getClass()) return false;\n+                RetrievableImpl that = (RetrievableImpl) o;\n+                return Objects.equals(root(), that.root()) &&\n+                        Objects.equals(parent(), that.parent()) &&\n+                        Objects.equals(conceptMap(), that.conceptMap()) &&\n+                        requiresReiteration() == that.requiresReiteration() &&\n+                        Objects.equals(filter, that.filter);\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                return hash;\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "7cd387dafe9bdca801a3696d5085d3439b83203e",
    "filename": "reasoner/resolution/answer/AnswerStateOld.java",
    "status": "added",
    "additions": 1198,
    "deletions": 0,
    "changes": 1198,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateOld.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateOld.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/AnswerStateOld.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,1198 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner.resolution.answer;\n+\n+import static grakn.common.collection.Collections.set;\n+import static grakn.core.common.iterator.Iterators.iterate;\n+\n+public abstract class AnswerStateOld {\n+//\n+//    private final Actor.Driver<? extends Resolver<?>> root;\n+//    final ConceptMap conceptMap;\n+//    final boolean requiresReiteration;\n+//\n+//    AnswerStateOld(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//        this.conceptMap = conceptMap;\n+//        this.root = root;\n+//        this.requiresReiteration = requiresReiteration;\n+//    }\n+//\n+//    public abstract ConceptMap conceptMap();\n+//\n+//    public boolean requiresReiteration() {\n+//        return requiresReiteration;\n+//    }\n+//\n+//    public boolean isTop() { return false; }\n+//\n+//    public Top asTop() {\n+//        throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Top.class));\n+//    }\n+//\n+//    public boolean isPartial() { return false; }\n+//\n+//    public Partial<?, ?> asPartial() {\n+//        throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Partial.Compound.class));\n+//    }\n+//\n+//    public Actor.Driver<? extends Resolver<?>> root() {\n+//        return root;\n+//    }\n+//\n+//    public static abstract class Top2 extends AnswerStateOld {\n+//\n+//        public Top2(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//            super(conceptMap, root, requiresReiteration);\n+//        }\n+//\n+//        public boolean isTop() { return true; }\n+//\n+//        public Top2 asTop() {\n+//            return this;\n+//        }\n+//\n+//        public boolean isMatch() {\n+//            return false;\n+//        }\n+//\n+//        public Match.Top asMatch() {\n+//            throw GraknException.of(ILLEGAL_CAST, this.getClass(), Top.Match.class);\n+//        }\n+//\n+//        public boolean isExplain() {\n+//            return false;\n+//        }\n+//\n+//        public Explain.Top asExplain() {\n+//            throw GraknException.of(ILLEGAL_CAST, this.getClass(), Top.Explain.class);\n+//        }\n+//\n+//    }\n+//\n+//    public static abstract class Partial2 extends AnswerStateOld {\n+//\n+//    }\n+//\n+//    public static abstract class Match extends AnswerStateOld {\n+//\n+//\n+//        public static abstract class Top extends Top2 {\n+//\n+//            final boolean explainable;\n+//            final Set<Identifier.Variable.Name> getFilter;\n+//            private final int hash;\n+//\n+//            Top(ConceptMap conceptMap, @Nullable Set<Identifier.Variable.Name> getFilter, Actor.Driver<? extends Resolver<?>> root,\n+//                  boolean requiresReiteration, boolean explainable) {\n+//                super(conceptMap, root, requiresReiteration);\n+//                this.getFilter = getFilter;\n+//                this.explainable = explainable;\n+//                this.hash = Objects.hash(conceptMap, getFilter, root, requiresReiteration, explainable);\n+//            }\n+//\n+//            public static Match.Top.Initial initial(Set<Identifier.Variable.Name> getFilter, Actor.Driver<? extends Resolver<?>> root, boolean explainable) {\n+//                return new Match.Top.Initial(new ConceptMap(), getFilter, root, explainable);\n+//            }\n+//\n+//            @Override\n+//            public ConceptMap conceptMap() {\n+//                return conceptMap.filter(getFilter);\n+//            }\n+//\n+//            @Override\n+//            public boolean isMatch() {\n+//                return true;\n+//            }\n+//\n+//            @Override\n+//            public Match.Top asMatch() {\n+//                return this;\n+//            }\n+//\n+//            public boolean isFinished() {\n+//                return false;\n+//            }\n+//\n+//            public Top.Match.Finished asFinished() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Top.Match.Finished.class);\n+//            }\n+//\n+//            @Override\n+//            public boolean equals(Object o) {\n+//                if (this == o) return true;\n+//                if (o == null || getClass() != o.getClass()) return false;\n+//                Match.Top.Initial that = (Match.Top.Initial) o;\n+//                return Objects.equals(root(), that.root()) &&\n+//                        Objects.equals(conceptMap, that.conceptMap) &&\n+//                        Objects.equals(getFilter, that.getFilter) &&\n+//                        requiresReiteration == that.requiresReiteration &&\n+//                        explainable == that.explainable;\n+//            }\n+//\n+//            @Override\n+//            public int hashCode() {\n+//                return hash;\n+//            }\n+//\n+//            public static class Initial extends Match.Top {\n+//\n+//                Initial(ConceptMap conceptMap, @Nullable Set<Identifier.Variable.Name> getFilter, Actor.Driver<? extends Resolver<?>> root, boolean explain) {\n+//                    super(conceptMap, getFilter, root, false, explain);\n+//                }\n+//\n+//                public Match.Partial.Compound.Root toDownstream() {\n+//                    return Match.Partial.Compound.Root.create(conceptMap, this, root(), explainable);\n+//                }\n+//\n+//                Match.Top.Finished finish(ConceptMap conceptMap, boolean requiresReiteration) {\n+//                    return new Match.Top.Finished(conceptMap, getFilter, root(), requiresReiteration, explainable);\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Match.Top.Initial{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap +\n+//                            \", filter=\" + getFilter +\n+//                            '}';\n+//                }\n+//\n+//            }\n+//\n+//            public static class Finished extends Match.Top {\n+//\n+//                Finished(ConceptMap conceptMap, @Nullable Set<Identifier.Variable.Name> getFilter, Actor.Driver<? extends Resolver<?>> root,\n+//                         boolean requiresReiteration, boolean explainable) {\n+//                    super(conceptMap, getFilter, root, requiresReiteration, explainable); }\n+//\n+//                @Override\n+//                public boolean isFinished() {\n+//                    return true;\n+//                }\n+//\n+//                @Override\n+//                public Match.Top.Finished asFinished() {\n+//                    return this;\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Match.Top.Finished{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap +\n+//                            \", filter=\" + getFilter +\n+//                            \", requiresReiteration=\" + requiresReiteration +\n+//                            '}';\n+//                }\n+//            }\n+//        }\n+//\n+//        public static class Partial extends Partial2 {\n+//\n+//            public static abstract class Compound extends Partial {\n+//\n+//                public static class Root extends Compound {\n+//\n+//                }\n+//\n+//                public static class NonRoot extends Compound {\n+//\n+//                }\n+//\n+//                public static class Condition extends Compound {\n+//\n+//                }\n+//\n+//            }\n+//\n+//            public static class Concludable extends Partial {\n+//\n+//            }\n+//\n+//            public static class Conclusion extends Partial {\n+//\n+//            }\n+//\n+//        }\n+//\n+//    }\n+//\n+//    public static abstract class Explain extends AnswerStateOld {\n+//\n+//        public static class Top extends Top2 {\n+//\n+//            public Top(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                super(conceptMap, root, requiresReiteration);\n+//            }\n+//\n+//            public static Explain.Top.Initial initial(ConceptMap bounds, Actor.Driver<RootResolver.Explain> root) {\n+//                return new Explain.Top.Initial(bounds, root, false);\n+//            }\n+//\n+//            @Override\n+//            public ConceptMap conceptMap() {\n+//                return conceptMap;\n+//            }\n+//\n+//            @Override\n+//            public boolean isExplain() {\n+//                return true;\n+//            }\n+//\n+//            @Override\n+//            public Explain.Top asExplain() {\n+//                return this;\n+//            }\n+//\n+//            public boolean isFinished() {\n+//                return false;\n+//            }\n+//\n+//            public Explain.Top.Finished asFinished() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Explain.class);\n+//            }\n+//\n+//            public static class Initial extends Explain.Top {\n+//\n+//                private final int hash;\n+//\n+//                public Initial(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                    super(conceptMap, root, requiresReiteration);\n+//                    this.hash = Objects.hash(root, conceptMap, requiresReiteration);\n+//                }\n+//\n+//                public Explain.Partial.Compound.Root toDownstream() {\n+//                    return Explain.Partial.Compound.root(conceptMap, this, root());\n+//                }\n+//\n+//                public Finished finish(ConceptMap conceptMap, boolean requiresReiteration, Explanation explanation) {\n+//                    return new Finished(conceptMap, root(), requiresReiteration, explanation);\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    AnswerStateOld.Explain.Top.Initial that = (AnswerStateOld.Explain.Top.Initial) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            requiresReiteration == that.requiresReiteration;\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//            }\n+//\n+//            public static class Finished extends Explain.Top {\n+//\n+//                private final Explanation explanation;\n+//                private final int hash;\n+//\n+//                public Finished(ConceptMap conceptMap, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration,\n+//                                Explanation explanation) {\n+//                    super(conceptMap, root, requiresReiteration);\n+//                    this.explanation = explanation;\n+//                    this.hash = Objects.hash(root, conceptMap, requiresReiteration, explanation);\n+//                }\n+//\n+//                @Override\n+//                public boolean isFinished() {\n+//                    return true;\n+//                }\n+//\n+//                @Override\n+//                public Finished asFinished() {\n+//                    return this;\n+//                }\n+//\n+//                public Explanation explanation() {\n+//                    return explanation;\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Explain.To.Finished{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap +\n+//                            \", requiresReiteration=\" + requiresReiteration +\n+//                            \", explanation=\" + explanation +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    Explain.Top.Finished that = (Explain.Top.Finished) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            requiresReiteration == that.requiresReiteration &&\n+//                            Objects.equals(explanation, that.explanation);\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//\n+//            }\n+//        }\n+//\n+//        public static class Partial extends Partial2 {\n+//\n+//            public static abstract class Compound extends Partial {\n+//\n+//                public static class Root extends Compound {\n+//\n+//                }\n+//\n+//                public static class Condition extends Compound {\n+//\n+//                }\n+//\n+//            }\n+//\n+//            public static class Concludable extends Partial {\n+//\n+//            }\n+//\n+//            public static class Conclusion extends Partial {\n+//\n+//            }\n+//\n+//        }\n+//\n+//    }\n+//\n+//    public static abstract class Partial<SELF extends Partial<SELF, PARENT>, PARENT extends AnswerStateOld> extends AnswerStateOld {\n+//\n+//        final PARENT parent;\n+//\n+//        public Partial(ConceptMap partialAnswer, PARENT parent, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//            super(partialAnswer, root, requiresReiteration);\n+//            this.parent = parent;\n+//        }\n+//\n+//        public ConceptMap conceptMap() {\n+//            return conceptMap;\n+//        }\n+//\n+//        protected PARENT parent() {\n+//            return parent;\n+//        }\n+//\n+//        @Override\n+//        public boolean isPartial() { return true; }\n+//\n+//        @Override\n+//        public Partial<?, ?> asPartial() {\n+//            return this;\n+//        }\n+//\n+//        public boolean isCompound() { return false; }\n+//\n+//        public boolean isConcludable() { return false; }\n+//\n+//        public boolean isConclusion() { return false; }\n+//\n+//        public Compound<?, ?> asCompound() {\n+//            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Compound.class));\n+//        }\n+//\n+//        public Concludable<?, ?> asConcludable() {\n+//            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Concludable.class));\n+//        }\n+//\n+//        public Conclusion<?, ?> asConclusion() {\n+//            throw GraknException.of(INVALID_CASTING, className(this.getClass()), className(Conclusion.Match.class));\n+//        }\n+//\n+//        protected ConceptMap extendAnswer(ConceptMap extension) {\n+//            return extendAnswer(extension, null);\n+//        }\n+//\n+//        protected ConceptMap extendAnswer(ConceptMap extension, ExplainableAnswer explainableAnswer) {\n+//            /*\n+//            We MUST retain initial concepts, and add derived answers afterward. It's possible, and correct,\n+//            that the derived answers overlap but are different: for example, when a subtype is found\n+//            by the derived answer, but the initial already uses the supertype.\n+//             */\n+//            Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>(extension.concepts());\n+//            // add the initial concept map second, to make sure we override and retain all of these\n+//            concepts.putAll(conceptMap().concepts());\n+//            return new ConceptMap(concepts, explainableAnswer);\n+//        }\n+//\n+//        abstract SELF with(ConceptMap extension, boolean requiresReiteration);\n+//\n+//        public static abstract class Compound<SLF extends Compound<SLF, PRNT>, PRNT extends AnswerStateOld>\n+//                extends Partial<SLF, PRNT> {\n+//\n+//            public Compound(ConceptMap partialAnswer, PRNT parent, Actor.Driver<? extends Resolver<?>> root,\n+//                            boolean requiresReiteration) {\n+//                super(partialAnswer, parent, root, requiresReiteration);\n+//            }\n+//\n+//            public Match.NonRoot filterToDownstream(Set<Identifier.Variable.Retrievable> filter) {\n+//                return Match.NonRoot.create(this, filter, root());\n+//            }\n+//\n+//            public abstract Concludable<?, ?> mapToDownstream(Mapping mapping, Conjunction nextResolverConjunction);\n+//\n+//            @Override\n+//            public boolean isCompound() { return true; }\n+//\n+//            @Override\n+//            public Compound<?, ?> asCompound() { return this; }\n+//\n+//            public boolean isRoot() { return false; }\n+//\n+//            public Match.Root asRoot() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.Root.class);\n+//            }\n+//\n+//            public boolean isExplainRoot() { return false; }\n+//\n+//            public ExplainRoot asExplainRoot() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.Root.class);\n+//            }\n+//\n+//            public boolean isCondition() { return false; }\n+//\n+//            public Match.Condition<?> asCondition() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.Condition.class);\n+//            }\n+//\n+//            public boolean isNonRoot() { return false; }\n+//\n+//            public Match.NonRoot asNonRoot() {\n+//                throw GraknException.of(ILLEGAL_CAST, this.getClass(), Match.NonRoot.class);\n+//            }\n+//\n+//            public static abstract class Match<S extends Match<S, P>, P extends AnswerStateOld> extends Compound<S, P> {\n+//\n+//                public Match(ConceptMap partialAnswer, P parent, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                    super(partialAnswer, parent, root, requiresReiteration);\n+//                }\n+//\n+//                abstract S with(ConceptMap extension, boolean requiresReiteration, Conjunction source);\n+//\n+//                public static class Root extends Match<Root, Top.Match.Initial> {\n+//\n+//                    private final boolean explainable;\n+//                    private final Set<ExplainableAnswer.Explainable> explainables;\n+//                    private final int hash;\n+//\n+//                    public Root(ConceptMap partialAnswer, Top.Match.Initial parent, Actor.Driver<? extends Resolver<?>> root,\n+//                                boolean requiresReiteration, boolean explainable, Set<ExplainableAnswer.Explainable> explainables) {\n+//                        super(partialAnswer, parent, root, requiresReiteration);\n+//                        this.explainable = explainable;\n+//                        this.explainables = explainables;\n+//                        this.hash = Objects.hash(root, conceptMap, parent, explainable);\n+//                    }\n+//\n+//                    static Root create(ConceptMap conceptMap, Top.Match.Initial parent, Actor.Driver<? extends Resolver<?>> root, boolean explain) {\n+//                        return new Root(conceptMap, parent, root, false, explain, explain ? new HashSet<>() : null);\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean isRoot() { return true; }\n+//\n+//                    @Override\n+//                    public Root asRoot() { return this; }\n+//\n+//                    @Override\n+//                    Root with(ConceptMap extension, boolean requiresReiteration) {\n+//                        return new Root(extendAnswer(extension), parent(), root(), requiresReiteration, explainable, explainables);\n+//                    }\n+//\n+//                    @Override\n+//                    public Root with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+//                        Set<ExplainableAnswer.Explainable> explainablesExtended;\n+//                        if (explainable) {\n+//                            explainablesExtended = new HashSet<>(explainables);\n+//                            explainablesExtended.add(ExplainableAnswer.Explainable.unidentified(source));\n+//                        } else {\n+//                            explainablesExtended = null;\n+//                        }\n+//                        return new Root(extendAnswer(extension), parent(), root(), requiresReiteration, explainable, explainablesExtended);\n+//                    }\n+//\n+//                    @Override\n+//                    public Concludable.Match<Root> mapToDownstream(Mapping mapping, Conjunction nextResolverConjunction) {\n+//                        return Concludable.match(this, mapping, root(), nextResolverConjunction, explainable);\n+//                    }\n+//\n+//                    public Top.Match.Finished toFinishedTop(Conjunction conjunctionAnswered) {\n+//                        // TODO add the conjunction and explainables into the concept map\n+//                        return parent().finish(conceptMap(), requiresReiteration);\n+//                    }\n+//\n+//                    @Override\n+//                    public String toString() {\n+//                        return \"AnswerState.Partial.Compound.Root{\" +\n+//                                \"root=\" + root() +\n+//                                \", conceptMap=\" + conceptMap() +\n+//                                \", explainables=\" + explainables +\n+//                                '}';\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean equals(Object o) {\n+//                        if (this == o) return true;\n+//                        if (o == null || getClass() != o.getClass()) return false;\n+//                        Root that = (Root) o;\n+//                        return Objects.equals(root(), that.root()) &&\n+//                                Objects.equals(conceptMap, that.conceptMap) &&\n+//                                Objects.equals(parent, that.parent) &&\n+//                                explainable == that.explainable;\n+//                    }\n+//\n+//                    @Override\n+//                    public int hashCode() {\n+//                        return hash;\n+//                    }\n+//\n+//                }\n+//\n+//                public static class Condition<P extends Conclusion<P, ?>> extends Match<Condition<P>, P> {\n+//\n+//                    private final Set<ExplainableAnswer.Explainable> explainables;\n+//                    private final Set<Identifier.Variable.Retrievable> filter;\n+//                    private final int hash;\n+//\n+//                    private Condition(ConceptMap filteredMap, P parent, Set<Identifier.Variable.Retrievable> filter,\n+//                                      Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration, Set<ExplainableAnswer.Explainable> explainables) {\n+//                        super(filteredMap, parent, root, requiresReiteration);\n+//                        this.explainables = explainables;\n+//                        this.filter = filter;\n+//                        this.hash = Objects.hash(root, conceptMap, parent, filter);\n+//                    }\n+//\n+//                    static <P extends Conclusion<P, ?>> Condition<P> create(P parent, Set<Identifier.Variable.Retrievable> filter,\n+//                                                                            Actor.Driver<? extends Resolver<?>> root) {\n+//                        return new Condition<>(parent.conceptMap().filter(filter), parent, filter, root, false, set());\n+//                    }\n+//\n+//                    @Override\n+//                    public Concludable.Match<Condition<P>> mapToDownstream(Mapping mapping, Conjunction nextResolverConjunction) {\n+//                        return Concludable.match(this, mapping, root(), nextResolverConjunction, false);\n+//                    }\n+//\n+//                    public P toUpstream(Conjunction conditionConjunction) {\n+//                        if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+//                        // TODO we don't want explainables all, we only need them in `ExplainCondition`\n+//                        ExplainableAnswer conditionAnswer = new ExplainableAnswer(conceptMap, conditionConjunction, explainables);\n+//                        return parent().with(conceptMap().filter(filter), requiresReiteration || parent().requiresReiteration(), conditionAnswer);\n+//                    }\n+//\n+//                    @Override\n+//                    Condition<P> with(ConceptMap extension, boolean requiresReiteration) {\n+//                        return new Condition<>(extendAnswer(extension), parent(), filter, root(), requiresReiteration, explainables);\n+//                    }\n+//\n+//                    @Override\n+//                    public Condition<P> with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+//                        // TODO we don't want to have explanation or source here at all, we only need them in `ExplainCondition`\n+//                        Set<ExplainableAnswer.Explainable> explainablesClone = new HashSet<>(explainables);\n+//                        explainablesClone.add(ExplainableAnswer.Explainable.unidentified(source));\n+//                        return new Condition<>(extendAnswer(extension), parent(), filter, root(), requiresReiteration, explainablesClone);\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean isCondition() {\n+//                        return true;\n+//                    }\n+//\n+//                    @Override\n+//                    public Condition<P> asCondition() {\n+//                        return this;\n+//                    }\n+//\n+//                    @Override\n+//                    public String toString() {\n+//                        return \"AnswerState.Partial.Compound.Condition{\" +\n+//                                \"root=\" + root() +\n+//                                \", conceptMap=\" + conceptMap() +\n+//                                \", filter=\" + filter +\n+//                                \", explainables=\" + explainables +\n+//                                '}';\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean equals(Object o) {\n+//                        if (this == o) return true;\n+//                        if (o == null || getClass() != o.getClass()) return false;\n+//                        Condition that = (Condition) o;\n+//                        return Objects.equals(root(), that.root()) &&\n+//                                Objects.equals(conceptMap, that.conceptMap) &&\n+//                                Objects.equals(parent, that.parent) &&\n+//                                Objects.equals(filter, that.filter);\n+//                    }\n+//\n+//                    @Override\n+//                    public int hashCode() {\n+//                        return hash;\n+//                    }\n+//                }\n+//\n+//                public static class NonRoot extends Match<NonRoot, Compound<?, ?>> {\n+//\n+//                    private final Set<Identifier.Variable.Retrievable> filter;\n+//                    private final int hash;\n+//\n+//                    private NonRoot(ConceptMap filteredConceptMap, Compound<?, ?> parent, Set<Identifier.Variable.Retrievable> filter,\n+//                                    Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                        super(filteredConceptMap, parent, root, requiresReiteration);\n+//                        this.filter = filter;\n+//                        this.hash = Objects.hash(root, conceptMap, parent, filter);\n+//                    }\n+//\n+//                    static NonRoot create(Compound<?, ?> parent, Set<Identifier.Variable.Retrievable> filter,\n+//                                          Actor.Driver<? extends Resolver<?>> root) {\n+//                        return new NonRoot(parent.conceptMap().filter(filter), parent, filter, root, false);\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean isNonRoot() { return true; }\n+//\n+//                    @Override\n+//                    public NonRoot asNonRoot() { return this; }\n+//\n+//                    @Override\n+//                    public Concludable.Match<NonRoot> mapToDownstream(Mapping mapping, Conjunction nextResolverConjunction) {\n+//                        return Concludable.match(this, mapping, root(), nextResolverConjunction, false);\n+//                    }\n+//\n+//                    public Compound<?, ?> toUpstream() {\n+//                        if (conceptMap().concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+//                        return parent().with(conceptMap().filter(filter), requiresReiteration || parent().requiresReiteration());\n+//                    }\n+//\n+//                    public Compound<?, ?> aggregateToUpstream(ConceptMap conceptMap) {\n+//                        if (conceptMap.concepts().isEmpty()) throw GraknException.of(ILLEGAL_STATE);\n+//                        return parent().with(conceptMap.filter(filter), requiresReiteration || parent().requiresReiteration());\n+//                    }\n+//\n+//                    @Override\n+//                    NonRoot with(ConceptMap extension, boolean requiresReiteration) {\n+//                        return new NonRoot(extendAnswer(extension), parent(), filter, root(), requiresReiteration);\n+//                    }\n+//\n+//                    @Override\n+//                    public NonRoot with(ConceptMap extension, boolean requiresReiteration, Conjunction source) {\n+//                        return new NonRoot(extendAnswer(extension), parent(), filter, root(), requiresReiteration);\n+//                    }\n+//\n+//                    @Override\n+//                    public String toString() {\n+//                        return \"AnswerState.Compound.NonRoot{\" +\n+//                                \"root=\" + root() +\n+//                                \", conceptMap=\" + conceptMap() +\n+//                                \", filter=\" + filter +\n+//                                '}';\n+//                    }\n+//\n+//                    @Override\n+//                    public boolean equals(Object o) {\n+//                        if (this == o) return true;\n+//                        if (o == null || getClass() != o.getClass()) return false;\n+//                        NonRoot filtered = (NonRoot) o;\n+//                        return Objects.equals(root(), filtered.root()) &&\n+//                                Objects.equals(conceptMap, filtered.conceptMap) &&\n+//                                Objects.equals(parent, filtered.parent) &&\n+//                                Objects.equals(filter, filtered.filter);\n+//                    }\n+//\n+//                    @Override\n+//                    public int hashCode() {\n+//                        return hash;\n+//                    }\n+//                }\n+//            }\n+//\n+//            public static class ExplainRoot extends Compound<ExplainRoot, Top.Explain.Initial> {\n+//\n+//                private final int hash;\n+//                private final Explanation explanation;\n+//\n+//                private ExplainRoot(ConceptMap partialAnswer, Top.Explain.Initial parent, Actor.Driver<? extends Resolver<?>> root,\n+//                                    boolean requiresReiteration, @Nullable Explanation explanation) {\n+//                    super(partialAnswer, parent, root, requiresReiteration);\n+//                    this.explanation = explanation;\n+//                    this.hash = Objects.hash(root, conceptMap, parent, requiresReiteration, explanation);\n+//                }\n+//\n+//                static ExplainRoot create(ConceptMap conceptMap, Top.Explain.Initial parent, Actor.Driver<? extends Resolver<?>> root) {\n+//                    return new ExplainRoot(conceptMap, parent, root, false, null);\n+//                }\n+//\n+//                @Override\n+//                ExplainRoot with(ConceptMap extension, boolean requiresReiteration) {\n+//                    // TODO we don't really want this method here do we?\n+//                    return new ExplainRoot(extendAnswer(extension), parent(), root(), requiresReiteration, null);\n+//                }\n+//\n+//                public ExplainRoot with(ConceptMap extension, boolean requiresReiteration, Explanation explanation) {\n+//                    return new ExplainRoot(extendAnswer(extension), parent(), root(), requiresReiteration, explanation);\n+//                }\n+//\n+//                public boolean hasExplanation() {\n+//                    return explanation != null;\n+//                }\n+//\n+//                @Override\n+//                public Concludable.Explain mapToDownstream(Mapping mapping, Conjunction nextResolverConjunction) {\n+//                    return Concludable.explain(this, mapping, root(), nextResolverConjunction);\n+//                }\n+//\n+//                public Top.Explain.Finished toFinishedTop() {\n+//                    return parent().finish(conceptMap(), requiresReiteration || parent().requiresReiteration(), explanation);\n+//                }\n+//\n+//                @Override\n+//                public boolean isExplainRoot() {\n+//                    return true;\n+//                }\n+//\n+//                @Override\n+//                public ExplainRoot asExplainRoot() {\n+//                    return this;\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Partial.Compound.ExplainRoot{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap() +\n+//                            \", requiresReiteration=\" + requiresReiteration +\n+//                            \", explanation=\" + explanation +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    ExplainRoot that = (ExplainRoot) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            Objects.equals(parent, that.parent) &&\n+//                            Objects.equals(requiresReiteration, that.requiresReiteration) &&\n+//                            Objects.equals(explanation, that.explanation);\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//\n+//            }\n+//\n+//        }\n+//\n+//        public static abstract class Concludable<SLF extends Concludable<SLF, PRNT>, PRNT extends Compound<PRNT, ?>>\n+//                extends Partial<SLF, PRNT> {\n+//\n+//            final ConclusionAnswer conclusionAnswer; // TODO we only want this in the Explain\n+//            final Conjunction sourceConjunction; //TODO we only want this in Match, if at all since it's a bit odd\n+//            final Mapping mapping;\n+//\n+//            public Concludable(ConceptMap partialAnswer, Mapping mapping, Conjunction sourceConjunction, @Nullable ConclusionAnswer conclusionAnswer,\n+//                               PRNT parent, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                super(partialAnswer, parent, root, requiresReiteration);\n+//                this.mapping = mapping;\n+//                this.sourceConjunction = sourceConjunction;\n+//                this.conclusionAnswer = conclusionAnswer;\n+//            }\n+//\n+//            static <P extends Compound.Match<P, ?>> Match<P> match(P parent, Mapping mapping, Actor.Driver<? extends Resolver<?>> root, Conjunction sourceConjunction, boolean explainable) {\n+//                ConceptMap mappedConceptMap = mapping.transform(parent.conceptMap());\n+//                return new Match<>(mappedConceptMap, parent, mapping, root, false, explainable, sourceConjunction, null);\n+//            }\n+//\n+//            static Explain explain(Compound.ExplainRoot parent, Mapping mapping, Actor.Driver<? extends Resolver<?>> root, Conjunction sourceConjunction) {\n+//                ConceptMap mappedConceptMap = mapping.transform(parent.conceptMap());\n+//                return new Explain(mappedConceptMap, parent, mapping, sourceConjunction, null, root, false);\n+//            }\n+//\n+//            public abstract PRNT toUpstreamLookup(ConceptMap additionalConcepts, boolean isInferredConclusion);\n+//\n+//            public abstract PRNT toUpstreamInferred();\n+//\n+//            public abstract Optional<? extends Conclusion<?, ?>> toDownstream(Unifier unifier, Rule rule);\n+//\n+//            @Override\n+//            public boolean isConcludable() { return true; }\n+//\n+//            @Override\n+//            public Concludable<?, ?> asConcludable() { return this; }\n+//\n+//            public boolean isExplain() {\n+//                return false;\n+//            }\n+//\n+//            public static class Match<P extends Compound.Match<P, ?>> extends Concludable<Match<P>, P> {\n+//\n+//                private final boolean explainable;\n+//                private final int hash;\n+//\n+//                private Match(ConceptMap mappedConceptMap, P parent, Mapping mapping, Actor.Driver<? extends Resolver<?>> root,\n+//                              boolean requiresReiteration, boolean explainable, Conjunction sourceConjunction, @Nullable ConclusionAnswer conclusionAnswer) {\n+//                    super(mappedConceptMap, mapping, sourceConjunction, conclusionAnswer, parent, root, requiresReiteration);\n+//                    this.explainable = explainable;\n+//                    this.hash = Objects.hash(root, conceptMap, mapping, parent, requiresReiteration, explainable);\n+//                }\n+//\n+//                @Override\n+//                public P toUpstreamLookup(ConceptMap additionalConcepts, boolean isInferredConclusion) {\n+//                    if (isInferredConclusion) {\n+//                        return parent().with(mapping.unTransform(additionalConcepts), requiresReiteration || parent().requiresReiteration(),\n+//                                             sourceConjunction);\n+//                    } else {\n+//                        return parent().with(mapping.unTransform(additionalConcepts), requiresReiteration || parent().requiresReiteration());\n+//                    }\n+//                }\n+//\n+//                @Override\n+//                public P toUpstreamInferred() {\n+//                    return parent().with(mapping.unTransform(this.conceptMap()), requiresReiteration || parent().requiresReiteration(),\n+//                                         sourceConjunction);\n+//                }\n+//\n+//                @Override\n+//                public Optional<Conclusion.Match> toDownstream(Unifier unifier, Rule rule) {\n+//                    return Conclusion.Match.match(this, unifier, rule, root(), explainable);\n+//                }\n+//\n+//                @Override\n+//                Concludable.Match<P> with(ConceptMap extension, boolean requiresReiteration) {\n+//                    // if we decide to keep an \"explain\" flag, we would use this endpoint\n+//                    throw GraknException.of(ILLEGAL_STATE);\n+//                }\n+//\n+//                Concludable.Match<P> with(ConceptMap extension, boolean requiresReiteration, ConclusionAnswer conclusionAnswer) {\n+//                    return new Concludable.Match<>(extendAnswer(extension), parent(), mapping, root(), requiresReiteration, explainable, sourceConjunction, conclusionAnswer);\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Partial.Concludable.Match{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap() +\n+//                            \", mapping=\" + mapping +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    Match that = (Match) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            Objects.equals(parent, that.parent) &&\n+//                            Objects.equals(mapping, that.mapping) &&\n+//                            requiresReiteration == that.requiresReiteration;\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//            }\n+//\n+//            public static class Explain extends Concludable<Explain, Compound.ExplainRoot> {\n+//\n+//                private final int hash;\n+//\n+//                private Explain(ConceptMap mappedConceptMap, Compound.ExplainRoot parent, Mapping mapping, Conjunction sourceConjunction,\n+//                                @Nullable ConclusionAnswer conclusionAnswer, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                    super(mappedConceptMap, mapping, sourceConjunction, conclusionAnswer, parent, root, requiresReiteration);\n+//                    //note: includes conclusion answer\n+//                    this.hash = Objects.hash(root, conceptMap, mapping, parent, requiresReiteration, conclusionAnswer);\n+//                }\n+//\n+//                @Override\n+//                public Compound.ExplainRoot toUpstreamLookup(ConceptMap additionalConcepts, boolean isInferredConclusion) {\n+//                    throw GraknException.of(ILLEGAL_STATE);\n+////                    if (isInferredConclusion) {\n+////                        return parent().with(mapping.unTransform(additionalConcepts), requiresReiteration || parent().requiresReiteration(), null);\n+////                    } else {\n+////                        return parent().with(mapping.unTransform(additionalConcepts), requiresReiteration || parent().requiresReiteration());\n+////                    }\n+//                }\n+//\n+//                @Override\n+//                public Compound.ExplainRoot toUpstreamInferred() {\n+//                    Explanation explanation = new Explanation(conclusionAnswer.rule(), mapping, conclusionAnswer, conclusionAnswer.conditionAnswer());\n+//                    return parent().with(mapping.unTransform(this.conceptMap()), requiresReiteration || parent().requiresReiteration(), explanation);\n+//                }\n+//\n+//                @Override\n+//                public Optional<Conclusion.Explain> toDownstream(Unifier unifier, Rule rule) {\n+//                    return Conclusion.explain(this, unifier, rule, root());\n+//                }\n+//\n+//                @Override\n+//                Explain with(ConceptMap extension, boolean requiresReiteration) {\n+//                    // if we decide to keep an \"explain\" flag, we would use this endpoint\n+//                    throw GraknException.of(ILLEGAL_STATE);\n+//                }\n+//\n+//                Explain with(ConceptMap extension, boolean requiresReiteration, ConclusionAnswer conclusionAnswer) {\n+//                    return new Explain(extendAnswer(extension), parent(), mapping, sourceConjunction, conclusionAnswer, root(), requiresReiteration);\n+//                }\n+//\n+//                @Override\n+//                public boolean isExplain() {\n+//                    return true;\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Partial.Concludable.Explain{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap() +\n+//                            \", mapping=\" + mapping +\n+//                            \", conclusionAnswer=\" + conclusionAnswer +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    Explain that = (Explain) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            Objects.equals(parent, that.parent) &&\n+//                            Objects.equals(mapping, that.mapping) &&\n+//                            Objects.equals(conclusionAnswer, that.conclusionAnswer) &&\n+//                            requiresReiteration == that.requiresReiteration;\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//            }\n+//        }\n+//\n+//        public static abstract class Conclusion<SLF extends Conclusion<SLF, PRNT>, PRNT extends Concludable<?, ?>> extends Partial<SLF, PRNT> {\n+//\n+//            final Rule rule;\n+//            final Unifier unifier;\n+//            final Instance instanceRequirements;\n+//            final ExplainableAnswer conditionAnswer; // TODO we only want this in Explain, not in Match\n+//\n+//            public Conclusion(ConceptMap partialAnswer, PRNT parent, Rule rule, Unifier unifier,\n+//                              Instance instanceRequirements, @Nullable ExplainableAnswer conditionAnswer, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                super(partialAnswer, parent, root, requiresReiteration);\n+//                this.rule = rule;\n+//                this.unifier = unifier;\n+//                this.instanceRequirements = instanceRequirements;\n+//                this.conditionAnswer = conditionAnswer;\n+//            }\n+//\n+//            static Optional<Match> match(Concludable.Match<?> parent, Unifier unifier, Rule rule, Actor.Driver<? extends Resolver<?>> root, boolean explainable) {\n+//                Optional<Pair<ConceptMap, Instance>> unified = unifier.unify(parent.conceptMap());\n+//                return unified.map(unification -> new Match(\n+//                        unification.first(), parent, rule, unifier, unification.second(), root, false, explainable, null\n+//                ));\n+//            }\n+//\n+//            static Optional<Explain> explain(Concludable.Explain parent, Unifier unifier, Rule rule, Actor.Driver<? extends Resolver<?>> root) {\n+//                Optional<Pair<ConceptMap, Instance>> unified = unifier.unify(parent.conceptMap());\n+//                return unified.map(unification -> new Explain(\n+//                        unification.first(), parent, rule, unifier, unification.second(), null, root, false\n+//                ));\n+//            }\n+//\n+//            abstract SLF with(ConceptMap extension, boolean requiresReiteration, ExplainableAnswer conditionAnswer);\n+//\n+//            // TODO it should be possible to generify this method implementation too, the generics get tricky\n+//            public abstract Optional<? extends PRNT> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts);\n+//\n+//            // TODO it should be possible to generify this method implementation too, the generics get tricky\n+//            public abstract Compound.Match.Condition<SLF> toDownstream(Set<Identifier.Variable.Retrievable> filter);\n+//\n+//            public abstract SLF extend(ConceptMap ans);\n+//\n+//            @Override\n+//            public boolean isConclusion() { return true; }\n+//\n+//            @Override\n+//            public Conclusion<?, ?> asConclusion() { return this; }\n+//\n+//            public static class Match extends Conclusion<Match, Concludable.Match<?>> {\n+//\n+//                private final boolean explainable;\n+//                private final int hash;\n+//\n+//                private Match(ConceptMap unifiedConceptMap, Concludable.Match<?> parent, Rule rule, Unifier unifier,\n+//                              Instance instanceRequirements, Actor.Driver<? extends Resolver<?>> root,\n+//                              boolean requiresReiteration, boolean explainable, @Nullable ExplainableAnswer conditionAnswer) {\n+//                    super(unifiedConceptMap, parent, rule, unifier, instanceRequirements, conditionAnswer, root, requiresReiteration);\n+//                    this.explainable = explainable;\n+//                    this.hash = Objects.hash(root, conceptMap, rule, unifier, instanceRequirements, parent, requiresReiteration, explainable);\n+//                }\n+//\n+//                @Override\n+//                public Optional<Concludable.Match<?>> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts) {\n+//                    Optional<ConceptMap> unUnified = unifier.unUnify(concepts, instanceRequirements);\n+//                    return unUnified.map(ans -> {\n+//                        // TODO we could make this \"free\" (object creation only) and skip the toConceptMap if we just store the raw map\n+//                        ConclusionAnswer conclusionAnswer = new ConclusionAnswer(rule, toConceptMap(concepts), unifier, conditionAnswer);\n+//                        return parent().with(ans, true, conclusionAnswer);\n+//                    });\n+//                }\n+//\n+//                @Override\n+//                public Compound.Match.Condition<Match> toDownstream(Set<Identifier.Variable.Retrievable> filter) {\n+//                    return Compound.Match.Condition.create(this, filter, root());\n+//                }\n+//\n+//                @Override\n+//                public Match extend(ConceptMap ans) {\n+//                    Map<Identifier.Variable.Retrievable, Concept> extended = new HashMap<>();\n+//                    extended.putAll(ans.concepts());\n+//                    extended.putAll(conceptMap.concepts());\n+//                    return new Match(new ConceptMap(extended), parent(), rule, unifier, instanceRequirements, root(), requiresReiteration, explainable, conditionAnswer\n+//                    );\n+//                }\n+//\n+//                Match with(ConceptMap extension, boolean requiresReiteration) {\n+//                    throw GraknException.of(ILLEGAL_STATE);\n+//                }\n+//\n+//                Match with(ConceptMap extension, boolean requiresReiteration, ExplainableAnswer conditionAnswer) {\n+//                    return new Match(extendAnswer(extension), parent(), rule, unifier, instanceRequirements, root(), requiresReiteration, explainable, conditionAnswer);\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Partial.Conclusion.Match{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap() +\n+//                            \", rule=\" + rule.getLabel() +\n+//                            \", unifier=\" + unifier +\n+//                            \", instanceRequirements=\" + instanceRequirements +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    Match that = (Match) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            Objects.equals(parent, that.parent) &&\n+//                            Objects.equals(rule, that.rule) &&\n+//                            Objects.equals(unifier, that.unifier) &&\n+//                            Objects.equals(instanceRequirements, that.instanceRequirements) &&\n+//                            requiresReiteration == that.requiresReiteration &&\n+//                            explainable == that.explainable;\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//            }\n+//\n+//            public static class Explain extends Conclusion<Explain, Concludable.Explain> {\n+//\n+//                private final int hash;\n+//\n+//                private Explain(ConceptMap unifiedConceptMap, Concludable.Explain parent, Rule rule, Unifier unifier,\n+//                                Instance instanceRequirements, @Nullable ExplainableAnswer conditionAnswer, Actor.Driver<? extends Resolver<?>> root, boolean requiresReiteration) {\n+//                    super(unifiedConceptMap, parent, rule, unifier, instanceRequirements, conditionAnswer, root, requiresReiteration);\n+//                    this.hash = Objects.hash(root, conceptMap, rule, unifier, instanceRequirements, parent, conditionAnswer);\n+//                }\n+//\n+//                @Override\n+//                public Optional<Concludable.Explain> aggregateToUpstream(Map<Identifier.Variable, Concept> concepts) {\n+//                    Optional<ConceptMap> unUnified = unifier.unUnify(concepts, instanceRequirements);\n+//                    return unUnified.map(ans -> {\n+//                        // TODO we could make this \"free\" (object creation only) and skip the toConceptMap if we just store the raw map\n+//                        ConclusionAnswer conclusionAnswer = new ConclusionAnswer(rule, toConceptMap(concepts), unifier, conditionAnswer);\n+//                        return parent().with(ans, true, conclusionAnswer);\n+//                    });\n+//                }\n+//\n+//                @Override\n+//                public Compound.Match.Condition<Explain> toDownstream(Set<Identifier.Variable.Retrievable> filter) {\n+//                    return Compound.Match.Condition.create(this, filter, root());\n+//                }\n+//\n+//                @Override\n+//                public Explain extend(ConceptMap ans) {\n+//                    Map<Identifier.Variable.Retrievable, Concept> extended = new HashMap<>();\n+//                    extended.putAll(ans.concepts());\n+//                    extended.putAll(conceptMap.concepts());\n+//                    return new Explain(new ConceptMap(extended), parent(), rule, unifier, instanceRequirements, conditionAnswer, root(),\n+//                                       requiresReiteration);\n+//                }\n+//\n+//                Explain with(ConceptMap extension, boolean requiresReiteration) {\n+//                    throw GraknException.of(ILLEGAL_STATE);\n+//                }\n+//\n+//                Explain with(ConceptMap extension, boolean requiresReiteration, ExplainableAnswer conditionAnswer) {\n+//                    return new Explain(extendAnswer(extension), parent(), rule, unifier, instanceRequirements, conditionAnswer, root(), requiresReiteration);\n+//                }\n+//\n+//                @Override\n+//                public String toString() {\n+//                    return \"AnswerState.Partial.Conclusion{\" +\n+//                            \"root=\" + root() +\n+//                            \", conceptMap=\" + conceptMap() +\n+//                            \", rule=\" + rule.getLabel() +\n+//                            \", unifier=\" + unifier +\n+//                            \", instanceRequirements=\" + instanceRequirements +\n+//                            \", conditionAnswer=\" + conditionAnswer +\n+//                            '}';\n+//                }\n+//\n+//                @Override\n+//                public boolean equals(Object o) {\n+//                    if (this == o) return true;\n+//                    if (o == null || getClass() != o.getClass()) return false;\n+//                    Explain that = (Explain) o;\n+//                    return Objects.equals(root(), that.root()) &&\n+//                            Objects.equals(conceptMap, that.conceptMap) &&\n+//                            Objects.equals(parent, that.parent) &&\n+//                            Objects.equals(rule, that.rule) &&\n+//                            Objects.equals(unifier, that.unifier) &&\n+//                            Objects.equals(instanceRequirements, that.instanceRequirements) &&\n+//                            requiresReiteration == that.requiresReiteration &&\n+//                            Objects.equals(conditionAnswer, that.conditionAnswer);\n+//                }\n+//\n+//                @Override\n+//                public int hashCode() {\n+//                    return hash;\n+//                }\n+//            }\n+//        }\n+//    }\n+}"
  },
  {
    "sha": "1b99cd75ec6aabf8744cbc86ee94d1e09ab0281f",
    "filename": "reasoner/resolution/answer/AnswerStateTest.java",
    "status": "modified",
    "additions": 17,
    "deletions": 18,
    "changes": 35,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateTest.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/AnswerStateTest.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/AnswerStateTest.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -22,8 +22,8 @@\n import grakn.core.concept.ConceptImpl;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Mapped;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Top;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Concludable;\n+import grakn.core.reasoner.resolution.answer.AnswerStateImpl.TopImpl.MatchImpl.InitialImpl;\n import grakn.core.traversal.common.Identifier;\n import org.junit.Test;\n \n@@ -33,42 +33,41 @@\n import java.util.Set;\n \n import static grakn.common.collection.Collections.set;\n-import static grakn.core.reasoner.resolution.answer.AnswerState.Partial.Identity.identity;\n-import static junit.framework.TestCase.assertEquals;\n-import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n public class AnswerStateTest {\n \n     @Test\n-    public void test_initial_empty_mapped_to_downstream_and_back() {\n+    public void test_root_empty_mapped_to_downstream_and_back() {\n         Map<Identifier.Variable.Retrievable, Identifier.Variable.Retrievable> mapping = new HashMap<>();\n         mapping.put(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"x\"));\n         mapping.put(Identifier.Variable.name(\"b\"), Identifier.Variable.name(\"y\"));\n         Set<Identifier.Variable.Name> filter = set(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"b\"));\n-        Mapped mapped = Top.initial(filter, false, null).toDownstream().mapToDownstream(Mapping.of(mapping), null);\n+        Concludable.Match<?> mapped = InitialImpl.create(filter, new ConceptMap(), null, false).toDownstream().toDownstream(Mapping.of(mapping), null);\n         assertTrue(mapped.conceptMap().concepts().isEmpty());\n \n         Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>();\n         concepts.put(Identifier.Variable.name(\"x\"), new MockConcept(0));\n         concepts.put(Identifier.Variable.name(\"y\"), new MockConcept(1));\n-        Partial<?> partial = mapped.aggregateToUpstream(new ConceptMap(concepts));\n+        Partial.Compound<?, ?> partial = mapped.toUpstreamLookup(new ConceptMap(concepts), false);\n         Map<Identifier.Variable.Retrievable, Concept> expected = new HashMap<>();\n         expected.put(Identifier.Variable.name(\"a\"), new MockConcept(0));\n         expected.put(Identifier.Variable.name(\"b\"), new MockConcept(1));\n         assertEquals(new ConceptMap(expected), partial.conceptMap());\n     }\n \n     @Test\n-    public void test_initial_partially_mapped_to_downstream_and_back() {\n+    public void test_root_partially_mapped_to_downstream_and_back() {\n         Map<Identifier.Variable.Retrievable, Identifier.Variable.Retrievable> mapping = new HashMap<>();\n         mapping.put(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"x\"));\n         mapping.put(Identifier.Variable.name(\"b\"), Identifier.Variable.name(\"y\"));\n         Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>();\n         concepts.put(Identifier.Variable.name(\"a\"), new MockConcept(0));\n         Set<Identifier.Variable.Name> filter = set(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"b\"));\n-        Top top = Top.initial(filter, false, null);\n-        Mapped mapped = identity(new ConceptMap(concepts), top, null, null, false)\n-                .mapToDownstream(Mapping.of(mapping), null);\n+        Concludable.Match<?> mapped = InitialImpl.create(filter, new ConceptMap(), null, false).toDownstream()\n+                .with(new ConceptMap(concepts), false)\n+                .toDownstream(Mapping.of(mapping), null);\n \n         Map<Identifier.Variable.Retrievable, Concept> expectedMapped = new HashMap<>();\n         expectedMapped.put(Identifier.Variable.name(\"x\"), new MockConcept(0));\n@@ -77,7 +76,7 @@ public void test_initial_partially_mapped_to_downstream_and_back() {\n         Map<Identifier.Variable.Retrievable, Concept> downstreamConcepts = new HashMap<>();\n         downstreamConcepts.put(Identifier.Variable.name(\"x\"), new MockConcept(0));\n         downstreamConcepts.put(Identifier.Variable.name(\"y\"), new MockConcept(1));\n-        Partial<?> partial = mapped.aggregateToUpstream(new ConceptMap(downstreamConcepts));\n+        Partial.Compound<?, ?> partial = mapped.toUpstreamLookup(new ConceptMap(downstreamConcepts), false);\n \n         Map<Identifier.Variable.Retrievable, Concept> expectedWithInitial = new HashMap<>();\n         expectedWithInitial.put(Identifier.Variable.name(\"a\"), new MockConcept(0));\n@@ -86,17 +85,17 @@ public void test_initial_partially_mapped_to_downstream_and_back() {\n     }\n \n     @Test\n-    public void test_initial_with_unmapped_elements() {\n+    public void test_root_with_unmapped_elements() {\n         Map<Identifier.Variable.Retrievable, Identifier.Variable.Retrievable> mapping = new HashMap<>();\n         mapping.put(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"x\"));\n         mapping.put(Identifier.Variable.name(\"b\"), Identifier.Variable.name(\"y\"));\n         Map<Identifier.Variable.Retrievable, Concept> concepts = new HashMap<>();\n         concepts.put(Identifier.Variable.name(\"a\"), new MockConcept(0));\n         concepts.put(Identifier.Variable.name(\"c\"), new MockConcept(2));\n         Set<Identifier.Variable.Name> filter = set(Identifier.Variable.name(\"a\"), Identifier.Variable.name(\"b\"));\n-        Top top = Top.initial(filter, false, null);\n-        Mapped mapped = identity(new ConceptMap(concepts), top, null, null, false)\n-                .mapToDownstream(Mapping.of(mapping), null);\n+        Concludable.Match<?> mapped = InitialImpl.create(filter, new ConceptMap(), null, false).toDownstream()\n+                .with(new ConceptMap(concepts), false)\n+                .toDownstream(Mapping.of(mapping), null);\n \n         Map<Identifier.Variable.Retrievable, Concept> expectedMapped = new HashMap<>();\n         expectedMapped.put(Identifier.Variable.name(\"x\"), new MockConcept(0));\n@@ -105,7 +104,7 @@ public void test_initial_with_unmapped_elements() {\n         Map<Identifier.Variable.Retrievable, Concept> downstreamConcepts = new HashMap<>();\n         downstreamConcepts.put(Identifier.Variable.name(\"x\"), new MockConcept(0));\n         downstreamConcepts.put(Identifier.Variable.name(\"y\"), new MockConcept(1));\n-        Partial<?> partial = mapped.aggregateToUpstream(new ConceptMap(downstreamConcepts));\n+        Partial.Compound<?, ?> partial = mapped.toUpstreamLookup(new ConceptMap(downstreamConcepts), false);\n \n         Map<Identifier.Variable.Retrievable, Concept> expectedWithInitial = new HashMap<>();\n         expectedWithInitial.put(Identifier.Variable.name(\"a\"), new MockConcept(0));"
  },
  {
    "sha": "7d7ce60f106c3fcd07f86b28a0920e0755dbd759",
    "filename": "reasoner/resolution/answer/ConclusionAnswer.java",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/ConclusionAnswer.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/ConclusionAnswer.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/ConclusionAnswer.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner.resolution.answer;\n+\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.logic.Rule;\n+import grakn.core.logic.resolvable.Unifier;\n+\n+import java.util.Objects;\n+\n+public class ConclusionAnswer {\n+\n+    private final Rule rule;\n+    private final ConceptMap conceptMap;\n+    private final Unifier unifier;\n+    private final ConceptMap conditionAnswer;\n+    private final int hash;\n+\n+    public ConclusionAnswer(Rule rule, ConceptMap conceptMap, Unifier unifier, ConceptMap conditionAnswer) {\n+        this.rule = rule;\n+        this.conceptMap = conceptMap;\n+        this.unifier = unifier;\n+        this.conditionAnswer = conditionAnswer;\n+        this.hash = Objects.hash(rule, conceptMap, unifier, conditionAnswer);\n+    }\n+\n+    public Rule rule() {\n+        return rule;\n+    }\n+\n+    public ConceptMap conditionAnswer() {\n+        return conditionAnswer;\n+    }\n+\n+    public ConceptMap answer() {\n+        return conceptMap;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        final ConclusionAnswer that = (ConclusionAnswer) o;\n+        return Objects.equals(rule, that.rule) &&\n+                Objects.equals(conceptMap, that.conceptMap) &&\n+                Objects.equals(unifier, that.unifier) &&\n+                Objects.equals(conditionAnswer, that.conditionAnswer);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return hash;\n+    }\n+\n+    public Unifier unifier() {\n+        return unifier;\n+    }\n+}"
  },
  {
    "sha": "6760121e492fe4e6c728cd7e8a9ee799a9184fbf",
    "filename": "reasoner/resolution/answer/Explanation.java",
    "status": "added",
    "additions": 85,
    "deletions": 0,
    "changes": 85,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/Explanation.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/Explanation.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/Explanation.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (C) 2021 Grakn Labs\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package grakn.core.reasoner.resolution.answer;\n+\n+import grakn.core.concept.answer.ConceptMap;\n+import grakn.core.logic.Rule;\n+import grakn.core.logic.resolvable.Unifier;\n+import grakn.core.traversal.common.Identifier.Variable.Retrievable;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class Explanation {\n+\n+    private final Rule rule;\n+    private final Mapping intermediateMapping;\n+    private final ConclusionAnswer conclusionAnswer;\n+    private final ConceptMap conditionAnswer;\n+    private final int hash;\n+\n+    public Explanation(Rule rule, Mapping intermediateMapping, ConclusionAnswer conclusionAnswer, ConceptMap conditionAnswer) {\n+        this.rule = rule;\n+        this.intermediateMapping = intermediateMapping;\n+        this.conclusionAnswer = conclusionAnswer;\n+        this.conditionAnswer = conditionAnswer;\n+        this.hash = Objects.hash(rule, intermediateMapping, conclusionAnswer, conditionAnswer);\n+    }\n+\n+    public Map<Retrievable, Set<Retrievable>> variableMapping() {\n+        Unifier unifier = conclusionAnswer.unifier();\n+        Map<Retrievable, Set<Retrievable>> merged = new HashMap<>();\n+\n+        intermediateMapping.mapping().forEach((from, to) -> {\n+            Set<Retrievable> tos = merged.computeIfAbsent(from, (key) -> new HashSet<>());\n+            if (unifier.mapping().containsKey(to)) {\n+                unifier.mapping().get(to).forEach(var -> {\n+                    if (var.isRetrievable()) tos.add(var.asRetrievable());\n+                });\n+            }\n+        });\n+        return merged;\n+    }\n+\n+    public ConclusionAnswer conclusionAnswer() {\n+        return conclusionAnswer;\n+    }\n+\n+    public ConceptMap conditionAnswer() {\n+        return conditionAnswer;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        final Explanation that = (Explanation) o;\n+        return Objects.equals(rule, that.rule) &&\n+                Objects.equals(intermediateMapping, that.intermediateMapping) &&\n+                Objects.equals(conclusionAnswer, that.conclusionAnswer) &&\n+                Objects.equals(conditionAnswer, that.conditionAnswer);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return hash;\n+    }\n+}"
  },
  {
    "sha": "4574d48f10da81a927f72455a988c847b805234a",
    "filename": "reasoner/resolution/answer/Mapping.java",
    "status": "modified",
    "additions": 6,
    "deletions": 2,
    "changes": 8,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/Mapping.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/answer/Mapping.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/answer/Mapping.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -50,7 +50,7 @@ public ConceptMap transform(ConceptMap conceptMap) {\n                 transformed.put(mapped, concept);\n             }\n         }\n-        return new ConceptMap(transformed);\n+        return new ConceptMap(transformed, conceptMap.explainables().isPresent() ? conceptMap.explainables().get() : null);\n     }\n \n     public ConceptMap unTransform(ConceptMap conceptMap) {\n@@ -62,7 +62,11 @@ public ConceptMap unTransform(ConceptMap conceptMap) {\n             Concept concept = entry.getValue();\n             transformed.put(reverseMapping.get(id), concept);\n         }\n-        return new ConceptMap(transformed);\n+        return new ConceptMap(transformed, conceptMap.explainables().isPresent() ? conceptMap.explainables().get() : null);\n+    }\n+\n+    Map<Retrievable, Retrievable> mapping() {\n+        return mapping;\n     }\n \n     @Override"
  },
  {
    "sha": "ad3c1b7e7b82eb3671066ef7d823b04c71627b7b",
    "filename": "reasoner/resolution/framework/Request.java",
    "status": "modified",
    "additions": 0,
    "deletions": 5,
    "changes": 5,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/framework/Request.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/framework/Request.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/framework/Request.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -93,12 +93,7 @@ public String toString() {\n                 \"sender=\" + sender +\n                 \", receiver=\" + receiver +\n                 \", partial=\" + partialAnswer +\n-                \", partialDerivation=\" + partialAnswer.derivation() +\n                 '}';\n     }\n \n-    public AnswerState.Derivation partialDerivation() {\n-        return partialAnswer.derivation();\n-    }\n-\n }"
  },
  {
    "sha": "8ec177592b4cdc53708b01047800ae2c9e26bf68",
    "filename": "reasoner/resolution/framework/Resolver.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/framework/Resolver.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/framework/Resolver.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/framework/Resolver.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -32,6 +32,7 @@\n import grakn.core.pattern.variable.Variable;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n import grakn.core.reasoner.resolution.answer.AnswerState;\n+import grakn.core.reasoner.resolution.answer.AnswerStateOld;\n import grakn.core.reasoner.resolution.framework.Response.Answer;\n import grakn.core.traversal.Traversal;\n import grakn.core.traversal.TraversalEngine;\n@@ -92,6 +93,7 @@ protected void exception(Throwable e) {\n     protected abstract void receiveFail(Response.Fail fromDownstream, int iteration);\n \n     public void terminate(Throwable cause) {\n+        LOG.error(\"error\", cause);\n         this.terminated = true;\n     }\n "
  },
  {
    "sha": "ddf23e3278b1abcb17822e177109db101ef54c78",
    "filename": "reasoner/resolution/framework/ResponseProducer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 106,
    "changes": 106,
    "blob_url": "https://github.com/graknlabs/grakn/blob/5762344f3c493d0666fa011a331682c6b34ebb87/reasoner/resolution/framework/ResponseProducer.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/5762344f3c493d0666fa011a331682c6b34ebb87/reasoner/resolution/framework/ResponseProducer.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/framework/ResponseProducer.java?ref=5762344f3c493d0666fa011a331682c6b34ebb87",
    "patch": "@@ -1,106 +0,0 @@\n-/*\n- * Copyright (C) 2021 Grakn Labs\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Affero General Public License as\n- * published by the Free Software Foundation, either version 3 of the\n- * License, or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU Affero General Public License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n- *\n- */\n-\n-package grakn.core.reasoner.resolution.framework;\n-\n-import grakn.core.common.iterator.FunctionalIterator;\n-import grakn.core.concept.answer.ConceptMap;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n-\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-public class ResponseProducer {\n-    private final Set<ConceptMap> produced;\n-    private final FunctionalIterator<Partial<?>> newUpstreamAnswers;\n-    private final LinkedHashSet<Request> downstreamProducer;\n-    private final int iteration;\n-    private Iterator<Request> downstreamProducerSelector;\n-\n-    public ResponseProducer(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration) {\n-        this(upstreamAnswers, iteration, new HashSet<>());\n-    }\n-\n-    private ResponseProducer(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration, Set<ConceptMap> produced) {\n-        this.newUpstreamAnswers = upstreamAnswers.filter(partial -> !hasProduced(partial.conceptMap()));\n-        this.iteration = iteration;\n-        this.produced = produced;\n-        downstreamProducer = new LinkedHashSet<>();\n-        downstreamProducerSelector = downstreamProducer.iterator();\n-    }\n-\n-    public void recordProduced(ConceptMap conceptMap) {\n-        produced.add(conceptMap);\n-    }\n-\n-    public boolean hasProduced(ConceptMap conceptMap) {\n-        return produced.contains(conceptMap);\n-    }\n-\n-    public boolean hasUpstreamAnswer() {\n-        return newUpstreamAnswers.hasNext();\n-    }\n-\n-    public FunctionalIterator<Partial<?>> upstreamAnswers() {\n-        return newUpstreamAnswers;\n-    }\n-\n-    public boolean hasDownstreamProducer() {\n-        return !downstreamProducer.isEmpty();\n-    }\n-\n-    public Request nextDownstreamProducer() {\n-        if (!downstreamProducerSelector.hasNext()) downstreamProducerSelector = downstreamProducer.iterator();\n-        return downstreamProducerSelector.next();\n-    }\n-\n-    public void addDownstreamProducer(Request request) {\n-        assert !(downstreamProducer.contains(request)) : \"downstream answer producer already contains this request\";\n-\n-        downstreamProducer.add(request);\n-        downstreamProducerSelector = downstreamProducer.iterator();\n-    }\n-\n-    public void removeDownstreamProducer(Request request) {\n-        boolean removed = downstreamProducer.remove(request);\n-        // only update the iterator when removing an element, to avoid resetting and reusing first request too often\n-        // note: this is a large performance win when processing large batches of requests\n-        if (removed) downstreamProducerSelector = downstreamProducer.iterator();\n-    }\n-\n-    public int iteration() {\n-        return iteration;\n-    }\n-\n-    /**\n-     * Prepare a response producer for the another iteration from this one\n-     */\n-    public ResponseProducer newIteration(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration) {\n-        return new ResponseProducer(upstreamAnswers, iteration, new HashSet<>());\n-    }\n-\n-    /**\n-     * Prepare a response producer for the another iteration from this one\n-     * Notably maintains the set of produced answers for deduplication\n-     */\n-    public ResponseProducer newIterationRetainDedup(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration) {\n-        return new ResponseProducer(upstreamAnswers, iteration, this.produced);\n-    }\n-}"
  },
  {
    "sha": "00726571b4edab79839299d282869b488df4e8db",
    "filename": "reasoner/resolution/resolver/CompoundResolver.java",
    "status": "modified",
    "additions": 6,
    "deletions": 8,
    "changes": 14,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/CompoundResolver.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/CompoundResolver.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/resolver/CompoundResolver.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -18,7 +18,6 @@\n package grakn.core.reasoner.resolution.resolver;\n \n import grakn.core.concept.ConceptManager;\n-import grakn.core.reasoner.resolution.ResolutionRecorder;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n import grakn.core.reasoner.resolution.framework.Request;\n import grakn.core.reasoner.resolution.framework.Resolver;\n@@ -31,6 +30,7 @@\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.Map;\n+import java.util.stream.Stream;\n \n public abstract class CompoundResolver<\n         RESOLVER extends CompoundResolver<RESOLVER, REQ_STATE>,\n@@ -39,15 +39,12 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(CompoundResolver.class);\n \n-    final Driver<ResolutionRecorder> resolutionRecorder;\n     final Map<Request, REQ_STATE> requestStates;\n     boolean isInitialised;\n \n     protected CompoundResolver(Driver<RESOLVER> driver, String name, ResolverRegistry registry,\n-                               TraversalEngine traversalEngine, ConceptManager conceptMgr, boolean resolutionTracing,\n-                               Driver<ResolutionRecorder> resolutionRecorder) {\n+                               TraversalEngine traversalEngine, ConceptManager conceptMgr, boolean resolutionTracing ) {\n         super(driver, name, registry, traversalEngine, conceptMgr, resolutionTracing);\n-        this.resolutionRecorder = resolutionRecorder;\n         this.requestStates = new HashMap<>();\n         this.isInitialised = false;\n     }\n@@ -93,15 +90,16 @@ private REQ_STATE getOrUpdateRequestState(Request fromUpstream, int iteration) {\n             requestStates.put(fromUpstream, requestStateCreate(fromUpstream, iteration));\n         } else {\n             REQ_STATE requestState = requestStates.get(fromUpstream);\n-            assert requestState.iteration() == iteration ||\n-                    requestState.iteration() + 1 == iteration;\n+//            assert requestState.iteration() == iteration ||\n+//                    requestState.iteration() + 1 == iteration;\n \n-            if (requestState.iteration() + 1 == iteration) {\n+            if (requestState.iteration() < iteration) {\n                 // when the same request for the next iteration the first time, re-initialise required state\n                 REQ_STATE responseProducerNextIter = requestStateReiterate(fromUpstream, requestState, iteration);\n                 this.requestStates.put(fromUpstream, responseProducerNextIter);\n             }\n         }\n+        boolean bad = requestStates.values().stream().anyMatch(rs -> rs.iteration() + 1 < iteration);\n         return requestStates.get(fromUpstream);\n     }\n "
  },
  {
    "sha": "2934b6ee0b893e9ea01330ade607240cd4750fb8",
    "filename": "reasoner/resolution/resolver/ConcludableResolver.java",
    "status": "modified",
    "additions": 30,
    "deletions": 29,
    "changes": 59,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConcludableResolver.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConcludableResolver.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/resolver/ConcludableResolver.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -24,13 +24,11 @@\n import grakn.core.concept.ConceptManager;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.logic.LogicManager;\n-import grakn.core.logic.resolvable.Concludable;\n+import grakn.core.logic.Rule;\n import grakn.core.logic.resolvable.Unifier;\n import grakn.core.pattern.Conjunction;\n-import grakn.core.reasoner.resolution.ResolutionRecorder;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n-import grakn.core.reasoner.resolution.answer.AnswerState.Partial.Unified;\n import grakn.core.reasoner.resolution.framework.Request;\n import grakn.core.reasoner.resolution.framework.Resolver;\n import grakn.core.reasoner.resolution.framework.Response;\n@@ -52,27 +50,27 @@\n import static grakn.core.common.iterator.Iterators.iterate;\n \n public class ConcludableResolver extends Resolver<ConcludableResolver> {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(ConcludableResolver.class);\n \n     private final LinkedHashMap<Driver<ConclusionResolver>, Set<Unifier>> applicableRules;\n-    private final Concludable concludable;\n+    private final Map<Driver<ConclusionResolver>, Rule> resolverRules;\n+    private final grakn.core.logic.resolvable.Concludable concludable;\n     private final LogicManager logicMgr;\n     private final Map<Driver<? extends Resolver<?>>, RecursionState> recursionStates;\n-    private final Driver<ResolutionRecorder> resolutionRecorder;\n     private final Map<Request, RequestState> requestStates;\n     private final Set<Identifier.Variable.Retrievable> unboundVars;\n     private boolean isInitialised;\n \n-    public ConcludableResolver(Driver<ConcludableResolver> driver, Concludable concludable,\n-                               Driver<ResolutionRecorder> resolutionRecorder, ResolverRegistry registry,\n-                               TraversalEngine traversalEngine, ConceptManager conceptMgr, LogicManager logicMgr,\n-                               boolean resolutionTracing) {\n+    public ConcludableResolver(Driver<ConcludableResolver> driver, grakn.core.logic.resolvable.Concludable concludable,\n+                               ResolverRegistry registry, TraversalEngine traversalEngine, ConceptManager conceptMgr,\n+                               LogicManager logicMgr, boolean resolutionTracing) {\n         super(driver, ConcludableResolver.class.getSimpleName() + \"(pattern: \" + concludable.pattern() + \")\",\n               registry, traversalEngine, conceptMgr, resolutionTracing);\n         this.logicMgr = logicMgr;\n-        this.resolutionRecorder = resolutionRecorder;\n         this.concludable = concludable;\n         this.applicableRules = new LinkedHashMap<>();\n+        this.resolverRules = new HashMap<>();\n         this.recursionStates = new HashMap<>();\n         this.requestStates = new HashMap<>();\n         this.unboundVars = unboundVars(concludable.pattern());\n@@ -104,16 +102,14 @@ protected void receiveAnswer(Answer fromDownstream, int iteration) {\n         Request fromUpstream = fromUpstream(toDownstream);\n         RequestState requestState = this.requestStates.get(fromUpstream);\n \n-        Partial<?> upstreamAnswer = fromDownstream.answer().asMapped().toUpstream();\n+        Partial.Compound<?, ?> upstreamAnswer = fromDownstream.answer().asConcludable().toUpstreamInferred();\n \n-        if (!requestState.hasProduced(upstreamAnswer.conceptMap())) {\n+        if (upstreamAnswer.isExplain()) {\n+            answerFound(upstreamAnswer, fromUpstream, iteration);\n+        } else if (!requestState.hasProduced(upstreamAnswer.conceptMap())) {\n             requestState.recordProduced(upstreamAnswer.conceptMap());\n             answerFound(upstreamAnswer, fromUpstream, iteration);\n         } else {\n-            if (fromDownstream.answer().recordExplanations()) {\n-                LOG.trace(\"{}: Recording deduplicated answer derivation: {}\", name(), upstreamAnswer);\n-                resolutionRecorder.execute(actor -> actor.record(upstreamAnswer));\n-            }\n             nextAnswer(fromUpstream, requestState, iteration);\n         }\n     }\n@@ -126,9 +122,9 @@ protected void receiveAnswer(Answer fromDownstream, int iteration) {\n     forward them downstream (to parallelise searching for the single answer), and when the first one finds an answer,\n     we respond for all N ahead of time. Then, when the rules actually return an answer to this concludable, we do nothing.\n      */\n-    private void answerFound(Partial<?> upstreamAnswer, Request fromUpstream, int iteration) {\n+    private void answerFound(Partial.Compound<?, ?> upstreamAnswer, Request fromUpstream, int iteration) {\n         RequestState requestState = this.requestStates.get(fromUpstream);\n-        if (requestState.singleAnswerRequired()) {\n+        if (requestState.singleAnswerRequired() && !upstreamAnswer.isExplain()) {\n             requestState.clearDownstreamProducers();\n         }\n         answerToUpstream(upstreamAnswer, fromUpstream, iteration);\n@@ -170,6 +166,7 @@ protected void initialiseDownstreamResolvers() {\n                         Driver<ConclusionResolver> conclusionResolver = registry.registerConclusion(rule.conclusion());\n                         applicableRules.putIfAbsent(conclusionResolver, new HashSet<>());\n                         applicableRules.get(conclusionResolver).add(unifier);\n+                        resolverRules.put(conclusionResolver, rule);\n                     } catch (GraknException e) {\n                         terminate(e);\n                     }\n@@ -179,7 +176,7 @@ protected void initialiseDownstreamResolvers() {\n \n     private void nextAnswer(Request fromUpstream, RequestState requestState, int iteration) {\n         if (requestState.hasUpstreamAnswer()) {\n-            Partial<?> upstreamAnswer = requestState.upstreamAnswers().next();\n+            Partial.Compound<?, ?> upstreamAnswer = requestState.upstreamAnswers().next();\n             requestState.recordProduced(upstreamAnswer.conceptMap());\n             answerFound(upstreamAnswer, fromUpstream, iteration);\n         } else {\n@@ -196,9 +193,9 @@ private RequestState getOrUpdateRequestState(Request fromUpstream, int iteration\n             requestStates.put(fromUpstream, requestStateCreate(fromUpstream, iteration));\n         } else {\n             RequestState requestState = this.requestStates.get(fromUpstream);\n-            assert requestState.iteration() == iteration || requestState.iteration() + 1 == iteration;\n+//            assert requestState.iteration() == iteration || requestState.iteration() + 1 == iteration;\n \n-            if (requestState.iteration() + 1 == iteration) {\n+            if (requestState.iteration() < iteration) {\n                 // when the same request for the next iteration the first time, re-initialise required state\n                 RequestState newRequestState = requestStateCreate(fromUpstream, iteration);\n                 this.requestStates.put(fromUpstream, newRequestState);\n@@ -216,10 +213,13 @@ protected RequestState requestStateCreate(Request fromUpstream, int iteration) {\n             iterationState.nextIteration(iteration);\n         }\n \n-        assert fromUpstream.partialAnswer().isMapped();\n-        FunctionalIterator<Partial<?>> upstreamAnswers =\n+        assert fromUpstream.partialAnswer().isConcludable();\n+        FunctionalIterator<Partial.Compound<?, ?>> upstreamAnswers = fromUpstream.partialAnswer().asConcludable().isExplain() ?\n+                Iterators.empty() :\n                 traversalIterator(concludable.pattern(), fromUpstream.partialAnswer().conceptMap())\n-                        .map(conceptMap -> fromUpstream.partialAnswer().asMapped().aggregateToUpstream(conceptMap));\n+                        .map(conceptMap -> fromUpstream.partialAnswer().asConcludable().asMatch()\n+                                .toUpstreamLookup(conceptMap, concludable.isInferredAnswer(conceptMap))\n+                        );\n \n         boolean singleAnswerRequired = fromUpstream.partialAnswer().conceptMap().concepts().keySet().containsAll(unboundVars());\n         RequestState requestState = new RequestState(upstreamAnswers, iteration, singleAnswerRequired);\n@@ -231,10 +231,11 @@ private void mayRegisterRules(Request fromUpstream, RecursionState recursionStat\n         // loop termination: when receiving a new request, we check if we have seen it before from this root query\n         // if we have, we do not allow rules to be registered as possible downstreams\n         if (!recursionState.hasReceived(fromUpstream.partialAnswer().conceptMap())) {\n+            Partial.Concludable<?> partialAnswer = fromUpstream.partialAnswer().asConcludable();\n             for (Map.Entry<Driver<ConclusionResolver>, Set<Unifier>> entry : applicableRules.entrySet()) {\n                 Driver<ConclusionResolver> conclusionResolver = entry.getKey();\n                 for (Unifier unifier : entry.getValue()) {\n-                    Optional<Unified> unified = fromUpstream.partialAnswer().unifyToDownstream(unifier, conclusionResolver);\n+                    Optional<? extends Partial.Conclusion<?, ?>> unified = partialAnswer.toDownstream(unifier, resolverRules.get(conclusionResolver));\n                     if (unified.isPresent()) {\n                         Request toDownstream = Request.create(driver(), conclusionResolver, unified.get());\n                         requestState.addDownstreamProducer(toDownstream);\n@@ -261,17 +262,17 @@ else if (var.isThing() && !var.asThing().iid().isPresent())\n \n     private static class RequestState {\n         private final Set<ConceptMap> produced;\n-        private final FunctionalIterator<Partial<?>> newUpstreamAnswers;\n+        private final FunctionalIterator<Partial.Compound<?, ?>> newUpstreamAnswers;\n         private final LinkedHashSet<Request> downstreamProducer;\n         private final int iteration;\n         private final boolean singleAnswerRequired;\n         private Iterator<Request> downstreamProducerSelector;\n \n-        public RequestState(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration, boolean singleAnswerRequired) {\n+        public RequestState(FunctionalIterator<Partial.Compound<?, ?>> upstreamAnswers, int iteration, boolean singleAnswerRequired) {\n             this(upstreamAnswers, iteration, singleAnswerRequired, new HashSet<>());\n         }\n \n-        private RequestState(FunctionalIterator<Partial<?>> upstreamAnswers, int iteration, boolean singleAnswerRequired,\n+        private RequestState(FunctionalIterator<Partial.Compound<?, ?>> upstreamAnswers, int iteration, boolean singleAnswerRequired,\n                              Set<ConceptMap> produced) {\n             this.newUpstreamAnswers = upstreamAnswers.filter(partial -> !hasProduced(partial.conceptMap()));\n             this.iteration = iteration;\n@@ -293,7 +294,7 @@ public boolean hasUpstreamAnswer() {\n             return newUpstreamAnswers.hasNext();\n         }\n \n-        public FunctionalIterator<Partial<?>> upstreamAnswers() {\n+        public FunctionalIterator<Partial.Compound<?, ?>> upstreamAnswers() {\n             return newUpstreamAnswers;\n         }\n "
  },
  {
    "sha": "bb31e787f90562692097f0a9d635b611d490f909",
    "filename": "reasoner/resolution/resolver/ConclusionResolver.java",
    "status": "modified",
    "additions": 27,
    "deletions": 31,
    "changes": 58,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConclusionResolver.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConclusionResolver.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/resolver/ConclusionResolver.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -23,9 +23,8 @@\n import grakn.core.concept.ConceptManager;\n import grakn.core.concept.answer.ConceptMap;\n import grakn.core.logic.Rule;\n-import grakn.core.reasoner.resolution.ResolutionRecorder;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n-import grakn.core.reasoner.resolution.answer.AnswerState;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n import grakn.core.reasoner.resolution.framework.Request;\n import grakn.core.reasoner.resolution.framework.Resolver;\n import grakn.core.reasoner.resolution.framework.Response;\n@@ -51,19 +50,16 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(ConclusionResolver.class);\n \n-    private final Driver<ResolutionRecorder> resolutionRecorder;\n     private final Rule.Conclusion conclusion;\n     private final Map<Request, RequestState> requestStates;\n     private Driver<ConditionResolver> ruleResolver;\n     private boolean isInitialised;\n \n     public ConclusionResolver(Driver<ConclusionResolver> driver, Rule.Conclusion conclusion, ResolverRegistry registry,\n-                              Driver<ResolutionRecorder> resolutionRecorder, TraversalEngine traversalEngine,\n-                              ConceptManager conceptMgr, boolean resolutionTracing) {\n-        super(driver, ConclusionResolver.class.getSimpleName() + \"(\" + conclusion.rule().getLabel() + \")\",\n+                              TraversalEngine traversalEngine, ConceptManager conceptMgr, boolean resolutionTracing) {\n+        super(driver, ConclusionResolver.class.getSimpleName() + \"(\" + conclusion + \")\",\n               registry, traversalEngine, conceptMgr, resolutionTracing);\n         this.conclusion = conclusion;\n-        this.resolutionRecorder = resolutionRecorder;\n         this.requestStates = new HashMap<>();\n         this.isInitialised = false;\n     }\n@@ -98,8 +94,8 @@ protected void receiveAnswer(Response.Answer fromDownstream, int iteration) {\n                 .materialise(fromDownstream.answer().conceptMap(), traversalEngine, conceptMgr);\n         if (!materialisations.hasNext()) throw GraknException.of(ILLEGAL_STATE);\n \n-        FunctionalIterator<AnswerState.Partial<?>> materialisedAnswers = materialisations\n-                .map(concepts -> fromUpstream.partialAnswer().asUnified().aggregateToUpstream(concepts))\n+        FunctionalIterator<Partial.Concludable<?>> materialisedAnswers = materialisations\n+                .map(concepts -> fromDownstream.answer().asConclusion().aggregateToUpstream(concepts))\n                 .filter(Optional::isPresent)\n                 .map(Optional::get);\n         requestState.addResponses(materialisedAnswers);\n@@ -143,9 +139,9 @@ protected void initialiseDownstreamResolvers() {\n     }\n \n     private void nextAnswer(Request fromUpstream, RequestState requestState, int iteration) {\n-        Optional<AnswerState.Partial<?>> answer = requestState.nextResponse();\n-        if (answer.isPresent()) {\n-            answerToUpstream(answer.get(), fromUpstream, iteration);\n+        Optional<Partial.Concludable<?>> upstreamAnswer = requestState.nextResponse();\n+        if (upstreamAnswer.isPresent()) {\n+            answerToUpstream(upstreamAnswer.get(), fromUpstream, iteration);\n         } else if (requestState.hasDownstream()) {\n             requestFromDownstream(requestState.nextDownstream(), fromUpstream, iteration);\n         } else {\n@@ -158,10 +154,9 @@ private RequestState getOrUpdateRequestState(Request fromUpstream, int iteration\n             requestStates.put(fromUpstream, createRequestState(fromUpstream, iteration));\n         } else {\n             RequestState requestState = this.requestStates.get(fromUpstream);\n-            assert requestState.iteration() == iteration ||\n-                    requestState.iteration() + 1 == iteration;\n+//            assert requestState.iteration() == iteration || requestState.iteration() + 1 == iteration;\n \n-            if (requestState.iteration() + 1 == iteration) {\n+            if (requestState.iteration() < iteration) {\n                 // when the same request for the next iteration the first time, re-initialise required state\n                 RequestState requestStateNextIter = createRequestState(fromUpstream, iteration);\n                 this.requestStates.put(fromUpstream, requestStateNextIter);\n@@ -175,39 +170,40 @@ private RequestState createRequestState(Request fromUpstream, int iteration) {\n \n         RequestState requestState = new RequestState(iteration);\n \n-        ConceptMap partialAnswer = fromUpstream.partialAnswer().conceptMap();\n+        assert fromUpstream.partialAnswer().isConclusion();\n+        Partial.Conclusion<?, ?> partialAnswer = fromUpstream.partialAnswer().asConclusion();\n         // we do a extra traversal to expand the partial answer if we already have the concept that is meant to be generated\n         // and if there's extra variables to be populated\n-        assert conclusion.retrievableIds().containsAll(partialAnswer.concepts().keySet());\n-        if (conclusion.generating().isPresent() && conclusion.retrievableIds().size() > partialAnswer.concepts().size() &&\n-                partialAnswer.concepts().containsKey(conclusion.generating().get().id())) {\n-            FunctionalIterator<AnswerState.Partial.Filtered> completedAnswers = candidateAnswers(fromUpstream, partialAnswer);\n-            completedAnswers.forEachRemaining(answer -> requestState.addDownstream(Request.create(driver(), ruleResolver,\n-                                                                                                  answer)));\n+        assert conclusion.retrievableIds().containsAll(partialAnswer.conceptMap().concepts().keySet());\n+        if (conclusion.generating().isPresent() && conclusion.retrievableIds().size() > partialAnswer.conceptMap().concepts().size() &&\n+                partialAnswer.conceptMap().concepts().containsKey(conclusion.generating().get().id())) {\n+            FunctionalIterator<Partial.Compound<?, ?>> completedDownstreamAnswers = candidateAnswers(partialAnswer);\n+            completedDownstreamAnswers.forEachRemaining(answer -> requestState.addDownstream(Request.create(driver(), ruleResolver,\n+                                                                                                            answer)));\n         } else {\n             Set<Identifier.Variable.Retrievable> named = iterate(conclusion.retrievableIds()).filter(Identifier::isName).toSet();\n-            AnswerState.Partial.Filtered downstreamAnswer = fromUpstream.partialAnswer().filterToDownstream(named, ruleResolver);\n+            Partial.Compound<?, ?> downstreamAnswer = partialAnswer.toDownstream(named);\n             requestState.addDownstream(Request.create(driver(), ruleResolver, downstreamAnswer));\n         }\n \n         return requestState;\n     }\n \n-    private FunctionalIterator<AnswerState.Partial.Filtered> candidateAnswers(Request fromUpstream, ConceptMap answer) {\n-        Traversal traversal1 = boundTraversal(conclusion.conjunction().traversal(), answer);\n-        FunctionalIterator<ConceptMap> traversal = traversalEngine.iterator(traversal1).map(conceptMgr::conceptMap);\n+    private FunctionalIterator<Partial.Compound<?, ?>> candidateAnswers(Partial.Conclusion<?, ?> partialAnswer) {\n+        Traversal traversal = boundTraversal(conclusion.conjunction().traversal(), partialAnswer.conceptMap());\n+        FunctionalIterator<ConceptMap> answers = traversalEngine.iterator(traversal).map(conceptMgr::conceptMap);\n         Set<Identifier.Variable.Retrievable> named = iterate(conclusion.retrievableIds()).filter(Identifier::isName).toSet();\n-        return traversal.map(ans -> fromUpstream.partialAnswer().asUnified().extend(ans).filterToDownstream(named, ruleResolver));\n+        return answers.map(ans -> partialAnswer.extend(ans).toDownstream(named));\n     }\n \n     @Override\n     public String toString() {\n-        return name() + \": then \" + conclusion.rule().then();\n+        return name();\n     }\n \n     private static class RequestState {\n \n-        private final List<FunctionalIterator<AnswerState.Partial<?>>> materialisedAnswers;\n+        private final List<FunctionalIterator<Partial.Concludable<?>>> materialisedAnswers;\n         private final LinkedHashSet<Request> downstreams;\n         private Iterator<Request> downstreamProducerSelector;\n         private final int iteration;\n@@ -223,11 +219,11 @@ public int iteration() {\n             return iteration;\n         }\n \n-        public void addResponses(FunctionalIterator<AnswerState.Partial<?>> materialisations) {\n+        public void addResponses(FunctionalIterator<Partial.Concludable<?>> materialisations) {\n             materialisedAnswers.add(materialisations);\n         }\n \n-        public Optional<AnswerState.Partial<?>> nextResponse() {\n+        public Optional<Partial.Concludable<?>> nextResponse() {\n             if (hasResponse()) return Optional.of(materialisedAnswers.get(0).next());\n             else return Optional.empty();\n         }"
  },
  {
    "sha": "6c431cf3a502ae3fb2446eec74a4e285bc16994d",
    "filename": "reasoner/resolution/resolver/ConditionResolver.java",
    "status": "modified",
    "additions": 25,
    "deletions": 9,
    "changes": 34,
    "blob_url": "https://github.com/graknlabs/grakn/blob/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConditionResolver.java",
    "raw_url": "https://github.com/graknlabs/grakn/raw/9287106366c0cc10a7419e5436e874c47616bfd8/reasoner/resolution/resolver/ConditionResolver.java",
    "contents_url": "https://api.github.com/repos/graknlabs/grakn/contents/reasoner/resolution/resolver/ConditionResolver.java?ref=9287106366c0cc10a7419e5436e874c47616bfd8",
    "patch": "@@ -21,11 +21,10 @@\n import grakn.core.logic.LogicManager;\n import grakn.core.logic.Rule;\n import grakn.core.logic.resolvable.Concludable;\n-import grakn.core.pattern.Conjunction;\n import grakn.core.reasoner.resolution.Planner;\n-import grakn.core.reasoner.resolution.ResolutionRecorder;\n import grakn.core.reasoner.resolution.ResolverRegistry;\n import grakn.core.reasoner.resolution.answer.AnswerState;\n+import grakn.core.reasoner.resolution.answer.AnswerState.Partial;\n import grakn.core.reasoner.resolution.framework.Request;\n import grakn.core.traversal.TraversalEngine;\n import org.slf4j.Logger;\n@@ -41,16 +40,16 @@\n \n     private final Rule.Condition condition;\n \n-    public ConditionResolver(Driver<ConditionResolver> driver, Rule.Condition condition, Driver<ResolutionRecorder> resolutionRecorder,\n+    public ConditionResolver(Driver<ConditionResolver> driver, Rule.Condition condition,\n                              ResolverRegistry registry, TraversalEngine traversalEngine, ConceptManager conceptMgr,\n                              LogicManager logicMgr, Planner planner, boolean resolutionTracing) {\n-        super(driver, ConditionResolver.class.getCanonicalName() + \"(rule:\" + condition.rule().getLabel() + \")\",\n-              resolutionRecorder, registry, traversalEngine, conceptMgr, logicMgr, planner, resolutionTracing);\n+        super(driver, ConditionResolver.class.getSimpleName() + \"(\" + condition + \")\",\n+               registry, traversalEngine, conceptMgr, logicMgr, planner, resolutionTracing);\n         this.condition = condition;\n     }\n \n     @Override\n-    public Conjunction conjunction() {\n+    public grakn.core.pattern.Conjunction conjunction() {\n         return condition.rule().when();\n     }\n \n@@ -69,8 +68,25 @@ protected void nextAnswer(Request fromUpstream, RequestState requestState, int i\n     }\n \n     @Override\n-    protected Optional<AnswerState> toUpstreamAnswer(AnswerState.Partial<?> fromDownstream) {\n-        return Optional.of(fromDownstream.asFiltered().toUpstream());\n+    boolean tryAcceptUpstreamAnswer(AnswerState upstreamAnswer, Request fromUpstream, int iteration) {\n+        RequestState requestState = requestStates.get(fromUpstream);\n+        if (!requestState.hasProduced(upstreamAnswer.conceptMap())) {\n+            requestState.recordProduced(upstreamAnswer.conceptMap());\n+            answerToUpstream(upstreamAnswer, fromUpstream, iteration);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    protected Optional<AnswerState> toUpstreamAnswer(Partial.Compound<?, ?> partialAnswer) {\n+        assert partialAnswer.isCondition();\n+        if (partialAnswer.asCondition().isExplain()) {\n+            return Optional.of(partialAnswer.asCondition().asExplain().toUpstream(conjunction()));\n+        } else {\n+            return Optional.of(partialAnswer.asCondition().asMatch().toUpstream());\n+        }\n     }\n \n     @Override\n@@ -85,7 +101,7 @@ protected void nextAnswer(Request fromUpstream, RequestState requestState, int i\n \n     @Override\n     public String toString() {\n-        return name() + \": \" + condition.rule().when();\n+        return name();\n     }\n \n }"
  }
]
