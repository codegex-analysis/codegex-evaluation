[
  {
    "sha": "a81a03d98ef123fc5b3059745c976eed9d4db102",
    "filename": "main/src/cgeo/geocaching/filters/core/AbstractFilter.java",
    "status": "added",
    "additions": 35,
    "deletions": 0,
    "changes": 35,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/AbstractFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/AbstractFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/AbstractFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,35 @@\n+package cgeo.geocaching.filters.core;\n+\n+public abstract class AbstractFilter<T> implements IFilter<T> {\n+\n+    private String filterId;\n+\n+    @Override\n+    public void init(final String filterId, final String config) {\n+        this.filterId = filterId;\n+        applyConfig(config);\n+    }\n+\n+    @Override\n+    public String getFilterId() {\n+        return filterId;\n+    }\n+\n+    protected abstract void applyConfig(String config);\n+\n+    @Override\n+    public boolean supportsPartiallyLoadedFiltering() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsDbFiltering() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getSqlWhere() {\n+        return null;\n+    }\n+\n+}"
  },
  {
    "sha": "53bd68ec1f31427a7808a66bf568d406d5004ada",
    "filename": "main/src/cgeo/geocaching/filters/core/AndFilter.java",
    "status": "added",
    "additions": 22,
    "deletions": 0,
    "changes": 22,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/AndFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/AndFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/AndFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,22 @@\n+package cgeo.geocaching.filters.core;\n+\n+import cgeo.geocaching.utils.CollectionStream;\n+\n+public class AndFilter<T> extends LogicalFilter<T> {\n+\n+    @Override\n+    public boolean filter(final T item) {\n+        for (IFilter<T> child : getChildren()) {\n+            if (!child.filter(item)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String getSqlWhere() {\n+        return CollectionStream.of(getChildren())\n+            .map(f -> \"(\" + f.getSqlWhere() + \") \").toJoinedString(\" AND \");\n+    }\n+}"
  },
  {
    "sha": "a22cd77d6475838f13808036a15c3aba02ed12b2",
    "filename": "main/src/cgeo/geocaching/filters/core/FilterFactory.java",
    "status": "added",
    "additions": 226,
    "deletions": 0,
    "changes": 226,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/FilterFactory.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/FilterFactory.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/FilterFactory.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,226 @@\n+package cgeo.geocaching.filters.core;\n+\n+import androidx.annotation.NonNull;\n+import androidx.core.util.Supplier;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class FilterFactory {\n+\n+    private static final String AND_TOKEN = \"AND\";\n+    private static final String OR_TOKEN = \"OR\";\n+    private static final String NOT_TOKEN = \"NOT\";\n+\n+    private static final char OPEN_PAREN = '(';\n+    private static final char CLOSE_PAREN = ')';\n+    private static final char LOGIC_SEPARATOR = ';';\n+    private static final char ESCAPE_CHAR = '\\\\';\n+\n+    private static final Map<String, Map<Class<?>, Supplier<IFilter<?>>>> REGISTERED_SIMPLE_FILE_CREATORS = new HashMap<>();\n+\n+    private FilterFactory() {\n+        //no instane shall be created\n+    }\n+\n+    public static <T> IFilter<T> createFilter(@NonNull final Class<T> clazz, @NonNull final String filterConfig) throws ParseException {\n+        return new Parser<>(clazz, filterConfig).parse();\n+    }\n+\n+    public static String getFilterConfig(@NonNull final IFilter<?> filter) {\n+        final StringBuilder sb = new StringBuilder();\n+        writeFilterConfig(filter, sb);\n+        return sb.toString();\n+    }\n+\n+    public static <T> void registerSimpleFilterCreator(@NonNull final Class<? extends T> clazz, @NonNull final String filterId, @NonNull final Supplier<IFilter<T>> creator) {\n+        Map<Class<?>, Supplier<IFilter<?>>> idMap = REGISTERED_SIMPLE_FILE_CREATORS.get(filterId);\n+        if (idMap == null) {\n+            idMap = new HashMap<>();\n+            REGISTERED_SIMPLE_FILE_CREATORS.put(filterId, idMap);\n+        }\n+        idMap.put(clazz, (Supplier<IFilter<?>>) ((Object) creator));\n+    }\n+\n+    private static void writeFilterConfig(final IFilter<?> filter, final StringBuilder stringBuilder) {\n+        if (filter instanceof LogicalFilter<?>) {\n+            if (filter instanceof AndFilter<?>) {\n+                stringBuilder.append(AND_TOKEN);\n+            }\n+            if (filter instanceof OrFilter<?>) {\n+                stringBuilder.append(OR_TOKEN);\n+            }\n+            if (filter instanceof NotFilter<?>) {\n+                stringBuilder.append(NOT_TOKEN);\n+            }\n+            stringBuilder.append(OPEN_PAREN);\n+            boolean first = true;\n+            for (IFilter<?> child : ((LogicalFilter<?>) filter).getChildren()) {\n+                if (!first) {\n+                    stringBuilder.append(LOGIC_SEPARATOR);\n+                }\n+                first = false;\n+                writeFilterConfig(child, stringBuilder);\n+            }\n+            stringBuilder.append(CLOSE_PAREN);\n+        } else {\n+          stringBuilder.append(filter.getFilterId()).append(\":\").append(filter.getConfig()\n+              .replaceAll(\"\"  + ESCAPE_CHAR + ESCAPE_CHAR, \"\"  + ESCAPE_CHAR + ESCAPE_CHAR + ESCAPE_CHAR + ESCAPE_CHAR)\n+              .replaceAll(\"\" + LOGIC_SEPARATOR, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + LOGIC_SEPARATOR)\n+              .replaceAll(\"\" + ESCAPE_CHAR + CLOSE_PAREN, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + CLOSE_PAREN)\n+          );\n+        }\n+    }\n+\n+    private static class Parser<TT> {\n+        private final String config;\n+        private final Class<TT> clazz;\n+        private int idx = 0;\n+\n+        Parser(final Class<TT> clazz, final String config) {\n+            this.clazz = clazz;\n+            this.config = config;\n+        }\n+\n+        @NonNull\n+        public IFilter<TT> parse() throws ParseException {\n+            final IFilter<TT> result = parseNext();\n+            skipWhitespaces();\n+            if (config.length() != idx) {\n+                throwParseException(\"Unexpected leftover in expression\");\n+            }\n+            return result;\n+        }\n+\n+        /** Parses next expression starting from idx and leaving idx at next token AFTER expression */\n+        private IFilter<TT> parseNext() throws ParseException {\n+            checkEndOfExpression();\n+            final boolean isAnd = config.startsWith(AND_TOKEN, idx);\n+            final boolean isOr = config.startsWith(OR_TOKEN, idx);\n+            final boolean isNot = config.startsWith(NOT_TOKEN, idx);\n+            if (isAnd || isOr || isNot) {\n+                final LogicalFilter<TT> logicalFilter = isAnd ? new AndFilter<>() : (isOr ? new OrFilter<>() : new NotFilter<>());\n+                idx += isAnd ? AND_TOKEN.length() : (isOr ? OR_TOKEN.length() : NOT_TOKEN.length());\n+                checkEndOfExpression();\n+                if (config.charAt(idx) != OPEN_PAREN) {\n+                    throwParseException(\"GroupToken must be followed by parenthesis\");\n+                }\n+                idx++;\n+                final List<IFilter<TT>> children = new ArrayList<>();\n+                while (true) {\n+                    final IFilter<TT> child = parseNext();\n+                    children.add(child);\n+                    checkEndOfExpression();\n+                    if (config.charAt(idx) == CLOSE_PAREN) {\n+                        idx++;\n+                        logicalFilter.setChildren(children);\n+                        return logicalFilter;\n+                    }\n+                    if (config.charAt(idx) == LOGIC_SEPARATOR) {\n+                        idx++;\n+                    }\n+                }\n+            } else {\n+                return getSimpleFilter(clazz, parseToNextDelim());\n+            }\n+        }\n+\n+        private String parseToNextDelim()  {\n+            final StringBuilder result = new StringBuilder();\n+            boolean nextCharIsEscaped = false;\n+            boolean done = false;\n+            while (!done) {\n+                if (idx >= config.length()) {\n+                    break;\n+                }\n+                final char c = config.charAt(idx);\n+                switch (c) {\n+                    case '\\\\':\n+                        if (nextCharIsEscaped) {\n+                            result.append('\\\\');\n+                        }\n+                        nextCharIsEscaped = !nextCharIsEscaped;\n+                        break;\n+                    case LOGIC_SEPARATOR:\n+                    case CLOSE_PAREN:\n+                        if (!nextCharIsEscaped) {\n+                            done = true;\n+                            break;\n+                        }\n+                        result.append(c);\n+                        nextCharIsEscaped = false;\n+                        break;\n+                    default:\n+                        result.append(c);\n+                        nextCharIsEscaped = false;\n+                        break;\n+                }\n+                if (!done) {\n+                    idx++;\n+                }\n+            }\n+            return result.toString();\n+        }\n+\n+        private <T> IFilter<T> getSimpleFilter(final Class<T> clazz, final String filterConfig) throws ParseException {\n+            final int idx = filterConfig.indexOf(\":\");\n+            if (idx < 0) {\n+                throwParseException(\"FilterId not parseable: '\" + filterConfig + \"'\");\n+            }\n+            final String filterId = filterConfig.substring(0, idx).trim();\n+            final String config = filterConfig.substring(idx + 1); //do NOT trim() the config! Whitespace might be meaningful to filter\n+\n+            IFilter<T> result = null;\n+            final Map<Class<?>, Supplier<IFilter<?>>> idMap = REGISTERED_SIMPLE_FILE_CREATORS.get(filterId);\n+            if (idMap != null) {\n+                Supplier<IFilter<?>> creator = idMap.get(clazz);\n+                if (creator == null) {\n+                    for (Class<?> c : idMap.keySet()) {\n+                        if (c.isAssignableFrom(clazz)) {\n+                            creator = idMap.get(c);\n+                        }\n+                    }\n+                }\n+                if (creator != null) {\n+                    result = (IFilter<T>) creator.get();\n+                }\n+            }\n+\n+            if (result == null) {\n+                throwParseException(\"No filter found for id '\" + filterId + \"'\");\n+            }\n+\n+            result.init(filterId, config);\n+\n+            return result;\n+        }\n+\n+        private void skipWhitespaces() {\n+            while (idx < config.length() && Character.isWhitespace(config.charAt(idx))) {\n+                idx++;\n+            }\n+        }\n+\n+        private void checkEndOfExpression() throws ParseException {\n+            skipWhitespaces();\n+            if (idx >= config.length()) {\n+                throwParseException(\"Unexpected end of expression\");\n+            }\n+        }\n+\n+        private void throwParseException(final String message) throws ParseException {\n+            String markedConfig = config;\n+            if (idx >= config.length()) {\n+                markedConfig += \"[]\";\n+            } else {\n+                markedConfig = markedConfig.substring(0, idx) + \"[\" + markedConfig.charAt(idx) + \"]\" + markedConfig.substring(idx + 1);\n+            }\n+            throw new ParseException(\"Problem parsing '\" + markedConfig + \"' (pos marked with []: \" + idx + \"): \" + message, idx);\n+\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "898034a30e39f1020c437f85a54b8474981bc1b6",
    "filename": "main/src/cgeo/geocaching/filters/core/IFilter.java",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/IFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/IFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/IFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,20 @@\n+package cgeo.geocaching.filters.core;\n+\n+public interface IFilter<T> {\n+\n+    String getFilterId();\n+\n+    void init(String filterId, String config);\n+\n+    boolean supportsPartiallyLoadedFiltering();\n+\n+    boolean filter(T item);\n+\n+    boolean supportsDbFiltering();\n+\n+    String getSqlWhere();\n+\n+\n+    String getConfig();\n+\n+}"
  },
  {
    "sha": "b7287b4e456f6bf3fc0d118317d6ef651b603008",
    "filename": "main/src/cgeo/geocaching/filters/core/LogicalFilter.java",
    "status": "added",
    "additions": 53,
    "deletions": 0,
    "changes": 53,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/LogicalFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/LogicalFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/LogicalFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,53 @@\n+package cgeo.geocaching.filters.core;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public abstract class LogicalFilter<T> implements IFilter<T> {\n+\n+    private final List<IFilter<T>> children = new ArrayList<>();\n+\n+    @Override\n+    public void init(final String filterId, final String params) {\n+        //do nothing\n+    }\n+\n+    @Override\n+    public String getFilterId() {\n+        return null;\n+    }\n+\n+    protected List<IFilter<T>> getChildren() {\n+        return children;\n+    }\n+\n+    public void setChildren(final List<IFilter<T>> children) {\n+        this.children.clear();\n+        this.children.addAll(children);\n+    }\n+\n+    @Override\n+    public boolean supportsPartiallyLoadedFiltering() {\n+        for (IFilter<T> child : this.children) {\n+            if (!child.supportsPartiallyLoadedFiltering()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsDbFiltering() {\n+        for (IFilter<T> child : this.children) {\n+            if (!child.supportsDbFiltering()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String getConfig() {\n+        return null;\n+    }\n+}"
  },
  {
    "sha": "469915d666fbbe35f183d9a3d43912df7ee834b9",
    "filename": "main/src/cgeo/geocaching/filters/core/NotFilter.java",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/NotFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/NotFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/NotFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,15 @@\n+package cgeo.geocaching.filters.core;\n+\n+public class NotFilter<T> extends LogicalFilter<T> {\n+\n+\n+    @Override\n+    public boolean filter(final T item) {\n+        return !getChildren().isEmpty() && !getChildren().get(0).filter(item);\n+    }\n+\n+    @Override\n+    public String getSqlWhere() {\n+        return \"NOT (\" + getChildren().get(0).getSqlWhere() + \")\";\n+    }\n+}"
  },
  {
    "sha": "df0f9e5d859b9be7d18bea5dfca1dd0194c291fe",
    "filename": "main/src/cgeo/geocaching/filters/core/OrFilter.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/OrFilter.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/filters/core/OrFilter.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/filters/core/OrFilter.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,23 @@\n+package cgeo.geocaching.filters.core;\n+\n+import cgeo.geocaching.utils.CollectionStream;\n+\n+public class OrFilter<T> extends LogicalFilter<T> {\n+\n+\n+    @Override\n+    public boolean filter(final T item) {\n+        for (IFilter<T> child : getChildren()) {\n+            if (child.filter(item)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String getSqlWhere() {\n+        return CollectionStream.of(getChildren())\n+            .map(f -> \"(\" + f.getSqlWhere() + \") \").toJoinedString(\" OR \");\n+    }\n+}"
  },
  {
    "sha": "3fe6c04ef2f4a95e55004eea6a2d459fedc69bb5",
    "filename": "main/src/cgeo/geocaching/utils/expressions/ExpressionParser.java",
    "status": "added",
    "additions": 207,
    "deletions": 0,
    "changes": 207,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/ExpressionParser.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/ExpressionParser.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/utils/expressions/ExpressionParser.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,207 @@\n+package cgeo.geocaching.utils.expressions;\n+\n+import androidx.annotation.NonNull;\n+import androidx.core.util.Supplier;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ExpressionParser<T extends IExpression<T>> {\n+\n+\n+    private static final char OPEN_PAREN = '(';\n+    private static final char CLOSE_PAREN = ')';\n+    private static final char LOGIC_SEPARATOR = ';';\n+    private static final char TYPEID_CONFIG_SEPARATOR = ':';\n+    private static final char ESCAPE_CHAR = (char) 92; //backslash\n+\n+    private final Map<String, Supplier<T>> registeredExpressions = new HashMap<>();\n+\n+\n+    public ExpressionParser<T> register(final Supplier<T> expressionCreator) {\n+        final String typeId = expressionCreator.get().getTypeId();\n+        this.registeredExpressions.put(typeId == null ? \"\" : typeId.trim(), expressionCreator);\n+        return this;\n+    }\n+\n+    public T create(@NonNull final String config) throws ParseException {\n+        return new Parser(config).parse();\n+    }\n+\n+    public String getConfig(@NonNull final T exp) {\n+        final StringBuilder sb = new StringBuilder();\n+        writeConfig(exp, sb);\n+        return sb.toString();\n+    }\n+\n+\n+    private void writeConfig(final T exp, final StringBuilder stringBuilder) {\n+        stringBuilder.append(escape(exp.getTypeId()));\n+        final String expConfig = exp.getConfig();\n+        if (expConfig != null) {\n+            stringBuilder.append(TYPEID_CONFIG_SEPARATOR).append(escape(expConfig));\n+        }\n+        final List<T> children = exp.getChildren();\n+        if (children != null && !children.isEmpty()) {\n+            stringBuilder.append(OPEN_PAREN);\n+            boolean first = true;\n+            for (T child : children) {\n+                if (!first) {\n+                    stringBuilder.append(LOGIC_SEPARATOR);\n+                }\n+                first = false;\n+                writeConfig(child, stringBuilder);\n+            }\n+            stringBuilder.append(CLOSE_PAREN);\n+        }\n+    }\n+\n+    private String escape(final String raw) {\n+        return raw.replaceAll(\"\"  + ESCAPE_CHAR + ESCAPE_CHAR, \"\"  + ESCAPE_CHAR + ESCAPE_CHAR + ESCAPE_CHAR + ESCAPE_CHAR)\n+            .replaceAll(\"\" + LOGIC_SEPARATOR, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + LOGIC_SEPARATOR)\n+            .replaceAll(\"\" + TYPEID_CONFIG_SEPARATOR, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + TYPEID_CONFIG_SEPARATOR)\n+            .replaceAll(\"\" + ESCAPE_CHAR + OPEN_PAREN, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + OPEN_PAREN)\n+            .replaceAll(\"\" + ESCAPE_CHAR + CLOSE_PAREN, \"\" + ESCAPE_CHAR + ESCAPE_CHAR + CLOSE_PAREN);\n+\n+    }\n+\n+    private class Parser {\n+        private final String config;\n+        private int idx = 0;\n+\n+        Parser(final String config) {\n+            this.config = config;\n+        }\n+\n+        @NonNull\n+        public T parse() throws ParseException {\n+            final T result = parseNext();\n+            skipWhitespaces();\n+            if (config.length() != idx) {\n+                throwParseException(\"Unexpected leftover in expression\");\n+            }\n+            return result;\n+        }\n+\n+        /** Parses next expression starting from idx and leaving idx at next token AFTER expression */\n+        private T parseNext() throws ParseException {\n+            checkEndOfExpression();\n+            final T exp = parseNextExpression();\n+            skipWhitespaces();\n+\n+            if (idx >= config.length() || config.charAt(idx) != OPEN_PAREN) {\n+                return exp;\n+            }\n+\n+            idx++;\n+            while (true) {\n+                exp.addChild(parseNext());\n+                checkEndOfExpression();\n+                boolean isClosingParen = config.charAt(idx) == CLOSE_PAREN;\n+                if (!isClosingParen && config.charAt(idx) != LOGIC_SEPARATOR) {\n+                    throwParseException(\"Expected '\" + CLOSE_PAREN + \"' or '\" + LOGIC_SEPARATOR + \"' but found '\" + config.charAt(idx) + \"'\");\n+                }\n+                idx++;\n+                if (isClosingParen) {\n+                    return exp;\n+                }\n+            }\n+        }\n+\n+        private T parseNextExpression() throws ParseException {\n+            final String typeId = parseToNextDelim().trim();\n+\n+            String typeConfig = null;\n+            if (idx < config.length() && config.charAt(idx) == TYPEID_CONFIG_SEPARATOR) {\n+                idx++;\n+                typeConfig = parseToNextDelim().trim();\n+            }\n+            if (typeId.isEmpty() && typeConfig == null) {\n+                throwParseException(\"Expression expected, but none was found\");\n+            }\n+\n+            final T expression;\n+            if (registeredExpressions.containsKey(typeId)) {\n+                expression = registeredExpressions.get(typeId).get();\n+                if (typeConfig != null) {\n+                    expression.setConfig(typeConfig);\n+                }\n+            } else if (registeredExpressions.containsKey(\"\") && typeConfig == null) {\n+                expression = registeredExpressions.get(\"\").get();\n+                expression.setConfig(typeId);\n+            } else  {\n+                expression = null; //make compiler happy, value will never be used\n+                throwParseException(\"No expression type found for id '\" + typeId + \"' and no default expression could be applied\");\n+            }\n+\n+            return expression;\n+        }\n+\n+        private String parseToNextDelim()  {\n+            final StringBuilder result = new StringBuilder();\n+            boolean nextCharIsEscaped = false;\n+            boolean done = false;\n+            while (!done) {\n+                if (idx >= config.length()) {\n+                    break;\n+                }\n+                final char c = config.charAt(idx);\n+                switch (c) {\n+                    case ESCAPE_CHAR:\n+                        if (nextCharIsEscaped) {\n+                            result.append(ESCAPE_CHAR);\n+                        }\n+                        nextCharIsEscaped = !nextCharIsEscaped;\n+                        break;\n+                    case TYPEID_CONFIG_SEPARATOR:\n+                    case LOGIC_SEPARATOR:\n+                    case OPEN_PAREN:\n+                    case CLOSE_PAREN:\n+                        if (!nextCharIsEscaped) {\n+                            done = true;\n+                            break;\n+                        }\n+                        result.append(c);\n+                        nextCharIsEscaped = false;\n+                        break;\n+                    default:\n+                        result.append(c);\n+                        nextCharIsEscaped = false;\n+                        break;\n+                }\n+                if (!done) {\n+                    idx++;\n+                }\n+            }\n+            return result.toString();\n+        }\n+\n+        private void skipWhitespaces() {\n+            while (idx < config.length() && Character.isWhitespace(config.charAt(idx))) {\n+                idx++;\n+            }\n+        }\n+\n+        private void checkEndOfExpression() throws ParseException {\n+            skipWhitespaces();\n+            if (idx >= config.length()) {\n+                throwParseException(\"Unexpected end of expression\");\n+            }\n+        }\n+\n+        private void throwParseException(final String message) throws ParseException {\n+            String markedConfig = config;\n+            if (idx >= config.length()) {\n+                markedConfig += \"[]\";\n+            } else {\n+                markedConfig = markedConfig.substring(0, idx) + \"[\" + markedConfig.charAt(idx) + \"]\" + markedConfig.substring(idx + 1);\n+            }\n+            throw new ParseException(\"Problem parsing '\" + markedConfig + \"' (pos marked with []: \" + idx + \"): \" + message, idx);\n+\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "a11afbcbfc2be2822a740b82895701f4e05fd045",
    "filename": "main/src/cgeo/geocaching/utils/expressions/IExpression.java",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/IExpression.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/IExpression.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/utils/expressions/IExpression.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,17 @@\n+package cgeo.geocaching.utils.expressions;\n+\n+import java.util.List;\n+\n+public interface IExpression<T extends IExpression> {\n+\n+    String getTypeId();\n+\n+    void setConfig(String value);\n+\n+    String getConfig();\n+\n+    void addChild(T child);\n+\n+    List<T> getChildren();\n+\n+}"
  },
  {
    "sha": "e27cc3578707fab0ff4a60f0dddb799248a5535c",
    "filename": "main/src/cgeo/geocaching/utils/expressions/LambdaExpression.java",
    "status": "added",
    "additions": 67,
    "deletions": 0,
    "changes": 67,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/LambdaExpression.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/expressions/LambdaExpression.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/utils/expressions/LambdaExpression.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,67 @@\n+package cgeo.geocaching.utils.expressions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import cgeo.geocaching.utils.functions.Func2;\n+import cgeo.geocaching.utils.functions.Func3;\n+\n+public class LambdaExpression<P, R> implements IExpression<LambdaExpression<P, R>> {\n+\n+\n+    private final String typeId;\n+    private final Func2<String, P, R> valueFunction;\n+    private final Func3<String, P, List<R>, R> groupFunction;\n+\n+    private final List<LambdaExpression<P, R>> children = new ArrayList<>();\n+\n+    private String config;\n+\n+    public LambdaExpression(final String typeId, final Func2<String, P, R> function) {\n+        this.typeId = typeId;\n+        this.valueFunction = function;\n+        this.groupFunction = null;\n+    }\n+\n+    public LambdaExpression(final String typeId, final Func3<String, P, List<R>, R> function) {\n+        this.typeId = typeId;\n+        this.valueFunction = null;\n+        this.groupFunction = function;\n+    }\n+\n+    @Override\n+    public void setConfig(final String config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public String getConfig() {\n+        return config;\n+    }\n+\n+    @Override\n+    public void addChild(final LambdaExpression<P, R> child) {\n+        children.add(child);\n+    }\n+\n+    @Override\n+    public List<LambdaExpression<P, R>> getChildren() {\n+        return children;\n+    }\n+\n+    @Override\n+    public String getTypeId() {\n+        return typeId;\n+    }\n+\n+    public R call(final P param) {\n+        if (valueFunction != null) {\n+            return valueFunction.call(config, param);\n+        }\n+        final List<R> result = new ArrayList<>();\n+        for (LambdaExpression<P, R> child : getChildren()) {\n+            result.add(child.call(param));\n+        }\n+        return groupFunction.call(getConfig(),  param, result);\n+    }\n+}"
  },
  {
    "sha": "8b5599724ad1d466e67af2257f6f0ad5399b3581",
    "filename": "main/src/cgeo/geocaching/utils/functions/Func2.java",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/functions/Func2.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/functions/Func2.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/utils/functions/Func2.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,5 @@\n+package cgeo.geocaching.utils.functions;\n+\n+public interface Func2<A, B, R> {\n+    R call(A a, B b);\n+}"
  },
  {
    "sha": "9d853e489f2af857ef70206648cc500f9b45212d",
    "filename": "main/src/cgeo/geocaching/utils/functions/Func3.java",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/functions/Func3.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/main/src/cgeo/geocaching/utils/functions/Func3.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/utils/functions/Func3.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,5 @@\n+package cgeo.geocaching.utils.functions;\n+\n+public interface Func3<A, B, C, R> {\n+    R call(A a, B b, C c);\n+}"
  },
  {
    "sha": "a65d4c049c20f7f8cfb735ef4c6197a204ed9fd7",
    "filename": "tests/src/cgeo/geocaching/filters/core/FilterFactoryTest.java",
    "status": "added",
    "additions": 130,
    "deletions": 0,
    "changes": 130,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/tests/src/cgeo/geocaching/filters/core/FilterFactoryTest.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/tests/src/cgeo/geocaching/filters/core/FilterFactoryTest.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/tests/src/cgeo/geocaching/filters/core/FilterFactoryTest.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,130 @@\n+package cgeo.geocaching.filters.core;\n+\n+import java.text.ParseException;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+import static org.assertj.core.api.Java6Assertions.fail;\n+\n+public class FilterFactoryTest {\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        FilterFactory.registerSimpleFilterCreator(CharSequence.class, \"contains\", CharSequenceContainsFilter::new);\n+        FilterFactory.registerSimpleFilterCreator(String.class, \"startswith\", StringStartsWithFilter::new);\n+    }\n+\n+    @Test\n+    public void simpleRoundtripFilterTest() throws ParseException {\n+        final String testFilterConfig = \"contains:test\";\n+\n+        final IFilter<String> someFilter = FilterFactory.createFilter(String.class, testFilterConfig);\n+        assertThat(someFilter.filter(\"this is a test\")).isTrue();\n+        assertThat(someFilter.filter(\"cgeono\")).isFalse();\n+\n+        final String filterConfig = FilterFactory.getFilterConfig(someFilter);\n+        assertThat(filterConfig).isEqualTo(testFilterConfig);\n+    }\n+\n+    @Test\n+    public void simpleFilterWithWhitespaces() throws ParseException {\n+        final String testFilterConfig = \"  AND ( contains  :test; NOT (  startswith :cgeo) )  \";\n+\n+        final IFilter<String> someFilter = FilterFactory.createFilter(String.class, testFilterConfig);\n+        assertThat(someFilter.filter(\"this is a test\")).isTrue();\n+        assertThat(someFilter.filter(\"cgeotest\")).isFalse();\n+    }\n+\n+    @Test\n+    public void simpleLogicRoundtripFilterTest() throws ParseException {\n+        final String testFilterConfig = \"AND(contains:test;NOT(startswith:cgeo))\";\n+\n+        final IFilter<String> someFilter = FilterFactory.createFilter(String.class, testFilterConfig);\n+        assertThat(someFilter.filter(\"test\")).isTrue();\n+        assertThat(someFilter.filter(\"cgeotest\")).isFalse();\n+\n+        final String filterConfig = FilterFactory.getFilterConfig(someFilter);\n+        assertThat(filterConfig).isEqualTo(testFilterConfig);\n+    }\n+\n+    @Test\n+    public void escapeCharacters() throws ParseException {\n+        final String testFilterConfig = \"AND(contains:a\\\\;a;NOT(OR(startswith:\\\\);startswith:\\\\\\\\)))\";\n+\n+        final IFilter<String> someFilter = FilterFactory.createFilter(String.class, testFilterConfig);\n+        assertThat(someFilter.filter(\"this is a;a test\")).isTrue();\n+        assertThat(someFilter.filter(\"this is a;;a test\")).isFalse();\n+        assertThat(someFilter.filter(\"\\\\this is a;a test\")).isFalse();\n+        assertThat(someFilter.filter(\")this is a;a test\")).isFalse();\n+\n+        final String filterConfig = FilterFactory.getFilterConfig(someFilter);\n+        assertThat(filterConfig).isEqualTo(testFilterConfig);\n+    }\n+\n+    @Test\n+    public void parsingErrors() throws ParseException {\n+\n+        assertParseException(\"Unexpected end of expression\", () -> FilterFactory.createFilter(String.class, \"\"));\n+        assertParseException(\"FilterId not parseable\", () -> FilterFactory.createFilter(String.class, \"()\"));\n+        assertParseException(\"Unexpected end of expression\", () -> FilterFactory.createFilter(String.class, \"AND(contains:test\"));\n+        assertParseException(\"Unexpected end of expression\", () -> FilterFactory.createFilter(String.class, \"AND(contains:test;\"));\n+        assertParseException(\"FilterId not parseable\", () -> FilterFactory.createFilter(String.class, \"AND(contains)\"));\n+        assertParseException(\"No filter found for id\", () -> FilterFactory.createFilter(String.class, \"AND(notexisting:test;\"));\n+        assertParseException(\"Unexpected leftover in expression\", () -> FilterFactory.createFilter(String.class, \"AND(contains:test)a\"));\n+    }\n+\n+    @FunctionalInterface\n+    public interface MethodWithParseException {\n+        void call() throws ParseException;\n+    }\n+\n+    private void assertParseException(final String expectedMessageContains, final MethodWithParseException c) {\n+        try {\n+            c.call();\n+            fail(\"Expected ParseException\");\n+        } catch (ParseException pe) {\n+            assertThat(pe.getMessage()).as(\"ParsingException message\").contains(expectedMessageContains);\n+        }\n+    }\n+\n+    public static class CharSequenceContainsFilter extends AbstractFilter<CharSequence> {\n+\n+        private String contains;\n+\n+        @Override\n+        protected void applyConfig(final String config) {\n+            this.contains = config;\n+        }\n+\n+        @Override\n+        public boolean filter(final CharSequence item) {\n+            return item.toString().contains(contains);\n+        }\n+\n+        @Override\n+        public String getConfig() {\n+            return contains;\n+        }\n+    }\n+\n+    public static class StringStartsWithFilter extends AbstractFilter<String> {\n+\n+        private String startsWith;\n+\n+        @Override\n+        protected void applyConfig(final String config) {\n+            this.startsWith = config;\n+        }\n+\n+        @Override\n+        public boolean filter(final String item) {\n+            return item.startsWith(startsWith);\n+        }\n+\n+        @Override\n+        public String getConfig() {\n+            return startsWith;\n+        }\n+    }\n+}"
  },
  {
    "sha": "4ff3ae8611677e03a3a859604f4130ed0430d108",
    "filename": "tests/src/cgeo/geocaching/utils/expressions/ExpressionParserTest.java",
    "status": "added",
    "additions": 138,
    "deletions": 0,
    "changes": 138,
    "blob_url": "https://github.com/cgeo/cgeo/blob/7093385c5e9e668eb7cc25855d24878e3bb9a35b/tests/src/cgeo/geocaching/utils/expressions/ExpressionParserTest.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/7093385c5e9e668eb7cc25855d24878e3bb9a35b/tests/src/cgeo/geocaching/utils/expressions/ExpressionParserTest.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/tests/src/cgeo/geocaching/utils/expressions/ExpressionParserTest.java?ref=7093385c5e9e668eb7cc25855d24878e3bb9a35b",
    "patch": "@@ -0,0 +1,138 @@\n+package cgeo.geocaching.utils.expressions;\n+\n+import android.content.Intent;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.text.ParseException;\n+\n+import cgeo.geocaching.filters.core.FilterFactory;\n+import cgeo.geocaching.filters.core.FilterFactoryTest;\n+\n+import static org.assertj.core.api.Java6Assertions.assertThat;\n+import static org.assertj.core.api.Java6Assertions.fail;\n+\n+public class ExpressionParserTest {\n+\n+    private final ExpressionParser<LambdaExpression<Integer, Integer>> calculator = new ExpressionParser<>();\n+\n+    @Before\n+    public void before() {\n+        calculator\n+            .register(() -> new LambdaExpression<>(\"\", (s, i) -> Integer.parseInt(s)))\n+            .register(() -> new LambdaExpression<>(\"x\", (s, i) -> i))\n+            .register(() -> new LambdaExpression<>(\"length\", (s, i) -> s == null ? 0 : s.length()))\n+            .register(() -> new LambdaExpression<>(\"+\", (s, i, list) -> {\n+                int res = 0;\n+                for(Integer in : list) {\n+                    res += in;\n+                }\n+                return res;\n+            }))\n+            .register(() -> new LambdaExpression<>(\"-\", (s, i, list) -> {\n+                int res = 0;\n+                boolean first = true;\n+                for (Integer in : list) {\n+                    if (first) {\n+                        res = in;\n+                    } else {\n+                        res -= in;\n+                    }\n+                    first = false;\n+                }\n+                return res;\n+            }))\n+            .register(() -> new LambdaExpression<>(\"*\", (s, i, list) -> {\n+            int res = list.isEmpty() ? 0 : 1;\n+            for (Integer in : list) {\n+                res *= in;\n+            }\n+            return res;\n+            }))\n+            .register(() -> new LambdaExpression<>(\":\", (s, i, list) -> {\n+                int res = 0;\n+                boolean first = true;\n+                for (Integer in : list) {\n+                    if (first) {\n+                        res = in;\n+                    } else {\n+                        res /= in;\n+                    }\n+                    first = false;\n+                }\n+                return res;\n+            }))\n+            .register(() -> new LambdaExpression<>(\"^\", (s, i, list) -> {\n+                int res = 0;\n+                final int factor = s == null ? 1 : Integer.parseInt(s);\n+                for (Integer in : list) {\n+                    res += Math.pow(in, factor);\n+                }\n+                return res;\n+            }));\n+    }\n+\n+    @Test\n+    public void simple() throws ParseException {\n+        assertLambdaExpression(\":2\", true, 0, 2);\n+        assertLambdaExpression(\"2\", false, 0, 2);\n+        assertLambdaExpression(\"x\", true, 3, 3);\n+        assertLambdaExpression(\"length:abcde\", true, 0, 5);\n+    }\n+\n+    @Test\n+    public void simpleGroup() throws ParseException {\n+        assertLambdaExpression(\"+(:2;:3;x)\", true, 4, 9);\n+    }\n+\n+    @Test\n+    public void escapedCharacters() throws ParseException {\n+        assertLambdaExpression(\"\\\\::notused(*(length:\\\\)\\\\:\\\\\\\\\\\\(b\\\\;;:4);x)\", true, 8, 3); //length should be 6\n+    }\n+\n+    @Test\n+    public void whitespaces() throws ParseException {\n+        assertLambdaExpression(\"  length  :  1234567  \", false, 0, 7);\n+        assertLambdaExpression(\"   +   (  length  :  1234567  ;   :  1   ;   x ; -  (  3  ;  1  )  )  \", false, 8, 18);\n+    }\n+\n+    @Test\n+    public void parameterizedGroupExpression() throws ParseException {\n+        assertLambdaExpression(\"^:2(x;:2)\", true, 5, 29);\n+    }\n+\n+    @Test\n+    public void parsingErrors() {\n+        assertParseException(\"\", \"Unexpected end of expression\");\n+        assertParseException(\"()\", \"Expression expected, but none was found\");\n+        assertParseException(\"+(5;3\", \"Unexpected end of expression\");\n+        assertParseException(\"+(5;3;\", \"Unexpected end of expression\");\n+        assertParseException(\"+(nonexisting:x)\", \"No expression type found for id\");\n+        assertParseException(\"+(3;x)a\", \"Unexpected leftover in expression\");\n+    }\n+\n+    private void assertParseException(final String expressionString, final String expectedMessageContains) {\n+        try {\n+            final LambdaExpression<Integer, Integer> exp = calculator.create(expressionString);\n+            fail(\"Expected ParseException for '\" + expressionString + \"', but got: '\" + calculator.getConfig(exp) + \"'\");\n+        } catch (ParseException pe) {\n+            assertThat(pe.getMessage()).as(\"ParsingException message\").contains(expectedMessageContains);\n+        }\n+    }\n+\n+    private void assertLambdaExpression(final String expressionString, final boolean testConfigEquality, final Integer ... paramExpextedResultPairs) throws ParseException {\n+        final LambdaExpression<Integer, Integer> exp = calculator.create(expressionString);\n+        for (int i=0; i < paramExpextedResultPairs.length; i += 2) {\n+            assertThat(exp.call(paramExpextedResultPairs[i])).isEqualTo(paramExpextedResultPairs[i+1]);\n+        }\n+        final String config = calculator.getConfig(exp);\n+        if (testConfigEquality) {\n+            assertThat(calculator.getConfig(exp)).isEqualTo(expressionString);\n+        }\n+        final LambdaExpression<Integer, Integer> exp2 = calculator.create(config);\n+        for (int i=0; i < paramExpextedResultPairs.length; i += 2) {\n+            assertThat(exp.call(paramExpextedResultPairs[i])).isEqualTo(paramExpextedResultPairs[i+1]);\n+        }\n+    }\n+}"
  }
]
