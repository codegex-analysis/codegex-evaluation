[
  {
    "sha": "c3e6b49c71cefd26933315417c0db4cf8becc84c",
    "filename": "main/AndroidManifest.xml",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/AndroidManifest.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/AndroidManifest.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/AndroidManifest.xml?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -744,6 +744,12 @@\n             android:name=\".speech.SpeechService\"\n             android:label=\"@string/tts_service\" >\n         </service>\n+        <service\n+            android:name=\".brouter.BRouterService\"\n+            android:exported=\"false\"\n+            android:enabled=\"true\"\n+            android:process=\":brouter_service\">\n+        </service>\n \n         <activity\n             android:name=\".connector.oc.OCAuthorizationActivity\""
  },
  {
    "sha": "fbf3beb3100acfaf231b287153d6611c01d30240",
    "filename": "main/res/values/preference_keys.xml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/res/values/preference_keys.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/res/values/preference_keys.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/preference_keys.xml?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -273,6 +273,8 @@\n     <string translatable=\"false\" name=\"pref_persistablefolder_backup\">persistablefolder_backup</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_fieldnotes\">persistablefolder_fieldnotes</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_spoilerimages\">persistablefolder_spoilerimages</string>\n+    <string translatable=\"false\" name=\"pref_persistablefolder_routingbase\">persistablefolder_routingbase</string>\n+    <string translatable=\"false\" name=\"pref_persistablefolder_routingtiles\">persistablefolder_routingtiles</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_testdir\">persistablefolder_testdir</string>\n \n     <!-- ids for persistable uri prefs -->"
  },
  {
    "sha": "84775dfb1446b25da54494385d158fef272ff5a9",
    "filename": "main/res/values/strings.xml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/res/values/strings.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/res/values/strings.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/strings.xml?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -885,6 +885,8 @@\n     <string name=\"persistablefolder_logfiles\">Logfiles</string>\n     <string name=\"persistablefolder_fieldnotes\">Field Notes</string>\n     <string name=\"persistablefolder_spoilerimages\">Spoiler Images</string>\n+    <string name=\"persistablefolder_routingbase\">Routing</string>\n+    <string name=\"persistablefolder_routingtiles\">Routing data</string>\n \n     <!-- FolderUtils: async processing -->\n     <string name=\"folder_process_status_done\">%1$s/%2$s, %3$s/%4$s done</string>"
  },
  {
    "sha": "cd1cdfb8aeea005abc99d1b86367d9fb3b2f6e83",
    "filename": "main/src/cgeo/geocaching/brouter/BRouterConstants.java",
    "status": "added",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterConstants.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterConstants.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/BRouterConstants.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,10 @@\n+package cgeo.geocaching.brouter;\n+\n+public class BRouterConstants {\n+    public static final String BROUTER_LOOKUPS_FILENAME = \"lookups.dat\";\n+    public static final String BROUTER_PROFILE_FILEEXTENSION = \".brf\";\n+\n+    private BRouterConstants() {\n+        // utility class\n+    }\n+}"
  },
  {
    "sha": "8a2cd293bc56a0ec698468bf47a563ad57cc0d7f",
    "filename": "main/src/cgeo/geocaching/brouter/BRouterService.java",
    "status": "added",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterService.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterService.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/BRouterService.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,78 @@\n+package cgeo.geocaching.brouter;\n+\n+import cgeo.geocaching.utils.Log;\n+\n+import android.app.Service;\n+import android.content.Intent;\n+import android.os.Bundle;\n+import android.os.Environment;\n+import android.os.IBinder;\n+\n+import java.util.ArrayList;\n+\n+public class BRouterService extends Service {\n+\n+    private final IBRouterService.Stub myBRouterServiceStub = new IBRouterService.Stub() {\n+        @Override\n+        public String getTrackFromParams(final Bundle params) {\n+            final BRouterWorker worker = new BRouterWorker();\n+\n+            final String baseDir = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/cgeo/routing\";\n+            worker.segmentDir = baseDir + \"/segments4/\";\n+\n+            // should be:\n+            // final Folder base = PersistableFolder.ROUTING_BASE.getFolder();\n+            // worker.segmentDir = PersistableFolder.ROUTING_TILES.getFolder();\n+\n+            final String fast = params.getString(\"fast\");\n+            final boolean isFast = \"1\".equals(fast) || \"true\".equals(fast) || \"yes\".equals(fast);\n+            final String mode = params.getString(\"v\");\n+            final String modeKey = mode + \"_\" + (isFast ? \"fast\" : \"short\");\n+\n+            // c:geo uses default profile mapping:\n+            if (mode.equals(\"motorcar\")) {\n+                worker.profileName = isFast ? \"car-fast\" : \"moped\";\n+            } else if (mode.equals(\"bicycle\")) {\n+                worker.profileName = isFast ? \"fastbike\" : \"trekking\";\n+            } else if (mode.equals(\"foot\")) {\n+                worker.profileName = \"shortest\";\n+            } else {\n+                Log.e(\"no brouter service config found, mode \" + modeKey);\n+                return \"no brouter service config found, mode \" + modeKey;\n+            }\n+            worker.rawTrackPath = baseDir + \"/\" + modeKey + \"_rawtrack.dat\";\n+            worker.nogoList = new ArrayList<>();\n+\n+            try {\n+                return worker.getTrackFromParams(params);\n+            } catch (IllegalArgumentException iae) {\n+                return iae.getMessage();\n+            }\n+        }\n+\n+    };\n+\n+    @Override\n+    public IBinder onBind(final Intent arg0) {\n+        Log.d(getClass().getSimpleName() + \"onBind()\");\n+        return myBRouterServiceStub;\n+    }\n+\n+    @Override\n+    public void onCreate() {\n+        super.onCreate();\n+        Log.d(getClass().getSimpleName() + \"onCreate()\");\n+    }\n+\n+    @Override\n+    public void onDestroy() {\n+        super.onDestroy();\n+        Log.d(getClass().getSimpleName() + \"onDestroy()\");\n+    }\n+\n+    @Override\n+    public int onStartCommand(final Intent intent, final int flags, final int startId) {\n+        return START_STICKY;\n+    }\n+\n+}"
  },
  {
    "sha": "3da2b323d5ddddddb67f0371ebd065d7078a64e3",
    "filename": "main/src/cgeo/geocaching/brouter/BRouterWorker.java",
    "status": "added",
    "additions": 119,
    "deletions": 0,
    "changes": 119,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterWorker.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/BRouterWorker.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/BRouterWorker.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,119 @@\n+package cgeo.geocaching.brouter;\n+\n+import cgeo.geocaching.brouter.core.OsmNodeNamed;\n+import cgeo.geocaching.brouter.core.OsmTrack;\n+import cgeo.geocaching.brouter.core.RoutingContext;\n+import cgeo.geocaching.brouter.core.RoutingEngine;\n+import cgeo.geocaching.utils.Log;\n+\n+import android.os.Bundle;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class BRouterWorker {\n+    // public String baseDir;\n+    public String segmentDir;\n+    public String profileName;\n+    public String rawTrackPath;\n+    public List<OsmNodeNamed> waypoints;\n+    public List<OsmNodeNamed> nogoList;\n+\n+    public String getTrackFromParams(final Bundle params) {\n+        long maxRunningTime = 60000;\n+        final String sMaxRunningTime = params.getString(\"maxRunningTime\");\n+        if (sMaxRunningTime != null) {\n+            maxRunningTime = Integer.parseInt(sMaxRunningTime) * 1000;\n+        }\n+\n+        final RoutingContext rc = new RoutingContext();\n+        rc.rawTrackPath = rawTrackPath;\n+        rc.profileFilename = profileName + BRouterConstants.BROUTER_PROFILE_FILEEXTENSION;\n+\n+        final String tiFormat = params.getString(\"turnInstructionFormat\");\n+        if (tiFormat != null) {\n+            if (\"osmand\".equalsIgnoreCase(tiFormat)) {\n+                rc.turnInstructionMode = 3;\n+            } else if (\"locus\".equalsIgnoreCase(tiFormat)) {\n+                rc.turnInstructionMode = 2;\n+            }\n+        }\n+\n+        if (params.containsKey(\"direction\")) {\n+            rc.startDirection = params.getInt(\"direction\");\n+        }\n+\n+        readNogos(params); // add interface provided nogos\n+        RoutingContext.prepareNogoPoints(nogoList);\n+        rc.nogopoints = nogoList;\n+\n+        waypoints = readPositions(params);\n+\n+        final RoutingEngine cr = new RoutingEngine(null, null, segmentDir, waypoints, rc);\n+        cr.quite = true;\n+        cr.doRun(maxRunningTime);\n+\n+        // store new reference track if any\n+        // (can exist for timed-out search)\n+        if (cr.getFoundRawTrack() != null) {\n+            try {\n+                cr.getFoundRawTrack().writeBinary(rawTrackPath);\n+            } catch (Exception ignored) {\n+            }\n+        }\n+\n+        if (cr.getErrorMessage() != null) {\n+            return cr.getErrorMessage();\n+        }\n+\n+        final String format = params.getString(\"trackFormat\");\n+        final boolean writeKml = \"kml\".equals(format);\n+\n+        final OsmTrack track = cr.getFoundTrack();\n+        return track == null ? null : writeKml ? track.formatAsKml() : track.formatAsGpx();\n+    }\n+\n+    private List<OsmNodeNamed> readPositions(final Bundle params) {\n+        final List<OsmNodeNamed> wplist = new ArrayList<OsmNodeNamed>();\n+\n+        final double[] lats = params.getDoubleArray(\"lats\");\n+        final double[] lons = params.getDoubleArray(\"lons\");\n+\n+        if (lats == null || lats.length < 2 || lons == null || lons.length < 2) {\n+            throw new IllegalArgumentException(\"we need two lat/lon points at least!\");\n+        }\n+\n+        for (int i = 0; i < lats.length && i < lons.length; i++) {\n+            final OsmNodeNamed n = new OsmNodeNamed();\n+            n.name = \"via\" + i;\n+            n.ilon = (int) ((lons[i] + 180.) * 1000000. + 0.5);\n+            n.ilat = (int) ((lats[i] + 90.) * 1000000. + 0.5);\n+            wplist.add(n);\n+        }\n+        wplist.get(0).name = \"from\";\n+        wplist.get(wplist.size() - 1).name = \"to\";\n+\n+        return wplist;\n+    }\n+\n+    private void readNogos(final Bundle params) {\n+        final double[] lats = params.getDoubleArray(\"nogoLats\");\n+        final double[] lons = params.getDoubleArray(\"nogoLons\");\n+        final double[] radi = params.getDoubleArray(\"nogoRadi\");\n+\n+        if (lats == null || lons == null || radi == null) {\n+            return;\n+        }\n+\n+        for (int i = 0; i < lats.length && i < lons.length && i < radi.length; i++) {\n+            final OsmNodeNamed n = new OsmNodeNamed();\n+            n.name = \"nogo\" + (int) radi[i];\n+            n.ilon = (int) ((lons[i] + 180.) * 1000000. + 0.5);\n+            n.ilat = (int) ((lats[i] + 90.) * 1000000. + 0.5);\n+            n.isNogo = true;\n+            n.nogoWeight = Double.NaN;\n+            Log.i(\"added interface provided nogo: \" + n);\n+            nogoList.add(n);\n+        }\n+    }\n+}"
  },
  {
    "sha": "486e38e23e6f31af8bccaee0a86b5928a43deb7a",
    "filename": "main/src/cgeo/geocaching/brouter/IBRouterService.aidl",
    "status": "renamed",
    "additions": 16,
    "deletions": 8,
    "changes": 24,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/IBRouterService.aidl",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/IBRouterService.aidl",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/IBRouterService.aidl?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -1,22 +1,30 @@\n-package btools.routingapp;\n+package cgeo.geocaching.brouter;\n \n interface IBRouterService {\n+\n     //param params--> Map of params:\n-    //  \"pathToFileResult\"-->String with the path to where the result must be saved, including file name and extension\n-    //                    -->if null, the track is passed via the return argument\n     //  \"maxRunningTime\"-->String with a number of seconds for the routing timeout, default = 60\n-    //  \"turnInstructionFormat\"-->String selecting the format for turn-instructions values: osmand, locus\n-    //  \"trackFormat\"-->[kml|gpx] default = gpx\n+    //  \"v\"-->[motorcar|bicycle|foot]\n+    //  \"fast\"-->[0|1]\n     //  \"lats\"-->double[] array of latitudes; 2 values at least.\n     //  \"lons\"-->double[] array of longitudes; 2 values at least.\n+    //\n+    //  \"turnInstructionFormat\"-->String selecting the format for turn-instructions values: osmand, locus\n+    //  \"trackFormat\"-->[kml|gpx] default = gpx\n     //  \"nogoLats\"-->double[] array of nogo latitudes; may be null.\n     //  \"nogoLons\"-->double[] array of nogo longitudes; may be null.\n     //  \"nogoRadi\"-->double[] array of nogo radius in meters; may be null.\n-    //  \"fast\"-->[0|1]\n-    //  \"v\"-->[motorcar|bicycle|foot]\n-    //  \"remoteProfile\"--> (String), net-content of a profile. If remoteProfile != null, v+fast are ignored\n+    //\n     //return null if all ok and no path given, the track if ok and path given, an error message if it was wrong\n+    //\n     //call in a background thread, heavy task!\n \n+    // standard BRouter parameters NOT supported by c:geo\n+    // --------------------------------------------------\n+    //  \"pathToFileResult\"-->String with the path to where the result must be saved, including file name and extension\n+    //                    -->if null, the track is passed via the return argument\n+    //  \"remoteProfile\"--> (String), net-content of a profile. If remoteProfile != null, v+fast are ignored\n+    //  \"acceptCompressedFormat\"\n+\n     String getTrackFromParams(in Bundle params);\n }",
    "previous_filename": "main/src/btools/routingapp/IBRouterService.aidl"
  },
  {
    "sha": "8839222afecbdca2ca3f1615927727b59a48702d",
    "filename": "main/src/cgeo/geocaching/brouter/codec/DataBuffers.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/DataBuffers.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/DataBuffers.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/DataBuffers.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,31 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+import cgeo.geocaching.brouter.util.BitCoderContext;\n+\n+/**\n+ * Container for some re-usable databuffers for the decoder\n+ */\n+public final class DataBuffers {\n+    public byte[] iobuffer;\n+    public byte[] tagbuf1 = new byte[256];\n+    public BitCoderContext bctx1 = new BitCoderContext(tagbuf1);\n+    public byte[] bbuf1 = new byte[65636];\n+    public int[] ibuf1 = new int[4096];\n+    public int[] ibuf2 = new int[2048];\n+    public int[] ibuf3 = new int[2048];\n+    public int[] alon = new int[2048];\n+    public int[] alat = new int[2048];\n+\n+    public DataBuffers() {\n+        this(new byte[65636]);\n+    }\n+\n+    /**\n+     * construct a set of databuffers except\n+     * for 'iobuffer', where the given array is used\n+     */\n+    public DataBuffers(final byte[] iobuffer) {\n+        this.iobuffer = iobuffer;\n+    }\n+\n+}"
  },
  {
    "sha": "8830eb257467c115bbd23314d97383f3cdaad02d",
    "filename": "main/src/cgeo/geocaching/brouter/codec/IntegerFifo3Pass.java",
    "status": "added",
    "additions": 53,
    "deletions": 0,
    "changes": 53,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/IntegerFifo3Pass.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/IntegerFifo3Pass.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/IntegerFifo3Pass.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,53 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+/**\n+ * Special integer fifo suitable for 3-pass encoding\n+ */\n+public class IntegerFifo3Pass {\n+    private int[] a;\n+    private int size;\n+    private int pos;\n+\n+    private int pass;\n+\n+    public IntegerFifo3Pass(final int capacity) {\n+        a = capacity < 4 ? new int[4] : new int[capacity];\n+    }\n+\n+    /**\n+     * Starts a new encoding pass and resets the reading pointer\n+     * from the stats collected in pass2 and writes that to the given context\n+     */\n+    public void init() {\n+        pass++;\n+        pos = 0;\n+    }\n+\n+    /**\n+     * writes to the fifo in pass2\n+     */\n+    public void add(final int value) {\n+        if (pass == 2) {\n+            if (size == a.length) {\n+                final int[] aa = new int[2 * size];\n+                System.arraycopy(a, 0, aa, 0, size);\n+                a = aa;\n+            }\n+            a[size++] = value;\n+        }\n+    }\n+\n+    /**\n+     * reads from the fifo in pass3 (in pass1/2 returns just 1)\n+     */\n+    public int getNext() {\n+        return pass == 3 ? get(pos++) : 1;\n+    }\n+\n+    private int get(final int idx) {\n+        if (idx >= size) {\n+            throw new IndexOutOfBoundsException(\"list size=\" + size + \" idx=\" + idx);\n+        }\n+        return a[idx];\n+    }\n+}"
  },
  {
    "sha": "f1b4c6185ec1a7aba7adcabf0cee5679e2beef0a",
    "filename": "main/src/cgeo/geocaching/brouter/codec/LinkedListContainer.java",
    "status": "added",
    "additions": 79,
    "deletions": 0,
    "changes": 79,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/LinkedListContainer.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/LinkedListContainer.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/LinkedListContainer.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,79 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+/**\n+ * Simple container for a list of lists of integers\n+ */\n+public class LinkedListContainer {\n+    private int[] ia; // prev, data, prev, data, ...\n+    private int size;\n+    private final int[] startpointer; // 0=void, odd=head-data-cell\n+    private int listpointer;\n+\n+    /**\n+     * Construct a container for the given number of lists\n+     * <p>\n+     * If no default-buffer is given, an int[nlists*4] is constructed,\n+     * able to hold 2 entries per list on average\n+     *\n+     * @param nlists        the number of lists\n+     * @param defaultbuffer an optional data array for re-use (gets replaced if too small)\n+     */\n+    public LinkedListContainer(final int nlists, final int[] defaultbuffer) {\n+        ia = defaultbuffer == null ? new int[nlists * 4] : defaultbuffer;\n+        startpointer = new int[nlists];\n+    }\n+\n+    /**\n+     * Add a data element to the given list\n+     *\n+     * @param listNr the list to add the data to\n+     * @param data   the data value\n+     */\n+    public void addDataElement(final int listNr, final int data) {\n+        if (size + 2 > ia.length) {\n+            resize();\n+        }\n+        ia[size++] = startpointer[listNr];\n+        startpointer[listNr] = size;\n+        ia[size++] = data;\n+    }\n+\n+    /**\n+     * Initialize a list for reading\n+     *\n+     * @param listNr the list to initialize\n+     * @return the number of entries in that list\n+     */\n+    public int initList(final int listNr) {\n+        int cnt = 0;\n+        listpointer = startpointer[listNr];\n+        int lp = listpointer;\n+        while (lp != 0) {\n+            lp = ia[lp - 1];\n+            cnt++;\n+        }\n+        return cnt;\n+    }\n+\n+    /**\n+     * Get a data element from the list previously initialized.\n+     * Data elements are return in reverse order (lifo)\n+     *\n+     * @return the data element\n+     * @throws IllegalArgumentException if no more element\n+     */\n+    public int getDataElement() {\n+        if (listpointer == 0) {\n+            throw new IllegalArgumentException(\"no more element!\");\n+        }\n+        final int data = ia[listpointer];\n+        listpointer = ia[listpointer - 1];\n+        return data;\n+    }\n+\n+    private void resize() {\n+        final int[] ia2 = new int[2 * ia.length];\n+        System.arraycopy(ia, 0, ia2, 0, ia.length);\n+        ia = ia2;\n+    }\n+}"
  },
  {
    "sha": "21f861d2f53f13048893c82b454c588585354468",
    "filename": "main/src/cgeo/geocaching/brouter/codec/MicroCache.java",
    "status": "added",
    "additions": 334,
    "deletions": 0,
    "changes": 334,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/MicroCache.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/MicroCache.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/MicroCache.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,334 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+import cgeo.geocaching.brouter.util.ByteDataWriter;\n+\n+/**\n+ * a micro-cache is a data cache for an area of some square kilometers or some\n+ * hundreds or thousands nodes\n+ * <p>\n+ * This is the basic io-unit: always a full microcache is loaded from the\n+ * data-file if a node is requested at a position not yet covered by the caches\n+ * already loaded\n+ * <p>\n+ * The nodes are represented in a compact way (typical 20-50 bytes per node),\n+ * but in a way that they do not depend on each other, and garbage collection is\n+ * supported to remove the nodes already consumed from the cache.\n+ * <p>\n+ * The cache-internal data representation is different from that in the\n+ * data-files, where a cache is encoded as a whole, allowing more\n+ * redundancy-removal for a more compact encoding\n+ */\n+public class MicroCache extends ByteDataWriter {\n+    public static final MicroCache emptyNonVirgin = new MicroCache(null);\n+    public static boolean debug = false;\n+\n+    static {\n+        emptyNonVirgin.virgin = false;\n+    }\n+\n+    // cache control: a virgin cache can be\n+    // put to ghost state for later recovery\n+    public boolean virgin = true;\n+    public boolean ghost = false;\n+    protected int[] faid;\n+    protected int[] fapos;\n+    protected int size = 0;\n+    private int delcount = 0;\n+    private int delbytes = 0;\n+    private int p2size; // next power of 2 of size\n+\n+    protected MicroCache(final byte[] ab) {\n+        super(ab);\n+    }\n+\n+    public static MicroCache emptyCache() {\n+        return new MicroCache(null); // TODO: singleton?\n+    }\n+\n+    protected void init(final int size) {\n+        this.size = size;\n+        delcount = 0;\n+        delbytes = 0;\n+        p2size = 0x40000000;\n+        while (p2size > size) {\n+            p2size >>= 1;\n+        }\n+    }\n+\n+    public final void finishNode(final long id) {\n+        fapos[size] = aboffset;\n+        faid[size] = shrinkId(id);\n+        size++;\n+    }\n+\n+    public final void discardNode() {\n+        aboffset = startPos(size);\n+    }\n+\n+    public final int getSize() {\n+        return size;\n+    }\n+\n+    public final int getDataSize() {\n+        return ab == null ? 0 : ab.length;\n+    }\n+\n+    /**\n+     * Set the internal reader (aboffset, aboffsetEnd) to the body data for the given id\n+     * <p>\n+     * If a node is not found in an empty cache, this is usually an edge-effect\n+     * (data-file does not exist or neighboured data-files of differnt age),\n+     * but is can as well be a symptom of a node-identity breaking bug.\n+     * <p>\n+     * Current implementation always returns false for not-found, however, for\n+     * regression testing, at least for the case that is most likely a bug\n+     * (node found but marked as deleted = ready for garbage collection\n+     * = already consumed) the RunException should be re-enabled\n+     *\n+     * @return true if id was found\n+     */\n+    public final boolean getAndClear(final long id64) {\n+        if (size == 0) {\n+            return false;\n+        }\n+        final int id = shrinkId(id64);\n+        final int[] a = faid;\n+        int offset = p2size;\n+        int n = 0;\n+\n+        while (offset > 0) {\n+            final int nn = n + offset;\n+            if (nn < size && a[nn] <= id) {\n+                n = nn;\n+            }\n+            offset >>= 1;\n+        }\n+        if (a[n] == id && (fapos[n] & 0x80000000) == 0) {\n+            aboffset = startPos(n);\n+            aboffsetEnd = fapos[n];\n+            fapos[n] |= 0x80000000; // mark deleted\n+            delbytes += aboffsetEnd - aboffset;\n+            delcount++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected final int startPos(final int n) {\n+        return n > 0 ? fapos[n - 1] & 0x7fffffff : 0;\n+    }\n+\n+    public final int collect(final int threshold) {\n+        if (delcount <= threshold) {\n+            return 0;\n+        }\n+\n+        virgin = false;\n+\n+        final int nsize = size - delcount;\n+        if (nsize == 0) {\n+            faid = null;\n+            fapos = null;\n+        } else {\n+            final int[] nfaid = new int[nsize];\n+            final int[] nfapos = new int[nsize];\n+            int idx = 0;\n+\n+            final byte[] nab = new byte[ab.length - delbytes];\n+            int nabOff = 0;\n+            for (int i = 0; i < size; i++) {\n+                final int pos = fapos[i];\n+                if ((pos & 0x80000000) == 0) {\n+                    final int start = startPos(i);\n+                    final int end = fapos[i];\n+                    final int len = end - start;\n+                    System.arraycopy(ab, start, nab, nabOff, len);\n+                    nfaid[idx] = faid[i];\n+                    nabOff += len;\n+                    nfapos[idx] = nabOff;\n+                    idx++;\n+                }\n+            }\n+            faid = nfaid;\n+            fapos = nfapos;\n+            ab = nab;\n+        }\n+        final int deleted = delbytes;\n+        init(nsize);\n+        return deleted;\n+    }\n+\n+    public final void unGhost() {\n+        ghost = false;\n+        delcount = 0;\n+        delbytes = 0;\n+        for (int i = 0; i < size; i++) {\n+            fapos[i] &= 0x7fffffff; // clear deleted flags\n+        }\n+    }\n+\n+    /**\n+     * @return the 64-bit global id for the given cache-position\n+     */\n+    public final long getIdForIndex(final int i) {\n+        final int id32 = faid[i];\n+        return expandId(id32);\n+    }\n+\n+    /**\n+     * expand a 32-bit micro-cache-internal id into a 64-bit (lon|lat) global-id\n+     *\n+     * @see #shrinkId\n+     */\n+    public long expandId(final int id32) {\n+        throw new IllegalArgumentException(\"expandId for empty cache\");\n+    }\n+\n+    /**\n+     * shrink a 64-bit (lon|lat) global-id into a a 32-bit micro-cache-internal id\n+     *\n+     * @see #expandId\n+     */\n+    public int shrinkId(final long id64) {\n+        throw new IllegalArgumentException(\"shrinkId for empty cache\");\n+    }\n+\n+    /**\n+     * @return true if the given lon/lat position is internal for that micro-cache\n+     */\n+    public boolean isInternal(final int ilon, final int ilat) {\n+        throw new IllegalArgumentException(\"isInternal for empty cache\");\n+    }\n+\n+    /**\n+     * (stasticially) encode the micro-cache into the format used in the datafiles\n+     *\n+     * @param buffer byte array to encode into (considered big enough)\n+     * @return the size of the encoded data\n+     */\n+    public int encodeMicroCache(final byte[] buffer) {\n+        throw new IllegalArgumentException(\"encodeMicroCache for empty cache\");\n+    }\n+\n+    /**\n+     * Compare the content of this microcache to another\n+     *\n+     * @return null if equals, else a diff-report\n+     */\n+    public String compareWith(final MicroCache mc) {\n+        final String msg = compareWithHelper(mc);\n+        if (msg != null) {\n+            final StringBuilder sb = new StringBuilder(msg);\n+            sb.append(\"\\nencode cache:\\n\").append(summary());\n+            sb.append(\"\\ndecode cache:\\n\").append(mc.summary());\n+            return sb.toString();\n+        }\n+        return null;\n+    }\n+\n+    private String summary() {\n+        final StringBuilder sb = new StringBuilder(\"size=\" + size + \" aboffset=\" + aboffset);\n+        for (int i = 0; i < size; i++) {\n+            sb.append(\"\\nidx=\" + i + \" faid=\" + faid[i] + \" fapos=\" + fapos[i]);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private String compareWithHelper(final MicroCache mc) {\n+        if (size != mc.size) {\n+            return \"size missmatch: \" + size + \"->\" + mc.size;\n+        }\n+        for (int i = 0; i < size; i++) {\n+            if (faid[i] != mc.faid[i]) {\n+                return \"faid missmatch at index \" + i + \":\" + faid[i] + \"->\" + mc.faid[i];\n+            }\n+            final int start = i > 0 ? fapos[i - 1] : 0;\n+            final int end = fapos[i] < mc.fapos[i] ? fapos[i] : mc.fapos[i];\n+            final int len = end - start;\n+            for (int offset = 0; offset < len; offset++) {\n+                if (mc.ab.length <= start + offset) {\n+                    return \"data buffer too small\";\n+                }\n+                if (ab[start + offset] != mc.ab[start + offset]) {\n+                    return \"data missmatch at index \" + i + \" offset=\" + offset;\n+                }\n+            }\n+            if (fapos[i] != mc.fapos[i]) {\n+                return \"fapos missmatch at index \" + i + \":\" + fapos[i] + \"->\" + mc.fapos[i];\n+            }\n+        }\n+        if (aboffset != mc.aboffset) {\n+            return \"datasize missmatch: \" + aboffset + \"->\" + mc.aboffset;\n+        }\n+        return null;\n+    }\n+\n+    public void calcDelta(final MicroCache mc1, final MicroCache mc2) {\n+        int idx1 = 0;\n+        int idx2 = 0;\n+\n+        while (idx1 < mc1.size || idx2 < mc2.size) {\n+            final int id1 = idx1 < mc1.size ? mc1.faid[idx1] : Integer.MAX_VALUE;\n+            final int id2 = idx2 < mc2.size ? mc2.faid[idx2] : Integer.MAX_VALUE;\n+            final int id;\n+            if (id1 >= id2) {\n+                id = id2;\n+                final int start2 = idx2 > 0 ? mc2.fapos[idx2 - 1] : 0;\n+                final int len2 = mc2.fapos[idx2++] - start2;\n+\n+                if (id1 == id2) {\n+                    // id exists in both caches, compare data\n+                    final int start1 = idx1 > 0 ? mc1.fapos[idx1 - 1] : 0;\n+                    final int len1 = mc1.fapos[idx1++] - start1;\n+                    if (len1 == len2) {\n+                        int i = 0;\n+                        while (i < len1) {\n+                            if (mc1.ab[start1 + i] != mc2.ab[start2 + i]) {\n+                                break;\n+                            }\n+                            i++;\n+                        }\n+                        if (i == len1) {\n+                            continue; // same data -> do nothing\n+                        }\n+                    }\n+                }\n+                write(mc2.ab, start2, len2);\n+            } else {\n+                idx1++;\n+                id = id1; // deleted node\n+            }\n+            fapos[size] = aboffset;\n+            faid[size] = id;\n+            size++;\n+        }\n+    }\n+\n+    public void addDelta(final MicroCache mc1, final MicroCache mc2, final boolean keepEmptyNodes) {\n+        int idx1 = 0;\n+        int idx2 = 0;\n+\n+        while (idx1 < mc1.size || idx2 < mc2.size) {\n+            final int id1 = idx1 < mc1.size ? mc1.faid[idx1] : Integer.MAX_VALUE;\n+            final int id2 = idx2 < mc2.size ? mc2.faid[idx2] : Integer.MAX_VALUE;\n+            if (id1 >= id2) { // data from diff file wins\n+                final int start2 = idx2 > 0 ? mc2.fapos[idx2 - 1] : 0;\n+                final int len2 = mc2.fapos[idx2++] - start2;\n+                if (keepEmptyNodes || len2 > 0) {\n+                    write(mc2.ab, start2, len2);\n+                    fapos[size] = aboffset;\n+                    faid[size++] = id2;\n+                }\n+                if (id1 == id2) { // // id exists in both caches\n+                    idx1++;\n+                }\n+            } else { // use data from base file\n+                final int start1 = idx1 > 0 ? mc1.fapos[idx1 - 1] : 0;\n+                final int len1 = mc1.fapos[idx1++] - start1;\n+                write(mc1.ab, start1, len1);\n+                fapos[size] = aboffset;\n+                faid[size++] = id1;\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "71aef5ae5bcf793a88bd779fd7d4448751ef0b40",
    "filename": "main/src/cgeo/geocaching/brouter/codec/MicroCache2.java",
    "status": "added",
    "additions": 542,
    "deletions": 0,
    "changes": 542,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/MicroCache2.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/MicroCache2.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/MicroCache2.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,542 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+import cgeo.geocaching.brouter.util.ByteDataReader;\n+import cgeo.geocaching.brouter.util.IByteArrayUnifier;\n+\n+import java.util.HashMap;\n+\n+/**\n+ * MicroCache2 is the new format that uses statistical encoding and\n+ * is able to do access filtering and waypoint matching during encoding\n+ */\n+public final class MicroCache2 extends MicroCache {\n+    private final int lonBase;\n+    private final int latBase;\n+    private final int cellsize;\n+\n+    public MicroCache2(final int size, final byte[] databuffer, final int lonIdx, final int latIdx, final int divisor) throws Exception {\n+        super(databuffer); // sets ab=databuffer, aboffset=0\n+\n+        faid = new int[size];\n+        fapos = new int[size];\n+        this.size = 0;\n+        cellsize = 1000000 / divisor;\n+        lonBase = lonIdx * cellsize;\n+        latBase = latIdx * cellsize;\n+    }\n+\n+    public MicroCache2(final StatCoderContext bc, final DataBuffers dataBuffers, final int lonIdx, final int latIdx, final int divisor, final TagValueValidator wayValidator, final WaypointMatcher waypointMatcher) throws Exception {\n+        super(null);\n+        cellsize = 1000000 / divisor;\n+        lonBase = lonIdx * cellsize;\n+        latBase = latIdx * cellsize;\n+\n+        final TagValueCoder wayTagCoder = new TagValueCoder(bc, dataBuffers, wayValidator);\n+        final TagValueCoder nodeTagCoder = new TagValueCoder(bc, dataBuffers, null);\n+        final NoisyDiffCoder nodeIdxDiff = new NoisyDiffCoder(bc);\n+        final NoisyDiffCoder nodeEleDiff = new NoisyDiffCoder(bc);\n+        final NoisyDiffCoder extLonDiff = new NoisyDiffCoder(bc);\n+        final NoisyDiffCoder extLatDiff = new NoisyDiffCoder(bc);\n+        final NoisyDiffCoder transEleDiff = new NoisyDiffCoder(bc);\n+\n+        size = bc.decodeNoisyNumber(5);\n+        faid = size > dataBuffers.ibuf2.length ? new int[size] : dataBuffers.ibuf2;\n+        fapos = size > dataBuffers.ibuf3.length ? new int[size] : dataBuffers.ibuf3;\n+\n+\n+        final int[] alon = size > dataBuffers.alon.length ? new int[size] : dataBuffers.alon;\n+        final int[] alat = size > dataBuffers.alat.length ? new int[size] : dataBuffers.alat;\n+\n+        if (debug) {\n+            System.out.println(\"*** decoding cache of size=\" + size + \" for lonIdx=\" + lonIdx + \" latIdx=\" + latIdx);\n+        }\n+\n+        bc.decodeSortedArray(faid, 0, size, 29, 0);\n+\n+        for (int n = 0; n < size; n++) {\n+            final long id64 = expandId(faid[n]);\n+            alon[n] = (int) (id64 >> 32);\n+            alat[n] = (int) (id64 & 0xffffffff);\n+        }\n+\n+        final int netdatasize = bc.decodeNoisyNumber(10);\n+        ab = netdatasize > dataBuffers.bbuf1.length ? new byte[netdatasize] : dataBuffers.bbuf1;\n+        aboffset = 0;\n+\n+        final int[] validBits = new int[(size + 31) >> 5];\n+\n+        int finaldatasize = 0;\n+\n+        final LinkedListContainer reverseLinks = new LinkedListContainer(size, dataBuffers.ibuf1);\n+\n+        int selev = 0;\n+        for (int n = 0; n < size; n++) { // loop over nodes\n+            final int ilon = alon[n];\n+            final int ilat = alat[n];\n+\n+            // future escapes (turn restrictions?)\n+            short trExceptions = 0;\n+            int featureId = bc.decodeVarBits();\n+            if (featureId == 13) {\n+                fapos[n] = aboffset;\n+                validBits[n >> 5] |= 1 << n; // mark dummy-node valid\n+                continue; // empty node escape (delta files only)\n+            }\n+            while (featureId != 0) {\n+                final int bitsize = bc.decodeNoisyNumber(5);\n+\n+                if (featureId == 2) { // exceptions to turn-restriction\n+                    trExceptions = (short) bc.decodeBounded(1023);\n+                } else if (featureId == 1) { // turn-restriction\n+                    writeBoolean(true);\n+                    writeShort(trExceptions); // exceptions from previous feature\n+                    trExceptions = 0;\n+\n+                    writeBoolean(bc.decodeBit()); // isPositive\n+                    writeInt(ilon + bc.decodeNoisyDiff(10)); // fromLon\n+                    writeInt(ilat + bc.decodeNoisyDiff(10)); // fromLat\n+                    writeInt(ilon + bc.decodeNoisyDiff(10)); // toLon\n+                    writeInt(ilat + bc.decodeNoisyDiff(10)); // toLat\n+                } else {\n+                    for (int i = 0; i < bitsize; i++) {\n+                        bc.decodeBit(); // unknown feature, just skip\n+                    }\n+                }\n+                featureId = bc.decodeVarBits();\n+            }\n+            writeBoolean(false);\n+\n+            selev += nodeEleDiff.decodeSignedValue();\n+            writeShort((short) selev);\n+            final TagValueWrapper nodeTags = nodeTagCoder.decodeTagValueSet();\n+            writeVarBytes(nodeTags == null ? null : nodeTags.data);\n+\n+            final int links = bc.decodeNoisyNumber(1);\n+            if (debug) {\n+                System.out.println(\"***   decoding node \" + ilon + \"/\" + ilat + \" with links=\" + links);\n+            }\n+            for (int li = 0; li < links; li++) {\n+                int sizeoffset = 0;\n+                final int nodeIdx = n + nodeIdxDiff.decodeSignedValue();\n+\n+                int dlonRemaining;\n+                int dlatRemaining;\n+\n+                boolean isReverse = false;\n+                if (nodeIdx != n) { // internal (forward-) link\n+                    dlonRemaining = alon[nodeIdx] - ilon;\n+                    dlatRemaining = alat[nodeIdx] - ilat;\n+                } else {\n+                    isReverse = bc.decodeBit();\n+                    dlonRemaining = extLonDiff.decodeSignedValue();\n+                    dlatRemaining = extLatDiff.decodeSignedValue();\n+                }\n+                if (debug) {\n+                    System.out.println(\"***     decoding link to \" + (ilon + dlonRemaining) + \"/\" + (ilat + dlatRemaining) + \" extern=\" + (nodeIdx == n));\n+                }\n+\n+                final TagValueWrapper wayTags = wayTagCoder.decodeTagValueSet();\n+\n+                final boolean linkValid = wayTags != null || wayValidator == null;\n+                if (linkValid) {\n+                    final int startPointer = aboffset;\n+                    sizeoffset = writeSizePlaceHolder();\n+\n+                    writeVarLengthSigned(dlonRemaining);\n+                    writeVarLengthSigned(dlatRemaining);\n+\n+                    validBits[n >> 5] |= 1 << n; // mark source-node valid\n+                    if (nodeIdx != n) { // valid internal (forward-) link\n+                        reverseLinks.addDataElement(nodeIdx, n); // register reverse link\n+                        finaldatasize += 1 + aboffset - startPointer; // reserve place for reverse\n+                        validBits[nodeIdx >> 5] |= 1 << nodeIdx; // mark target-node valid\n+                    }\n+                    writeModeAndDesc(isReverse, wayTags == null ? null : wayTags.data);\n+                }\n+\n+                if (!isReverse) { // write geometry for forward links only\n+                    WaypointMatcher matcher = wayTags == null || wayTags.accessType < 2 ? null : waypointMatcher;\n+                    final int ilontarget = ilon + dlonRemaining;\n+                    final int ilattarget = ilat + dlatRemaining;\n+                    if (matcher != null && !matcher.start(ilon, ilat, ilontarget, ilattarget)) {\n+                        matcher = null;\n+                    }\n+\n+                    final int transcount = bc.decodeVarBits();\n+                    if (debug) {\n+                        System.out.println(\"***       decoding geometry with count=\" + transcount);\n+                    }\n+                    int count = transcount + 1;\n+                    for (int i = 0; i < transcount; i++) {\n+                        final int dlon = bc.decodePredictedValue(dlonRemaining / count);\n+                        final int dlat = bc.decodePredictedValue(dlatRemaining / count);\n+                        dlonRemaining -= dlon;\n+                        dlatRemaining -= dlat;\n+                        count--;\n+                        final int elediff = transEleDiff.decodeSignedValue();\n+                        if (wayTags != null) {\n+                            writeVarLengthSigned(dlon);\n+                            writeVarLengthSigned(dlat);\n+                            writeVarLengthSigned(elediff);\n+                        }\n+\n+                        if (matcher != null) {\n+                            matcher.transferNode(ilontarget - dlonRemaining, ilattarget - dlatRemaining);\n+                        }\n+                    }\n+                    if (matcher != null) {\n+                        matcher.end();\n+                    }\n+                }\n+                if (linkValid) {\n+                    injectSize(sizeoffset);\n+                }\n+            }\n+            fapos[n] = aboffset;\n+        }\n+\n+        // calculate final data size\n+        int finalsize = 0;\n+        int startpos = 0;\n+        for (int i = 0; i < size; i++) {\n+            final int endpos = fapos[i];\n+            if ((validBits[i >> 5] & (1 << i)) != 0) {\n+                finaldatasize += endpos - startpos;\n+                finalsize++;\n+            }\n+            startpos = endpos;\n+        }\n+        // append the reverse links at the end of each node\n+        final byte[] abOld = ab;\n+        final int[] faidOld = faid;\n+        final int[] faposOld = fapos;\n+        final int sizeOld = size;\n+        ab = new byte[finaldatasize];\n+        faid = new int[finalsize];\n+        fapos = new int[finalsize];\n+        aboffset = 0;\n+        size = 0;\n+\n+        startpos = 0;\n+        for (int n = 0; n < sizeOld; n++) {\n+            final int endpos = faposOld[n];\n+            if ((validBits[n >> 5] & (1 << n)) != 0) {\n+                final int len = endpos - startpos;\n+                System.arraycopy(abOld, startpos, ab, aboffset, len);\n+                if (debug) {\n+                    System.out.println(\"*** copied \" + len + \" bytes from \" + aboffset + \" for node \" + n);\n+                }\n+                aboffset += len;\n+\n+                final int cnt = reverseLinks.initList(n);\n+                if (debug) {\n+                    System.out.println(\"*** appending \" + cnt + \" reverse links for node \" + n);\n+                }\n+\n+                for (int ri = 0; ri < cnt; ri++) {\n+                    final int nodeIdx = reverseLinks.getDataElement();\n+                    final int sizeoffset = writeSizePlaceHolder();\n+                    writeVarLengthSigned(alon[nodeIdx] - alon[n]);\n+                    writeVarLengthSigned(alat[nodeIdx] - alat[n]);\n+                    writeModeAndDesc(true, null);\n+                    injectSize(sizeoffset);\n+                }\n+                faid[size] = faidOld[n];\n+                fapos[size] = aboffset;\n+                size++;\n+            }\n+            startpos = endpos;\n+        }\n+        init(size);\n+    }\n+\n+    public byte[] readUnified(final int len, final IByteArrayUnifier u) {\n+        final byte[] b = u.unify(ab, aboffset, len);\n+        aboffset += len;\n+        return b;\n+    }\n+\n+    @Override\n+    public long expandId(final int id32In) {\n+        int id32 = id32In;\n+        int dlon = 0;\n+        int dlat = 0;\n+\n+        for (int bm = 1; bm < 0x8000; bm <<= 1) {\n+            if ((id32 & 1) != 0) {\n+                dlon |= bm;\n+            }\n+            if ((id32 & 2) != 0) {\n+                dlat |= bm;\n+            }\n+            id32 >>= 2;\n+        }\n+\n+        final int lon32 = lonBase + dlon;\n+        final int lat32 = latBase + dlat;\n+\n+        return ((long) lon32) << 32 | lat32;\n+    }\n+\n+    @Override\n+    public int shrinkId(final long id64) {\n+        final int lon32 = (int) (id64 >> 32);\n+        final int lat32 = (int) (id64 & 0xffffffff);\n+        final int dlon = lon32 - lonBase;\n+        final int dlat = lat32 - latBase;\n+        int id32 = 0;\n+\n+        for (int bm = 0x4000; bm > 0; bm >>= 1) {\n+            id32 <<= 2;\n+            if ((dlon & bm) != 0) {\n+                id32 |= 1;\n+            }\n+            if ((dlat & bm) != 0) {\n+                id32 |= 2;\n+            }\n+        }\n+        return id32;\n+    }\n+\n+    @Override\n+    public boolean isInternal(final int ilon, final int ilat) {\n+        return ilon >= lonBase && ilon < lonBase + cellsize\n+            && ilat >= latBase && ilat < latBase + cellsize;\n+    }\n+\n+    @Override\n+    public int encodeMicroCache(final byte[] buffer) {\n+        final HashMap<Long, Integer> idMap = new HashMap<Long, Integer>();\n+        for (int n = 0; n < size; n++) { // loop over nodes\n+            idMap.put(expandId(faid[n]), n);\n+        }\n+\n+        final IntegerFifo3Pass linkCounts = new IntegerFifo3Pass(256);\n+        final IntegerFifo3Pass transCounts = new IntegerFifo3Pass(256);\n+        final IntegerFifo3Pass restrictionBits = new IntegerFifo3Pass(16);\n+\n+        final TagValueCoder wayTagCoder = new TagValueCoder();\n+        final TagValueCoder nodeTagCoder = new TagValueCoder();\n+        final NoisyDiffCoder nodeIdxDiff = new NoisyDiffCoder();\n+        final NoisyDiffCoder nodeEleDiff = new NoisyDiffCoder();\n+        final NoisyDiffCoder extLonDiff = new NoisyDiffCoder();\n+        final NoisyDiffCoder extLatDiff = new NoisyDiffCoder();\n+        final NoisyDiffCoder transEleDiff = new NoisyDiffCoder();\n+\n+        int netdatasize = 0;\n+\n+        for (int pass = 1; ; pass++) { // 3 passes: counters, stat-collection, encoding\n+            final boolean dostats = pass == 3;\n+            final boolean dodebug = debug && pass == 3;\n+\n+            if (pass < 3) {\n+                netdatasize = fapos[size - 1];\n+            }\n+\n+            final StatCoderContext bc = new StatCoderContext(buffer);\n+\n+            linkCounts.init();\n+            transCounts.init();\n+            restrictionBits.init();\n+\n+            wayTagCoder.encodeDictionary(bc);\n+            if (dostats) {\n+                bc.assignBits(\"wayTagDictionary\");\n+            }\n+            nodeTagCoder.encodeDictionary(bc);\n+            if (dostats) {\n+                bc.assignBits(\"nodeTagDictionary\");\n+            }\n+            nodeIdxDiff.encodeDictionary(bc);\n+            nodeEleDiff.encodeDictionary(bc);\n+            extLonDiff.encodeDictionary(bc);\n+            extLatDiff.encodeDictionary(bc);\n+            transEleDiff.encodeDictionary(bc);\n+            if (dostats) {\n+                bc.assignBits(\"noisebits\");\n+            }\n+            bc.encodeNoisyNumber(size, 5);\n+            if (dostats) {\n+                bc.assignBits(\"nodecount\");\n+            }\n+            bc.encodeSortedArray(faid, 0, size, 0x20000000, 0);\n+            if (dostats) {\n+                bc.assignBits(\"node-positions\");\n+            }\n+            bc.encodeNoisyNumber(netdatasize, 10); // net-size\n+            if (dostats) {\n+                bc.assignBits(\"netdatasize\");\n+            }\n+            if (dodebug) {\n+                System.out.println(\"*** encoding cache of size=\" + size);\n+            }\n+            int lastSelev = 0;\n+\n+            for (int n = 0; n < size; n++) { // loop over nodes\n+                aboffset = startPos(n);\n+                aboffsetEnd = fapos[n];\n+                if (dodebug) {\n+                    System.out.println(\"*** encoding node \" + n + \" from \" + aboffset + \" to \" + aboffsetEnd);\n+                }\n+\n+                final long id64 = expandId(faid[n]);\n+                final int ilon = (int) (id64 >> 32);\n+                final int ilat = (int) (id64 & 0xffffffff);\n+\n+                if (aboffset == aboffsetEnd) {\n+                    bc.encodeVarBits(13); // empty node escape (delta files only)\n+                    continue;\n+                }\n+\n+                // write turn restrictions\n+                while (readBoolean()) {\n+                    final short exceptions = readShort(); // except bikes, psv, ...\n+                    if (exceptions != 0) {\n+                        bc.encodeVarBits(2); // 2 = tr exceptions\n+                        bc.encodeNoisyNumber(10, 5); // bit-count\n+                        bc.encodeBounded(1023, exceptions & 1023);\n+                    }\n+                    bc.encodeVarBits(1); // 1 = turn restriction\n+                    bc.encodeNoisyNumber(restrictionBits.getNext(), 5); // bit-count using look-ahead fifo\n+                    final long b0 = bc.getWritingBitPosition();\n+                    bc.encodeBit(readBoolean()); // isPositive\n+                    bc.encodeNoisyDiff(readInt() - ilon, 10); // fromLon\n+                    bc.encodeNoisyDiff(readInt() - ilat, 10); // fromLat\n+                    bc.encodeNoisyDiff(readInt() - ilon, 10); // toLon\n+                    bc.encodeNoisyDiff(readInt() - ilat, 10); // toLat\n+                    restrictionBits.add((int) (bc.getWritingBitPosition() - b0));\n+                }\n+                bc.encodeVarBits(0); // end of extra data\n+\n+                if (dostats) {\n+                    bc.assignBits(\"extradata\");\n+                }\n+\n+                final int selev = readShort();\n+                nodeEleDiff.encodeSignedValue(selev - lastSelev);\n+                if (dostats) {\n+                    bc.assignBits(\"nodeele\");\n+                }\n+                lastSelev = selev;\n+                nodeTagCoder.encodeTagValueSet(readVarBytes());\n+                if (dostats) {\n+                    bc.assignBits(\"nodeTagIdx\");\n+                }\n+                int nlinks = linkCounts.getNext();\n+                if (dodebug) {\n+                    System.out.println(\"*** nlinks=\" + nlinks);\n+                }\n+                bc.encodeNoisyNumber(nlinks, 1);\n+                if (dostats) {\n+                    bc.assignBits(\"link-counts\");\n+                }\n+\n+                nlinks = 0;\n+                while (hasMoreData()) { // loop over links\n+                    // read link data\n+                    final int startPointer = aboffset;\n+                    final int endPointer = getEndPointer();\n+\n+                    final int ilonlink = ilon + readVarLengthSigned();\n+                    final int ilatlink = ilat + readVarLengthSigned();\n+\n+                    final int sizecode = readVarLengthUnsigned();\n+                    final boolean isReverse = (sizecode & 1) != 0;\n+                    final int descSize = sizecode >> 1;\n+                    byte[] description = null;\n+                    if (descSize > 0) {\n+                        description = new byte[descSize];\n+                        readFully(description);\n+                    }\n+\n+                    final long link64 = ((long) ilonlink) << 32 | ilatlink;\n+                    final Integer idx = idMap.get(link64);\n+                    final boolean isInternal = idx != null;\n+\n+                    if (isReverse && isInternal) {\n+                        if (dodebug) {\n+                            System.out.println(\"*** NOT encoding link reverse=\" + isReverse + \" internal=\" + isInternal);\n+                        }\n+                        netdatasize -= aboffset - startPointer;\n+                        continue; // do not encode internal reverse links\n+                    }\n+                    if (dodebug) {\n+                        System.out.println(\"*** encoding link reverse=\" + isReverse + \" internal=\" + isInternal);\n+                    }\n+                    nlinks++;\n+\n+                    if (isInternal) {\n+                        final int nodeIdx = idx;\n+                        if (dodebug) {\n+                            System.out.println(\"*** target nodeIdx=\" + nodeIdx);\n+                        }\n+                        if (nodeIdx == n) {\n+                            throw new RuntimeException(\"ups: self ref?\");\n+                        }\n+                        nodeIdxDiff.encodeSignedValue(nodeIdx - n);\n+                        if (dostats) {\n+                            bc.assignBits(\"nodeIdx\");\n+                        }\n+                    } else {\n+                        nodeIdxDiff.encodeSignedValue(0);\n+                        bc.encodeBit(isReverse);\n+                        extLonDiff.encodeSignedValue(ilonlink - ilon);\n+                        extLatDiff.encodeSignedValue(ilatlink - ilat);\n+                        if (dostats) {\n+                            bc.assignBits(\"externalNode\");\n+                        }\n+                    }\n+                    wayTagCoder.encodeTagValueSet(description);\n+                    if (dostats) {\n+                        bc.assignBits(\"wayDescIdx\");\n+                    }\n+\n+                    if (!isReverse) {\n+                        final byte[] geometry = readDataUntil(endPointer);\n+                        // write transition nodes\n+                        int count = transCounts.getNext();\n+                        if (dodebug) {\n+                            System.out.println(\"*** encoding geometry with count=\" + count);\n+                        }\n+                        bc.encodeVarBits(count++);\n+                        if (dostats) {\n+                            bc.assignBits(\"transcount\");\n+                        }\n+                        int transcount = 0;\n+                        if (geometry != null) {\n+                            int dlonRemaining = ilonlink - ilon;\n+                            int dlatRemaining = ilatlink - ilat;\n+\n+                            final ByteDataReader r = new ByteDataReader(geometry);\n+                            while (r.hasMoreData()) {\n+                                transcount++;\n+\n+                                final int dlon = r.readVarLengthSigned();\n+                                final int dlat = r.readVarLengthSigned();\n+                                bc.encodePredictedValue(dlon, dlonRemaining / count);\n+                                bc.encodePredictedValue(dlat, dlatRemaining / count);\n+                                dlonRemaining -= dlon;\n+                                dlatRemaining -= dlat;\n+                                if (count > 1) {\n+                                    count--;\n+                                }\n+                                if (dostats) {\n+                                    bc.assignBits(\"transpos\");\n+                                }\n+                                transEleDiff.encodeSignedValue(r.readVarLengthSigned());\n+                                if (dostats) {\n+                                    bc.assignBits(\"transele\");\n+                                }\n+                            }\n+                        }\n+                        transCounts.add(transcount);\n+                    }\n+                }\n+                linkCounts.add(nlinks);\n+            }\n+            if (pass == 3) {\n+                return bc.closeAndGetEncodedLength();\n+            }\n+        }\n+    }\n+}"
  },
  {
    "sha": "6ead99656957a4458b5d8fe26bd5d776583b1385",
    "filename": "main/src/cgeo/geocaching/brouter/codec/NoisyDiffCoder.java",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/NoisyDiffCoder.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/NoisyDiffCoder.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/NoisyDiffCoder.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,82 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+/**\n+ * Encoder/Decoder for signed integers that automatically detects the typical\n+ * range of these numbers to determine a noisy-bit count as a very simple\n+ * dictionary\n+ * <p>\n+ * Adapted for 3-pass encoding (counters -&gt; statistics -&gt; encoding )\n+ * but doesn't do anything at pass1\n+ */\n+public final class NoisyDiffCoder {\n+    private int tot;\n+    private int[] freqs;\n+    private int noisybits;\n+    private StatCoderContext bc;\n+    private int pass;\n+\n+    /**\n+     * Create a decoder and read the noisy-bit count from the gibe context\n+     */\n+    public NoisyDiffCoder(final StatCoderContext bc) {\n+        noisybits = bc.decodeVarBits();\n+        this.bc = bc;\n+    }\n+\n+    /**\n+     * Create an encoder for 3-pass-encoding\n+     */\n+    public NoisyDiffCoder() {\n+    }\n+\n+    /**\n+     * encodes a signed int (pass3 only, stats collection in pass2)\n+     */\n+    public void encodeSignedValue(final int value) {\n+        if (pass == 3) {\n+            bc.encodeNoisyDiff(value, noisybits);\n+        } else if (pass == 2) {\n+            count(value < 0 ? -value : value);\n+        }\n+    }\n+\n+    /**\n+     * decodes a signed int\n+     */\n+    public int decodeSignedValue() {\n+        return bc.decodeNoisyDiff(noisybits);\n+    }\n+\n+    /**\n+     * Starts a new encoding pass and (in pass3) calculates the noisy-bit count\n+     * from the stats collected in pass2 and writes that to the given context\n+     */\n+    public void encodeDictionary(final StatCoderContext bc) {\n+        if (++pass == 3) {\n+            // how many noisy bits?\n+            for (noisybits = 0; noisybits < 14 && tot > 0; noisybits++) {\n+                if (freqs[noisybits] < (tot >> 1)) {\n+                    break;\n+                }\n+            }\n+            bc.encodeVarBits(noisybits);\n+        }\n+        this.bc = bc;\n+    }\n+\n+    private void count(final int value) {\n+        if (freqs == null) {\n+            freqs = new int[14];\n+        }\n+        int bm = 1;\n+        for (int i = 0; i < 14; i++) {\n+            if (value < bm) {\n+                break;\n+            } else {\n+                freqs[i]++;\n+            }\n+            bm <<= 1;\n+        }\n+        tot++;\n+    }\n+}"
  },
  {
    "sha": "eabfdec5f48b63ddfc058e562b3705f6ba60c378",
    "filename": "main/src/cgeo/geocaching/brouter/codec/StatCoderContext.java",
    "status": "added",
    "additions": 257,
    "deletions": 0,
    "changes": 257,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/StatCoderContext.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/StatCoderContext.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/StatCoderContext.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,257 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+import cgeo.geocaching.brouter.util.BitCoderContext;\n+\n+import java.util.TreeMap;\n+\n+public final class StatCoderContext extends BitCoderContext {\n+    private static final int[] noisy_bits = new int[1024];\n+    private static TreeMap<String, long[]> statsPerName;\n+\n+    static {\n+        // noisybits lookup\n+        for (int i = 0; i < 1024; i++) {\n+            int p = i;\n+            int noisybits = 0;\n+            while (p > 2) {\n+                noisybits++;\n+                p >>= 1;\n+            }\n+            noisy_bits[i] = noisybits;\n+        }\n+    }\n+\n+    private long lastbitpos = 0;\n+\n+\n+    public StatCoderContext(final byte[] ab) {\n+        super(ab);\n+    }\n+\n+    /**\n+     * Get a textual report on the bit-statistics\n+     *\n+     * @see #assignBits\n+     */\n+    public static String getBitReport() {\n+        if (statsPerName == null) {\n+            return \"<empty bit report>\";\n+        }\n+        final StringBuilder sb = new StringBuilder();\n+        for (String name : statsPerName.keySet()) {\n+            final long[] stats = statsPerName.get(name);\n+            sb.append(name + \" count=\" + stats[1] + \" bits=\" + stats[0] + \"\\n\");\n+        }\n+        statsPerName = null;\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * assign the de-/encoded bits since the last call assignBits to the given\n+     * name. Used for encoding statistics\n+     *\n+     * @see #getBitReport\n+     */\n+    public void assignBits(final String name) {\n+        final long bitpos = getWritingBitPosition();\n+        if (statsPerName == null) {\n+            statsPerName = new TreeMap<String, long[]>();\n+        }\n+        long[] stats = statsPerName.get(name);\n+        if (stats == null) {\n+            stats = new long[2];\n+            statsPerName.put(name, stats);\n+        }\n+        stats[0] += bitpos - lastbitpos;\n+        stats[1] += 1;\n+        lastbitpos = bitpos;\n+    }\n+\n+    /**\n+     * encode an unsigned integer with some of of least significant bits\n+     * considered noisy\n+     *\n+     * @see #decodeNoisyNumber\n+     */\n+    public void encodeNoisyNumber(final int valueIn, final int noisybits) {\n+        int value = valueIn;\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"encodeVarBits expects positive value\");\n+        }\n+        if (noisybits > 0) {\n+            final int mask = 0xffffffff >>> (32 - noisybits);\n+            encodeBounded(mask, value & mask);\n+            value >>= noisybits;\n+        }\n+        encodeVarBits(value);\n+    }\n+\n+    /**\n+     * decode an unsigned integer with some of of least significant bits\n+     * considered noisy\n+     *\n+     * @see #encodeNoisyNumber\n+     */\n+    public int decodeNoisyNumber(final int noisybits) {\n+        final int value = decodeBits(noisybits);\n+        return value | (decodeVarBits() << noisybits);\n+    }\n+\n+    /**\n+     * encode a signed integer with some of of least significant bits considered\n+     * noisy\n+     *\n+     * @see #decodeNoisyDiff\n+     */\n+    public void encodeNoisyDiff(final int valueIn, final int noisybits) {\n+        int value = valueIn;\n+        if (noisybits > 0) {\n+            value += 1 << (noisybits - 1);\n+            final int mask = 0xffffffff >>> (32 - noisybits);\n+            encodeBounded(mask, value & mask);\n+            value >>= noisybits;\n+        }\n+        encodeVarBits(value < 0 ? -value : value);\n+        if (value != 0) {\n+            encodeBit(value < 0);\n+        }\n+    }\n+\n+    /**\n+     * decode a signed integer with some of of least significant bits considered\n+     * noisy\n+     *\n+     * @see #encodeNoisyDiff\n+     */\n+    public int decodeNoisyDiff(final int noisybits) {\n+        int value = 0;\n+        if (noisybits > 0) {\n+            value = decodeBits(noisybits) - (1 << (noisybits - 1));\n+        }\n+        int val2 = decodeVarBits() << noisybits;\n+        if (val2 != 0 && decodeBit()) {\n+            val2 = -val2;\n+        }\n+        return value + val2;\n+    }\n+\n+    /**\n+     * encode a signed integer with the typical range and median taken from the\n+     * predicted value\n+     *\n+     * @see #decodePredictedValue\n+     */\n+    public void encodePredictedValue(final int value, final int predictor) {\n+        int p = predictor < 0 ? -predictor : predictor;\n+        int noisybits = 0;\n+\n+        while (p > 2) {\n+            noisybits++;\n+            p >>= 1;\n+        }\n+        encodeNoisyDiff(value - predictor, noisybits);\n+    }\n+\n+    /**\n+     * decode a signed integer with the typical range and median taken from the\n+     * predicted value\n+     *\n+     * @see #encodePredictedValue\n+     */\n+    public int decodePredictedValue(final int predictor) {\n+        int p = predictor < 0 ? -predictor : predictor;\n+        int noisybits = 0;\n+        while (p > 1023) {\n+            noisybits++;\n+            p >>= 1;\n+        }\n+        return predictor + decodeNoisyDiff(noisybits + noisy_bits[p]);\n+    }\n+\n+    /**\n+     * encode an integer-array making use of the fact that it is sorted. This is\n+     * done, starting with the most significant bit, by recursively encoding the\n+     * number of values with the current bit being 0. This yields an number of\n+     * bits per value that only depends on the typical distance between subsequent\n+     * values and also benefits\n+     *\n+     * @param values  the array to encode\n+     * @param offset  position in this array where to start\n+     * @param subsize number of values to encode\n+     * @param nextbitIn bitmask with the most significant bit set to 1\n+     * @param maskIn    should be 0\n+     */\n+    public void encodeSortedArray(final int[] values, final int offset, final int subsize, final int nextbitIn, final int maskIn) {\n+        int nextbit = nextbitIn;\n+        int mask = maskIn;\n+        if (subsize == 1) { // last-choice shortcut\n+            while (nextbit != 0) {\n+                encodeBit((values[offset] & nextbit) != 0);\n+                nextbit >>= 1;\n+            }\n+        }\n+        if (nextbit == 0) {\n+            return;\n+        }\n+\n+        final int data = mask & values[offset];\n+        mask |= nextbit;\n+\n+        // count 0-bit-fraction\n+        int i = offset;\n+        final int end = subsize + offset;\n+        for (; i < end; i++) {\n+            if ((values[i] & mask) != data) {\n+                break;\n+            }\n+        }\n+        final int size1 = i - offset;\n+        final int size2 = subsize - size1;\n+\n+        encodeBounded(subsize, size1);\n+        if (size1 > 0) {\n+            encodeSortedArray(values, offset, size1, nextbit >> 1, mask);\n+        }\n+        if (size2 > 0) {\n+            encodeSortedArray(values, i, size2, nextbit >> 1, mask);\n+        }\n+    }\n+\n+    /**\n+     * @param values  the array to encode\n+     * @param offsetIn  position in this array where to start\n+     * @param subsizeIn number of values to encode\n+     * @param nextbit bitmask with the most significant bit set to 1\n+     * @param valueIn   should be 0\n+     * @see #encodeSortedArray\n+     */\n+    public void decodeSortedArray(final int[] values, final int offsetIn, final int subsizeIn, final int nextbitpos, final int valueIn) {\n+        int offset = offsetIn;\n+        int subsize = subsizeIn;\n+        int value = valueIn;\n+        if (subsize == 1) { // last-choice shortcut\n+            if (nextbitpos >= 0) {\n+                value |= decodeBitsReverse(nextbitpos + 1);\n+            }\n+            values[offset] = value;\n+            return;\n+        }\n+        if (nextbitpos < 0) {\n+            while (subsize-- > 0) {\n+                values[offset++] = value;\n+            }\n+            return;\n+        }\n+\n+        final int size1 = decodeBounded(subsize);\n+        final int size2 = subsize - size1;\n+\n+        if (size1 > 0) {\n+            decodeSortedArray(values, offset, size1, nextbitpos - 1, value);\n+        }\n+        if (size2 > 0) {\n+            decodeSortedArray(values, offset + size1, size2, nextbitpos - 1, value | (1 << nextbitpos));\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "26807fe3fb3b90aa950602cf1c34a3c90a0c77a3",
    "filename": "main/src/cgeo/geocaching/brouter/codec/TagValueCoder.java",
    "status": "added",
    "additions": 247,
    "deletions": 0,
    "changes": 247,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueCoder.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueCoder.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/TagValueCoder.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,247 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+import cgeo.geocaching.brouter.util.BitCoderContext;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.PriorityQueue;\n+\n+/**\n+ * Encoder/Decoder for way-/node-descriptions\n+ * <p>\n+ * It detects identical descriptions and sorts them\n+ * into a huffman-tree according to their frequencies\n+ * <p>\n+ * Adapted for 3-pass encoding (counters -&gt; statistics -&gt; encoding )\n+ * but doesn't do anything at pass1\n+ */\n+public final class TagValueCoder {\n+    private HashMap<TagValueSet, TagValueSet> identityMap;\n+    private Object tree;\n+    private BitCoderContext bc;\n+    private int pass;\n+    private int nextTagValueSetId;\n+\n+    public TagValueCoder(final BitCoderContext bc, final DataBuffers buffers, final TagValueValidator validator) {\n+        tree = decodeTree(bc, buffers, validator);\n+        this.bc = bc;\n+    }\n+\n+    public TagValueCoder() {\n+        identityMap = new HashMap<TagValueSet, TagValueSet>();\n+    }\n+\n+    public void encodeTagValueSet(final byte[] data) {\n+        if (pass == 1) {\n+            return;\n+        }\n+        final TagValueSet tvsProbe = new TagValueSet(nextTagValueSetId);\n+        tvsProbe.data = data;\n+        TagValueSet tvs = identityMap.get(tvsProbe);\n+        if (pass == 3) {\n+            bc.encodeBounded(tvs.range - 1, tvs.code);\n+        } else if (pass == 2) {\n+            if (tvs == null) {\n+                tvs = tvsProbe;\n+                nextTagValueSetId++;\n+                identityMap.put(tvs, tvs);\n+            }\n+            tvs.frequency++;\n+        }\n+    }\n+\n+    public TagValueWrapper decodeTagValueSet() {\n+        Object node = tree;\n+        while (node instanceof TreeNode) {\n+            final TreeNode tn = (TreeNode) node;\n+            final boolean nextBit = bc.decodeBit();\n+            node = nextBit ? tn.child2 : tn.child1;\n+        }\n+        return (TagValueWrapper) node;\n+    }\n+\n+    public void encodeDictionary(final BitCoderContext bc) {\n+        if (++pass == 3) {\n+            if (identityMap.size() == 0) {\n+                final TagValueSet dummy = new TagValueSet(nextTagValueSetId++);\n+                identityMap.put(dummy, dummy);\n+            }\n+            final PriorityQueue<TagValueSet> queue = new PriorityQueue<TagValueSet>(2 * identityMap.size(), new TagValueSet.FrequencyComparator());\n+            queue.addAll(identityMap.values());\n+            while (queue.size() > 1) {\n+                final TagValueSet node = new TagValueSet(nextTagValueSetId++);\n+                node.child1 = queue.poll();\n+                node.child2 = queue.poll();\n+                node.frequency = node.child1.frequency + node.child2.frequency;\n+                queue.add(node);\n+            }\n+            final TagValueSet root = queue.poll();\n+            root.encode(bc, 1, 0);\n+        }\n+        this.bc = bc;\n+    }\n+\n+    private Object decodeTree(final BitCoderContext bc, final DataBuffers buffers, final TagValueValidator validator) {\n+        final boolean isNode = bc.decodeBit();\n+        if (isNode) {\n+            final TreeNode node = new TreeNode();\n+            node.child1 = decodeTree(bc, buffers, validator);\n+            node.child2 = decodeTree(bc, buffers, validator);\n+            return node;\n+        }\n+\n+        final byte[] buffer = buffers.tagbuf1;\n+        final BitCoderContext ctx = buffers.bctx1;\n+        ctx.reset(buffer);\n+\n+        int inum = 0;\n+        int lastEncodedInum = 0;\n+\n+        boolean hasdata = false;\n+        for (; ; ) {\n+            final int delta = bc.decodeVarBits();\n+            if (!hasdata && delta == 0) {\n+                return null;\n+            }\n+            if (delta == 0) {\n+                ctx.encodeVarBits(0);\n+                break;\n+            }\n+            inum += delta;\n+\n+            final int data = bc.decodeVarBits();\n+\n+            if (validator == null || validator.isLookupIdxUsed(inum)) {\n+                hasdata = true;\n+                ctx.encodeVarBits(inum - lastEncodedInum);\n+                ctx.encodeVarBits(data);\n+                lastEncodedInum = inum;\n+            }\n+        }\n+\n+        final byte[] res;\n+        final int len = ctx.closeAndGetEncodedLength();\n+        if (validator == null) {\n+            res = new byte[len];\n+            System.arraycopy(buffer, 0, res, 0, len);\n+        } else {\n+            res = validator.unify(buffer, 0, len);\n+        }\n+\n+        final int accessType = validator == null ? 2 : validator.accessType(res);\n+        if (accessType > 0) {\n+            final TagValueWrapper w = new TagValueWrapper();\n+            w.data = res;\n+            w.accessType = accessType;\n+            return w;\n+        }\n+        return null;\n+    }\n+\n+    public static final class TreeNode {\n+        public Object child1;\n+        public Object child2;\n+    }\n+\n+    public static final class TagValueSet {\n+        public byte[] data;\n+        public int frequency;\n+        public int code;\n+        public int range;\n+        public TagValueSet child1;\n+        public TagValueSet child2;\n+        private final int id; // serial number to make the comparator well defined in case of equal frequencies\n+\n+        public TagValueSet(final int id) {\n+            this.id = id;\n+        }\n+\n+        public void encode(final BitCoderContext bc, final int range, final int code) {\n+            this.range = range;\n+            this.code = code;\n+            final boolean isNode = child1 != null;\n+            bc.encodeBit(isNode);\n+            if (isNode) {\n+                child1.encode(bc, range << 1, code);\n+                child2.encode(bc, range << 1, code + range);\n+            } else {\n+                if (data == null) {\n+                    bc.encodeVarBits(0);\n+                    return;\n+                }\n+                final BitCoderContext src = new BitCoderContext(data);\n+                for (; ; ) {\n+                    final int delta = src.decodeVarBits();\n+                    bc.encodeVarBits(delta);\n+                    if (delta == 0) {\n+                        break;\n+                    }\n+                    final int data = src.decodeVarBits();\n+                    bc.encodeVarBits(data);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (o instanceof TagValueSet) {\n+                final TagValueSet tvs = (TagValueSet) o;\n+                if (data == null) {\n+                    return tvs.data == null;\n+                }\n+                if (tvs.data == null) {\n+                    return data == null;\n+                }\n+                if (data.length != tvs.data.length) {\n+                    return false;\n+                }\n+                for (int i = 0; i < data.length; i++) {\n+                    if (data[i] != tvs.data[i]) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (data == null) {\n+                return 0;\n+            }\n+            int h = 17;\n+            for (int i = 0; i < data.length; i++) {\n+                h = (h << 8) + data[i];\n+            }\n+            return h;\n+        }\n+\n+        public static class FrequencyComparator implements Comparator<TagValueSet> {\n+\n+            @Override\n+            public int compare(final TagValueSet tvs1, final TagValueSet tvs2) {\n+                if (tvs1.frequency < tvs2.frequency) {\n+                    return -1;\n+                }\n+                if (tvs1.frequency > tvs2.frequency) {\n+                    return 1;\n+                }\n+\n+                // to avoid ordering instability, decide on the id if frequency is equal\n+                if (tvs1.id < tvs2.id) {\n+                    return -1;\n+                }\n+                if (tvs1.id > tvs2.id) {\n+                    return 1;\n+                }\n+\n+                if (tvs1 != tvs2) {\n+                    throw new RuntimeException(\"identity corruption!\");\n+                }\n+                return 0;\n+            }\n+        }\n+\n+    }\n+}"
  },
  {
    "sha": "9dc490da24d1c5dc4c9d3530090c7233efe25cfa",
    "filename": "main/src/cgeo/geocaching/brouter/codec/TagValueValidator.java",
    "status": "added",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueValidator.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueValidator.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/TagValueValidator.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,16 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+\n+public interface TagValueValidator {\n+    /**\n+     * @param tagValueSet the way description to check\n+     * @return 0 = nothing, 1=no matching, 2=normal\n+     */\n+    int accessType(byte[] tagValueSet);\n+\n+    byte[] unify(byte[] tagValueSet, int offset, int len);\n+\n+    boolean isLookupIdxUsed(int idx);\n+\n+    void setDecodeForbidden(boolean decodeForbidden);\n+}"
  },
  {
    "sha": "712fb0c2334c390a7d1ce41d90b362e374209bd8",
    "filename": "main/src/cgeo/geocaching/brouter/codec/TagValueWrapper.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueWrapper.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/TagValueWrapper.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/TagValueWrapper.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,11 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+\n+/**\n+ * TagValueWrapper wrapps a description bitmap\n+ * to add the access-type\n+ */\n+public final class TagValueWrapper {\n+    public byte[] data;\n+    public int accessType;\n+}"
  },
  {
    "sha": "a7e0c187d002849449e4db069ee0a585c9cc61f7",
    "filename": "main/src/cgeo/geocaching/brouter/codec/WaypointMatcher.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/WaypointMatcher.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/WaypointMatcher.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/WaypointMatcher.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,14 @@\n+package cgeo.geocaching.brouter.codec;\n+\n+/**\n+ * a waypoint matcher gets way geometries\n+ * from the decoder to find the closest\n+ * matches to the waypoints\n+ */\n+public interface WaypointMatcher {\n+    boolean start(int ilonStart, int ilatStart, int ilonTarget, int ilatTarget);\n+\n+    void transferNode(int ilon, int ilat);\n+\n+    void end();\n+}"
  },
  {
    "sha": "e0ff370bb807998d8461b1725ce09824be3ba517",
    "filename": "main/src/cgeo/geocaching/brouter/codec/package-info.java",
    "status": "added",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/package-info.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/codec/package-info.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/codec/package-info.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,5 @@\n+/**\n+ * This is the c:geo adaption of https://github.com/abrensch/brouter\n+ * (with permission from the author)\n+ */\n+package cgeo.geocaching.brouter.codec;"
  },
  {
    "sha": "d4b03022aa5d359fccd0861d027cd20308eb1586",
    "filename": "main/src/cgeo/geocaching/brouter/core/KinematicModel.java",
    "status": "added",
    "additions": 140,
    "deletions": 0,
    "changes": 140,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicModel.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicModel.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/KinematicModel.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,140 @@\n+/**\n+ * Container for link between two Osm nodes\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.expressions.BExpressionContextNode;\n+import cgeo.geocaching.brouter.expressions.BExpressionContextWay;\n+\n+import java.util.Map;\n+\n+final class KinematicModel extends OsmPathModel {\n+    public double turnAngleDecayTime;\n+    public double fRoll;\n+    public double fAir;\n+    public double fRecup;\n+    public double pStandby;\n+    public double outsideTemp;\n+    public double recupEfficiency;\n+    public double totalweight;\n+    public double vmax;\n+    public double leftWaySpeed;\n+    public double rightWaySpeed;\n+    // derived values\n+    public double pw; // balance power\n+    public double cost0; // minimum possible cost per meter\n+    protected BExpressionContextWay ctxWay;\n+    protected BExpressionContextNode ctxNode;\n+    protected Map<String, String> params;\n+    private int wayIdxMaxspeed;\n+    private int wayIdxMaxspeedExplicit;\n+    private int wayIdxMinspeed;\n+    private int nodeIdxMaxspeed;\n+    private boolean initDone = false;\n+    private double lastEffectiveLimit;\n+    private double lastBreakingSpeed;\n+\n+    public OsmPrePath createPrePath() {\n+        return new KinematicPrePath();\n+    }\n+\n+    public OsmPath createPath() {\n+        return new KinematicPath();\n+    }\n+\n+    @Override\n+    public void init(final BExpressionContextWay expctxWay, final BExpressionContextNode expctxNode, final Map<String, String> extraParams) {\n+        if (!initDone) {\n+            ctxWay = expctxWay;\n+            ctxNode = expctxNode;\n+            wayIdxMaxspeed = ctxWay.getOutputVariableIndex(\"maxspeed\", false);\n+            wayIdxMaxspeedExplicit = ctxWay.getOutputVariableIndex(\"maxspeed_explicit\", false);\n+            wayIdxMinspeed = ctxWay.getOutputVariableIndex(\"minspeed\", false);\n+            nodeIdxMaxspeed = ctxNode.getOutputVariableIndex(\"maxspeed\", false);\n+            initDone = true;\n+        }\n+\n+        params = extraParams;\n+\n+        turnAngleDecayTime = getParam(\"turnAngleDecayTime\", 5.f);\n+        fRoll = getParam(\"f_roll\", 232.f);\n+        fAir = getParam(\"f_air\", 0.4f);\n+        fRecup = getParam(\"f_recup\", 400.f);\n+        pStandby = getParam(\"p_standby\", 250.f);\n+        outsideTemp = getParam(\"outside_temp\", 20.f);\n+        recupEfficiency = getParam(\"recup_efficiency\", 0.7f);\n+        totalweight = getParam(\"totalweight\", 1640.f);\n+        vmax = getParam(\"vmax\", 80.f) / 3.6;\n+        leftWaySpeed = getParam(\"leftWaySpeed\", 12.f) / 3.6;\n+        rightWaySpeed = getParam(\"rightWaySpeed\", 12.f) / 3.6;\n+\n+        pw = 2. * fAir * vmax * vmax * vmax - pStandby;\n+        cost0 = (pw + pStandby) / vmax + fRoll + fAir * vmax * vmax;\n+    }\n+\n+    protected float getParam(final String name, final float defaultValue) {\n+        final String sval = params == null ? null : params.get(name);\n+        if (sval != null) {\n+            return Float.parseFloat(sval);\n+        }\n+        final float v = ctxWay.getVariableValue(name, defaultValue);\n+        if (params != null) {\n+            params.put(name, \"\" + v);\n+        }\n+        return v;\n+    }\n+\n+    public float getWayMaxspeed() {\n+        return ctxWay.getBuildInVariable(wayIdxMaxspeed) / 3.6f;\n+    }\n+\n+    public float getWayMaxspeedExplicit() {\n+        return ctxWay.getBuildInVariable(wayIdxMaxspeedExplicit) / 3.6f;\n+    }\n+\n+    public float getWayMinspeed() {\n+        return ctxWay.getBuildInVariable(wayIdxMinspeed) / 3.6f;\n+    }\n+\n+    public float getNodeMaxspeed() {\n+        return ctxNode.getBuildInVariable(nodeIdxMaxspeed) / 3.6f;\n+    }\n+\n+    /**\n+     * get the effective speed limit from the way-limit and vmax/vmin\n+     */\n+    public double getEffectiveSpeedLimit() {\n+        // performance related inline coding\n+        final double minspeed = getWayMinspeed();\n+        final double espeed = Math.max(minspeed, vmax);\n+        final double maxspeed = getWayMaxspeed();\n+        return Math.min(maxspeed, espeed);\n+    }\n+\n+    /**\n+     * get the breaking speed for current balance-power (pw) and effective speed limit (vl)\n+     */\n+    public double getBreakingSpeed(final double vl) {\n+        if (vl == lastEffectiveLimit) {\n+            return lastBreakingSpeed;\n+        }\n+\n+        double v = vl * 0.8;\n+        final double pw2 = pw + pStandby;\n+        final double e = recupEfficiency;\n+        final double x0 = pw2 / vl + fAir * e * vl * vl + (1. - e) * fRoll;\n+        for (int i = 0; i < 5; i++) {\n+            final double v2 = v * v;\n+            final double x = pw2 / v + fAir * e * v2 - x0;\n+            final double dx = 2. * e * fAir * v - pw2 / v2;\n+            v -= x / dx;\n+        }\n+        lastEffectiveLimit = vl;\n+        lastBreakingSpeed = v;\n+\n+        return v;\n+    }\n+\n+}"
  },
  {
    "sha": "c1477e4e6f2ed599e6f35b6f5d4c603e80fb0443",
    "filename": "main/src/cgeo/geocaching/brouter/core/KinematicPath.java",
    "status": "added",
    "additions": 283,
    "deletions": 0,
    "changes": 283,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicPath.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicPath.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/KinematicPath.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,283 @@\n+/**\n+ * The path-instance of the kinematic model\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.util.FastMathUtils;\n+\n+\n+final class KinematicPath extends OsmPath {\n+    private double ekin; // kinetic energy (Joule)\n+    private double totalTime;  // travel time (seconds)\n+    private double totalEnergy; // total route energy (Joule)\n+    private float floatingAngleLeft; // sliding average left bend (degree)\n+    private float floatingAngleRight; // sliding average right bend (degree)\n+\n+    @Override\n+    protected void init(final OsmPath orig) {\n+        final KinematicPath origin = (KinematicPath) orig;\n+        ekin = origin.ekin;\n+        totalTime = origin.totalTime;\n+        totalEnergy = origin.totalEnergy;\n+        floatingAngleLeft = origin.floatingAngleLeft;\n+        floatingAngleRight = origin.floatingAngleRight;\n+        priorityclassifier = origin.priorityclassifier;\n+    }\n+\n+    @Override\n+    protected void resetState() {\n+        ekin = 0.;\n+        totalTime = 0.;\n+        totalEnergy = 0.;\n+        floatingAngleLeft = 0.f;\n+        floatingAngleRight = 0.f;\n+    }\n+\n+    @Override\n+    protected double processWaySection(final RoutingContext rc, final double dist, final double deltaH, final double elevation, final double angle, final double cosangle, final boolean isStartpoint, final int nsection, final int lastpriorityclassifier) {\n+        final KinematicModel km = (KinematicModel) rc.pm;\n+\n+        double cost = 0.;\n+        double extraTime = 0.;\n+\n+        if (isStartpoint) {\n+            // for forward direction, we start with target speed\n+            if (!rc.inverseDirection) {\n+                extraTime = 0.5 * (1. - cosangle) * 40.; // 40 seconds turn penalty\n+            }\n+        } else {\n+            double turnspeed = 999.; // just high\n+\n+            if (km.turnAngleDecayTime != 0.) { // process turn-angle slowdown\n+                if (angle < 0) {\n+                    floatingAngleLeft -= (float) angle;\n+                } else {\n+                    floatingAngleRight += (float) angle;\n+                }\n+                final float aa = Math.max(floatingAngleLeft, floatingAngleRight);\n+\n+                final double curveSpeed = aa > 10. ? 200. / aa : 20.;\n+                final double distanceTime = dist / curveSpeed;\n+                final double decayFactor = FastMathUtils.exp(-distanceTime / km.turnAngleDecayTime);\n+                floatingAngleLeft = (float) (floatingAngleLeft * decayFactor);\n+                floatingAngleRight = (float) (floatingAngleRight * decayFactor);\n+\n+                if (curveSpeed < 20.) {\n+                    turnspeed = curveSpeed;\n+                }\n+            }\n+\n+            if (nsection == 0) { // process slowdown by crossing geometry\n+                double junctionspeed = 999.; // just high\n+\n+                final int classifiermask = (int) rc.expctxWay.getClassifierMask();\n+\n+                // penalty for equal priority crossing\n+                boolean hasLeftWay = false;\n+                boolean hasRightWay = false;\n+                boolean hasResidential = false;\n+                for (OsmPrePath prePath = rc.firstPrePath; prePath != null; prePath = prePath.next) {\n+                    final KinematicPrePath pp = (KinematicPrePath) prePath;\n+\n+                    if (((pp.classifiermask ^ classifiermask) & 8) != 0) { // exactly one is linktype\n+                        continue;\n+                    }\n+\n+                    if ((pp.classifiermask & 32) != 0) { // touching a residential?\n+                        hasResidential = true;\n+                    }\n+\n+                    if (pp.priorityclassifier > priorityclassifier || pp.priorityclassifier == priorityclassifier && priorityclassifier < 20) {\n+                        final double diff = pp.angle - angle;\n+                        if (diff < -40. && diff > -140.) {\n+                            hasLeftWay = true;\n+                        }\n+                        if (diff > 40. && diff < 140.) {\n+                            hasRightWay = true;\n+                        }\n+                    }\n+                }\n+                final double residentialSpeed = 13.;\n+\n+                if (hasLeftWay && junctionspeed > km.leftWaySpeed) {\n+                    junctionspeed = km.leftWaySpeed;\n+                }\n+                if (hasRightWay && junctionspeed > km.rightWaySpeed) {\n+                    junctionspeed = km.rightWaySpeed;\n+                }\n+                if (hasResidential && junctionspeed > residentialSpeed) {\n+                    junctionspeed = residentialSpeed;\n+                }\n+\n+                if ((lastpriorityclassifier < 20) ^ (priorityclassifier < 20)) {\n+                    extraTime += 10.;\n+                    junctionspeed = 0; // full stop for entering or leaving road network\n+                }\n+\n+                if (lastpriorityclassifier != priorityclassifier && (classifiermask & 8) != 0) {\n+                    extraTime += 2.; // two seconds for entering a link-type\n+                }\n+                turnspeed = Math.min(turnspeed, junctionspeed);\n+\n+                if (message != null) {\n+                    message.vnode0 = (int) (junctionspeed * 3.6 + 0.5);\n+                }\n+            }\n+            cutEkin(km.totalweight, turnspeed); // apply turnspeed\n+        }\n+\n+        // linear temperature correction\n+        final double tcorr = (20. - km.outsideTemp) * 0.0035;\n+\n+        // air_pressure down 1mb/8m\n+        final double ecorr = 0.0001375 * (elevation - 100.);\n+\n+        final double fAir = km.fAir * (1. + tcorr - ecorr);\n+\n+        final double distanceCost = evolveDistance(km, dist, deltaH, fAir);\n+\n+        if (message != null) {\n+            message.costfactor = (float) (distanceCost / dist);\n+            message.vmax = (int) (km.getWayMaxspeed() * 3.6 + 0.5);\n+            message.vmaxExplicit = (int) (km.getWayMaxspeedExplicit() * 3.6 + 0.5);\n+            message.vmin = (int) (km.getWayMinspeed() * 3.6 + 0.5);\n+            message.extraTime = (int) (extraTime * 1000);\n+        }\n+\n+        cost += extraTime * km.pw / km.cost0;\n+        totalTime += extraTime;\n+\n+        return cost + distanceCost;\n+    }\n+\n+\n+    protected double evolveDistance(final KinematicModel km, final double dist, final double deltaH, final double fAir) {\n+        // elevation force\n+        final double fh = deltaH * km.totalweight * 9.81 / dist;\n+\n+        final double effectiveSpeedLimit = km.getEffectiveSpeedLimit();\n+        final double emax = 0.5 * km.totalweight * effectiveSpeedLimit * effectiveSpeedLimit;\n+        if (emax <= 0.) {\n+            return -1.;\n+        }\n+        final double vb = km.getBreakingSpeed(effectiveSpeedLimit);\n+        final double elow = 0.5 * km.totalweight * vb * vb;\n+\n+        double elapsedTime = 0.;\n+        double dissipatedEnergy = 0.;\n+\n+        double v = Math.sqrt(2. * ekin / km.totalweight);\n+        double d = dist;\n+        while (d > 0.) {\n+            final boolean slow = ekin < elow;\n+            final boolean fast = ekin >= emax;\n+            final double etarget = slow ? elow : emax;\n+            double f = km.fRoll + fAir * v * v + fh;\n+            final double fRecup = Math.max(0., fast ? -f : (slow ? km.fRecup : 0) - fh); // additional recup for slow part\n+            f += fRecup;\n+\n+            double deltaEkin;\n+            final double timeStep;\n+            double x;\n+            if (fast) {\n+                x = d;\n+                deltaEkin = x * f;\n+                timeStep = x / v;\n+                ekin = etarget;\n+            } else {\n+                deltaEkin = etarget - ekin;\n+                final double b = 2. * fAir / km.totalweight;\n+                final double x0 = deltaEkin / f;\n+                final double x0b = x0 * b;\n+                x = x0 * (1. - x0b * (0.5 + x0b * (0.333333333 - x0b * 0.25))); // = ln( deltaEkin*b/f + 1.) / b;\n+                final double maxstep = Math.min(50., d);\n+                if (x >= maxstep) {\n+                    x = maxstep;\n+                    final double xb = x * b;\n+                    deltaEkin = x * f * (1. + xb * (0.5 + xb * (0.166666667 + xb * 0.0416666667))); // = f/b* exp(xb-1)\n+                    ekin += deltaEkin;\n+                } else {\n+                    ekin = etarget;\n+                }\n+                final double v2 = Math.sqrt(2. * ekin / km.totalweight);\n+                final double a = f / km.totalweight; // TODO: average force?\n+                timeStep = (v2 - v) / a;\n+                v = v2;\n+            }\n+            d -= x;\n+            elapsedTime += timeStep;\n+\n+            // dissipated energy does not contain elevation and efficient recup\n+            dissipatedEnergy += deltaEkin - x * (fh + fRecup * km.recupEfficiency);\n+\n+            // correction: inefficient recup going into heating is half efficient\n+            final double ieRecup = x * fRecup * (1. - km.recupEfficiency);\n+            final double eaux = timeStep * km.pStandby;\n+            dissipatedEnergy -= Math.max(ieRecup, eaux) * 0.5;\n+        }\n+\n+        dissipatedEnergy += elapsedTime * km.pStandby;\n+\n+        totalTime += elapsedTime;\n+        totalEnergy += dissipatedEnergy + dist * fh;\n+\n+        return (km.pw * elapsedTime + dissipatedEnergy) / km.cost0; // =cost\n+    }\n+\n+    @Override\n+    protected double processTargetNode(final RoutingContext rc) {\n+        final KinematicModel km = (KinematicModel) rc.pm;\n+\n+        // finally add node-costs for target node\n+        if (targetNode.nodeDescription != null) {\n+            rc.expctxNode.evaluate(false, targetNode.nodeDescription);\n+            final float initialcost = rc.expctxNode.getInitialcost();\n+            if (initialcost >= 1000000.) {\n+                return -1.;\n+            }\n+            cutEkin(km.totalweight, km.getNodeMaxspeed()); // apply node maxspeed\n+\n+            if (message != null) {\n+                message.linknodecost += (int) initialcost;\n+                message.nodeKeyValues = rc.expctxNode.getKeyValueDescription(false, targetNode.nodeDescription);\n+\n+                message.vnode1 = (int) (km.getNodeMaxspeed() * 3.6 + 0.5);\n+            }\n+            return initialcost;\n+        }\n+        return 0.;\n+    }\n+\n+    private void cutEkin(final double weight, final double speed) {\n+        final double e = 0.5 * weight * speed * speed;\n+        if (ekin > e) {\n+            ekin = e;\n+        }\n+    }\n+\n+\n+    @Override\n+    public int elevationCorrection(final RoutingContext rc) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean definitlyWorseThan(final OsmPath path, final RoutingContext rc) {\n+        final KinematicPath p = (KinematicPath) path;\n+\n+        final int c = p.cost;\n+        return cost > c + 100;\n+    }\n+\n+    @Override\n+    public double getTotalTime() {\n+        return totalTime;\n+    }\n+\n+    @Override\n+    public double getTotalEnergy() {\n+        return totalEnergy;\n+    }\n+}"
  },
  {
    "sha": "e77a84d45fba9351d417f211a332d15dd7dd7ca9",
    "filename": "main/src/cgeo/geocaching/brouter/core/KinematicPrePath.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicPrePath.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/KinematicPrePath.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/KinematicPrePath.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,55 @@\n+/**\n+ * Simple version of OsmPath just to get angle and priority of first segment\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.mapaccess.OsmNode;\n+import cgeo.geocaching.brouter.mapaccess.OsmTransferNode;\n+\n+final class KinematicPrePath extends OsmPrePath {\n+    public double angle;\n+    public int priorityclassifier;\n+    public int classifiermask;\n+\n+    protected void initPrePath(final OsmPath origin, final RoutingContext rc) {\n+        final byte[] description = link.descriptionBitmap;\n+        if (description == null) {\n+            throw new IllegalArgumentException(\"null description for: \" + link);\n+        }\n+\n+        // extract the 3 positions of the first section\n+        final int lon0 = origin.originLon;\n+        final int lat0 = origin.originLat;\n+\n+        final OsmNode p1 = sourceNode;\n+        final int lon1 = p1.getILon();\n+        final int lat1 = p1.getILat();\n+\n+        final boolean isReverse = link.isReverse(sourceNode);\n+\n+        // evaluate the way tags\n+        rc.expctxWay.evaluate(rc.inverseDirection ^ isReverse, description);\n+\n+        final OsmTransferNode transferNode = link.geometry == null ? null\n+            : rc.geometryDecoder.decodeGeometry(link.geometry, p1, targetNode, isReverse);\n+\n+        final int lon2;\n+        final int lat2;\n+\n+        if (transferNode == null) {\n+            lon2 = targetNode.ilon;\n+            lat2 = targetNode.ilat;\n+        } else {\n+            lon2 = transferNode.ilon;\n+            lat2 = transferNode.ilat;\n+        }\n+\n+        final int dist = rc.calcDistance(lon1, lat1, lon2, lat2);\n+\n+        angle = rc.anglemeter.calcAngle(lon0, lat0, lon1, lat1, lon2, lat2);\n+        priorityclassifier = (int) rc.expctxWay.getPriorityClassifier();\n+        classifiermask = (int) rc.expctxWay.getClassifierMask();\n+    }\n+}"
  },
  {
    "sha": "9b2d57ccda5c907433c173e0b96eb79ec00be84a",
    "filename": "main/src/cgeo/geocaching/brouter/core/MessageData.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/MessageData.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/MessageData.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/MessageData.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,102 @@\n+/**\n+ * Information on matched way point\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+\n+final class MessageData implements Cloneable {\n+    public int linkdist = 0;\n+    public int linkelevationcost = 0;\n+    public int linkturncost = 0;\n+    public int linknodecost = 0;\n+    public int linkinitcost = 0;\n+\n+    public float costfactor;\n+    public int priorityclassifier;\n+    public int classifiermask;\n+    public float turnangle;\n+    public String wayKeyValues;\n+    public String nodeKeyValues;\n+\n+    public int lon;\n+    public int lat;\n+    public short ele;\n+\n+    public float time;\n+    public float energy;\n+\n+    // speed profile\n+    public int vmaxExplicit = -1;\n+    public int vmax = -1;\n+    public int vmin = -1;\n+    public int vnode0 = 999;\n+    public int vnode1 = 999;\n+    public int extraTime = 0;\n+\n+    public String toMessage() {\n+        if (wayKeyValues == null) {\n+            return null;\n+        }\n+\n+        final int iCost = (int) (costfactor * 1000 + 0.5f);\n+        return (lon - 180000000) + \"\\t\"\n+            + (lat - 90000000) + \"\\t\"\n+            + ele / 4 + \"\\t\"\n+            + linkdist + \"\\t\"\n+            + iCost + \"\\t\"\n+            + linkelevationcost\n+            + \"\\t\" + linkturncost\n+            + \"\\t\" + linknodecost\n+            + \"\\t\" + linkinitcost\n+            + \"\\t\" + wayKeyValues\n+            + \"\\t\" + (nodeKeyValues == null ? \"\" : nodeKeyValues);\n+    }\n+\n+    public void add(final MessageData d) {\n+        linkdist += d.linkdist;\n+        linkelevationcost += d.linkelevationcost;\n+        linkturncost += d.linkturncost;\n+        linknodecost += d.linknodecost;\n+        linkinitcost += d.linkinitcost;\n+    }\n+\n+    public MessageData copy() {\n+        try {\n+            return (MessageData) clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"dist=\" + linkdist + \" prio=\" + priorityclassifier + \" turn=\" + turnangle;\n+    }\n+\n+    public int getPrio() {\n+        return priorityclassifier;\n+    }\n+\n+    public boolean isBadOneway() {\n+        return (classifiermask & 1) != 0;\n+    }\n+\n+    public boolean isGoodOneway() {\n+        return (classifiermask & 2) != 0;\n+    }\n+\n+    public boolean isRoundabout() {\n+        return (classifiermask & 4) != 0;\n+    }\n+\n+    public boolean isLinktType() {\n+        return (classifiermask & 8) != 0;\n+    }\n+\n+    public boolean isGoodForCars() {\n+        return (classifiermask & 16) != 0;\n+    }\n+\n+}"
  },
  {
    "sha": "4ed8cc725827c617f71938c40e00f71b79bc9018",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmNodeNamed.java",
    "status": "added",
    "additions": 102,
    "deletions": 0,
    "changes": 102,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmNodeNamed.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmNodeNamed.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmNodeNamed.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,102 @@\n+/**\n+ * Container for an osm node\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.mapaccess.OsmNode;\n+import cgeo.geocaching.brouter.util.CheapRulerHelper;\n+\n+public class OsmNodeNamed extends OsmNode {\n+    public String name;\n+    public double radius; // radius of nogopoint (in meters)\n+    public double nogoWeight;  // weight for nogopoint\n+    public boolean isNogo = false;\n+\n+    public OsmNodeNamed() {\n+    }\n+\n+    public OsmNodeNamed(final OsmNode n) {\n+        super(n.ilon, n.ilat);\n+    }\n+\n+    public static OsmNodeNamed decodeNogo(final String s) {\n+        final OsmNodeNamed n = new OsmNodeNamed();\n+        final int idx1 = s.indexOf(',');\n+        n.ilon = Integer.parseInt(s.substring(0, idx1));\n+        final int idx2 = s.indexOf(',', idx1 + 1);\n+        n.ilat = Integer.parseInt(s.substring(idx1 + 1, idx2));\n+        final int idx3 = s.indexOf(',', idx2 + 1);\n+        if (idx3 == -1) {\n+            n.name = s.substring(idx2 + 1);\n+            n.nogoWeight = Double.NaN;\n+        } else {\n+            n.name = s.substring(idx2 + 1, idx3);\n+            n.nogoWeight = Double.parseDouble(s.substring(idx3 + 1));\n+        }\n+        n.isNogo = true;\n+        return n;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (Double.isNaN(nogoWeight)) {\n+            return ilon + \",\" + ilat + \",\" + name;\n+        } else {\n+            return ilon + \",\" + ilat + \",\" + name + \",\" + nogoWeight;\n+        }\n+    }\n+\n+    public double distanceWithinRadius(final int lon1In, final int lat1In, final int lon2In, final int lat2In, final double totalSegmentLength) {\n+        int lon1 = lon1In;\n+        int lat1 = lat1In;\n+        int lon2 = lon2In;\n+        int lat2 = lat2In;\n+        final double[] lonlat2m = CheapRulerHelper.getLonLatToMeterScales((lat1 + lat2) >> 1);\n+\n+        boolean isFirstPointWithinCircle = CheapRulerHelper.distance(lon1, lat1, ilon, ilat) < radius;\n+        boolean isLastPointWithinCircle = CheapRulerHelper.distance(lon2, lat2, ilon, ilat) < radius;\n+        // First point is within the circle\n+        if (isFirstPointWithinCircle) {\n+            // Last point is within the circle\n+            if (isLastPointWithinCircle) {\n+                return totalSegmentLength;\n+            }\n+            // Last point is not within the circle\n+            // Just swap points and go on with first first point not within the\n+            // circle now.\n+            // Swap longitudes\n+            int tmp = lon2;\n+            lon2 = lon1;\n+            lon1 = tmp;\n+            // Swap latitudes\n+            tmp = lat2;\n+            lat2 = lat1;\n+            lat1 = tmp;\n+            // Fix boolean values\n+            isLastPointWithinCircle = isFirstPointWithinCircle;\n+            isFirstPointWithinCircle = false;\n+        }\n+        // Distance between the initial point and projection of center of\n+        // the circle on the current segment.\n+        final double initialToProject = (\n+            (lon2 - lon1) * (ilon - lon1) * lonlat2m[0] * lonlat2m[0]\n+                + (lat2 - lat1) * (ilat - lat1) * lonlat2m[1] * lonlat2m[1]\n+        ) / totalSegmentLength;\n+        // Distance between the initial point and the center of the circle.\n+        final double initialToCenter = CheapRulerHelper.distance(ilon, ilat, lon1, lat1);\n+        // Half length of the segment within the circle\n+        final double halfDistanceWithin = Math.sqrt(\n+            radius * radius - (\n+                initialToCenter * initialToCenter -\n+                    initialToProject * initialToProject\n+            )\n+        );\n+        // Last point is within the circle\n+        if (isLastPointWithinCircle) {\n+            return halfDistanceWithin + (totalSegmentLength - initialToProject);\n+        }\n+        return 2 * halfDistanceWithin;\n+    }\n+}"
  },
  {
    "sha": "c32f2a22993c3c8bfbc88e9f570a7eb445dcde30",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmNogoPolygon.java",
    "status": "added",
    "additions": 463,
    "deletions": 0,
    "changes": 463,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmNogoPolygon.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmNogoPolygon.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmNogoPolygon.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,463 @@\n+/**********************************************************************************************\n+ Copyright (C) 2018 Norbert Truchsess norbert.truchsess@t-online.de\n+\n+ The following methods are based on work of Dan Sunday published at:\n+ http://geomalgorithms.com/a03-_inclusion.html\n+\n+ cn_PnPoly, wn_PnPoly, inSegment, intersect2D_2Segments\n+ **********************************************************************************************/\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.util.CheapRulerHelper;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class OsmNogoPolygon extends OsmNodeNamed {\n+    public final List<Point> points = new ArrayList<Point>();\n+    public final boolean isClosed;\n+\n+    public OsmNogoPolygon(final boolean closed) {\n+        this.isClosed = closed;\n+        this.isNogo = true;\n+        this.name = \"\";\n+    }\n+\n+    public static boolean isOnLine(final long px, final long py, final long p0x, final long p0y, final long p1x, final long p1y) {\n+        final double v10x = px - p0x;\n+        final double v10y = py - p0y;\n+        final double v12x = p1x - p0x;\n+        final double v12y = p1y - p0y;\n+\n+        if (v10x == 0) { // P0->P1 vertical?\n+            if (v10y == 0) { // P0 == P1?\n+                return true;\n+            }\n+            if (v12x != 0) { // P1->P2 not vertical?\n+                return false;\n+            }\n+            return (v12y / v10y) >= 1; // P1->P2 at least as long as P1->P0?\n+        }\n+        if (v10y == 0) { // P0->P1 horizontal?\n+            if (v12y != 0) { // P1->P2 not horizontal?\n+                return false;\n+            }\n+            // if ( P10x == 0 ) // P0 == P1? already tested\n+            return (v12x / v10x) >= 1; // P1->P2 at least as long as P1->P0?\n+        }\n+        final double kx = v12x / v10x;\n+        if (kx < 1) {\n+            return false;\n+        }\n+        return kx == v12y / v10y;\n+    }\n+\n+    /**\n+     * inSegment(): determine if a point is inside a segment\n+     *\n+     * @param p      a point\n+     * @param segP0 starting point of segment\n+     * @param segP1 ending point of segment\n+     * @return 1 = P is inside S\n+     * 0 = P is not inside S\n+     */\n+    private static boolean inSegment(final Point p, final Point segP0, final Point segP1) {\n+        final int sp0x = segP0.x;\n+        final int sp1x = segP1.x;\n+\n+        if (sp0x != sp1x) { // S is not vertical\n+            final int px = p.x;\n+            if (sp0x <= px && px <= sp1x) {\n+                return true;\n+            }\n+            return sp0x >= px && px >= sp1x;\n+        } else { // S is vertical, so test y coordinate\n+            final int sp0y = segP0.y;\n+            final int sp1y = segP1.y;\n+            final int py = p.y;\n+\n+            if (sp0y <= py && py <= sp1y) {\n+                return true;\n+            }\n+            return sp0y >= py && py >= sp1y;\n+        }\n+    }\n+\n+    /**\n+     * intersect2D_2Segments(): find the 2D intersection of 2 finite segments\n+     *\n+     * @param s1p0 start point of segment 1\n+     * @param s1p1 end point of segment 1\n+     * @param s2p0 start point of segment 2\n+     * @param s2p1 end point of segment 2\n+     * @return 0=disjoint (no intersect)\n+     * 1=intersect in unique point I0\n+     * 2=overlap in segment from I0 to I1\n+     */\n+    private static int intersect2D2Segments(final Point s1p0, final Point s1p1, final Point s2p0, final Point s2p1) {\n+        final long ux = s1p1.x - s1p0.x; // vector u = S1P1-S1P0 (segment 1)\n+        final long uy = s1p1.y - s1p0.y;\n+        final long vx = s2p1.x - s2p0.x; // vector v = S2P1-S2P0 (segment 2)\n+        final long vy = s2p1.y - s2p0.y;\n+        final long wx = s1p0.x - s2p0.x; // vector w = S1P0-S2P0 (from start of segment 2 to start of segment 1\n+        final long wy = s1p0.y - s2p0.y;\n+\n+        final double d = ux * vy - uy * vx;\n+\n+        // test if  they are parallel (includes either being a point)\n+        if (d == 0) {           // S1 and S2 are parallel\n+            if ((ux * wy - uy * wx) != 0 || (vx * wy - vy * wx) != 0) {\n+                return 0; // they are NOT collinear\n+            }\n+\n+            // they are collinear or degenerate\n+            // check if they are degenerate  points\n+            final boolean du = (ux == 0) && (uy == 0);\n+            final boolean dv = (vx == 0) && (vy == 0);\n+            if (du && dv) {            // both segments are points\n+                return (wx == 0 && wy == 0) ? 0 : 1; // return 0 if they are distinct points\n+            }\n+            if (du) {                     // S1 is a single point\n+                return inSegment(s1p0, s2p0, s2p1) ? 1 : 0; // is it part of S2?\n+            }\n+            if (dv) {                    // S2 a single point\n+                return inSegment(s2p0, s1p0, s1p1) ? 1 : 0;  // is it part of S1?\n+            }\n+            // they are collinear segments - get  overlap (or not)\n+            double t0;                    // endpoints of S1 in eqn for S2\n+            double t1;\n+            final int w2x = s1p1.x - s2p0.x; // vector w2 = S1P1-S2P0 (from start of segment 2 to end of segment 1)\n+            final int w2y = s1p1.y - s2p0.y;\n+            if (vx != 0) {\n+                t0 = wx / vx;\n+                t1 = w2x / vx;\n+            } else {\n+                t0 = wy / vy;\n+                t1 = w2y / vy;\n+            }\n+            if (t0 > t1) {                   // must have t0 smaller than t1\n+                final double t = t0;     // swap if not\n+                t0 = t1;\n+                t1 = t;\n+            }\n+            if (t0 > 1 || t1 < 0) {\n+                return 0;      // NO overlap\n+            }\n+            t0 = t0 < 0 ? 0 : t0;               // clip to min 0\n+            t1 = t1 > 1 ? 1 : t1;               // clip to max 1\n+\n+            return (t0 == t1) ? 1 : 2;        // return 1 if intersect is a point\n+        }\n+\n+        // the segments are skew and may intersect in a point\n+        // get the intersect parameter for S1\n+\n+        final double sI = (vx * wy - vy * wx) / d;\n+        if (sI < 0 || sI > 1) {              // no intersect with S1\n+            return 0;\n+        }\n+\n+        // get the intersect parameter for S2\n+        final double tI = (ux * wy - uy * wx) / d;\n+        return (tI < 0 || tI > 1) ? 0 : 1; // return 0 if no intersect with S2\n+    }\n+\n+    public final void addVertex(final int lon, final int lat) {\n+        points.add(new Point(lon, lat));\n+    }\n+\n+    /**\n+     * calcBoundingCircle is inspired by the algorithm described on\n+     * http://geomalgorithms.com/a08-_containers.html\n+     * (fast computation of bounding circly in c). It is not as fast (the original\n+     * algorithm runs in linear time), as it may do more iterations but it takes\n+     * into account the coslat-factor being used for the linear approximation that\n+     * is also used in other places of brouter does change when moving the centerpoint\n+     * with each iteration.\n+     * This is done to ensure the calculated radius being used\n+     * in RoutingContext.calcDistance will actually contain the whole polygon.\n+     * <p>\n+     * For reasonable distributed vertices the implemented algorithm runs in O(n*ln(n)).\n+     * As this is only run once on initialization of OsmNogoPolygon this methods\n+     * overall usage of cpu is neglegible in comparism to the cpu-usage of the\n+     * actual routing algoritm.\n+     */\n+    public void calcBoundingCircle() {\n+        int cxmin = Integer.MAX_VALUE;\n+        int cxmax = Integer.MIN_VALUE;\n+        int cymin = Integer.MAX_VALUE;\n+        int cymax = Integer.MIN_VALUE;\n+\n+        // first calculate a starting center point as center of boundingbox\n+        for (int i = 0; i < points.size(); i++) {\n+            final Point p = points.get(i);\n+            if (p.x < cxmin) {\n+                cxmin = p.x;\n+            }\n+            if (p.x > cxmax) {\n+                cxmax = p.x;\n+            }\n+            if (p.y < cymin) {\n+                cymin = p.y;\n+            }\n+            if (p.y > cymax) {\n+                cymax = p.y;\n+            }\n+        }\n+\n+        int cx = (cxmax + cxmin) / 2; // center of circle\n+        int cy = (cymax + cymin) / 2;\n+\n+        final double[] lonlat2m = CheapRulerHelper.getLonLatToMeterScales(cy);\n+\n+        double rad = 0;  // radius\n+\n+        double dmax = 0; // length of vector from center to point\n+        int iMax = -1;\n+\n+        do {\n+            // now identify the point outside of the circle that has the greatest distance\n+            for (int i = 0; i < points.size(); i++) {\n+                final Point p = points.get(i);\n+                final double dist = CheapRulerHelper.distance(p.x, p.y, cx, cy);\n+                if (dist <= rad) {\n+                    continue;\n+                }\n+                if (dist > dmax) {\n+                    // new maximum distance found\n+                    dmax = dist;\n+                    iMax = i;\n+                }\n+            }\n+            if (iMax < 0) {\n+                break; // leave loop when no point outside the circle is found any more.\n+            }\n+            final double dd = 0.5 * (1 - rad / dmax);\n+\n+            final Point p = points.get(iMax); // calculate new radius to just include this point\n+            cx += (int) (dd * (p.x - cx) + 0.5); // shift center toward point\n+            cy += (int) (dd * (p.y - cy) + 0.5);\n+\n+            rad = CheapRulerHelper.distance(p.x, p.y, cx, cy);\n+            dmax = rad;\n+            iMax = -1;\n+        }\n+        while (true);\n+\n+        ilon = cx;\n+        ilat = cy;\n+        radius = rad;\n+    }\n+\n+    /**\n+     * tests whether a segment defined by lon and lat of two points does either\n+     * intersect the polygon or any of the endpoints (or both) are enclosed by\n+     * the polygon. For this test the winding-number algorithm is\n+     * being used. That means a point being within an overlapping region of the\n+     * polygon is also taken as being 'inside' the polygon.\n+     *\n+     * @param lon0 longitude of start point\n+     * @param lat0 latitude of start point\n+     * @param lon1 longitude of end point\n+     * @param lat1 latitude of start point\n+     * @return true if segment or any of it's points are 'inside' of polygon\n+     */\n+    public boolean intersects(final int lon0, final int lat0, final int lon1, final int lat1) {\n+        final Point p0 = new Point(lon0, lat0);\n+        final Point p1 = new Point(lon1, lat1);\n+        final int iLast = points.size() - 1;\n+        Point p2 = points.get(isClosed ? iLast : 0);\n+        for (int i = isClosed ? 0 : 1; i <= iLast; i++) {\n+            final Point p3 = points.get(i);\n+            // does it intersect with at least one of the polygon's segments?\n+            if (intersect2D2Segments(p0, p1, p2, p3) > 0) {\n+                return true;\n+            }\n+            p2 = p3;\n+        }\n+        return false;\n+    }\n+\n+/* Copyright 2001 softSurfer, 2012 Dan Sunday, 2018 Norbert Truchsess\n+   This code may be freely used and modified for any purpose providing that\n+   this copyright notice is included with it. SoftSurfer makes no warranty for\n+   this code, and cannot be held liable for any real or imagined damage\n+   resulting from its use. Users of this code must verify correctness for\n+   their application. */\n+\n+    public boolean isOnPolyline(final long px, final long py) {\n+        final int iLast = points.size() - 1;\n+        Point p1 = points.get(0);\n+        for (int i = 1; i <= iLast; i++) {\n+            final Point p2 = points.get(i);\n+            if (OsmNogoPolygon.isOnLine(px, py, p1.x, p1.y, p2.x, p2.y)) {\n+                return true;\n+            }\n+            p1 = p2;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * winding number test for a point in a polygon\n+     *\n+     * @param px longitude of the point to check\n+     * @param py latitude of the point to check\n+     * @return a boolean whether the point is within the polygon or not.\n+     */\n+    public boolean isWithin(final long px, final long py) {\n+        int wn = 0; // the winding number counter\n+\n+        // loop through all edges of the polygon\n+        final int iLast = points.size() - 1;\n+        final Point p0 = points.get(isClosed ? iLast : 0);\n+        long p0x = p0.x; // need to use long to avoid overflow in products\n+        long p0y = p0.y;\n+\n+        for (int i = isClosed ? 0 : 1; i <= iLast; i++) { // edge from v[i] to v[i+1]\n+            final Point p1 = points.get(i);\n+\n+            final long p1x = p1.x;\n+            final long p1y = p1.y;\n+\n+            if (OsmNogoPolygon.isOnLine(px, py, p0x, p0y, p1x, p1y)) {\n+                return true;\n+            }\n+\n+            final long intersect = (p1x - p0x) * (py - p0y) - (px - p0x) * (p1y - p0y);\n+            if (p0y <= py) {  // start y <= p.y\n+                // an upward crossing, p left of edge\n+                // have a valid up intersect\n+                if (p1y > py && intersect > 0) {\n+                    ++wn;\n+                }\n+            } else { // start y > p.y (no test needed)\n+                // a downward crossing, p right of edge\n+                // have a valid down intersect\n+                if (p1y <= py && intersect < 0) {\n+                    --wn;\n+                }\n+            }\n+            p0x = p1x;\n+            p0y = p1y;\n+        }\n+        return wn != 0;\n+    }\n+\n+/* Copyright 2001 softSurfer, 2012 Dan Sunday, 2018 Norbert Truchsess\n+   This code may be freely used and modified for any purpose providing that\n+   this copyright notice is included with it. SoftSurfer makes no warranty for\n+   this code, and cannot be held liable for any real or imagined damage\n+   resulting from its use. Users of this code must verify correctness for\n+   their application. */\n+\n+    /**\n+     * Compute the length of the segment within the polygon.\n+     *\n+     * @param lon1 Integer longitude of the first point of the segment.\n+     * @param lat1 Integer latitude of the first point of the segment.\n+     * @param lon2 Integer longitude of the last point of the segment.\n+     * @param lat2 Integer latitude of the last point of the segment.\n+     * @return The length, in meters, of the portion of the segment which is\n+     * included in the polygon.\n+     */\n+    public double distanceWithinPolygon(final int lon1, final int lat1, final int lon2, final int lat2) {\n+        double distance = 0.;\n+\n+        // Extremities of the segments\n+        final Point p1 = new Point(lon1, lat1);\n+        final Point p2 = new Point(lon2, lat2);\n+\n+        Point previousIntersectionOnSegment = null;\n+        if (isWithin(lon1, lat1)) {\n+            // Start point of the segment is within the polygon, this is the first\n+            // \"intersection\".\n+            previousIntersectionOnSegment = p1;\n+        }\n+\n+        // Loop over edges of the polygon to find intersections\n+        final int iLast = points.size() - 1;\n+        for (int i = isClosed ? 0 : 1, j = isClosed ? iLast : 0; i <= iLast; j = i++) {\n+            final Point edgePoint1 = points.get(j);\n+            final Point edgePoint2 = points.get(i);\n+            final int intersectsEdge = intersect2D2Segments(p1, p2, edgePoint1, edgePoint2);\n+\n+            if (isClosed && intersectsEdge == 1) {\n+                // Intersects with a (closed) polygon edge on a single point\n+                // Distance is zero when crossing a polyline.\n+                // Let's find this intersection point\n+                final int xdiffSegment = lon1 - lon2;\n+                final int xdiffEdge = edgePoint1.x - edgePoint2.x;\n+                final int ydiffSegment = lat1 - lat2;\n+                final int ydiffEdge = edgePoint1.y - edgePoint2.y;\n+                final int div = xdiffSegment * ydiffEdge - xdiffEdge * ydiffSegment;\n+                final long dSegment = (long) lon1 * (long) lat2 - (long) lon2 * (long) lat1;\n+                final long dEdge = (long) edgePoint1.x * (long) edgePoint2.y - (long) edgePoint2.x * (long) edgePoint1.y;\n+                // Coordinates of the intersection\n+                final Point intersection = new Point(\n+                    (int) ((dSegment * xdiffEdge - dEdge * xdiffSegment) / div),\n+                    (int) ((dSegment * ydiffEdge - dEdge * ydiffSegment) / div)\n+                );\n+                if (\n+                    previousIntersectionOnSegment != null\n+                        && isWithin(\n+                        (intersection.x + previousIntersectionOnSegment.x) >> 1,\n+                        (intersection.y + previousIntersectionOnSegment.y) >> 1\n+                    )\n+                ) {\n+                    // There was a previous match within the polygon and this part of the\n+                    // segment is within the polygon.\n+                    distance += CheapRulerHelper.distance(\n+                        previousIntersectionOnSegment.x, previousIntersectionOnSegment.y,\n+                        intersection.x, intersection.y\n+                    );\n+                }\n+                previousIntersectionOnSegment = intersection;\n+            } else if (intersectsEdge == 2) {\n+                // Segment and edge overlaps\n+                // FIXME: Could probably be done in a smarter way\n+                distance += Math.min(\n+                    CheapRulerHelper.distance(p1.x, p1.y, p2.x, p2.y),\n+                    Math.min(\n+                        CheapRulerHelper.distance(edgePoint1.x, edgePoint1.y, edgePoint2.x, edgePoint2.y),\n+                        Math.min(\n+                            CheapRulerHelper.distance(p1.x, p1.y, edgePoint2.x, edgePoint2.y),\n+                            CheapRulerHelper.distance(edgePoint1.x, edgePoint1.y, p2.x, p2.y)\n+                        )\n+                    )\n+                );\n+                // FIXME: We could store intersection.\n+                previousIntersectionOnSegment = null;\n+            }\n+        }\n+\n+        if (\n+            previousIntersectionOnSegment != null\n+                && isWithin(lon2, lat2)\n+        ) {\n+            // Last point is within the polygon, add the remaining missing distance.\n+            distance += CheapRulerHelper.distance(\n+                previousIntersectionOnSegment.x, previousIntersectionOnSegment.y,\n+                lon2, lat2\n+            );\n+        }\n+        return distance;\n+    }\n+\n+/* Copyright 2001 softSurfer, 2012 Dan Sunday, 2018 Norbert Truchsess\n+   This code may be freely used and modified for any purpose providing that\n+   this copyright notice is included with it. SoftSurfer makes no warranty for\n+   this code, and cannot be held liable for any real or imagined damage\n+   resulting from its use. Users of this code must verify correctness for\n+   their application. */\n+\n+    public static final class Point {\n+        public final int y;\n+        public final int x;\n+\n+        Point(final int lon, final int lat) {\n+            x = lon;\n+            y = lat;\n+        }\n+    }\n+}"
  },
  {
    "sha": "ceceb5ce8660a0a4faa9f7cda5a2c7d4b780fa2e",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmPath.java",
    "status": "added",
    "additions": 432,
    "deletions": 0,
    "changes": 432,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPath.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPath.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmPath.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,432 @@\n+/**\n+ * Container for link between two Osm nodes\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.mapaccess.OsmLink;\n+import cgeo.geocaching.brouter.mapaccess.OsmLinkHolder;\n+import cgeo.geocaching.brouter.mapaccess.OsmNode;\n+import cgeo.geocaching.brouter.mapaccess.OsmTransferNode;\n+import cgeo.geocaching.brouter.mapaccess.TurnRestriction;\n+import cgeo.geocaching.brouter.util.CheapRulerHelper;\n+\n+import java.io.IOException;\n+\n+abstract class OsmPath implements OsmLinkHolder {\n+    private static final int PATH_START_BIT = 1;\n+    private static final int CAN_LEAVE_DESTINATION_BIT = 2;\n+    private static final int IS_ON_DESTINATION_BIT = 4;\n+    private static final int HAD_DESTINATION_START_BIT = 8;\n+    /**\n+     * The cost of that path (a modified distance)\n+     */\n+    public int cost = 0;\n+    // the elevation assumed for that path can have a value\n+    // if the corresponding node has not\n+    public short selev;\n+    public int airdistance = 0; // distance to endpos\n+    public OsmPathElement originElement;\n+    public OsmPathElement myElement;\n+    public int treedepth = 0;\n+    // the position of the waypoint just before\n+    // this path position (for angle calculation)\n+    public int originLon;\n+    public int originLat;\n+    public MessageData message;\n+    protected OsmNode sourceNode;\n+    protected OsmNode targetNode;\n+    protected OsmLink link;\n+    protected float traffic;\n+    // the classifier of the segment just before this paths position\n+    protected float lastClassifier;\n+    protected float lastInitialCost;\n+    protected int priorityclassifier;\n+    protected int bitfield = PATH_START_BIT;\n+    private OsmLinkHolder nextForLink = null;\n+\n+    private boolean getBit(final int mask) {\n+        return (bitfield & mask) != 0;\n+    }\n+\n+    private void setBit(final int mask, final boolean bit) {\n+        if (getBit(mask) != bit) {\n+            bitfield ^= mask;\n+        }\n+    }\n+\n+    public boolean didEnterDestinationArea() {\n+        return !getBit(HAD_DESTINATION_START_BIT) && getBit(IS_ON_DESTINATION_BIT);\n+    }\n+\n+    public void unregisterUpTree(final RoutingContext rc) {\n+        try {\n+            OsmPathElement pe = originElement;\n+            while (pe instanceof OsmPathElementWithTraffic && ((OsmPathElementWithTraffic) pe).unregister(rc)) {\n+                pe = pe.origin;\n+            }\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    public void registerUpTree() {\n+        if (originElement instanceof OsmPathElementWithTraffic) {\n+            final OsmPathElementWithTraffic ot = (OsmPathElementWithTraffic) originElement;\n+            ot.register();\n+            ot.addTraffic(traffic);\n+        }\n+    }\n+\n+    public void init(final OsmLink link) {\n+        this.link = link;\n+        targetNode = link.getTarget(null);\n+        selev = targetNode.getSElev();\n+\n+        originLon = -1;\n+        originLat = -1;\n+    }\n+\n+    public void init(final OsmPath origin, final OsmLink link, final OsmTrack refTrack, final boolean detailMode, final RoutingContext rc) {\n+        if (origin.myElement == null) {\n+            origin.myElement = OsmPathElement.create(origin, rc.countTraffic);\n+        }\n+        this.originElement = origin.myElement;\n+        this.link = link;\n+        this.sourceNode = origin.targetNode;\n+        this.targetNode = link.getTarget(sourceNode);\n+        this.cost = origin.cost;\n+        this.lastClassifier = origin.lastClassifier;\n+        this.lastInitialCost = origin.lastInitialCost;\n+        this.bitfield = origin.bitfield;\n+        init(origin);\n+        addAddionalPenalty(refTrack, detailMode, origin, link, rc);\n+    }\n+\n+    protected abstract void init(OsmPath orig);\n+\n+    protected abstract void resetState();\n+\n+\n+    protected void addAddionalPenalty(final OsmTrack refTrack, final boolean detailMode, final OsmPath origin, final OsmLink link, final RoutingContext rc) {\n+        final byte[] description = link.descriptionBitmap;\n+        if (description == null) {\n+            throw new IllegalArgumentException(\"null description for: \" + link);\n+        }\n+\n+        final boolean recordTransferNodes = detailMode || rc.countTraffic;\n+\n+        rc.nogoCost = 0.;\n+\n+        // extract the 3 positions of the first section\n+        int lon0 = origin.originLon;\n+        int lat0 = origin.originLat;\n+\n+        int lon1 = sourceNode.getILon();\n+        int lat1 = sourceNode.getILat();\n+        short ele1 = origin.selev;\n+\n+        int linkdisttotal = 0;\n+\n+        message = detailMode ? new MessageData() : null;\n+\n+        final boolean isReverse = link.isReverse(sourceNode);\n+\n+        // evaluate the way tags\n+        rc.expctxWay.evaluate(rc.inverseDirection ^ isReverse, description);\n+\n+\n+        // calculate the costfactor inputs\n+        final float costfactor = rc.expctxWay.getCostfactor();\n+        final boolean isTrafficBackbone = cost == 0 && rc.expctxWay.getIsTrafficBackbone() > 0.f;\n+        final int lastpriorityclassifier = priorityclassifier;\n+        priorityclassifier = (int) rc.expctxWay.getPriorityClassifier();\n+\n+        // *** add initial cost if the classifier changed\n+        final float newClassifier = rc.expctxWay.getInitialClassifier();\n+        final float newInitialCost = rc.expctxWay.getInitialcost();\n+        final float classifierDiff = newClassifier - lastClassifier;\n+        if (newClassifier != 0. && lastClassifier != 0. && (classifierDiff > 0.0005 || classifierDiff < -0.0005)) {\n+            final float initialcost = rc.inverseDirection ? lastInitialCost : newInitialCost;\n+            if (initialcost >= 1000000.) {\n+                cost = -1;\n+                return;\n+            }\n+\n+            final int iicost = (int) initialcost;\n+            if (message != null) {\n+                message.linkinitcost += iicost;\n+            }\n+            cost += iicost;\n+        }\n+        lastClassifier = newClassifier;\n+        lastInitialCost = newInitialCost;\n+\n+        // *** destination logic: no destination access in between\n+        final int classifiermask = (int) rc.expctxWay.getClassifierMask();\n+        final boolean newDestination = (classifiermask & 64) != 0;\n+        final boolean oldDestination = getBit(IS_ON_DESTINATION_BIT);\n+        if (getBit(PATH_START_BIT)) {\n+            setBit(PATH_START_BIT, false);\n+            setBit(CAN_LEAVE_DESTINATION_BIT, newDestination);\n+            setBit(HAD_DESTINATION_START_BIT, newDestination);\n+        } else {\n+            if (oldDestination && !newDestination) {\n+                if (getBit(CAN_LEAVE_DESTINATION_BIT)) {\n+                    setBit(CAN_LEAVE_DESTINATION_BIT, false);\n+                } else {\n+                    cost = -1;\n+                    return;\n+                }\n+            }\n+        }\n+        setBit(IS_ON_DESTINATION_BIT, newDestination);\n+\n+\n+        OsmTransferNode transferNode = link.geometry == null ? null\n+            : rc.geometryDecoder.decodeGeometry(link.geometry, sourceNode, targetNode, isReverse);\n+\n+        for (int nsection = 0; ; nsection++) {\n+\n+            originLon = lon1;\n+            originLat = lat1;\n+\n+            final int lon2;\n+            final int lat2;\n+            short ele2;\n+\n+            if (transferNode == null) {\n+                lon2 = targetNode.ilon;\n+                lat2 = targetNode.ilat;\n+                ele2 = targetNode.selev;\n+            } else {\n+                lon2 = transferNode.ilon;\n+                lat2 = transferNode.ilat;\n+                ele2 = transferNode.selev;\n+            }\n+\n+            boolean isStartpoint = lon0 == -1 && lat0 == -1;\n+\n+            // check turn restrictions (n detail mode (=final pass) no TR to not mess up voice hints)\n+            if (nsection == 0 && rc.considerTurnRestrictions && !detailMode && !isStartpoint && (rc.inverseDirection\n+                ? TurnRestriction.isTurnForbidden(sourceNode.firstRestriction, lon2, lat2, lon0, lat0, rc.bikeMode, rc.carMode)\n+                : TurnRestriction.isTurnForbidden(sourceNode.firstRestriction, lon0, lat0, lon2, lat2, rc.bikeMode, rc.carMode))) {\n+                cost = -1;\n+                return;\n+            }\n+\n+            // if recording, new MessageData for each section (needed for turn-instructions)\n+            if (message != null && message.wayKeyValues != null) {\n+                originElement.message = message;\n+                message = new MessageData();\n+            }\n+\n+            int dist = rc.calcDistance(lon1, lat1, lon2, lat2);\n+\n+            boolean stopAtEndpoint = false;\n+            if (rc.shortestmatch) {\n+                if (rc.isEndpoint) {\n+                    stopAtEndpoint = true;\n+                    ele2 = interpolateEle(ele1, ele2, rc.wayfraction);\n+                } else {\n+                    // we just start here, reset everything\n+                    cost = 0;\n+                    resetState();\n+                    lon0 = -1; // reset turncost-pipe\n+                    lat0 = -1;\n+                    isStartpoint = true;\n+\n+                    if (recordTransferNodes) {\n+                        if (rc.wayfraction > 0.) {\n+                            ele1 = interpolateEle(ele1, ele2, 1. - rc.wayfraction);\n+                            originElement = OsmPathElement.create(rc.ilonshortest, rc.ilatshortest, ele1, null, rc.countTraffic);\n+                        } else {\n+                            originElement = null; // prevent duplicate point\n+                        }\n+                    }\n+\n+                    if (rc.checkPendingEndpoint()) {\n+                        dist = rc.calcDistance(rc.ilonshortest, rc.ilatshortest, lon2, lat2);\n+                        if (rc.shortestmatch) {\n+                            stopAtEndpoint = true;\n+                            ele2 = interpolateEle(ele1, ele2, rc.wayfraction);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (message != null) {\n+                message.linkdist += dist;\n+            }\n+            linkdisttotal += dist;\n+\n+            // apply a start-direction if appropriate (by faking the origin position)\n+            if (isStartpoint) {\n+                if (rc.startDirectionValid) {\n+                    final double dir = rc.startDirection.intValue() * CheapRulerHelper.DEG_TO_RAD;\n+                    final double[] lonlat2m = CheapRulerHelper.getLonLatToMeterScales((lon0 + lat1) >> 1);\n+                    lon0 = lon1 - (int) (1000. * Math.sin(dir) / lonlat2m[0]);\n+                    lat0 = lat1 - (int) (1000. * Math.cos(dir) / lonlat2m[1]);\n+                } else {\n+                    lon0 = lon1 - (lon2 - lon1);\n+                    lat0 = lat1 - (lat2 - lat1);\n+                }\n+            }\n+            final double angle = rc.anglemeter.calcAngle(lon0, lat0, lon1, lat1, lon2, lat2);\n+            final double cosangle = rc.anglemeter.getCosAngle();\n+\n+            // *** elevation stuff\n+            double deltaH = 0.;\n+            if (ele2 == Short.MIN_VALUE) {\n+                ele2 = ele1;\n+            }\n+            if (ele1 != Short.MIN_VALUE) {\n+                deltaH = (ele2 - ele1) / 4.;\n+                if (rc.inverseDirection) {\n+                    deltaH = -deltaH;\n+                }\n+            }\n+\n+\n+            final double elevation = ele2 == Short.MIN_VALUE ? 100. : ele2 / 4.;\n+\n+            double sectionCost = processWaySection(rc, dist, deltaH, elevation, angle, cosangle, isStartpoint, nsection, lastpriorityclassifier);\n+            if ((sectionCost < 0. || costfactor > 9998. && !detailMode) || sectionCost + cost >= 2000000000.) {\n+                cost = -1;\n+                return;\n+            }\n+\n+            if (isTrafficBackbone) {\n+                sectionCost = 0.;\n+            }\n+\n+            cost += (int) sectionCost;\n+\n+            // calculate traffic\n+            if (rc.countTraffic) {\n+                final int minDist = (int) rc.trafficSourceMinDist;\n+                final int cost2 = cost < minDist ? minDist : cost;\n+                traffic += dist * rc.expctxWay.getTrafficSourceDensity() * Math.pow(cost2 / 10000.f, rc.trafficSourceExponent);\n+            }\n+\n+            // compute kinematic\n+            computeKinematic(rc, dist, deltaH, detailMode);\n+\n+            if (message != null) {\n+                message.turnangle = (float) angle;\n+                message.time = (float) getTotalTime();\n+                message.energy = (float) getTotalEnergy();\n+                message.priorityclassifier = priorityclassifier;\n+                message.classifiermask = classifiermask;\n+                message.lon = lon2;\n+                message.lat = lat2;\n+                message.ele = ele2;\n+                message.wayKeyValues = rc.expctxWay.getKeyValueDescription(isReverse, description);\n+            }\n+\n+            if (stopAtEndpoint) {\n+                if (recordTransferNodes) {\n+                    originElement = OsmPathElement.create(rc.ilonshortest, rc.ilatshortest, ele2, originElement, rc.countTraffic);\n+                    originElement.cost = cost;\n+                    if (message != null) {\n+                        originElement.message = message;\n+                    }\n+                }\n+                if (rc.nogoCost < 0) {\n+                    cost = -1;\n+                } else {\n+                    cost += rc.nogoCost;\n+                }\n+                return;\n+            }\n+\n+            if (transferNode == null) {\n+                // *** penalty for being part of the reference track\n+                if (refTrack != null && refTrack.containsNode(targetNode) && refTrack.containsNode(sourceNode)) {\n+                    final int reftrackcost = linkdisttotal;\n+                    cost += reftrackcost;\n+                }\n+                selev = ele2;\n+                break;\n+            }\n+            transferNode = transferNode.next;\n+\n+            if (recordTransferNodes) {\n+                originElement = OsmPathElement.create(lon2, lat2, ele2, originElement, rc.countTraffic);\n+                originElement.cost = cost;\n+                originElement.addTraffic(traffic);\n+                traffic = 0;\n+            }\n+            lon0 = lon1;\n+            lat0 = lat1;\n+            lon1 = lon2;\n+            lat1 = lat2;\n+            ele1 = ele2;\n+        }\n+\n+        // check for nogo-matches (after the *actual* start of segment)\n+        if (rc.nogoCost < 0) {\n+            cost = -1;\n+            return;\n+        } else {\n+            cost += rc.nogoCost;\n+        }\n+\n+        // add target-node costs\n+        final double targetCost = processTargetNode(rc);\n+        if (targetCost < 0. || targetCost + cost >= 2000000000.) {\n+            cost = -1;\n+            return;\n+        }\n+        cost += (int) targetCost;\n+    }\n+\n+\n+    public short interpolateEle(final short e1, final short e2, final double fraction) {\n+        if (e1 == Short.MIN_VALUE || e2 == Short.MIN_VALUE) {\n+            return Short.MIN_VALUE;\n+        }\n+        return (short) (e1 * (1. - fraction) + e2 * fraction);\n+    }\n+\n+    protected abstract double processWaySection(RoutingContext rc, double dist, double deltaH, double elevation, double angle, double cosangle, boolean isStartpoint, int nsection, int lastpriorityclassifier);\n+\n+    protected abstract double processTargetNode(RoutingContext rc);\n+\n+    protected void computeKinematic(final RoutingContext rc, final double dist, final double deltaH, final boolean detailMode) {\n+        // default: nothing to do\n+    }\n+\n+    public abstract int elevationCorrection(RoutingContext rc);\n+\n+    public abstract boolean definitlyWorseThan(OsmPath p, RoutingContext rc);\n+\n+    public OsmNode getSourceNode() {\n+        return sourceNode;\n+    }\n+\n+    public OsmNode getTargetNode() {\n+        return targetNode;\n+    }\n+\n+    public OsmLink getLink() {\n+        return link;\n+    }\n+\n+    public OsmLinkHolder getNextForLink() {\n+        return nextForLink;\n+    }\n+\n+    public void setNextForLink(final OsmLinkHolder holder) {\n+        nextForLink = holder;\n+    }\n+\n+    public double getTotalTime() {\n+        return 0.;\n+    }\n+\n+    public double getTotalEnergy() {\n+        return 0.;\n+    }\n+}"
  },
  {
    "sha": "05d67f0b32b6717c3eafb7a1ec76d7b44576cca6",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmPathElement.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathElement.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathElement.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmPathElement.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,114 @@\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.mapaccess.OsmNode;\n+import cgeo.geocaching.brouter.mapaccess.OsmPos;\n+import cgeo.geocaching.brouter.util.CheapRulerHelper;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ * Container for link between two Osm nodes\n+ *\n+ * @author ab\n+ */\n+\n+public class OsmPathElement implements OsmPos {\n+    public MessageData message = null; // description\n+    public int cost;\n+    public OsmPathElement origin;\n+    private int ilat; // latitude\n+    private int ilon; // longitude\n+    private short selev; // longitude\n+\n+    protected OsmPathElement() {\n+    }\n+\n+    // construct a path element from a path\n+    public static OsmPathElement create(final OsmPath path, final boolean countTraffic) {\n+        final OsmNode n = path.getTargetNode();\n+        final OsmPathElement pe = create(n.getILon(), n.getILat(), path.selev, path.originElement, countTraffic);\n+        pe.cost = path.cost;\n+        pe.message = path.message;\n+        return pe;\n+    }\n+\n+    public static OsmPathElement create(final int ilon, final int ilat, final short selev, final OsmPathElement origin, final boolean countTraffic) {\n+        final OsmPathElement pe = countTraffic ? new OsmPathElementWithTraffic() : new OsmPathElement();\n+        pe.ilon = ilon;\n+        pe.ilat = ilat;\n+        pe.selev = selev;\n+        pe.origin = origin;\n+        return pe;\n+    }\n+\n+    public static OsmPathElement readFromStream(final DataInput dis) throws IOException {\n+        final OsmPathElement pe = new OsmPathElement();\n+        pe.ilat = dis.readInt();\n+        pe.ilon = dis.readInt();\n+        pe.selev = dis.readShort();\n+        pe.cost = dis.readInt();\n+        return pe;\n+    }\n+\n+    // interface OsmPos\n+    public final int getILat() {\n+        return ilat;\n+    }\n+\n+    public final int getILon() {\n+        return ilon;\n+    }\n+\n+    public final short getSElev() {\n+        return selev;\n+    }\n+\n+    public final double getElev() {\n+        return selev / 4.;\n+    }\n+\n+    public final float getTime() {\n+        return message == null ? 0.f : message.time;\n+    }\n+\n+    public final void setTime(final float t) {\n+        if (message != null) {\n+            message.time = t;\n+        }\n+    }\n+\n+    public final float getEnergy() {\n+        return message == null ? 0.f : message.energy;\n+    }\n+\n+    public final void setEnergy(final float e) {\n+        if (message != null) {\n+            message.energy = e;\n+        }\n+    }\n+\n+    public final long getIdFromPos() {\n+        return ((long) ilon) << 32 | ilat;\n+    }\n+\n+    public final int calcDistance(final OsmPos p) {\n+        return (int) (CheapRulerHelper.distance(ilon, ilat, p.getILon(), p.getILat()) + 1.0);\n+    }\n+\n+    public void addTraffic(final float traffic) {\n+        // default: do nothing\n+    }\n+\n+    public String toString() {\n+        return ilon + \"_\" + ilat;\n+    }\n+\n+    public void writeToStream(final DataOutput dos) throws IOException {\n+        dos.writeInt(ilat);\n+        dos.writeInt(ilon);\n+        dos.writeShort(selev);\n+        dos.writeInt(cost);\n+    }\n+}"
  },
  {
    "sha": "e25cffe11673c62b1a8b063268941377c9564271",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmPathElementWithTraffic.java",
    "status": "added",
    "additions": 67,
    "deletions": 0,
    "changes": 67,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathElementWithTraffic.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathElementWithTraffic.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmPathElementWithTraffic.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,67 @@\n+package cgeo.geocaching.brouter.core;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * Extension to OsmPathElement to count traffic load\n+ *\n+ * @author ab\n+ */\n+\n+public final class OsmPathElementWithTraffic extends OsmPathElement {\n+    public static double maxtraffic = 0.;\n+    private int registerCount;\n+    private float farTraffic;\n+    private float nearTraffic;\n+\n+    public void register() {\n+        if (registerCount++ == 0 && origin instanceof OsmPathElementWithTraffic) {\n+            final OsmPathElementWithTraffic ot = (OsmPathElementWithTraffic) origin;\n+            ot.register();\n+            ot.farTraffic += farTraffic;\n+            ot.nearTraffic += nearTraffic;\n+            farTraffic = 0;\n+            nearTraffic = 0;\n+        }\n+    }\n+\n+    // unregister from origin if our registercount is 0, else do nothing\n+\n+    @Override\n+    public void addTraffic(final float traffic) {\n+        this.farTraffic += traffic;\n+        this.nearTraffic += traffic;\n+    }\n+\n+    public boolean unregister(final RoutingContext rc) throws IOException {\n+        if (--registerCount == 0) {\n+            if (origin instanceof OsmPathElementWithTraffic) {\n+                final OsmPathElementWithTraffic ot = (OsmPathElementWithTraffic) origin;\n+\n+                final int costdelta = cost - ot.cost;\n+                ot.farTraffic += farTraffic * Math.exp(-costdelta / rc.farTrafficDecayLength);\n+                ot.nearTraffic += nearTraffic * Math.exp(-costdelta / rc.nearTrafficDecayLength);\n+\n+                if (costdelta > 0 && farTraffic > maxtraffic) {\n+                    maxtraffic = farTraffic;\n+                }\n+\n+                final int t2 = cost == ot.cost ? -1 : (int) (rc.farTrafficWeight * farTraffic + rc.nearTrafficWeight * nearTraffic);\n+\n+                if (t2 > 4000 || t2 == -1) {\n+                    // System.out.println( \"unregistered: \" + this + \" origin=\" + ot + \" farTraffic =\" + farTraffic + \" nearTraffic =\" + nearTraffic + \" cost=\" + cost );\n+                    if (rc.trafficOutputStream != null) {\n+                        rc.trafficOutputStream.writeLong(getIdFromPos());\n+                        rc.trafficOutputStream.writeLong(ot.getIdFromPos());\n+                        rc.trafficOutputStream.writeInt(t2);\n+                    }\n+                }\n+                farTraffic = 0;\n+                nearTraffic = 0;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+}"
  },
  {
    "sha": "e792316cc900edbdb86dcb02f5a63e970e3be360",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmPathModel.java",
    "status": "added",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathModel.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPathModel.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmPathModel.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,19 @@\n+/**\n+ * Container for link between two Osm nodes\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.expressions.BExpressionContextNode;\n+import cgeo.geocaching.brouter.expressions.BExpressionContextWay;\n+\n+import java.util.Map;\n+\n+abstract class OsmPathModel {\n+    public abstract OsmPrePath createPrePath();\n+\n+    public abstract OsmPath createPath();\n+\n+    public abstract void init(BExpressionContextWay expctxWay, BExpressionContextNode expctxNode, Map<String, String> keyValues);\n+}"
  },
  {
    "sha": "50b262d64504c092117c4755e319d6b18b4b87e5",
    "filename": "main/src/cgeo/geocaching/brouter/core/OsmPrePath.java",
    "status": "added",
    "additions": 25,
    "deletions": 0,
    "changes": 25,
    "blob_url": "https://github.com/cgeo/cgeo/blob/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPrePath.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/6f3b934f890b27b9615a447b3af2e4dd23225d0f/main/src/cgeo/geocaching/brouter/core/OsmPrePath.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/brouter/core/OsmPrePath.java?ref=6f3b934f890b27b9615a447b3af2e4dd23225d0f",
    "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * Simple version of OsmPath just to get angle and priority of first segment\n+ *\n+ * @author ab\n+ */\n+package cgeo.geocaching.brouter.core;\n+\n+import cgeo.geocaching.brouter.mapaccess.OsmLink;\n+import cgeo.geocaching.brouter.mapaccess.OsmNode;\n+\n+public abstract class OsmPrePath {\n+    public OsmPrePath next;\n+    protected OsmNode sourceNode;\n+    protected OsmNode targetNode;\n+    protected OsmLink link;\n+\n+    public void init(final OsmPath origin, final OsmLink link, final RoutingContext rc) {\n+        this.link = link;\n+        this.sourceNode = origin.getTargetNode();\n+        this.targetNode = link.getTarget(sourceNode);\n+        initPrePath(origin, rc);\n+    }\n+\n+    protected abstract void initPrePath(OsmPath origin, RoutingContext rc);\n+}"
  }
]
