[
  {
    "sha": "37edf185c0a68bdd12dbacd3417a912d5ab82071",
    "filename": "main/AndroidManifest.xml",
    "status": "modified",
    "additions": 4,
    "deletions": 5,
    "changes": 9,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/AndroidManifest.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/AndroidManifest.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/AndroidManifest.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -248,9 +248,6 @@\n                 android:value=\"cgeo.geocaching.MainActivity\" />\n         </activity>\n         <activity android:name=\".settings.ViewSettingsActivity\" />\n-        <activity\n-            android:name=\".downloader.ReceiveMapFileActivity\">\n-        </activity>\n         <activity\n             android:name=\".HandleLocalFilesActivity\"\n             android:exported=\"true\"\n@@ -868,9 +865,11 @@\n                 android:name=\"android.support.PARENT_ACTIVITY\"\n                 android:value=\"cgeo.geocaching.MainActivity\" />\n         </activity>\n+        <activity android:name=\".downloader.DownloadConfirmationActivity\" android:exported=\"false\" />\n+        <activity android:name=\".downloader.ReceiveDownloadActivity\" />\n         <activity\n             android:name=\"cgeo.geocaching.downloader.MapDownloadSelectorActivity\"\n-            android:label=\"@string/downloadmap_title\"\n+            android:label=\"@string/download_title\"\n             android:parentActivityName=\"cgeo.geocaching.MainActivity\">\n             <meta-data\n                 android:name=\"android.support.PARENT_ACTIVITY\"\n@@ -910,7 +909,7 @@\n         </provider>\n \n         <!-- Receiver for downloaded (map) files -->\n-        <receiver android:name=\".downloader.MapDownloadNotificationReceiver\">\n+        <receiver android:name=\".downloader.DownloadNotificationReceiver\">\n             <intent-filter>\n                 <action android:name=\"android.intent.action.DOWNLOAD_COMPLETE\" />\n             </intent-filter>"
  },
  {
    "sha": "c2d48174f751f5d195a7060e77ba51b51e911549",
    "filename": "main/res/values/numbers.xml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/numbers.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/numbers.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/numbers.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -9,6 +9,8 @@\n     <!-- seekbar preference default & max values -->\n     <integer name=\"brouter_threshold_default\">10</integer>\n     <integer name=\"brouter_threshold_max\">120</integer>\n+    <integer name=\"brouter_updateinterval_default\">30</integer>\n+    <integer name=\"brouter_updateinterval_max\">366</integer>\n     <integer name=\"waypoint_threshold_default\">10</integer>\n     <integer name=\"waypoint_threshold_max\">200</integer>\n     <integer name=\"proximitynotification_distance_max\">1000</integer>"
  },
  {
    "sha": "fbae4e44c46fafa8fab1be651347b5aef17e8c48",
    "filename": "main/res/values/preference_keys.xml",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/preference_keys.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/preference_keys.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/preference_keys.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -36,6 +36,7 @@\n     <string translatable=\"false\" name=\"pref_fakekey_ec_authorization\">fakekey_ec_authorization</string>\n     <string translatable=\"false\" name=\"pref_fakekey_su_authorization\">fakekey_su_authorization</string>\n     <string translatable=\"false\" name=\"pref_fakekey_gcvote_authorization\">fakekey_gcvote_authorization</string>\n+    <string translatable=\"false\" name=\"preference_category_offlinerouting\">fakekey_offlinerouting_category</string>\n     <string translatable=\"false\" name=\"pref_connectorGCActive\">connectorGCActive</string>\n     <string translatable=\"false\" name=\"pref_username\">username</string>\n     <string translatable=\"false\" name=\"pref_password\">password</string>\n@@ -91,6 +92,10 @@\n     <string translatable=\"false\" name=\"pref_zoomincludingwaypoints\">zoomincludingwaypoints</string>\n     <string translatable=\"false\" name=\"pref_brouterDistanceThreshold\">brouterDistanceThreshold</string>\n     <string translatable=\"false\" name=\"pref_brouterShowBothDistances\">pref_brouterShowBothDistances</string>\n+    <string translatable=\"false\" name=\"pref_brouterAutoTileDownloads\">brouterAutoTileDownloads</string>\n+    <string translatable=\"false\" name=\"pref_brouterAutoTileDownloadsInterval\">brouterAutoTileDownloadsInterval</string>\n+    <string translatable=\"false\" name=\"pref_brouterAutoTileDownloadsLastCheck\">brouterAutoTileDownloadsLastCheck</string>\n+    <string translatable=\"false\" name=\"pref_fakekey_brouterTilesFolderInfo\">fakekey_brouterTilesFolderInfo</string>\n     <string translatable=\"false\" name=\"pref_bigSmileysOnMap\">pref_bigSmileysOnMap</string>\n     <string translatable=\"false\" name=\"pref_proximityNotificationGeneral\">pref_proximityNotificationGeneral</string>\n     <string translatable=\"false\" name=\"pref_proximityNotificationSpecific\">pref_proximityNotificationSpecific</string>\n@@ -273,6 +278,7 @@\n     <string translatable=\"false\" name=\"pref_persistablefolder_backup\">persistablefolder_backup</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_fieldnotes\">persistablefolder_fieldnotes</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_spoilerimages\">persistablefolder_spoilerimages</string>\n+    <string translatable=\"false\" name=\"pref_persistablefolder_broutertiles\">persistable_folder_broutertiles</string>\n     <string translatable=\"false\" name=\"pref_persistablefolder_testdir\">persistablefolder_testdir</string>\n \n     <!-- ids for persistable uri prefs -->"
  },
  {
    "sha": "776fdf18d55991d5821c16dc48ab91f42d02e1f6",
    "filename": "main/res/values/strings.xml",
    "status": "modified",
    "additions": 36,
    "deletions": 17,
    "changes": 53,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/strings.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/strings.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/strings.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -493,6 +493,8 @@\n     <string name=\"settings_title_map\">Map</string>\n     <string name=\"settings_summary_map\">Set map source, offline map settings and map details.</string>\n     <string name=\"settings_title_map_data\">Map Data</string>\n+    <string name=\"settings_title_offline_routing\">Offline routing</string>\n+    <string name=\"settings_summary_offline_routing\">Offline routing is available if helper app \\\"BRouter\\\" is installed and configured.</string>\n     <string name=\"settings_title_map_rotation\">Map rotation (Google Maps)</string>\n     <string name=\"settings_title_waypoints\">Waypoints</string>\n     <string name=\"settings_title_map_content\">Map Content</string>\n@@ -610,6 +612,8 @@\n     <string name=\"init_brouterThreshold\">Calculate route</string>\n     <string name=\"init_brouterThreshold_description\">Maximum distance up to which the BRouter helper app (if installed) will calculate a route.</string>\n     <string name=\"init_brouterShowBothDistances\">Show straight distance</string>\n+    <string name=\"init_brouterAutoTileDownloads\">Automatic download</string>\n+    <string name=\"init_brouterAutoTileDownloads_description\">Automatically offer to download missing routing tile data. BRouter data folder needs to be set in both c:geo and BRouter for this option to work.</string>\n     <string name=\"brouter_recalculating\">Recalculating route in background…</string>\n     <string name=\"init_summary_brouterShowBothDistances\">If routing is active: Show the straight distance in addition to the calculated route length.</string>\n     <string name=\"init_bigSmileysOnMap\">Big icons for logged caches</string>\n@@ -702,6 +706,10 @@\n     <string name=\"init_local_file_system\">Local File System</string>\n     <string name=\"init_base_directory_description\">Base folder for public local data</string>\n     <string name=\"init_map_directory_description\">Folder with offline maps</string>\n+    <string name=\"init_brouter_directory_description\">Folder with BRouter routing data</string>\n+    <string name=\"init_brouter_directory_additionalinfo\">(Default folder is something like \\'%1$s\\'. BRouter needs to be configured to use the same folder, see our online manual for details, especially when using Android 11 or higher.)</string>\n+    <string name=\"init_brouter_updateinterval_title\">Update interval</string>\n+    <string name=\"init_brouter_updateinterval_description\">Reminds you every x days for an update check</string>\n     <string name=\"init_gpx_importexportdir\">GPX Folder</string>\n     <string name=\"init_dataDir\">Select data folder</string>\n     <string name=\"init_dataDir_note\">You may choose to store the additional data for geocaches (spoilers, log images, …) on your external storage (emulated or real external SD card depending on your device).</string>\n@@ -885,6 +893,7 @@\n     <string name=\"persistablefolder_logfiles\">Logfiles</string>\n     <string name=\"persistablefolder_fieldnotes\">Field Notes</string>\n     <string name=\"persistablefolder_spoilerimages\">Spoiler Images</string>\n+    <string name=\"persistablefolder_broutertiles\">BRouter routing data</string>\n \n     <!-- FolderUtils: async processing -->\n     <string name=\"folder_process_status_done\">%1$s/%2$s, %3$s/%4$s done</string>\n@@ -2055,28 +2064,31 @@\n     <string name=\"localfile_title\">Open a local file</string>\n     <string name=\"localfile_cannot_handle\">Error reading file or c:geo cannot handle this file type.</string>\n \n-    <!-- ReceiveMapFileActivity -->\n-    <string name=\"receivemapfile_intenttitle\">Receive map file</string>\n-    <string name=\"receivemapfile_success\">Map file successfully received as \\\"%s\\\" and stored to the map folder</string>\n-    <string name=\"receivemapfile_error\">Error while receiving map file</string>\n-    <string name=\"receivemapfile_error_io_exception\">I/O error while receiving map file. Is your map folder \\\"%s\\\" writable?</string>\n-    <string name=\"receivemapfile_error_filenotfound_exception\">File not found error while receiving map file.</string>\n-    <string name=\"receivemapfile_alreadyexists\">A file with this name already exists. Overwrite existing file or save new file under a different name?</string>\n-    <string name=\"receivemapfile_option_overwrite\">Overwrite</string>\n-    <string name=\"receivemapfile_option_differentname\">Different name</string>\n-    <string name=\"receivemapfile_kb_copied\">%d kB copied</string>\n-    <string name=\"receivemapfile_cancelled\">Map file transfer cancelled</string>\n+    <!-- ReceiveDownloadActivity -->\n+    <string name=\"receivedownload_intenttitle\">Receive file</string>\n+    <string name=\"receivedownload_success\">File successfully stored as \\\"%s\\\"</string>\n+    <string name=\"receivedownload_error\">Error while receiving file</string>\n+    <string name=\"receivedownload_error_io_exception\">I/O error while receiving file. Is your folder \\\"%s\\\" writable?</string>\n+    <string name=\"receivedownload_error_filenotfound_exception\">File not found error while receiving file.</string>\n+    <string name=\"receivedownload_alreadyexists\">A file with this name already exists. Overwrite existing file or save new file under a different name?</string>\n+    <string name=\"receivedownload_option_overwrite\">Overwrite</string>\n+    <string name=\"receivedownload_option_differentname\">Different name</string>\n+    <string name=\"receivedownload_kb_copied\">%d kB copied</string>\n+    <string name=\"receivedownload_cancelled\">File transfer cancelled</string>\n \n     <!-- Download map preference and menu entry -->\n     <string name=\"downloadmap_title\">Download offline map</string>\n+    <string name=\"download_title\">Download file</string>\n     <string name=\"downloadmap_info\">Select a map file for your region by tapping the \\\"Save\\\" icon.\\n\\nThe download is performed in the background. When the transfer is complete, the file is copied to the c:geo map folder and set as the current map.\\n\\nBe careful: Downloading a map can cause high network traffic!</string>\n     <string name=\"downloadmap_choose\">Choose map</string>\n     <string name=\"downloadmap_filename\">Downloading %s</string>\n-    <string name=\"downloadmanager_not_available\">Map file cannot be downloaded, system download manager not available</string>\n+    <string name=\"downloadmanager_not_available\">File cannot be downloaded, system download manager not available</string>\n     <string name=\"download_started\">Downloading started in background</string>\n     <string name=\"downloadmap_target_not_writable\">The selected target \\\"%s\\\" is not writable - the downloaded map file is saved in the system download folder and must be moved manually to the map folder.</string>\n     <string name=\"downloadmap_allow_metered_network\">Allow download over metered network (e.g.: mobile connection)</string>\n-    <string name=\"downloadmap_confirmation\">Download map \\\"%1$s\\\"?\\n\\nThis may take quite some time and can lead to significant costs, depending on your network connection.\\n\\nSize info: %2$s</string>\n+    <string name=\"download_confirmation\">%1$sDownload file \\\"%2$s\\\"?%3$s</string>\n+    <string name=\"download_confirmation_updates\">Updates found for:\\n%1$s\\n\\nDo you want to update?%2$s</string>\n+    <string name=\"download_warning\">This may take quite some time and can lead to significant costs, depending on your network connection.</string>\n     <string name=\"downloadmap_handling\">The download itself will be handled by your system\\'s download manager in the background. You should see a notification as soon as the download started (which may take a while).</string>\n     <string name=\"button_continue\">Continue</string>\n     <string name=\"downloadmap_onedirup\">(one level up)</string>\n@@ -2089,11 +2101,17 @@\n     <string name=\"downloadmap_checking_for_updates\">Checking for updates…</string>\n     <string name=\"downloadmap_install_theme_title\">Install theme file</string>\n     <string name=\"downloadmap_install_theme_info\">Your downloaded map requires a special theme file. Do you want to download this as well?</string>\n+    <string name=\"downloadtile_title\">Missing routing data</string>\n+    <string name=\"downloadtile_info\">c:geo cannot calculate the requested route as there is some routing data file missing. Do you want to download missing routing data?</string>\n+    <string name=\"tileupdate_info\">Do you want to check for updates of downloaded routing data files?</string>\n+    <string name=\"no_updates_found\">No updates found</string>\n+    <string name=\"updates_check\">Updates check</string>\n     <string name=\"mapserver_mapsforge_info\">Basic maps, no map themes required</string>\n     <string name=\"mapserver_openandromaps_info\">Detailed maps, require map theme \\\"Elevate\\\"</string>\n     <string name=\"mapserver_openandromaps_themes_info\">Detailed map theme, built for \\\"OpenAndroMaps\\\" maps</string>\n     <string name=\"mapserver_freizeitkarte_info\">Detailed maps, require one of the \\\"freizeitkarte\\\" map themes.</string>\n     <string name=\"mapserver_freizeitkarte_themes_info\">Detailed map theme, built for \\\"Freizeitkarte\\\" maps</string>\n+    <string name=\"brouter_info\">Offline routing service</string>\n \n     <!-- history track -->\n     <string name=\"map_clear_trailhistory\">Clear history track</string>\n@@ -2124,9 +2142,11 @@\n     <string name=\"wizard_permissions_intro\">c:geo needs certain permissions on your device to work correctly.\\nI will explain more details in the next steps.</string>\n     <string name=\"wizard_permissions_folder_title\">Set folder: %s</string>\n     <string name=\"wizard_basefolder_request_explanation\">c:geo needs a local folder to store data like GPX files, backups, field notes and logfiles. As per default those files are stored in folders beneath a so called \"base folder\". Select or create such a folder in the next step.\\n\\nIf you upgraded c:geo from a previous version, select the existing folder \\\"cgeo\\\" on root level of your device storage.\\nHint: You may need to unhide your device\\'s internal storage first in the file selector being displayed next.</string>\n-    <string name=\"wizard_mapfolder_request_explanation\">c:geo needs a local folder to store offline map files. Select or create such a folder in the next step.</string>\n-    <string name=\"wizard_mapthemesfolder_request_explanation\">c:geo needs a local folder to store theme files for offline maps. Select or create such a folder in the next step.</string>\n-    <string name=\"wizard_gpxfolder_request_explanation\">c:geo needs a local folder to store GPX files (e.g. for importing / exporting caches or tracks). Select or create such a folder in the next step.</string>\n+    <string name=\"wizard_mapfolder_request_explanation\">c:geo needs a local folder to store offline map files.</string>\n+    <string name=\"wizard_mapthemesfolder_request_explanation\">c:geo needs a local folder to store theme files for offline maps.</string>\n+    <string name=\"wizard_gpxfolder_request_explanation\">c:geo needs a local folder to store GPX files (e.g. for importing / exporting caches or tracks).</string>\n+    <string name=\"wizard_broutertilesfolder_request_explanation\">In order to use the BRouter routing data auto-download and -update feature you need to set a tile data folder accessible by both BRouter and c:geo.</string>\n+    <string name=\"wizard_select_or_create\">Select or create such a folder in the next step.</string>\n     <string name=\"wizard_platforms_title\">Configure services</string>\n     <string name=\"wizard_platforms_intro\">To find geocaches with c:geo you need an account for a geocaching service supported by c:geo.\\nSelect the desired service below to either login with your existing account or create a new account.</string>\n     <string name=\"wizard_platforms_gc\">geocaching.com</string>\n@@ -2150,7 +2170,6 @@\n     <!-- Map Theme helper -->\n     <string name=\"mapthemes_foldersync_finished_toast\">%1$s folder synchronization finished after %2$s, %3$d of %4$s needed synchronization</string>\n \n-\n     <!-- default actions in dialogs -->\n     <string name=\"previous\">Previous</string>\n     <string name=\"skip\">Skip</string>"
  },
  {
    "sha": "c3194795d110b4b4ab40140644a198578933093c",
    "filename": "main/res/values/strings_not_translatable.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 1,
    "changes": 6,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/strings_not_translatable.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/values/strings_not_translatable.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/values/strings_not_translatable.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -222,7 +222,7 @@\n     <string translatable=\"false\" name=\"package_barcode_scanner\">com.google.zxing.client.android</string>\n     <string translatable=\"false\" name=\"package_locus\">menion.android.locus</string>\n \n-    <!-- map server urls -->\n+    <!-- map server & other download urls -->\n     <string translatable=\"false\" name=\"mapserver_mapsforge_name\">Mapsforge</string>\n     <string translatable=\"false\" name=\"mapserver_mapsforge_downloadurl\">https://ftp-stud.hs-esslingen.de/pub/Mirrors/download.mapsforge.org/maps/v5/</string>\n     <string translatable=\"false\" name=\"mapserver_mapsforge_likeiturl\">https://github.com/mapsforge/mapsforge</string>\n@@ -245,6 +245,10 @@\n     <string translatable=\"false\" name=\"mapserver_freizeitkarte_themes_name\">Freizeitkarte Themes</string>\n     <string translatable=\"false\" name=\"mapserver_freizeitkarte_themes_downloadurl\">http://download.freizeitkarte-osm.de/android/2012/</string>\n \n+    <string translatable=\"false\" name=\"brouter_name\">BRouter</string>\n+    <string translatable=\"false\" name=\"brouter_downloadurl\">http://brouter.de/brouter/segments4/</string>\n+    <string translatable=\"false\" name=\"brouter_projecturl\">https://www.brouter.de/brouter/</string>\n+\n     <!-- c:geo mail subject for problem reports -->\n     <string translatable=\"false\" name=\"mailsubject_problem_report\">c:geo problem report</string>\n </resources>"
  },
  {
    "sha": "3bafb3fe9ef7d27225af1831caf157b92f06b49a",
    "filename": "main/res/xml/preferences.xml",
    "status": "modified",
    "additions": 49,
    "deletions": 15,
    "changes": 64,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/xml/preferences.xml",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/res/xml/preferences.xml",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/res/xml/preferences.xml?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -596,6 +596,55 @@\n                 android:entryValues=\"@array/maprotationValues\" />\n         </PreferenceCategory>\n \n+        <PreferenceCategory android:title=\"@string/settings_title_offline_routing\" android:summary=\"@string/settings_summary_offline_routing\"\n+            android:layout=\"@layout/preference_category\"\n+            android:key=\"@string/preference_category_offlinerouting\">\n+            <Preference\n+                android:selectable=\"false\"\n+                android:summary=\"@string/init_brouterThreshold_description\"\n+                android:title=\"@string/init_brouterThreshold\" />\n+            <cgeo.geocaching.settings.ProximityPreference\n+                android:key=\"@string/pref_brouterDistanceThreshold\"\n+                app:min=\"1\"\n+                app:max=\"@integer/brouter_threshold_max\"\n+                android:defaultValue=\"@integer/brouter_threshold_default\"\n+                app:highRes=\"false\" />\n+\n+            <CheckBoxPreference\n+                android:defaultValue=\"false\"\n+                android:key=\"@string/pref_brouterShowBothDistances\"\n+                android:summary=\"@string/init_summary_brouterShowBothDistances\"\n+                android:title=\"@string/init_brouterShowBothDistances\" />\n+\n+            <CheckBoxPreference\n+                android:defaultValue=\"false\"\n+                android:key=\"@string/pref_brouterAutoTileDownloads\"\n+                android:summary=\"@string/init_brouterAutoTileDownloads_description\"\n+                android:title=\"@string/init_brouterAutoTileDownloads\" />\n+\n+            <Preference\n+                android:key=\"@string/pref_persistablefolder_broutertiles\"\n+                android:title=\"@string/init_brouter_directory_description\"\n+                android:dependency=\"@string/pref_brouterAutoTileDownloads\" />\n+            <Preference\n+                android:selectable=\"false\"\n+                android:key=\"@string/pref_fakekey_brouterTilesFolderInfo\"\n+                android:dependency=\"@string/pref_brouterAutoTileDownloads\" />\n+\n+            <Preference\n+                android:selectable=\"false\"\n+                android:summary=\"@string/init_brouter_updateinterval_description\"\n+                android:title=\"@string/init_brouter_updateinterval_title\"\n+                android:dependency=\"@string/pref_brouterAutoTileDownloads\" />\n+            <cgeo.geocaching.settings.SeekbarPreference\n+                android:key=\"@string/pref_brouterAutoTileDownloadsInterval\"\n+                app:min=\"0\"\n+                app:max=\"@integer/brouter_updateinterval_max\"\n+                android:defaultValue=\"@integer/brouter_updateinterval_default\"\n+                android:dependency=\"@string/pref_brouterAutoTileDownloads\" />\n+\n+        </PreferenceCategory>\n+\n         <PreferenceCategory android:title=\"@string/settings_title_waypoints\"\n             android:layout=\"@layout/preference_category\" >\n             <Preference\n@@ -642,21 +691,6 @@\n                 app:min=\"100\"\n                 app:max=\"@integer/historytrack_length_max\"\n                 android:defaultValue=\"@integer/historytrack_length_default\" />\n-            <Preference\n-                android:selectable=\"false\"\n-                android:summary=\"@string/init_brouterThreshold_description\"\n-                android:title=\"@string/init_brouterThreshold\" />\n-            <cgeo.geocaching.settings.ProximityPreference\n-                android:key=\"@string/pref_brouterDistanceThreshold\"\n-                app:min=\"1\"\n-                app:max=\"@integer/brouter_threshold_max\"\n-                android:defaultValue=\"@integer/brouter_threshold_default\"\n-                app:highRes=\"false\" />\n-            <CheckBoxPreference\n-                android:defaultValue=\"false\"\n-                android:key=\"@string/pref_brouterShowBothDistances\"\n-                android:summary=\"@string/init_summary_brouterShowBothDistances\"\n-                android:title=\"@string/init_brouterShowBothDistances\" />\n             <CheckBoxPreference\n                 android:defaultValue=\"false\"\n                 android:key=\"@string/pref_bigSmileysOnMap\""
  },
  {
    "sha": "d214b0821e97cfab34e21bd1816dbec50108c735",
    "filename": "main/src/cgeo/geocaching/HandleLocalFilesActivity.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/HandleLocalFilesActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/HandleLocalFilesActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/HandleLocalFilesActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -1,7 +1,7 @@\n package cgeo.geocaching;\n \n import cgeo.geocaching.activity.AbstractActivity;\n-import cgeo.geocaching.downloader.ReceiveMapFileActivity;\n+import cgeo.geocaching.downloader.ReceiveDownloadActivity;\n import cgeo.geocaching.files.FileType;\n import cgeo.geocaching.files.FileTypeDetector;\n import cgeo.geocaching.ui.dialog.Dialogs;\n@@ -33,7 +33,7 @@ public void onCreate(final Bundle savedInstanceState) {\n                 finished = true;\n                 break;\n             case MAP:\n-                continueWith(ReceiveMapFileActivity.class, intent);\n+                continueWith(ReceiveDownloadActivity.class, intent);\n                 finished = true;\n                 break;\n             default:"
  },
  {
    "sha": "6ad283d9273d539e253ccf54ab9cc054a9b7f05d",
    "filename": "main/src/cgeo/geocaching/InstallWizardActivity.java",
    "status": "modified",
    "additions": 31,
    "deletions": 14,
    "changes": 45,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/InstallWizardActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/InstallWizardActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/InstallWizardActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -4,8 +4,9 @@\n import cgeo.geocaching.connector.IConnector;\n import cgeo.geocaching.connector.gc.GCConnector;\n import cgeo.geocaching.databinding.InstallWizardBinding;\n+import cgeo.geocaching.downloader.DownloaderUtils;\n import cgeo.geocaching.downloader.MapDownloadSelectorActivity;\n-import cgeo.geocaching.downloader.MapDownloaderUtils;\n+import cgeo.geocaching.maps.routing.Routing;\n import cgeo.geocaching.permission.PermissionGrantedCallback;\n import cgeo.geocaching.permission.PermissionHandler;\n import cgeo.geocaching.permission.PermissionRequestContext;\n@@ -36,6 +37,7 @@\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n+import androidx.annotation.StringRes;\n import androidx.appcompat.app.AppCompatActivity;\n import androidx.core.app.ActivityCompat;\n import androidx.core.content.ContextCompat;\n@@ -60,7 +62,7 @@\n     private enum WizardStep {\n         WIZARD_START,\n         WIZARD_PERMISSIONS, WIZARD_PERMISSIONS_STORAGE, WIZARD_PERMISSIONS_LOCATION,\n-        WIZARD_PERMISSIONS_BASEFOLDER, WIZARD_PERMISSIONS_MAPFOLDER, WIZARD_PERMISSIONS_MAPTHEMEFOLDER, WIZARD_PERMISSIONS_GPXFOLDER,\n+        WIZARD_PERMISSIONS_BASEFOLDER, WIZARD_PERMISSIONS_MAPFOLDER, WIZARD_PERMISSIONS_MAPTHEMEFOLDER, WIZARD_PERMISSIONS_GPXFOLDER, WIZARD_PERMISSIONS_BROUTERTILESFOLDER,\n         WIZARD_PLATFORMS,\n         WIZARD_ADVANCED,\n         WIZARD_END\n@@ -150,25 +152,25 @@ private void updateDialog() {\n                 setNavigation(this::gotoPrevious, 0, null, 0, this::requestLocation, 0);\n                 break;\n             case WIZARD_PERMISSIONS_BASEFOLDER:\n-                setFolderTitle(PersistableFolder.BASE);\n-                text.setText(R.string.wizard_basefolder_request_explanation);\n+                setFolderInfo(PersistableFolder.BASE, R.string.wizard_basefolder_request_explanation, false);\n                 setNavigation(this::gotoPrevious, 0, forceSkipButton ? this::gotoNext : null, 0, this::requestBasefolder, 0);\n                 break;\n             case WIZARD_PERMISSIONS_MAPFOLDER:\n-                setFolderTitle(PersistableFolder.OFFLINE_MAPS);\n-                text.setText(R.string.wizard_mapfolder_request_explanation);\n+                setFolderInfo(PersistableFolder.OFFLINE_MAPS, R.string.wizard_mapfolder_request_explanation, true);\n                 setNavigation(this::gotoPrevious, 0, forceSkipButton ? this::gotoNext : null, 0, this::requestMapfolder, 0);\n                 break;\n             case WIZARD_PERMISSIONS_MAPTHEMEFOLDER:\n-                setFolderTitle(PersistableFolder.OFFLINE_MAP_THEMES);\n-                text.setText(R.string.wizard_mapthemesfolder_request_explanation);\n+                setFolderInfo(PersistableFolder.OFFLINE_MAP_THEMES, R.string.wizard_mapthemesfolder_request_explanation, true);\n                 setNavigation(this::gotoPrevious, 0, forceSkipButton ? this::gotoNext : null, 0, this::requestMapthemefolder, 0);\n                 break;\n             case WIZARD_PERMISSIONS_GPXFOLDER:\n-                setFolderTitle(PersistableFolder.GPX);\n-                text.setText(R.string.wizard_gpxfolder_request_explanation);\n+                setFolderInfo(PersistableFolder.GPX, R.string.wizard_gpxfolder_request_explanation, true);\n                 setNavigation(this::gotoPrevious, 0, forceSkipButton ? this::gotoNext : null, 0, this::requestGpxfolder, 0);\n                 break;\n+            case WIZARD_PERMISSIONS_BROUTERTILESFOLDER:\n+                setFolderInfo(PersistableFolder.BROUTER_TILES, R.string.wizard_broutertilesfolder_request_explanation, true);\n+                setNavigation(this::gotoPrevious, 0, forceSkipButton ? this::gotoNext : null, 0, this::requestBroutertilesfolder, 0);\n+                break;\n             case WIZARD_PLATFORMS:\n                 title.setText(R.string.wizard_platforms_title);\n                 text.setText(R.string.wizard_platforms_intro);\n@@ -188,7 +190,7 @@ private void updateDialog() {\n                 setNavigation(this::gotoPrevious, 0, null, 0, this::gotoNext, R.string.skip);\n                 setButton(button1, R.string.wizard_advanced_offlinemaps_label, v -> {\n                     setButtonToDone();\n-                    startActivityForResult(new Intent(this, MapDownloadSelectorActivity.class), MapDownloaderUtils.REQUEST_CODE);\n+                    startActivityForResult(new Intent(this, MapDownloadSelectorActivity.class), DownloaderUtils.REQUEST_CODE);\n                 }, button1Info, R.string.wizard_advanced_offlinemaps_info);\n                 setButton(button2, R.string.wizard_advanced_brouter_label, v -> {\n                     setButtonToDone();\n@@ -323,6 +325,7 @@ private boolean stepCanBeSkipped() {\n             || (step == WizardStep.WIZARD_PERMISSIONS_MAPFOLDER && !mapFolderNeedsMigration())\n             || (step == WizardStep.WIZARD_PERMISSIONS_MAPTHEMEFOLDER && !mapThemeFolderNeedsMigration())\n             || (step == WizardStep.WIZARD_PERMISSIONS_GPXFOLDER && !gpxFolderNeedsMigration())\n+            || (step == WizardStep.WIZARD_PERMISSIONS_BROUTERTILESFOLDER && !broutertilesFolderNeedsMigration())\n             || (step == WizardStep.WIZARD_PLATFORMS && mode == WizardMode.WIZARDMODE_MIGRATION)\n             || (step == WizardStep.WIZARD_ADVANCED && mode == WizardMode.WIZARDMODE_MIGRATION)\n             ;\n@@ -348,7 +351,7 @@ public static boolean isConfigurationOk(final Context context) {\n     }\n \n     public static boolean needsFolderMigration() {\n-        return mapFolderNeedsMigration() || mapThemeFolderNeedsMigration() || gpxFolderNeedsMigration();\n+        return mapFolderNeedsMigration() || mapThemeFolderNeedsMigration() || gpxFolderNeedsMigration() || broutertilesFolderNeedsMigration();\n     }\n \n     // -------------------------------------------------------------------\n@@ -389,8 +392,10 @@ public void onRequestPermissionsResult(final int requestCode, @NonNull final Str\n     // -------------------------------------------------------------------\n     // Android SAF-based permissions related methods\n \n-    private void setFolderTitle(final PersistableFolder folder) {\n+    private void setFolderInfo(final PersistableFolder folder, @StringRes final int info, final boolean addSelectOrCreateInfo) {\n         title.setText(String.format(getString(R.string.wizard_permissions_folder_title), getString(folder.getNameKeyId())));\n+        final String temp = getString(info) + (addSelectOrCreateInfo ? \" \" + getString(R.string.wizard_select_or_create) : \"\");\n+        text.setText(temp);\n     }\n \n     private void requestBasefolder() {\n@@ -453,6 +458,18 @@ private void requestGpxfolder() {\n         }\n     }\n \n+    private static boolean broutertilesFolderNeedsMigration() {\n+        return Settings.isBrouterAutoTileDownloads() && PersistableFolder.BROUTER_TILES.isLegacy() && Routing.isInstalled();\n+    }\n+\n+    private void requestBroutertilesfolder() {\n+        forceSkipButton = false;\n+        if (broutertilesFolderNeedsMigration()) {\n+            prepareFolderDefaultValues();\n+            getContentStorageHelper().migratePersistableFolder(PersistableFolder.BROUTER_TILES, v -> onReturnFromFolderMigration(!broutertilesFolderNeedsMigration()));\n+        }\n+    }\n+\n     private void prepareFolderDefaultValues() {\n         // re-evaluate default folder values, as the public folder may not have been accessible on startup\n         ContentStorage.get().reevaluateFolderDefaults();\n@@ -495,7 +512,7 @@ protected void onActivityResult(final int requestCode, final int resultCode, @Nu\n                 }, dialog -> { });\n             }\n         } else if (contentStorageActivityHelper == null || !contentStorageActivityHelper.onActivityResult(requestCode, resultCode, data)) {\n-            MapDownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n+            DownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n         }\n     }\n }"
  },
  {
    "sha": "86546797b2a15214e27909b67e883e3b392ea7b0",
    "filename": "main/src/cgeo/geocaching/MainActivity.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/MainActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/MainActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/MainActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -8,6 +8,7 @@\n import cgeo.geocaching.connector.gc.PocketQueryListActivity;\n import cgeo.geocaching.connector.internal.InternalConnector;\n import cgeo.geocaching.databinding.MainActivityBinding;\n+import cgeo.geocaching.downloader.DownloaderUtils;\n import cgeo.geocaching.enumerations.CacheType;\n import cgeo.geocaching.enumerations.StatusCode;\n import cgeo.geocaching.helper.UsefulAppsActivity;\n@@ -17,6 +18,7 @@\n import cgeo.geocaching.location.Units;\n import cgeo.geocaching.maps.DefaultMap;\n import cgeo.geocaching.maps.mapsforge.v6.RenderThemeHelper;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.network.Network;\n import cgeo.geocaching.permission.PermissionGrantedCallback;\n import cgeo.geocaching.permission.PermissionHandler;\n@@ -30,6 +32,7 @@\n import cgeo.geocaching.settings.SettingsActivity;\n import cgeo.geocaching.storage.DataStore;\n import cgeo.geocaching.storage.LocalStorage;\n+import cgeo.geocaching.storage.PersistableFolder;\n import cgeo.geocaching.storage.extension.FoundNumCounter;\n import cgeo.geocaching.storage.extension.OneTimeDialogs;\n import cgeo.geocaching.ui.WeakReferenceHandler;\n@@ -339,6 +342,8 @@ public void execute() {\n \n         // reactivate dialogs which are set to show later\n         OneTimeDialogs.nextStatus();\n+\n+        checkForRoutingTileUpdates();\n     }\n \n     @Override\n@@ -419,6 +424,22 @@ private void startBackgroundLogin() {\n         }\n     }\n \n+    private void checkForRoutingTileUpdates() {\n+        if (Settings.isBrouterAutoTileDownloads() && !PersistableFolder.BROUTER_TILES.isLegacy()) {\n+            final long now = System.currentTimeMillis() / 1000;\n+            final int interval = Settings.getBrouterAutoTileDownloadsInterval();\n+            if ((Settings.getBrouterAutoTileDownloadsLastCheckInS() + (interval * 24 * 60 * 60)) <= now) {\n+                DownloaderUtils.checkForUpdatesAndDownloadAll(this, Download.DownloadType.DOWNLOADTYPE_BROUTER_TILES, R.string.updates_check, R.string.tileupdate_info, this::returnFromTileUpdateCheck);\n+            }\n+        }\n+    }\n+\n+    private void returnFromTileUpdateCheck(final boolean updateCheckAllowed) {\n+        if (updateCheckAllowed) {\n+            Settings.setBrouterAutoTileDownloadsLastCheckInS(System.currentTimeMillis() / 1000);\n+        }\n+    }\n+\n     @Override\n     public void onDestroy() {\n         initialized = false;"
  },
  {
    "sha": "c4a3b83d91778d38218a5ff45d49e5ecad51c902",
    "filename": "main/src/cgeo/geocaching/downloader/AbstractDownloader.java",
    "status": "modified",
    "additions": 9,
    "deletions": 7,
    "changes": 16,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/AbstractDownloader.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/AbstractDownloader.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/AbstractDownloader.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -2,7 +2,7 @@\n \n import cgeo.geocaching.CgeoApplication;\n import cgeo.geocaching.R;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.PersistableFolder;\n import cgeo.geocaching.utils.MatcherWrapper;\n \n@@ -17,7 +17,7 @@\n import org.apache.commons.lang3.StringUtils;\n \n public abstract class AbstractDownloader {\n-    public OfflineMap.OfflineMapType offlineMapType;\n+    public Download.DownloadType offlineMapType;\n     public Uri mapBase;\n     public String mapSourceName;\n     public String mapSourceInfo;\n@@ -26,8 +26,10 @@\n     public PersistableFolder targetFolder;\n     public static final String oneDirUp = CgeoApplication.getInstance().getString(R.string.downloadmap_onedirup);\n     public String forceExtension = \"\";\n+    public boolean overwrite = false; // silently overwrite existing files?\n+    public boolean useCompanionFiles = true; // store source info (uri etc.) in companion files (true) or use date/timestamp and identical uri only (false)?\n \n-    AbstractDownloader(final OfflineMap.OfflineMapType offlineMapType, final @StringRes int mapBase, final @StringRes int mapSourceName, final @StringRes int mapSourceInfo, final @StringRes int projectUrl, final @StringRes int likeItUrl, final PersistableFolder targetFolder) {\n+    AbstractDownloader(final Download.DownloadType offlineMapType, final @StringRes int mapBase, final @StringRes int mapSourceName, final @StringRes int mapSourceInfo, final @StringRes int projectUrl, final @StringRes int likeItUrl, final PersistableFolder targetFolder) {\n         this.offlineMapType = offlineMapType;\n         this.mapBase = Uri.parse(CgeoApplication.getInstance().getString(mapBase));\n         this.mapSourceName = CgeoApplication.getInstance().getString(mapSourceName);\n@@ -41,10 +43,10 @@\n     }\n \n     // find available maps, dir-up, subdirs\n-    protected abstract void analyzePage(Uri uri, List<OfflineMap> list, String page);\n+    protected abstract void analyzePage(Uri uri, List<Download> list, String page);\n \n     // find source for single map\n-    protected abstract OfflineMap checkUpdateFor(String page, String remoteUrl, String remoteFilename);\n+    protected abstract Download checkUpdateFor(String page, String remoteUrl, String remoteFilename);\n \n     // create update check page url for download page url\n     // default is: identical\n@@ -53,14 +55,14 @@ protected String getUpdatePageUrl(final String downloadPageUrl) {\n     }\n \n     // generic matchers\n-    protected void basicUpMatcher(final Uri uri, final List<OfflineMap> list, final String page, final Pattern patternUp) {\n+    protected void basicUpMatcher(final Uri uri, final List<Download> list, final String page, final Pattern patternUp) {\n         if (!mapBase.equals(uri)) {\n             final MatcherWrapper matchUp = new MatcherWrapper(patternUp, page);\n             if (matchUp.find()) {\n                 final String oneUp = uri.toString();\n                 final int endOfPreviousSegment = oneUp.lastIndexOf(\"/\", oneUp.length() - 2); // skip trailing \"/\"\n                 if (endOfPreviousSegment > -1) {\n-                    final OfflineMap offlineMap = new OfflineMap(oneDirUp, Uri.parse(oneUp.substring(0, endOfPreviousSegment + 1)), true, \"\", \"\", offlineMapType);\n+                    final Download offlineMap = new Download(oneDirUp, Uri.parse(oneUp.substring(0, endOfPreviousSegment + 1)), true, \"\", \"\", offlineMapType);\n                     list.add(offlineMap);\n                 }\n             }"
  },
  {
    "sha": "29760bb658f4578f2791a850dbab4cf6ba1ad053",
    "filename": "main/src/cgeo/geocaching/downloader/AbstractMapDownloader.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/AbstractMapDownloader.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/AbstractMapDownloader.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/AbstractMapDownloader.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -2,7 +2,7 @@\n \n import cgeo.geocaching.R;\n import cgeo.geocaching.maps.mapsforge.MapsforgeMapProvider;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.ContentStorage;\n import cgeo.geocaching.storage.PersistableFolder;\n import cgeo.geocaching.ui.dialog.Dialogs;\n@@ -17,7 +17,7 @@\n \n abstract class AbstractMapDownloader extends AbstractDownloader {\n \n-    AbstractMapDownloader(final OfflineMap.OfflineMapType offlineMapType, final @StringRes int mapBase, final @StringRes int mapSourceName, final @StringRes int mapSourceInfo, final @StringRes int projectUrl, final @StringRes int likeItUrl) {\n+    AbstractMapDownloader(final Download.DownloadType offlineMapType, final @StringRes int mapBase, final @StringRes int mapSourceName, final @StringRes int mapSourceInfo, final @StringRes int projectUrl, final @StringRes int likeItUrl) {\n         super(offlineMapType, mapBase, mapSourceName, mapSourceInfo, projectUrl, likeItUrl, PersistableFolder.OFFLINE_MAPS);\n         this.forceExtension = FileUtils.MAP_FILE_EXTENSION;\n     }\n@@ -30,7 +30,7 @@ protected void onSuccessfulReceive(final Uri result) {\n \n     // check if any of the given file exists in the given path\n     // if none exists: confirm to & download first\n-    protected void findOrDownload(final Activity activity, final String[] filenames, final String baseUrl, final OfflineMap.OfflineMapType offlineMapType, final Runnable callback) {\n+    protected void findOrDownload(final Activity activity, final String[] filenames, final String baseUrl, final Download.DownloadType offlineMapType, final Runnable callback) {\n         boolean anyFileFound = false;\n         final List<ContentStorage.FileInformation> dirContent = ContentStorage.get().list(PersistableFolder.OFFLINE_MAP_THEMES);\n         for (ContentStorage.FileInformation fi : dirContent) {\n@@ -43,9 +43,9 @@ protected void findOrDownload(final Activity activity, final String[] filenames,\n         }\n \n         if (!anyFileFound) {\n-                Dialogs.confirm(activity, activity.getString(R.string.downloadmap_install_theme_title), activity.getString(R.string.downloadmap_install_theme_info), activity.getString(android.R.string.ok), (d, w) -> {\n+            Dialogs.confirm(activity, activity.getString(R.string.downloadmap_install_theme_title), activity.getString(R.string.downloadmap_install_theme_info), activity.getString(android.R.string.ok), (d, w) -> {\n                 final Uri newUri = Uri.parse(baseUrl + filenames[0]);\n-                MapDownloaderUtils.triggerDownload(activity, offlineMapType.id, newUri, \"\", System.currentTimeMillis(), callback);\n+                DownloaderUtils.triggerDownload(activity, R.string.download_title, offlineMapType.id, newUri, \"\", \"\", System.currentTimeMillis(), callback);\n             }, dialog -> callback.run());\n         } else {\n             callback.run();"
  },
  {
    "sha": "6a5188e872a627c51f8d270c70139f7329b4f808",
    "filename": "main/src/cgeo/geocaching/downloader/BRouterTileDownloader.java",
    "status": "added",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/BRouterTileDownloader.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/BRouterTileDownloader.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/BRouterTileDownloader.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -0,0 +1,64 @@\n+package cgeo.geocaching.downloader;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.models.Download;\n+import cgeo.geocaching.storage.PersistableFolder;\n+import cgeo.geocaching.utils.CalendarUtils;\n+import cgeo.geocaching.utils.Formatter;\n+import cgeo.geocaching.utils.MatcherWrapper;\n+\n+import android.net.Uri;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+public class BRouterTileDownloader extends AbstractDownloader {\n+    private static final Pattern PATTERN_TILE = Pattern.compile(\"href=\\\"([E|W][0-9]+_[N|S][0-9]*\\\\.rd5)\\\">[E|W][0-9]+_[N|S][0-9]*\\\\.rd5<\\\\/a>[ ]*([0-9][0-9]-[A-Za-z]{1,3}-[0-9]{1,4}) [0-9][0-9]:[0-9][0-9][ ]*([1-9][0-9]{3,15})\");\n+    // group 1: E50_N5.rd5\n+    // group 2: 21-Feb-2021\n+    // group 3: 12313423 (size in bytes)\n+    // 1126 Einträge\n+    private static final BRouterTileDownloader INSTANCE = new BRouterTileDownloader();\n+\n+    private BRouterTileDownloader() {\n+        super(Download.DownloadType.DOWNLOADTYPE_BROUTER_TILES, R.string.brouter_downloadurl, R.string.brouter_name, R.string.brouter_info, R.string.brouter_projecturl, 0, PersistableFolder.BROUTER_TILES);\n+        overwrite = true; // silently overwrite already existing files\n+        useCompanionFiles = false; // use single uri, and no companion files\n+        forceExtension = \".rd5\";\n+    }\n+\n+    @Override\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n+        final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_TILE, page);\n+        while (matchMap.find()) {\n+            final Download offlineMap = new Download(matchMap.group(1), Uri.parse(uri + matchMap.group(1)), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(2))), Formatter.formatBytes(Long.parseLong(matchMap.group(3))), offlineMapType);\n+            list.add(offlineMap);\n+        }\n+    }\n+\n+    @Override\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+        final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_TILE, page);\n+        while (matchMap.find()) {\n+            final String filename = matchMap.group(1);\n+            if (filename.equals(remoteFilename)) {\n+                return new Download(filename, Uri.parse(mapBase + filename), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(2))), Formatter.formatBytes(Long.parseLong(matchMap.group(3))), offlineMapType);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // BRouter uses a single download page, need to map here to its fixed address\n+    @Override\n+    protected String getUpdatePageUrl(final String downloadPageUrl) {\n+        return mapBase.toString();\n+    }\n+\n+    @NonNull\n+    public static BRouterTileDownloader getInstance() {\n+        return INSTANCE;\n+    }\n+\n+}"
  },
  {
    "sha": "43b8b1f886cc604e823df2e8fad0486dce7bd45a",
    "filename": "main/src/cgeo/geocaching/downloader/CompanionFileUtils.java",
    "status": "modified",
    "additions": 65,
    "deletions": 48,
    "changes": 113,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/CompanionFileUtils.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/CompanionFileUtils.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/CompanionFileUtils.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -1,6 +1,6 @@\n package cgeo.geocaching.downloader;\n \n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.ContentStorage;\n import cgeo.geocaching.utils.CalendarUtils;\n import cgeo.geocaching.utils.Log;\n@@ -45,24 +45,26 @@ private CompanionFileUtils() {\n     }\n \n     public static void writeInfo(@NonNull final String remoteUrl, @NonNull final String localFilename, @NonNull final String displayName, final long date, final int offlineMapTypeId) {\n-        final AbstractDownloader downloader = OfflineMap.OfflineMapType.getInstance(offlineMapTypeId);\n-        final Uri infoFile = ContentStorage.get().create(downloader.targetFolder, localFilename + INFOFILE_SUFFIX);\n-        try (OutputStream output = ContentStorage.get().openForWrite(infoFile)) {\n-            final int i = remoteUrl.lastIndexOf(\"/\");\n-            final String remotePage = i != -1 ? remoteUrl.substring(0, i) : remoteUrl;\n-            final String remoteFile = i != -1 ? remoteUrl.substring(i + 1) : localFilename;\n-\n-            final Properties prop = new Properties();\n-            prop.setProperty(PROP_PARSETYPE, String.valueOf(offlineMapTypeId));\n-            prop.setProperty(PROP_REMOTEPAGE, remotePage);\n-            prop.setProperty(PROP_REMOTEFILE, remoteFile);\n-            prop.setProperty(PROP_REMOTEDATE, CalendarUtils.yearMonthDay(date));\n-            prop.setProperty(PROP_LOCALFILE, localFilename);\n-            prop.setProperty(PROP_DISPLAYNAME, displayName);\n-\n-            prop.store(output, null);\n-        } catch (IOException io) {\n-            // ignore\n+        final AbstractDownloader downloader = Download.DownloadType.getInstance(offlineMapTypeId);\n+        if (downloader.useCompanionFiles) {\n+            final Uri infoFile = ContentStorage.get().create(downloader.targetFolder, localFilename + INFOFILE_SUFFIX);\n+            try (OutputStream output = ContentStorage.get().openForWrite(infoFile)) {\n+                final int i = remoteUrl.lastIndexOf(\"/\");\n+                final String remotePage = i != -1 ? remoteUrl.substring(0, i) : remoteUrl;\n+                final String remoteFile = i != -1 ? remoteUrl.substring(i + 1) : localFilename;\n+\n+                final Properties prop = new Properties();\n+                prop.setProperty(PROP_PARSETYPE, String.valueOf(offlineMapTypeId));\n+                prop.setProperty(PROP_REMOTEPAGE, remotePage);\n+                prop.setProperty(PROP_REMOTEFILE, remoteFile);\n+                prop.setProperty(PROP_REMOTEDATE, CalendarUtils.yearMonthDay(date));\n+                prop.setProperty(PROP_LOCALFILE, localFilename);\n+                prop.setProperty(PROP_DISPLAYNAME, displayName);\n+\n+                prop.store(output, null);\n+            } catch (IOException io) {\n+                // ignore\n+            }\n         }\n     }\n \n@@ -71,48 +73,63 @@ public static void writeInfo(@NonNull final String remoteUrl, @NonNull final Str\n      */\n     public static ArrayList<DownloadedFileData> availableOfflineMaps() {\n         final ArrayList<DownloadedFileData> result = new ArrayList<>();\n-        for (OfflineMap.OfflineMapTypeDescriptor type : OfflineMap.OfflineMapType.getOfflineMapTypes()) {\n+        for (Download.DownloadTypeDescriptor type : Download.DownloadType.getOfflineMapTypes()) {\n             result.addAll(availableOfflineMaps(type.type));\n         }\n         return result;\n     }\n \n     /**\n-     * returns a list of downloaded offline maps from requested source which are still available in the local filesystem\n+     * returns a list of downloaded offline files from requested source which are still available in the local filesystem\n      */\n-    public static ArrayList<DownloadedFileData> availableOfflineMaps(@NonNull final OfflineMap.OfflineMapType filter) {\n+    public static ArrayList<DownloadedFileData> availableOfflineMaps(@NonNull final Download.DownloadType filter) {\n         final ArrayList<DownloadedFileData> result = new ArrayList<>();\n-        final AbstractDownloader downloader = OfflineMap.OfflineMapType.getInstance(filter.id);\n+        final AbstractDownloader downloader = Download.DownloadType.getInstance(filter.id);\n \n-        final List<ContentStorage.FileInformation> mapDirContent = ContentStorage.get().list(downloader.targetFolder);\n-        final Map<String, Uri> mapDirMap = new HashMap<>();\n-        for (ContentStorage.FileInformation fi : mapDirContent) {\n-            mapDirMap.put(fi.name, fi.uri);\n+        final List<ContentStorage.FileInformation> files = ContentStorage.get().list(downloader.targetFolder);\n+        final Map<String, Uri> filesMap = new HashMap<>();\n+        for (ContentStorage.FileInformation fi : files) {\n+            filesMap.put(fi.name, fi.uri);\n         }\n \n-        for (ContentStorage.FileInformation fi : mapDirContent) {\n-            final String filename = fi.name;\n-            if (!filename.endsWith(INFOFILE_SUFFIX)) {\n-                continue;\n-            }\n-            try (InputStream input = ContentStorage.get().openForRead(downloader.targetFolder.getFolder(), filename)) {\n-                final DownloadedFileData offlineMapData = new DownloadedFileData();\n-                final Properties prop = new Properties();\n-                prop.load(input);\n-                offlineMapData.remoteParsetype = Integer.parseInt(prop.getProperty(PROP_PARSETYPE));\n-                if (filter == null || offlineMapData.remoteParsetype == filter.id) {\n-                    offlineMapData.remotePage = prop.getProperty(PROP_REMOTEPAGE);\n-                    offlineMapData.remoteFile = prop.getProperty(PROP_REMOTEFILE);\n-                    offlineMapData.remoteDate = CalendarUtils.parseYearMonthDay(prop.getProperty(PROP_REMOTEDATE));\n-                    offlineMapData.localFile = prop.getProperty(PROP_LOCALFILE);\n-                    offlineMapData.displayName = prop.getProperty(PROP_DISPLAYNAME);\n-\n-                    if (StringUtils.isNotBlank(offlineMapData.localFile) && mapDirMap.containsKey(offlineMapData.localFile)) {\n-                        result.add(offlineMapData);\n+        if (downloader.useCompanionFiles) {\n+            for (ContentStorage.FileInformation fi : files) {\n+                final String filename = fi.name;\n+                if (!filename.endsWith(INFOFILE_SUFFIX)) {\n+                    continue;\n+                }\n+                try (InputStream input = ContentStorage.get().openForRead(downloader.targetFolder.getFolder(), filename)) {\n+                    final DownloadedFileData offlineMapData = new DownloadedFileData();\n+                    final Properties prop = new Properties();\n+                    prop.load(input);\n+                    offlineMapData.remoteParsetype = Integer.parseInt(prop.getProperty(PROP_PARSETYPE));\n+                    if (offlineMapData.remoteParsetype == filter.id) {\n+                        offlineMapData.remotePage = prop.getProperty(PROP_REMOTEPAGE);\n+                        offlineMapData.remoteFile = prop.getProperty(PROP_REMOTEFILE);\n+                        offlineMapData.remoteDate = CalendarUtils.parseYearMonthDay(prop.getProperty(PROP_REMOTEDATE));\n+                        offlineMapData.localFile = prop.getProperty(PROP_LOCALFILE);\n+                        offlineMapData.displayName = prop.getProperty(PROP_DISPLAYNAME);\n+\n+                        if (StringUtils.isNotBlank(offlineMapData.localFile) && filesMap.containsKey(offlineMapData.localFile)) {\n+                            result.add(offlineMapData);\n+                        }\n                     }\n+                } catch (IOException | NumberFormatException e) {\n+                    Log.d(\"Offline map property file error for \" + filename + \": \" + e.getMessage());\n+                }\n+            }\n+        } else {\n+            for (ContentStorage.FileInformation fi : files) {\n+                if (!fi.name.endsWith(INFOFILE_SUFFIX) && fi.name.endsWith(downloader.forceExtension)) {\n+                    final DownloadedFileData download = new DownloadedFileData();\n+                    download.remoteParsetype = filter.id;\n+                    download.remoteDate = fi.lastModified;\n+                    download.remoteFile = fi.name;\n+                    download.localFile = fi.name;\n+                    download.displayName = fi.name;\n+                    // some properties remain unset when not using companion files (remotePage), others are guesses only (remoteFile, remoteParseType)\n+                    result.add(download);\n                 }\n-            } catch (IOException | NumberFormatException e) {\n-                Log.d(\"Offline map property file error for \" + filename + \": \" + e.getMessage());\n             }\n         }\n         return result;"
  },
  {
    "sha": "1fa41ed71255eee34e5548ee187275d4ca29b154",
    "filename": "main/src/cgeo/geocaching/downloader/DownloadConfirmationActivity.java",
    "status": "added",
    "additions": 26,
    "deletions": 0,
    "changes": 26,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloadConfirmationActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloadConfirmationActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/DownloadConfirmationActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -0,0 +1,26 @@\n+package cgeo.geocaching.downloader;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.activity.AbstractActivity;\n+import cgeo.geocaching.models.Download;\n+\n+import android.net.Uri;\n+import android.os.Bundle;\n+\n+public class DownloadConfirmationActivity extends AbstractActivity {\n+\n+    public static final String BUNDLE_FILENAME = \"filename\";\n+\n+    @Override\n+    public void onCreate(final Bundle savedInstanceState) {\n+        super.onCreate(savedInstanceState);\n+        setTheme();\n+\n+        final Bundle bundle = getIntent().getExtras();\n+        if (bundle != null) {\n+            final Uri uri = Uri.parse(getString(R.string.brouter_downloadurl) + bundle.getString(BUNDLE_FILENAME));\n+            DownloaderUtils.triggerDownload(this, R.string.downloadtile_title, Download.DownloadType.DOWNLOADTYPE_BROUTER_TILES.id, uri, getString(R.string.downloadtile_info), \"\", System.currentTimeMillis(), this::finish);\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "7541539ce240e32b8186f2dc23b51703b755dbc8",
    "filename": "main/src/cgeo/geocaching/downloader/DownloadNotificationReceiver.java",
    "status": "renamed",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloadNotificationReceiver.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloadNotificationReceiver.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/DownloadNotificationReceiver.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -11,7 +11,7 @@\n import android.database.Cursor;\n import android.net.Uri;\n \n-class MapDownloadNotificationReceiver extends BroadcastReceiver {\n+class DownloadNotificationReceiver extends BroadcastReceiver {\n \n     @Override\n     public void onReceive(final Context context, final Intent intent) {\n@@ -31,13 +31,13 @@ public void onReceive(final Context context, final Intent intent) {\n                         switch (status) {\n                             case DownloadManager.STATUS_SUCCESSFUL:\n                                 PendingDownload.remove(pendingDownload);\n-                                final Intent copyFileIntent = new Intent(context, ReceiveMapFileActivity.class);\n+                                final Intent copyFileIntent = new Intent(context, ReceiveDownloadActivity.class);\n                                 final Uri uri = downloadManager.getUriForDownloadedFile(pendingDownload);\n                                 copyFileIntent.setData(uri);\n-                                copyFileIntent.putExtra(ReceiveMapFileActivity.EXTRA_FILENAME, p.getFilename());\n-                                copyFileIntent.putExtra(MapDownloaderUtils.RESULT_CHOSEN_URL, p.getRemoteUrl());\n-                                copyFileIntent.putExtra(MapDownloaderUtils.RESULT_DATE, p.getDate());\n-                                copyFileIntent.putExtra(MapDownloaderUtils.RESULT_TYPEID, p.getOfflineMapTypeId());\n+                                copyFileIntent.putExtra(ReceiveDownloadActivity.EXTRA_FILENAME, p.getFilename());\n+                                copyFileIntent.putExtra(DownloaderUtils.RESULT_CHOSEN_URL, p.getRemoteUrl());\n+                                copyFileIntent.putExtra(DownloaderUtils.RESULT_DATE, p.getDate());\n+                                copyFileIntent.putExtra(DownloaderUtils.RESULT_TYPEID, p.getOfflineMapTypeId());\n                                 copyFileIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                                 context.startActivity(copyFileIntent);\n                                 Log.d(\"download #\" + pendingDownload + \" successful\");",
    "previous_filename": "main/src/cgeo/geocaching/downloader/MapDownloadNotificationReceiver.java"
  },
  {
    "sha": "1c31b0b32fc800335c879083829a04494e90d9fe",
    "filename": "main/src/cgeo/geocaching/downloader/DownloaderUtils.java",
    "status": "added",
    "additions": 280,
    "deletions": 0,
    "changes": 280,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloaderUtils.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/DownloaderUtils.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/DownloaderUtils.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -0,0 +1,280 @@\n+package cgeo.geocaching.downloader;\n+\n+import cgeo.geocaching.R;\n+import cgeo.geocaching.activity.ActivityMixin;\n+import cgeo.geocaching.models.Download;\n+import cgeo.geocaching.network.Network;\n+import cgeo.geocaching.network.Parameters;\n+import cgeo.geocaching.permission.PermissionGrantedCallback;\n+import cgeo.geocaching.permission.PermissionHandler;\n+import cgeo.geocaching.permission.PermissionRequestContext;\n+import cgeo.geocaching.storage.ContentStorage;\n+import cgeo.geocaching.storage.PersistableFolder;\n+import cgeo.geocaching.storage.extension.PendingDownload;\n+import cgeo.geocaching.ui.dialog.Dialogs;\n+import cgeo.geocaching.utils.AsyncTaskWithProgressText;\n+import cgeo.geocaching.utils.CalendarUtils;\n+import cgeo.geocaching.utils.Log;\n+import cgeo.geocaching.utils.functions.Action1;\n+\n+import android.app.Activity;\n+import android.app.AlertDialog;\n+import android.app.DownloadManager;\n+import android.content.Intent;\n+import android.net.Uri;\n+import android.os.Environment;\n+import android.view.View;\n+import android.widget.CheckBox;\n+import android.widget.TextView;\n+import android.widget.Toast;\n+import static android.app.Activity.RESULT_OK;\n+import static android.content.Context.DOWNLOAD_SERVICE;\n+\n+import androidx.annotation.Nullable;\n+import androidx.annotation.StringRes;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import okhttp3.Response;\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class DownloaderUtils {\n+\n+    public static final int REQUEST_CODE = 47131;\n+    public static final String RESULT_CHOSEN_URL = \"chosenUrl\";\n+    public static final String RESULT_SIZE_INFO = \"sizeInfo\";\n+    public static final String RESULT_DATE = \"dateInfo\";\n+    public static final String RESULT_TYPEID = \"typeId\";\n+\n+    private DownloaderUtils() {\n+        // utility class\n+    }\n+\n+    public static boolean onOptionsItemSelected(final Activity activity, final int id) {\n+        if (id == R.id.menu_download_offlinemap) {\n+            activity.startActivityForResult(new Intent(activity, MapDownloadSelectorActivity.class), REQUEST_CODE);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean onActivityResult(final Activity activity, final int requestCode, final int resultCode, final Intent data) {\n+        if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) {\n+            // trigger download manager for downloading the requested file\n+            final Uri uri = data.getParcelableExtra(RESULT_CHOSEN_URL);\n+            final String sizeInfo = data.getStringExtra(RESULT_SIZE_INFO);\n+            final long date = data.getLongExtra(RESULT_DATE, 0);\n+            final int type = data.getIntExtra(RESULT_TYPEID, Download.DownloadType.DEFAULT);\n+            if (null != uri) {\n+                triggerDownload(activity, R.string.downloadmap_title, type, uri, \"\", sizeInfo, date, null);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void triggerDownload(final Activity activity, @StringRes final int title, final int type, final Uri uri, final String additionalInfo, final String sizeInfo, final long date, final Runnable callback) {\n+        String temp = uri.getLastPathSegment();\n+        if (null == temp) {\n+            temp = \"default.map\";\n+        }\n+        final String filename = temp;\n+\n+        final AlertDialog.Builder builder = Dialogs.newBuilder(activity);\n+        builder.setTitle(title);\n+        final View layout = View.inflate(activity, R.layout.mapdownloader_confirmation, null);\n+        builder.setView(layout);\n+        final TextView downloadInfo = layout.findViewById(R.id.download_info);\n+        downloadInfo.setText(String.format(activity.getString(R.string.download_confirmation), StringUtils.isNotBlank(additionalInfo) ? additionalInfo + \"\\n\\n\" : \"\", filename, \"\\n\\n\" + activity.getString(R.string.download_warning) + (StringUtils.isNotBlank(sizeInfo) ? \"\\n\\n\" + sizeInfo : \"\")));\n+\n+        builder\n+            .setPositiveButton(android.R.string.ok, (dialog, which) -> {\n+                final boolean allowMeteredNetwork = ((CheckBox) layout.findViewById(R.id.allow_metered_network)).isChecked();\n+\n+                final DownloadManager.Request request = new DownloadManager.Request(uri)\n+                    .setTitle(filename)\n+                    .setDescription(String.format(activity.getString(R.string.downloadmap_filename), filename))\n+                    .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)\n+                    .setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename)\n+                    .setAllowedOverMetered(allowMeteredNetwork)\n+                    .setAllowedOverRoaming(allowMeteredNetwork);\n+                Log.i(\"Download enqueued: \" + Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + \"/\" + filename);\n+                final DownloadManager downloadManager = (DownloadManager) activity.getSystemService(DOWNLOAD_SERVICE);\n+                if (null != downloadManager) {\n+                    PendingDownload.add(downloadManager.enqueue(request), filename, uri.toString(), date, type);\n+                    ActivityMixin.showShortToast(activity, R.string.download_started);\n+                } else {\n+                    ActivityMixin.showToast(activity, R.string.downloadmanager_not_available);\n+                }\n+                dialog.dismiss();\n+                if (callback != null) {\n+                    callback.run();\n+                }\n+            })\n+            .setNegativeButton(android.R.string.cancel, (dialog, which) -> {\n+                dialog.dismiss();\n+                if (callback != null) {\n+                    callback.run();\n+                }\n+            })\n+            .create()\n+            .show();\n+    }\n+\n+    public interface DirectoryWritable {\n+        void run(PersistableFolder folder, boolean isAvailable);\n+    }\n+\n+    public static void checkTargetDirectory(final Activity activity, final PersistableFolder folder, final boolean beforeDownload, final DirectoryWritable callback) {\n+        PermissionHandler.requestStoragePermission(activity, new PermissionGrantedCallback(PermissionRequestContext.ReceiveMapFileActivity) {\n+            @Override\n+            protected void execute() {\n+                final boolean mapDirIsReady = ContentStorage.get().ensureFolder(folder);\n+\n+                if (mapDirIsReady) {\n+                    callback.run(folder, true);\n+                } else if (beforeDownload) {\n+                    Dialogs.confirm(activity, activity.getString(R.string.download_title), String.format(activity.getString(R.string.downloadmap_target_not_writable), folder), activity.getString(R.string.button_continue),\n+                        (dialog, which) -> callback.run(folder, true), dialog -> callback.run(folder, false));\n+                } else {\n+                    Dialogs.message(activity, activity.getString(R.string.download_title), String.format(activity.getString(R.string.downloadmap_target_not_writable), folder), activity.getString(android.R.string.ok), (dialog, which) -> callback.run(folder, false));\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * aks user whether to check for updates\n+     * if yes: checks whether updates are available for the type specified\n+     *      if yes: ask user to download them all\n+     *              if yes: trigger download(s)\n+     * calls callback with user reaction (true=checked for updates / false=user denied check)\n+     */\n+    public static void checkForUpdatesAndDownloadAll(final Activity activity, final Download.DownloadType type, @StringRes final int title, @StringRes final int info, final Action1<Boolean> callback) {\n+        Dialogs.confirm(activity, title, info, android.R.string.ok, (dialog, which) -> {\n+            new CheckForDownloadsTask(activity, title, type).execute();\n+            callback.call(true);\n+        }, dialog -> callback.call(false));\n+    }\n+\n+    private static class CheckForDownloadsTask extends AsyncTaskWithProgressText<Void, List<Download>> {\n+        private final Download.DownloadType currentType;\n+        private String lastUrl = \"\";\n+        private String lastPage = \"\";\n+        private final WeakReference<Activity> activityRef;\n+\n+        CheckForDownloadsTask(final Activity activity, @StringRes final int title, final Download.DownloadType type) {\n+            super(activity, activity.getString(title), activity.getString(R.string.downloadmap_checking_for_updates));\n+            this.activityRef = new WeakReference<>(activity);\n+            this.currentType = type;\n+        }\n+\n+        @Override\n+        protected List<Download> doInBackgroundInternal(final Void[] none) {\n+            final List<Download> result = new ArrayList<>();\n+            final ArrayList<CompanionFileUtils.DownloadedFileData> existingFiles = CompanionFileUtils.availableOfflineMaps(currentType);\n+\n+            for (CompanionFileUtils.DownloadedFileData existingFile : existingFiles) {\n+                final Download download = checkForUpdate(existingFile);\n+                if (download != null && download.getDateInfo() > existingFile.remoteDate) {\n+                    download.setAddInfo(CalendarUtils.yearMonthDay(existingFile.remoteDate));\n+                    result.add(download);\n+                }\n+            }\n+            return result;\n+        }\n+\n+        @Nullable\n+        private Download checkForUpdate(final CompanionFileUtils.DownloadedFileData offlineMapData) {\n+            final AbstractDownloader downloader = Download.DownloadType.getInstance(offlineMapData.remoteParsetype);\n+            if (downloader == null) {\n+                Log.e(\"Map update checker: Cannot find map downloader of type \" + offlineMapData.remoteParsetype + \" for file \" + offlineMapData.localFile);\n+                return null;\n+            }\n+\n+            final String url = downloader.getUpdatePageUrl(offlineMapData.remotePage);\n+            final String page;\n+\n+            if (url.equals(lastUrl)) {\n+                page = lastPage;\n+            } else {\n+                final Parameters params = new Parameters();\n+                try {\n+                    final Response response = Network.getRequest(url, params).blockingGet();\n+                    page = Network.getResponseData(response, true);\n+\n+                    if (StringUtils.isBlank(page)) {\n+                        Log.e(\"getMap: No data from server\");\n+                        return null;\n+                    }\n+\n+                    lastUrl = url;\n+                    lastPage = page;\n+                } catch (final Exception e) {\n+                    return null;\n+                }\n+            }\n+\n+            try {\n+                return downloader.checkUpdateFor(page, offlineMapData.remotePage, offlineMapData.remoteFile);\n+            } catch (final Exception e) {\n+                Log.e(\"Map update checker: error parsing parsing html page\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected void onPostExecuteInternal(final List<Download> result) {\n+            final Activity activity = activityRef.get();\n+            if (activity != null) {\n+                if (result.size() == 0) {\n+                    Toast.makeText(activity, R.string.no_updates_found, Toast.LENGTH_SHORT).show();\n+                } else {\n+                    String updates = \"\";\n+                    for (Download download : result) {\n+                        updates += (StringUtils.isNotBlank(updates) ? \", \" : \"\") + download.getName() + (StringUtils.isNotBlank(download.getSizeInfo()) ? \" (\" + download.getSizeInfo() + \")\" : \"\");\n+                    }\n+\n+                    final AlertDialog.Builder builder = Dialogs.newBuilder(activity);\n+                    builder.setTitle(R.string.updates_check);\n+                    final View layout = View.inflate(builder.getContext(), R.layout.mapdownloader_confirmation, null);\n+                    builder.setView(layout);\n+                    final TextView downloadInfo = layout.findViewById(R.id.download_info);\n+                    downloadInfo.setText(String.format(activity.getString(R.string.download_confirmation_updates), updates, \"\\n\\n\" + activity.getString(R.string.download_warning)));\n+\n+                    builder\n+                        .setPositiveButton(android.R.string.ok, (dialog, which) -> {\n+                            final boolean allowMeteredNetwork = ((CheckBox) layout.findViewById(R.id.allow_metered_network)).isChecked();\n+\n+                            final DownloadManager downloadManager = (DownloadManager) activity.getSystemService(DOWNLOAD_SERVICE);\n+                            if (null != downloadManager) {\n+                                for (Download download : result) {\n+                                    final DownloadManager.Request request = new DownloadManager.Request(download.getUri())\n+                                        .setTitle(download.getName())\n+                                        .setDescription(String.format(activity.getString(R.string.downloadmap_filename), download.getName()))\n+                                        .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)\n+                                        .setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, download.getName())\n+                                        .setAllowedOverMetered(allowMeteredNetwork)\n+                                        .setAllowedOverRoaming(allowMeteredNetwork);\n+                                    Log.i(\"Download enqueued: \" + Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + \"/\" + download.getName());\n+                                    PendingDownload.add(downloadManager.enqueue(request), download.getName(), download.getUri().toString(), download.getDateInfo(), download.getType().id);\n+                                }\n+                                ActivityMixin.showShortToast(activity, R.string.download_started);\n+                            } else {\n+                                ActivityMixin.showToast(activity, R.string.downloadmanager_not_available);\n+                            }\n+                            dialog.dismiss();\n+                        })\n+                        .setNegativeButton(android.R.string.cancel, (dialog, which) -> {\n+                            dialog.dismiss();\n+                        })\n+                        .create()\n+                        .show();\n+                }\n+            }\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "fd69596064d2c90b4c4c900f76f6a358658119f8",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloadSelectorActivity.java",
    "status": "modified",
    "additions": 28,
    "deletions": 28,
    "changes": 56,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloadSelectorActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloadSelectorActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloadSelectorActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -4,7 +4,7 @@\n import cgeo.geocaching.activity.AbstractActionBarActivity;\n import cgeo.geocaching.databinding.MapdownloaderActivityBinding;\n import cgeo.geocaching.databinding.MapdownloaderItemBinding;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.network.Network;\n import cgeo.geocaching.network.Parameters;\n import cgeo.geocaching.settings.Settings;\n@@ -43,12 +43,12 @@\n public class MapDownloadSelectorActivity extends AbstractActionBarActivity {\n \n     @NonNull\n-    private final List<OfflineMap> maps = new ArrayList<>();\n+    private final List<Download> maps = new ArrayList<>();\n     private ArrayList<CompanionFileUtils.DownloadedFileData> installedOfflineMaps;\n     private final MapListAdapter adapter = new MapListAdapter(this);\n     private MapdownloaderActivityBinding binding;\n     private AbstractDownloader current;\n-    private ArrayList<OfflineMap.OfflineMapTypeDescriptor> spinnerData = new ArrayList<>();\n+    private ArrayList<Download.DownloadTypeDescriptor> spinnerData = new ArrayList<>();\n \n     protected class MapListAdapter extends RecyclerView.Adapter<MapListAdapter.ViewHolder> {\n         @NonNull private final MapDownloadSelectorActivity activity;\n@@ -77,17 +77,17 @@ public ViewHolder onCreateViewHolder(final ViewGroup parent, final int viewType)\n             final View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.mapdownloader_item, parent, false);\n             final ViewHolder viewHolder = new ViewHolder(view);\n             viewHolder.binding.retrieve.setOnClickListener(v -> {\n-                final OfflineMap offlineMap = activity.getQueries().get(viewHolder.getAdapterPosition());\n+                final Download offlineMap = activity.getQueries().get(viewHolder.getAdapterPosition());\n                     new MapListTask(activity, offlineMap.getUri(), offlineMap.getName()).execute();\n             });\n             viewHolder.binding.download.setOnClickListener(v -> {\n-                final OfflineMap offlineMap = activity.getQueries().get(viewHolder.getAdapterPosition());\n+                final Download offlineMap = activity.getQueries().get(viewHolder.getAdapterPosition());\n                 // return to caller with URL chosen\n                 final Intent intent = new Intent();\n-                intent.putExtra(MapDownloaderUtils.RESULT_CHOSEN_URL, offlineMap.getUri());\n-                intent.putExtra(MapDownloaderUtils.RESULT_SIZE_INFO, offlineMap.getSizeInfo());\n-                intent.putExtra(MapDownloaderUtils.RESULT_DATE, offlineMap.getDateInfo());\n-                intent.putExtra(MapDownloaderUtils.RESULT_TYPEID, offlineMap.getType().id);\n+                intent.putExtra(DownloaderUtils.RESULT_CHOSEN_URL, offlineMap.getUri());\n+                intent.putExtra(DownloaderUtils.RESULT_SIZE_INFO, offlineMap.getSizeInfo());\n+                intent.putExtra(DownloaderUtils.RESULT_DATE, offlineMap.getDateInfo());\n+                intent.putExtra(DownloaderUtils.RESULT_TYPEID, offlineMap.getType().id);\n                 setResult(RESULT_OK, intent);\n                 finish();\n             });\n@@ -97,7 +97,7 @@ public ViewHolder onCreateViewHolder(final ViewGroup parent, final int viewType)\n         @SuppressLint(\"SetTextI18n\")\n         @Override\n         public void onBindViewHolder(final ViewHolder holder, final int position) {\n-            final OfflineMap offlineMap = activity.getQueries().get(position);\n+            final Download offlineMap = activity.getQueries().get(position);\n             holder.binding.download.setVisibility(!offlineMap.getIsDir() ? View.VISIBLE : View.GONE);\n             holder.binding.retrieve.setVisibility(offlineMap.getIsDir() ? View.VISIBLE : View.GONE);\n             holder.binding.label.setText(offlineMap.getName());\n@@ -115,7 +115,7 @@ public void onBindViewHolder(final ViewHolder holder, final int position) {\n         }\n     }\n \n-    private class MapListTask extends AsyncTaskWithProgressText<Void, List<OfflineMap>> {\n+    private class MapListTask extends AsyncTaskWithProgressText<Void, List<Download>> {\n         private final Uri uri;\n         private final String newSelectionTitle;\n \n@@ -127,7 +127,7 @@ public void onBindViewHolder(final ViewHolder holder, final int position) {\n         }\n \n         @Override\n-        protected List<OfflineMap> doInBackgroundInternal(final Void[] none) {\n+        protected List<Download> doInBackgroundInternal(final Void[] none) {\n             final Parameters params = new Parameters();\n \n             String page = \"\";\n@@ -142,7 +142,7 @@ public void onBindViewHolder(final ViewHolder holder, final int position) {\n                 Log.e(\"getMap: No data from server\");\n                 return Collections.emptyList();\n             }\n-            final List<OfflineMap> list = new ArrayList<>();\n+            final List<Download> list = new ArrayList<>();\n \n             try {\n                 current.analyzePage(uri, list, page);\n@@ -155,13 +155,13 @@ public void onBindViewHolder(final ViewHolder holder, final int position) {\n         }\n \n         @Override\n-        protected void onPostExecuteInternal(final List<OfflineMap> result) {\n+        protected void onPostExecuteInternal(final List<Download> result) {\n             setUpdateButtonVisibility();\n             setMaps(result, newSelectionTitle, false);\n         }\n     }\n \n-    private class MapUpdateCheckTask extends AsyncTaskWithProgressText<Void, List<OfflineMap>> {\n+    private class MapUpdateCheckTask extends AsyncTaskWithProgressText<Void, List<Download>> {\n         private final ArrayList<CompanionFileUtils.DownloadedFileData> installedOfflineMaps;\n         private final String newSelectionTitle;\n \n@@ -173,11 +173,11 @@ protected void onPostExecuteInternal(final List<OfflineMap> result) {\n         }\n \n         @Override\n-        protected List<OfflineMap> doInBackgroundInternal(final Void[] none) {\n-            final List<OfflineMap> result = new ArrayList<>();\n-            result.add(new OfflineMap(getString(R.string.downloadmap_title), current.mapBase, true, \"\", \"\", current.offlineMapType));\n+        protected List<Download> doInBackgroundInternal(final Void[] none) {\n+            final List<Download> result = new ArrayList<>();\n+            result.add(new Download(getString(R.string.downloadmap_title), current.mapBase, true, \"\", \"\", current.offlineMapType));\n             for (CompanionFileUtils.DownloadedFileData installedOfflineMap : installedOfflineMaps) {\n-                final OfflineMap offlineMap = checkForUpdate(installedOfflineMap);\n+                final Download offlineMap = checkForUpdate(installedOfflineMap);\n                 if (offlineMap != null && offlineMap.getDateInfo() > installedOfflineMap.remoteDate) {\n                     offlineMap.setAddInfo(CalendarUtils.yearMonthDay(installedOfflineMap.remoteDate));\n                     result.add(offlineMap);\n@@ -187,8 +187,8 @@ protected void onPostExecuteInternal(final List<OfflineMap> result) {\n         }\n \n         @Nullable\n-        private OfflineMap checkForUpdate(final CompanionFileUtils.DownloadedFileData offlineMapData) {\n-            final AbstractDownloader downloader = OfflineMap.OfflineMapType.getInstance(offlineMapData.remoteParsetype);\n+        private Download checkForUpdate(final CompanionFileUtils.DownloadedFileData offlineMapData) {\n+            final AbstractDownloader downloader = Download.DownloadType.getInstance(offlineMapData.remoteParsetype);\n             if (downloader == null) {\n                 Log.e(\"Map update checker: Cannot find map downloader of type \" + offlineMapData.remoteParsetype + \" for file \" + offlineMapData.localFile);\n                 return null;\n@@ -217,7 +217,7 @@ private OfflineMap checkForUpdate(final CompanionFileUtils.DownloadedFileData of\n         }\n \n         @Override\n-        protected void onPostExecuteInternal(final List<OfflineMap> result) {\n+        protected void onPostExecuteInternal(final List<Download> result) {\n             setMaps(result, newSelectionTitle, result.size() < 2);\n         }\n     }\n@@ -229,12 +229,12 @@ public void onCreate(final Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState, R.layout.mapdownloader_activity);\n         binding = MapdownloaderActivityBinding.bind(findViewById(R.id.mapdownloader_activity_viewroot));\n \n-        spinnerData = OfflineMap.OfflineMapType.getOfflineMapTypes();\n-        final ArrayAdapter<OfflineMap.OfflineMapTypeDescriptor> spinnerAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, spinnerData);\n+        spinnerData = Download.DownloadType.getOfflineMapTypes();\n+        final ArrayAdapter<Download.DownloadTypeDescriptor> spinnerAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, spinnerData);\n         spinnerAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n         binding.downloaderType.setAdapter(spinnerAdapter);\n \n-        final OfflineMap.OfflineMapTypeDescriptor descriptor = OfflineMap.OfflineMapType.fromTypeId(Settings.getMapDownloaderSource());\n+        final Download.DownloadTypeDescriptor descriptor = Download.DownloadType.fromTypeId(Settings.getMapDownloaderSource());\n         if (descriptor != null) {\n             final int spinnerPosition = spinnerAdapter.getPosition(descriptor);\n             binding.downloaderType.setSelection(spinnerPosition);\n@@ -276,7 +276,7 @@ private void changeSource(final int position) {\n             new MapUpdateCheckTask(this, installedOfflineMaps, getString(R.string.downloadmap_available_updates)).execute();\n         });\n \n-        MapDownloaderUtils.checkMapDirectory(this, true, (path, isWritable) -> {\n+        DownloaderUtils.checkTargetDirectory(this, current.targetFolder, true, (path, isWritable) -> {\n             if (isWritable) {\n                 final RecyclerView view = RecyclerViewProvider.provideRecyclerView(this, R.id.mapdownloader_list, true, true);\n                 view.setAdapter(adapter);\n@@ -289,15 +289,15 @@ private void changeSource(final int position) {\n         Settings.setMapDownloaderSource(current.offlineMapType.id);\n     }\n \n-    public List<OfflineMap> getQueries() {\n+    public List<Download> getQueries() {\n         return maps;\n     }\n \n     private void setUpdateButtonVisibility() {\n         binding.checkForUpdates.setVisibility (installedOfflineMaps != null && installedOfflineMaps.size() > 0 ? View.VISIBLE : View.GONE);\n     }\n \n-    private synchronized void setMaps(final List<OfflineMap> maps, @NonNull final String selectionTitle, final boolean noUpdatesFound) {\n+    private synchronized void setMaps(final List<Download> maps, @NonNull final String selectionTitle, final boolean noUpdatesFound) {\n         this.maps.clear();\n         this.maps.addAll(maps);\n         adapter.notifyDataSetChanged();"
  },
  {
    "sha": "d7bf76f88f0e2c69e1fb57391bd5ae0086f3de87",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarte.java",
    "status": "modified",
    "additions": 9,
    "deletions": 9,
    "changes": 18,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarte.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarte.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarte.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -3,7 +3,7 @@\n import cgeo.geocaching.CgeoApplication;\n import cgeo.geocaching.R;\n import cgeo.geocaching.files.InvalidXMLCharacterFilterReader;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.utils.Formatter;\n import cgeo.geocaching.utils.Log;\n \n@@ -30,7 +30,7 @@\n     private static final MapDownloaderFreizeitkarte INSTANCE = new MapDownloaderFreizeitkarte();\n \n     private MapDownloaderFreizeitkarte() {\n-        super (OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_FREIZEITKARTE, R.string.mapserver_freizeitkarte_downloadurl, R.string.mapserver_freizeitkarte_name, R.string.mapserver_freizeitkarte_info, R.string.mapserver_freizeitkarte_projecturl, R.string.mapserver_freizeitkarte_likeiturl);\n+        super (Download.DownloadType.DOWNLOADTYPE_MAP_FREIZEITKARTE, R.string.mapserver_freizeitkarte_downloadurl, R.string.mapserver_freizeitkarte_name, R.string.mapserver_freizeitkarte_info, R.string.mapserver_freizeitkarte_projecturl, R.string.mapserver_freizeitkarte_likeiturl);\n     }\n \n     private static class FZKParser {\n@@ -40,7 +40,7 @@ private MapDownloaderFreizeitkarte() {\n         private String description;\n         private String dateInfo;\n \n-        private void parse(@NonNull final String page, final List<OfflineMap> result, final OfflineMap.OfflineMapType offlineMapType) {\n+        private void parse(@NonNull final String page, final List<Download> result, final Download.DownloadType offlineMapType) {\n             final RootElement root = new RootElement(\"\", \"Freizeitkarte\");\n             final Element map = root.getChild(\"\", \"Map\");\n             map.setStartElementListener(attr -> {\n@@ -55,7 +55,7 @@ private void parse(@NonNull final String page, final List<OfflineMap> result, fi\n             map.getChild(\"\", \"MapsforgeDateOfCreation\").setEndTextElementListener(body -> dateInfo = body);\n             map.setEndElementListener(() -> {\n                 if (StringUtils.isNotBlank(url) && StringUtils.isNotBlank(dateInfo)) {\n-                    result.add(new OfflineMap(description, Uri.parse(url), false, dateInfo.substring(0, 10), Formatter.formatBytes(size), offlineMapType));\n+                    result.add(new Download(description, Uri.parse(url), false, dateInfo.substring(0, 10), Formatter.formatBytes(size), offlineMapType));\n                 }\n             });\n \n@@ -69,15 +69,15 @@ private void parse(@NonNull final String page, final List<OfflineMap> result, fi\n     }\n \n     @Override\n-    protected void analyzePage(final Uri uri, final List<OfflineMap> list, final String page) {\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n         new FZKParser().parse(page, list, offlineMapType);\n     }\n \n     @Override\n-    protected OfflineMap checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n-        final List<OfflineMap> list = new ArrayList<>();\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+        final List<Download> list = new ArrayList<>();\n         new FZKParser().parse(page, list, offlineMapType);\n-        for (OfflineMap map : list) {\n+        for (Download map : list) {\n             if (map.getUri().getLastPathSegment().equals(remoteFilename)) {\n                 return map;\n             }\n@@ -99,7 +99,7 @@ protected String toVisibleFilename(final String filename) {\n     @Override\n     protected void onFollowup(final Activity activity, final Runnable callback) {\n         // check whether a FZK theme exists in theme folder and ask whether user wants to download it as well, if it does not exist yet\n-        findOrDownload(activity, THEME_FILES, activity.getString(R.string.mapserver_freizeitkarte_themes_downloadurl), OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_FREIZEITKARTE_THEMES, callback);\n+        findOrDownload(activity, THEME_FILES, activity.getString(R.string.mapserver_freizeitkarte_themes_downloadurl), Download.DownloadType.DOWNLOADTYPE_THEME_FREIZEITKARTE, callback);\n     }\n \n     @NonNull"
  },
  {
    "sha": "7b137291cf9fe4a3d4224b7de70245cac9c4aea4",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarteThemes.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarteThemes.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarteThemes.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderFreizeitkarteThemes.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -4,7 +4,7 @@\n import cgeo.geocaching.R;\n import cgeo.geocaching.files.InvalidXMLCharacterFilterReader;\n import cgeo.geocaching.maps.mapsforge.v6.RenderThemeHelper;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.PersistableFolder;\n import cgeo.geocaching.utils.Formatter;\n import cgeo.geocaching.utils.Log;\n@@ -30,7 +30,7 @@\n     private static final MapDownloaderFreizeitkarteThemes INSTANCE = new MapDownloaderFreizeitkarteThemes();\n \n     private MapDownloaderFreizeitkarteThemes() {\n-        super(OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_FREIZEITKARTE_THEMES, R.string.mapserver_freizeitkarte_downloadurl, R.string.mapserver_freizeitkarte_themes_name, R.string.mapserver_freizeitkarte_themes_info, R.string.mapserver_freizeitkarte_projecturl, R.string.mapserver_freizeitkarte_likeiturl, PersistableFolder.OFFLINE_MAP_THEMES);\n+        super(Download.DownloadType.DOWNLOADTYPE_THEME_FREIZEITKARTE, R.string.mapserver_freizeitkarte_downloadurl, R.string.mapserver_freizeitkarte_themes_name, R.string.mapserver_freizeitkarte_themes_info, R.string.mapserver_freizeitkarte_projecturl, R.string.mapserver_freizeitkarte_likeiturl, PersistableFolder.OFFLINE_MAP_THEMES);\n         this.forceExtension = \".zip\";\n     }\n \n@@ -40,7 +40,7 @@ private MapDownloaderFreizeitkarteThemes() {\n         private long size;\n         private String description;\n \n-        private void parse(@NonNull final String page, final List<OfflineMap> result, final OfflineMap.OfflineMapType offlineMapType) {\n+        private void parse(@NonNull final String page, final List<Download> result, final Download.DownloadType offlineMapType) {\n             final RootElement root = new RootElement(\"\", \"Freizeitkarte\");\n             final Element theme = root.getChild(\"\", \"Theme\");\n             theme.setStartElementListener(attr -> {\n@@ -53,7 +53,7 @@ private void parse(@NonNull final String page, final List<OfflineMap> result, fi\n             theme.getChild(\"\", \"DescriptionEnglish\").setEndTextElementListener(body -> description = body);\n             theme.setEndElementListener(() -> {\n                 if (StringUtils.isNotBlank(url)) {\n-                    result.add(new OfflineMap(description, Uri.parse(url), false, \"\", Formatter.formatBytes(size), offlineMapType));\n+                    result.add(new Download(description, Uri.parse(url), false, \"\", Formatter.formatBytes(size), offlineMapType));\n                 }\n             });\n \n@@ -67,15 +67,15 @@ private void parse(@NonNull final String page, final List<OfflineMap> result, fi\n     }\n \n     @Override\n-    protected void analyzePage(final Uri uri, final List<OfflineMap> list, final String page) {\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n         new FZKParser().parse(page, list, offlineMapType);\n     }\n \n     @Override\n-    protected OfflineMap checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n-        final List<OfflineMap> list = new ArrayList<>();\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+        final List<Download> list = new ArrayList<>();\n         new FZKParser().parse(page, list, offlineMapType);\n-        for (OfflineMap map : list) {\n+        for (Download map : list) {\n             if (map.getUri().getLastPathSegment().equals(remoteFilename)) {\n                 return map;\n             }"
  },
  {
    "sha": "c96e9c4efeab37b09cfa6060dfccea0fe5a43b68",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderMapsforge.java",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderMapsforge.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderMapsforge.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderMapsforge.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -1,7 +1,7 @@\n package cgeo.geocaching.downloader;\n \n import cgeo.geocaching.R;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.utils.MatcherWrapper;\n \n import android.net.Uri;\n@@ -19,33 +19,33 @@\n     private static final MapDownloaderMapsforge INSTANCE = new MapDownloaderMapsforge();\n \n     private MapDownloaderMapsforge() {\n-        super (OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_MAPSFORGE, R.string.mapserver_mapsforge_downloadurl, R.string.mapserver_mapsforge_name, R.string.mapserver_mapsforge_info, R.string.mapserver_mapsforge_projecturl, R.string.mapserver_mapsforge_likeiturl);\n+        super (Download.DownloadType.DOWNLOADTYPE_MAP_MAPSFORGE, R.string.mapserver_mapsforge_downloadurl, R.string.mapserver_mapsforge_name, R.string.mapserver_mapsforge_info, R.string.mapserver_mapsforge_projecturl, R.string.mapserver_mapsforge_likeiturl);\n     }\n \n     @Override\n-    protected void analyzePage(final Uri uri, final List<OfflineMap> list, final String page) {\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n         basicUpMatcher(uri, list, page, PATTERN_UP);\n \n         final MatcherWrapper matchDir = new MatcherWrapper(PATTERN_DIR, page);\n         while (matchDir.find()) {\n-            final OfflineMap offlineMap = new OfflineMap(matchDir.group(1), Uri.parse(uri + matchDir.group(1)), true, \"\", \"\", offlineMapType);\n+            final Download offlineMap = new Download(matchDir.group(1), Uri.parse(uri + matchDir.group(1)), true, \"\", \"\", offlineMapType);\n             list.add(offlineMap);\n         }\n \n         final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_MAP, page);\n         while (matchMap.find()) {\n-            final OfflineMap offlineMap = new OfflineMap(matchMap.group(2), Uri.parse(uri + matchMap.group(1)), false, matchMap.group(3), matchMap.group(4), offlineMapType);\n+            final Download offlineMap = new Download(matchMap.group(2), Uri.parse(uri + matchMap.group(1)), false, matchMap.group(3), matchMap.group(4), offlineMapType);\n             list.add(offlineMap);\n         }\n     }\n \n     @Override\n-    protected OfflineMap checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n         final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_MAP, page);\n         while (matchMap.find()) {\n             final String filename = matchMap.group(1);\n             if (filename.equals(remoteFilename)) {\n-                return new OfflineMap(matchMap.group(2), Uri.parse(remoteUrl + \"/\" + filename), false, matchMap.group(3), matchMap.group(4), offlineMapType);\n+                return new Download(matchMap.group(2), Uri.parse(remoteUrl + \"/\" + filename), false, matchMap.group(3), matchMap.group(4), offlineMapType);\n             }\n         }\n         return null;"
  },
  {
    "sha": "8d8368e1ee0e81fb67b7e13129e312a42f68de39",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMaps.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMaps.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMaps.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMaps.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -1,7 +1,7 @@\n package cgeo.geocaching.downloader;\n \n import cgeo.geocaching.R;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.utils.CalendarUtils;\n import cgeo.geocaching.utils.Formatter;\n import cgeo.geocaching.utils.MatcherWrapper;\n@@ -22,33 +22,33 @@\n     private static final MapDownloaderOpenAndroMaps INSTANCE = new MapDownloaderOpenAndroMaps();\n \n     private MapDownloaderOpenAndroMaps() {\n-        super (OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_OPENANDROMAPS, R.string.mapserver_openandromaps_downloadurl, R.string.mapserver_openandromaps_name, R.string.mapserver_openandromaps_info, R.string.mapserver_openandromaps_projecturl, R.string.mapserver_openandromaps_likeiturl);\n+        super (Download.DownloadType.DOWNLOADTYPE_MAP_OPENANDROMAPS, R.string.mapserver_openandromaps_downloadurl, R.string.mapserver_openandromaps_name, R.string.mapserver_openandromaps_info, R.string.mapserver_openandromaps_projecturl, R.string.mapserver_openandromaps_likeiturl);\n     }\n \n     @Override\n-    protected void analyzePage(final Uri uri, final List<OfflineMap> list, final String page) {\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n         basicUpMatcher(uri, list, page, PATTERN_UP);\n \n         final MatcherWrapper matchDir = new MatcherWrapper(PATTERN_DIR, page);\n         while (matchDir.find()) {\n-            final OfflineMap offlineMap = new OfflineMap(matchDir.group(2), Uri.parse(uri + matchDir.group(1)), true, \"\", \"\", offlineMapType);\n+            final Download offlineMap = new Download(matchDir.group(2), Uri.parse(uri + matchDir.group(1)), true, \"\", \"\", offlineMapType);\n             list.add(offlineMap);\n         }\n \n         final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_MAP, page);\n         while (matchMap.find()) {\n-            final OfflineMap offlineMap = new OfflineMap(matchMap.group(2), Uri.parse(uri + matchMap.group(1)), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(3))), Formatter.formatBytes(Long.parseLong(matchMap.group(4))), offlineMapType);\n+            final Download offlineMap = new Download(matchMap.group(2), Uri.parse(uri + matchMap.group(1)), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(3))), Formatter.formatBytes(Long.parseLong(matchMap.group(4))), offlineMapType);\n             list.add(offlineMap);\n         }\n     }\n \n     @Override\n-    protected OfflineMap checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n         final MatcherWrapper matchMap = new MatcherWrapper(PATTERN_MAP, page);\n         while (matchMap.find()) {\n             final String filename = matchMap.group(1);\n             if (filename.equals(remoteFilename)) {\n-                return new OfflineMap(matchMap.group(2), Uri.parse(remoteUrl + \"/\" + filename), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(3))), Formatter.formatBytes(Long.parseLong(matchMap.group(4))), offlineMapType);\n+                return new Download(matchMap.group(2), Uri.parse(remoteUrl + \"/\" + filename), false, CalendarUtils.yearMonthDay(CalendarUtils.parseDayMonthYearUS(matchMap.group(3))), Formatter.formatBytes(Long.parseLong(matchMap.group(4))), offlineMapType);\n             }\n         }\n         return null;\n@@ -63,7 +63,7 @@ protected String toVisibleFilename(final String filename) {\n     @Override\n     protected void onFollowup(final Activity activity, final Runnable callback) {\n         // check whether Elevate.zip exists in theme folder and ask whether user wants to download it as well, if it does not exist yet\n-        findOrDownload(activity, THEME_FILES, activity.getString(R.string.mapserver_openandromaps_themes_downloadurl), OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_OPENANDROMAPS_THEMES, callback);\n+        findOrDownload(activity, THEME_FILES, activity.getString(R.string.mapserver_openandromaps_themes_downloadurl), Download.DownloadType.DOWNLOADTYPE_THEME_OPENANDROMAPS, callback);\n     }\n \n     @NonNull"
  },
  {
    "sha": "640b27e1b91b5ad23cb198450cf5818cd1314701",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMapsThemes.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMapsThemes.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMapsThemes.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderOpenAndroMapsThemes.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -3,7 +3,7 @@\n import cgeo.geocaching.CgeoApplication;\n import cgeo.geocaching.R;\n import cgeo.geocaching.maps.mapsforge.v6.RenderThemeHelper;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.PersistableFolder;\n import cgeo.geocaching.utils.MatcherWrapper;\n import cgeo.geocaching.utils.UriUtils;\n@@ -21,24 +21,24 @@\n     private static final MapDownloaderOpenAndroMapsThemes INSTANCE = new MapDownloaderOpenAndroMapsThemes();\n \n     private MapDownloaderOpenAndroMapsThemes() {\n-        super(OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_OPENANDROMAPS_THEMES, R.string.mapserver_openandromaps_themes_updatecheckurl, R.string.mapserver_openandromaps_themes_name, R.string.mapserver_openandromaps_themes_info, R.string.mapserver_openandromaps_projecturl, R.string.mapserver_openandromaps_likeiturl, PersistableFolder.OFFLINE_MAP_THEMES);\n+        super(Download.DownloadType.DOWNLOADTYPE_THEME_OPENANDROMAPS, R.string.mapserver_openandromaps_themes_updatecheckurl, R.string.mapserver_openandromaps_themes_name, R.string.mapserver_openandromaps_themes_info, R.string.mapserver_openandromaps_projecturl, R.string.mapserver_openandromaps_likeiturl, PersistableFolder.OFFLINE_MAP_THEMES);\n         this.forceExtension = \".zip\";\n     }\n \n     @Override\n-    protected void analyzePage(final Uri uri, final List<OfflineMap> list, final String page) {\n-        final OfflineMap file = checkUpdateFor(page, CgeoApplication.getInstance().getString(R.string.mapserver_openandromaps_themes_downloadurl), \"Elevate.zip\");\n+    protected void analyzePage(final Uri uri, final List<Download> list, final String page) {\n+        final Download file = checkUpdateFor(page, CgeoApplication.getInstance().getString(R.string.mapserver_openandromaps_themes_downloadurl), \"Elevate.zip\");\n         if (file != null) {\n             list.add(file);\n         }\n     }\n \n     @Override\n-    protected OfflineMap checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n+    protected Download checkUpdateFor(final String page, final String remoteUrl, final String remoteFilename) {\n         final MatcherWrapper matchDate = new MatcherWrapper(PATTERN_LAST_UPDATED_DATE, page);\n         if (matchDate.find()) {\n             final String date = \"20\" + matchDate.group(3) + \"-\" + matchDate.group(2) + \"-\" + matchDate.group(1);\n-            return new OfflineMap(\"Elevate\", Uri.parse(CgeoApplication.getInstance().getString(R.string.mapserver_openandromaps_themes_downloadurl) + \"Elevate.zip\"), false, date, \"\", offlineMapType);\n+            return new Download(\"Elevate\", Uri.parse(CgeoApplication.getInstance().getString(R.string.mapserver_openandromaps_themes_downloadurl) + \"Elevate.zip\"), false, date, \"\", offlineMapType);\n         }\n         return null;\n     }"
  },
  {
    "sha": "6025d22587de77097490bdcbd1e930d9d9057e45",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMap.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMap.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMap.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMap.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -2,7 +2,7 @@\n \n import cgeo.geocaching.R;\n import cgeo.geocaching.activity.AbstractActivity;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.utils.Log;\n \n import android.net.Uri;\n@@ -24,7 +24,7 @@ public void onCreate(final Bundle savedInstanceState) {\n         if (host.equals(\"download.openandromaps.org\") && path.startsWith(\"/mapsV4/\") && path.endsWith(\".zip\")) {\n             // remap Uri to their ftp server\n             final Uri newUri = Uri.parse(getString(R.string.mapserver_openandromaps_downloadurl) + path.substring(8));\n-            MapDownloaderUtils.triggerDownload(this, OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_OPENANDROMAPS.id, newUri, \"\", System.currentTimeMillis(), this::callback);\n+            DownloaderUtils.triggerDownload(this, R.string.downloadmap_title, Download.DownloadType.DOWNLOADTYPE_MAP_OPENANDROMAPS.id, newUri, \"\", \"\", System.currentTimeMillis(), this::callback);\n         } else {\n             // generic map download\n             Log.w(\"MapDownloaderReceiverSchemeMap: Received map download intent from unknown source: \" + uri.toString());"
  },
  {
    "sha": "e3b3ca25ba80bf01c9f5e8d6f43cc6d5cf7e8bc2",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMapTheme.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMapTheme.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMapTheme.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderReceiverSchemeMapTheme.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -2,7 +2,7 @@\n \n import cgeo.geocaching.R;\n import cgeo.geocaching.activity.AbstractActivity;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.utils.Log;\n \n import android.net.Uri;\n@@ -24,7 +24,7 @@ public void onCreate(final Bundle savedInstanceState) {\n         if (host.equals(\"download.openandromaps.org\") && path.startsWith(\"/themes/\") && path.endsWith(\".zip\")) {\n             // no remapping, as they have themes only on their homepage, not on their ftp site\n             final Uri newUri = Uri.parse(getString(R.string.mapserver_openandromaps_themes_downloadurl) + path.substring(8));\n-            MapDownloaderUtils.triggerDownload(this, OfflineMap.OfflineMapType.MAP_DOWNLOAD_TYPE_OPENANDROMAPS_THEMES.id, newUri, \"\", System.currentTimeMillis(), this::callback);\n+            DownloaderUtils.triggerDownload(this, R.string.downloadmap_title, Download.DownloadType.DOWNLOADTYPE_THEME_OPENANDROMAPS.id, newUri, \"\", \"\", System.currentTimeMillis(), this::callback);\n         } else {\n             // generic map theme download - not yet supported\n             Log.w(\"MapDownloaderReceiverSchemeMapTheme: Received map theme download intent from unknown source: \" + uri.toString());"
  },
  {
    "sha": "f812107ba0291cbbff27e8b6708307785d351931",
    "filename": "main/src/cgeo/geocaching/downloader/MapDownloaderUtils.java",
    "status": "removed",
    "additions": 0,
    "deletions": 133,
    "changes": 133,
    "blob_url": "https://github.com/cgeo/cgeo/blob/ce2e2238affaa42d3d3f7de42367a8489f9a8092/main/src/cgeo/geocaching/downloader/MapDownloaderUtils.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/ce2e2238affaa42d3d3f7de42367a8489f9a8092/main/src/cgeo/geocaching/downloader/MapDownloaderUtils.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/MapDownloaderUtils.java?ref=ce2e2238affaa42d3d3f7de42367a8489f9a8092",
    "patch": "@@ -1,133 +0,0 @@\n-package cgeo.geocaching.downloader;\n-\n-import cgeo.geocaching.R;\n-import cgeo.geocaching.activity.ActivityMixin;\n-import cgeo.geocaching.models.OfflineMap;\n-import cgeo.geocaching.permission.PermissionGrantedCallback;\n-import cgeo.geocaching.permission.PermissionHandler;\n-import cgeo.geocaching.permission.PermissionRequestContext;\n-import cgeo.geocaching.storage.ContentStorage;\n-import cgeo.geocaching.storage.PersistableFolder;\n-import cgeo.geocaching.storage.extension.PendingDownload;\n-import cgeo.geocaching.ui.dialog.Dialogs;\n-import cgeo.geocaching.utils.Log;\n-\n-import android.app.Activity;\n-import android.app.AlertDialog;\n-import android.app.DownloadManager;\n-import android.content.Intent;\n-import android.net.Uri;\n-import android.os.Environment;\n-import android.view.View;\n-import android.widget.CheckBox;\n-import android.widget.TextView;\n-import static android.app.Activity.RESULT_OK;\n-import static android.content.Context.DOWNLOAD_SERVICE;\n-\n-public class MapDownloaderUtils {\n-\n-    public static final int REQUEST_CODE = 47131;\n-    public static final String RESULT_CHOSEN_URL = \"chosenUrl\";\n-    public static final String RESULT_SIZE_INFO = \"sizeInfo\";\n-    public static final String RESULT_DATE = \"dateInfo\";\n-    public static final String RESULT_TYPEID = \"typeId\";\n-\n-    private MapDownloaderUtils() {\n-        // utility class\n-    }\n-\n-    public static boolean onOptionsItemSelected(final Activity activity, final int id) {\n-        if (id == R.id.menu_download_offlinemap) {\n-            activity.startActivityForResult(new Intent(activity, MapDownloadSelectorActivity.class), REQUEST_CODE);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public static boolean onActivityResult(final Activity activity, final int requestCode, final int resultCode, final Intent data) {\n-        if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) {\n-            // trigger download manager for downloading the requested file\n-            final Uri uri = data.getParcelableExtra(RESULT_CHOSEN_URL);\n-            final String sizeInfo = data.getStringExtra(RESULT_SIZE_INFO);\n-            final long date = data.getLongExtra(RESULT_DATE, 0);\n-            final int type = data.getIntExtra(RESULT_TYPEID, OfflineMap.OfflineMapType.DEFAULT);\n-            if (null != uri) {\n-                triggerDownload(activity, type, uri, sizeInfo, date, null);\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public static void triggerDownload(final Activity activity, final int type, final Uri uri, final String sizeInfo, final long date, final Runnable callback) {\n-        String temp = uri.getLastPathSegment();\n-        if (null == temp) {\n-            temp = \"default.map\";\n-        }\n-        final String filename = temp;\n-\n-        final AlertDialog.Builder builder = Dialogs.newBuilder(activity);\n-        builder.setTitle(R.string.downloadmap_title);\n-        final View layout = View.inflate(activity, R.layout.mapdownloader_confirmation, null);\n-        builder.setView(layout);\n-        final TextView downloadInfo = layout.findViewById(R.id.download_info);\n-        downloadInfo.setText(String.format(activity.getString(R.string.downloadmap_confirmation), filename, sizeInfo));\n-\n-        builder\n-            .setPositiveButton(android.R.string.ok, (dialog, which) -> {\n-                final boolean allowMeteredNetwork = ((CheckBox) layout.findViewById(R.id.allow_metered_network)).isChecked();\n-\n-                final DownloadManager.Request request = new DownloadManager.Request(uri)\n-                    .setTitle(filename)\n-                    .setDescription(String.format(activity.getString(R.string.downloadmap_filename), filename))\n-                    .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)\n-                    .setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename)\n-                    .setAllowedOverMetered(allowMeteredNetwork)\n-                    .setAllowedOverRoaming(allowMeteredNetwork);\n-                Log.i(\"Map download enqueued: \" + Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + \"/\" + filename);\n-                final DownloadManager downloadManager = (DownloadManager) activity.getSystemService(DOWNLOAD_SERVICE);\n-                if (null != downloadManager) {\n-                    PendingDownload.add(downloadManager.enqueue(request), filename, uri.toString(), date, type);\n-                    ActivityMixin.showShortToast(activity, R.string.download_started);\n-                } else {\n-                    ActivityMixin.showToast(activity, R.string.downloadmanager_not_available);\n-                }\n-                dialog.dismiss();\n-                if (callback != null) {\n-                    callback.run();\n-                }\n-            })\n-            .setNegativeButton(android.R.string.cancel, (dialog, which) -> {\n-                dialog.dismiss();\n-                if (callback != null) {\n-                    callback.run();\n-                }\n-            })\n-            .create()\n-            .show();\n-    }\n-\n-    public interface DirectoryWritable {\n-        void run (PersistableFolder folder, boolean isAvailable);\n-    }\n-\n-    public static void checkMapDirectory(final Activity activity, final boolean beforeDownload, final DirectoryWritable callback) {\n-        PermissionHandler.requestStoragePermission(activity, new PermissionGrantedCallback(PermissionRequestContext.ReceiveMapFileActivity) {\n-            @Override\n-            protected void execute() {\n-                final PersistableFolder folder = PersistableFolder.OFFLINE_MAPS;\n-                final boolean mapDirIsReady = ContentStorage.get().ensureFolder(folder);\n-\n-                if (mapDirIsReady) {\n-                    callback.run(folder, true);\n-                } else if (beforeDownload) {\n-                    Dialogs.confirm(activity, activity.getString(R.string.downloadmap_title), String.format(activity.getString(R.string.downloadmap_target_not_writable), folder), activity.getString(R.string.button_continue),\n-                            (dialog, which) -> callback.run(folder, true), dialog -> callback.run(folder, false));\n-                } else {\n-                    Dialogs.message(activity, activity.getString(R.string.downloadmap_title), String.format(activity.getString(R.string.downloadmap_target_not_writable), folder), activity.getString(android.R.string.ok), (dialog, which) -> callback.run(folder, false));\n-                }\n-            }\n-        });\n-    }\n-\n-}"
  },
  {
    "sha": "a78c602dfd024a5df4919a6f13ffff27d398bd3c",
    "filename": "main/src/cgeo/geocaching/downloader/ReceiveDownloadActivity.java",
    "status": "renamed",
    "additions": 57,
    "deletions": 49,
    "changes": 106,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/ReceiveDownloadActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/ReceiveDownloadActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/ReceiveDownloadActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -2,7 +2,7 @@\n \n import cgeo.geocaching.R;\n import cgeo.geocaching.activity.AbstractActivity;\n-import cgeo.geocaching.models.OfflineMap;\n+import cgeo.geocaching.models.Download;\n import cgeo.geocaching.storage.ContentStorage;\n import cgeo.geocaching.ui.dialog.Dialogs;\n import cgeo.geocaching.utils.AsyncTaskWithProgressText;\n@@ -35,7 +35,7 @@\n  * If no map directory is set currently, default map directory is used, created if needed, and saved as map directory in preferences.\n  * If the map file already exists under that name in the map directory, you have the option to either overwrite it or save it under a randomly generated name.\n  */\n-public class ReceiveMapFileActivity extends AbstractActivity {\n+public class ReceiveDownloadActivity extends AbstractActivity {\n \n     public static final String EXTRA_FILENAME = \"filename\";\n \n@@ -44,7 +44,7 @@\n \n     private String sourceURL = \"\";\n     private long sourceDate = 0;\n-    private int offlineMapTypeId = OfflineMap.OfflineMapType.DEFAULT;\n+    private int offlineMapTypeId = Download.DownloadType.DEFAULT;\n     private AbstractDownloader downloader;\n \n     protected enum CopyStates {\n@@ -59,12 +59,12 @@ public void onCreate(final Bundle savedInstanceState) {\n         final Intent intent = getIntent();\n         uri = intent.getData();\n         final String preset = intent.getStringExtra(EXTRA_FILENAME);\n-        sourceURL = intent.getStringExtra(MapDownloaderUtils.RESULT_CHOSEN_URL);\n-        sourceDate = intent.getLongExtra(MapDownloaderUtils.RESULT_DATE, 0);\n-        offlineMapTypeId = intent.getIntExtra(MapDownloaderUtils.RESULT_TYPEID, OfflineMap.OfflineMapType.DEFAULT);\n-        downloader = OfflineMap.OfflineMapType.getInstance(offlineMapTypeId);\n+        sourceURL = intent.getStringExtra(DownloaderUtils.RESULT_CHOSEN_URL);\n+        sourceDate = intent.getLongExtra(DownloaderUtils.RESULT_DATE, 0);\n+        offlineMapTypeId = intent.getIntExtra(DownloaderUtils.RESULT_TYPEID, Download.DownloadType.DEFAULT);\n+        downloader = Download.DownloadType.getInstance(offlineMapTypeId);\n \n-        MapDownloaderUtils.checkMapDirectory(this, false, (folder, isWritable) -> {\n+        DownloaderUtils.checkTargetDirectory(this, downloader.targetFolder, false, (folder, isWritable) -> {\n             if (isWritable) {\n                 boolean foundMapInZip = false;\n                 // test if ZIP file received\n@@ -117,7 +117,7 @@ private boolean guessFilename(final String preset) {\n     private void handleMapFile(final Activity activity, final boolean isZipFile, final String nameWithinZip) {\n         // check whether the target file or its companion file already exist\n         final List<ContentStorage.FileInformation> files = ContentStorage.get().list(downloader.targetFolder.getFolder(), false);\n-        Uri companionFileExists = CompanionFileUtils.companionFileExists(files, filename);\n+        Uri companionFileExists = downloader.useCompanionFiles ? CompanionFileUtils.companionFileExists(files, filename) : null;\n         Uri downloadFileExists = null;\n         for (ContentStorage.FileInformation fi : files) {\n             if (fi.name.equals(filename)) {\n@@ -134,50 +134,58 @@ private void handleMapFile(final Activity activity, final boolean isZipFile, fin\n         final Uri cf = companionFileExists;\n \n         if (df != null) {\n-            final AlertDialog.Builder builder = Dialogs.newBuilder(activity);\n-            final AlertDialog dialog = builder.setTitle(R.string.receivemapfile_intenttitle)\n-                .setCancelable(true)\n-                .setMessage(R.string.receivemapfile_alreadyexists)\n-                .setPositiveButton(R.string.receivemapfile_option_overwrite, (dialog3, button3) -> {\n-                    // for overwrite: delete existing files\n-                    ContentStorage.get().delete(df);\n-                    if (cf != null) {\n-                        ContentStorage.get().delete(cf);\n-                    }\n-                    new CopyTask(this, isZipFile, nameWithinZip).execute();\n-                })\n-                .setNeutralButton(R.string.receivemapfile_option_differentname, (dialog2, button2) -> {\n-                    // when overwriting generate new filename internally and check for collisions with companion file (would be a lone companion file, so delete silently)\n-                    final List<String> existingFiles = new ArrayList<>();\n-                    for (ContentStorage.FileInformation fi : files) {\n-                        existingFiles.add(fi.name);\n-                    }\n-                    filename = FileUtils.createUniqueFilename(filename, existingFiles);\n-                    final Uri newCompanionFile = CompanionFileUtils.companionFileExists(files, filename);\n-                    if (newCompanionFile != null) {\n-                        ContentStorage.get().delete(newCompanionFile);\n-                    }\n-                    new CopyTask(this, isZipFile, nameWithinZip).execute();\n-                })\n-                .setNegativeButton(android.R.string.cancel, (dialog4, which4) -> activity.finish())\n-                .create();\n-            dialog.setOwnerActivity(activity);\n-            dialog.show();\n+            if (downloader.overwrite) {\n+                ContentStorage.get().delete(df);\n+                if (cf != null) {\n+                    ContentStorage.get().delete(cf);\n+                }\n+                new CopyTask(this, isZipFile, nameWithinZip).execute();\n+            } else {\n+                final AlertDialog.Builder builder = Dialogs.newBuilder(activity);\n+                final AlertDialog dialog = builder.setTitle(R.string.receivedownload_intenttitle)\n+                    .setCancelable(true)\n+                    .setMessage(R.string.receivedownload_alreadyexists)\n+                    .setPositiveButton(R.string.receivedownload_option_overwrite, (dialog3, button3) -> {\n+                        // for overwrite: delete existing files\n+                        ContentStorage.get().delete(df);\n+                        if (cf != null) {\n+                            ContentStorage.get().delete(cf);\n+                        }\n+                        new CopyTask(this, isZipFile, nameWithinZip).execute();\n+                    })\n+                    .setNeutralButton(R.string.receivedownload_option_differentname, (dialog2, button2) -> {\n+                        // when overwriting generate new filename internally and check for collisions with companion file (would be a lone companion file, so delete silently)\n+                        final List<String> existingFiles = new ArrayList<>();\n+                        for (ContentStorage.FileInformation fi : files) {\n+                            existingFiles.add(fi.name);\n+                        }\n+                        filename = FileUtils.createUniqueFilename(filename, existingFiles);\n+                        final Uri newCompanionFile = CompanionFileUtils.companionFileExists(files, filename);\n+                        if (newCompanionFile != null) {\n+                            ContentStorage.get().delete(newCompanionFile);\n+                        }\n+                        new CopyTask(this, isZipFile, nameWithinZip).execute();\n+                    })\n+                    .setNegativeButton(android.R.string.cancel, (dialog4, which4) -> activity.finish())\n+                    .create();\n+                dialog.setOwnerActivity(activity);\n+                dialog.show();\n+            }\n         } else {\n             new CopyTask(this, isZipFile, nameWithinZip).execute();\n         }\n     }\n \n     protected class CopyTask extends AsyncTaskWithProgressText<String, CopyStates> {\n         private long bytesCopied = 0;\n-        private final String progressFormat = getString(R.string.receivemapfile_kb_copied);\n+        private final String progressFormat = getString(R.string.receivedownload_kb_copied);\n         private final AtomicBoolean cancelled = new AtomicBoolean(false);\n         private final Activity context;\n         private final boolean isZipFile;\n         private final String nameWithinZip;\n \n         CopyTask(final Activity activity, final boolean isZipFile, final String nameWithinZip) {\n-            super(activity, activity.getString(R.string.receivemapfile_intenttitle), \"\");\n+            super(activity, activity.getString(R.string.receivedownload_intenttitle), \"\");\n             setOnCancelListener((dialog, which) -> cancelled.set(true));\n             context = activity;\n             this.isZipFile = isZipFile;\n@@ -215,15 +223,15 @@ protected CopyStates doInBackgroundInternal(final String[] logTexts) {\n                 IOUtils.closeQuietly(inputStream);\n             }\n \n-            // clean up and refresh available map list\n+            // clean up\n             if (!cancelled.get()) {\n                 status = CopyStates.SUCCESS;\n                 try {\n                     getContentResolver().delete(uri, null, null);\n                 } catch (IllegalArgumentException iae) {\n                     Log.w(\"Deleting Uri '\" + uri + \"' failed, will be ignored\", iae);\n                 }\n-                // finalization AFTER deleting source file. This handles the very special case when Map Folder = Download Folder\n+                // finalization AFTER deleting source file. This handles the very special case when target folder = Download folder\n                 downloader.onSuccessfulReceive(outputUri);\n             } else {\n                 ContentStorage.get().delete(outputUri);\n@@ -262,25 +270,25 @@ protected void onPostExecuteInternal(final CopyStates status) {\n             }\n             switch (status) {\n                 case SUCCESS:\n-                    result = String.format(getString(R.string.receivemapfile_success), fileinfo);\n-                    if (StringUtils.isNotBlank(sourceURL)) {\n+                    result = String.format(getString(R.string.receivedownload_success), fileinfo);\n+                    if (downloader.useCompanionFiles && StringUtils.isNotBlank(sourceURL)) {\n                         CompanionFileUtils.writeInfo(sourceURL, filename, CompanionFileUtils.getDisplayName(fileinfo), sourceDate, offlineMapTypeId);\n                     }\n                     break;\n                 case CANCELLED:\n-                    result = getString(R.string.receivemapfile_cancelled);\n+                    result = getString(R.string.receivedownload_cancelled);\n                     break;\n                 case IO_EXCEPTION:\n-                    result = String.format(getString(R.string.receivemapfile_error_io_exception), downloader.targetFolder);\n+                    result = String.format(getString(R.string.receivedownload_error_io_exception), downloader.targetFolder);\n                     break;\n                 case FILENOTFOUND_EXCEPTION:\n-                    result = getString(R.string.receivemapfile_error_filenotfound_exception);\n+                    result = getString(R.string.receivedownload_error_filenotfound_exception);\n                     break;\n                 default:\n-                    result = getString(R.string.receivemapfile_error);\n+                    result = getString(R.string.receivedownload_error);\n                     break;\n             }\n-            Dialogs.message(context, getString(R.string.receivemapfile_intenttitle), result, getString(android.R.string.ok), (dialog, button) -> downloader.onFollowup(activity, ReceiveMapFileActivity.this::doFinish));\n+            Dialogs.message(context, getString(R.string.receivedownload_intenttitle), result, getString(android.R.string.ok), (dialog, button) -> downloader.onFollowup(activity, ReceiveDownloadActivity.this::doFinish));\n         }\n \n     }",
    "previous_filename": "main/src/cgeo/geocaching/downloader/ReceiveMapFileActivity.java"
  },
  {
    "sha": "f214b555b1da72e6b62d7564ee0c19679d032c25",
    "filename": "main/src/cgeo/geocaching/downloader/package-info.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/package-info.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/downloader/package-info.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/downloader/package-info.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -13,7 +13,7 @@\n  * - Android internal Download manager gets triggered for download of a\n  *   specific file,\n  *   temporary info for this process is stored as PendingDownload\n- * - Download manager calls MapDownloadNotificationReceiver with result\n+ * - Download manager calls DownloadNotificationReceiver with result\n  * - this deletes the PendingDownload and triggers ReceiveMapFileActivity\n  * - here copying the file to its final destination (unzipping along the\n  *   way, if needed) and handling of companion file is done"
  },
  {
    "sha": "80672d6987192f6caa0f8d5bf1b69e1dc5b0eb40",
    "filename": "main/src/cgeo/geocaching/maps/CGeoMap.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/CGeoMap.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/CGeoMap.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/maps/CGeoMap.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -11,7 +11,7 @@\n import cgeo.geocaching.connector.ConnectorFactory;\n import cgeo.geocaching.connector.gc.GCMap;\n import cgeo.geocaching.connector.gc.Tile;\n-import cgeo.geocaching.downloader.MapDownloaderUtils;\n+import cgeo.geocaching.downloader.DownloaderUtils;\n import cgeo.geocaching.enumerations.CacheType;\n import cgeo.geocaching.enumerations.CoordinatesType;\n import cgeo.geocaching.enumerations.LoadFlags;\n@@ -832,7 +832,7 @@ public boolean onOptionsItemSelected(@NonNull final MenuItem item) {\n         } else if (!HistoryTrackUtils.onOptionsItemSelected(activity, id, () -> mapView.repaintRequired(overlayPositionAndScale instanceof GeneralOverlay ? ((GeneralOverlay) overlayPositionAndScale) : null), this::clearTrailHistory)\n             && !this.trackUtils.onOptionsItemSelected(id, tracks, this::setTracks, this::centerOnPosition)\n             && !this.individualRouteUtils.onOptionsItemSelected(id, individualRoute, this::clearIndividualRoute, this::reloadIndividualRoute, this::centerOnPosition, this::setTarget)\n-            && !MapDownloaderUtils.onOptionsItemSelected(activity, id)) {\n+            && !DownloaderUtils.onOptionsItemSelected(activity, id)) {\n             final MapSource mapSource = MapProviderFactory.getMapSource(id);\n             if (mapSource != null) {\n                 item.setChecked(true);"
  },
  {
    "sha": "6a6dfb14e0069218eabfebc202858821ed92b81f",
    "filename": "main/src/cgeo/geocaching/maps/google/v2/GoogleMapActivity.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/google/v2/GoogleMapActivity.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/google/v2/GoogleMapActivity.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/maps/google/v2/GoogleMapActivity.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -5,7 +5,7 @@\n import cgeo.geocaching.R;\n import cgeo.geocaching.activity.ActivityMixin;\n import cgeo.geocaching.activity.FilteredActivity;\n-import cgeo.geocaching.downloader.MapDownloaderUtils;\n+import cgeo.geocaching.downloader.DownloaderUtils;\n import cgeo.geocaching.maps.AbstractMap;\n import cgeo.geocaching.maps.CGeoMap;\n import cgeo.geocaching.maps.interfaces.MapActivityImpl;\n@@ -224,7 +224,7 @@ protected void onActivityResult(final int requestCode, final int resultCode, fin\n         }\n         this.trackUtils.onActivityResult(requestCode, resultCode, data);\n         this.individualRouteUtils.onActivityResult(requestCode, resultCode, data, mapBase::reloadIndividualRoute);\n-        MapDownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n+        DownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n     }\n \n     @Override"
  },
  {
    "sha": "625c59f449e0809c10ba587211992ae6c7d04df9",
    "filename": "main/src/cgeo/geocaching/maps/mapsforge/v6/NewMap.java",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/cgeo/cgeo/blob/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/mapsforge/v6/NewMap.java",
    "raw_url": "https://github.com/cgeo/cgeo/raw/23dd4cdcbbe95d3f0042769364bc99c467d993dc/main/src/cgeo/geocaching/maps/mapsforge/v6/NewMap.java",
    "contents_url": "https://api.github.com/repos/cgeo/cgeo/contents/main/src/cgeo/geocaching/maps/mapsforge/v6/NewMap.java?ref=23dd4cdcbbe95d3f0042769364bc99c467d993dc",
    "patch": "@@ -15,7 +15,7 @@\n import cgeo.geocaching.connector.gc.GCMap;\n import cgeo.geocaching.connector.gc.Tile;\n import cgeo.geocaching.connector.internal.InternalConnector;\n-import cgeo.geocaching.downloader.MapDownloaderUtils;\n+import cgeo.geocaching.downloader.DownloaderUtils;\n import cgeo.geocaching.enumerations.CacheListType;\n import cgeo.geocaching.enumerations.CacheType;\n import cgeo.geocaching.enumerations.CoordinatesType;\n@@ -425,7 +425,7 @@ public boolean onOptionsItemSelected(@NonNull final MenuItem item) {\n         } else if (!HistoryTrackUtils.onOptionsItemSelected(this, id, () -> historyLayer.requestRedraw(), this::clearTrailHistory)\n             && !this.trackUtils.onOptionsItemSelected(id, tracks, this::setTracks, this::centerOnPosition)\n             && !this.individualRouteUtils.onOptionsItemSelected(id, individualRoute, this::clearIndividualRoute, this::reloadIndividualRoute, this::centerOnPosition, this::setTarget)\n-            && !MapDownloaderUtils.onOptionsItemSelected(this, id)) {\n+            && !DownloaderUtils.onOptionsItemSelected(this, id)) {\n             final String language = MapProviderFactory.getLanguage(id);\n             if (language != null || id == MAP_LANGUAGE_DEFAULT) {\n                 item.setChecked(true);\n@@ -1624,7 +1624,7 @@ protected void onActivityResult(final int requestCode, final int resultCode, fin\n         }\n         this.trackUtils.onActivityResult(requestCode, resultCode, data);\n         this.individualRouteUtils.onActivityResult(requestCode, resultCode, data, this::reloadIndividualRoute);\n-        MapDownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n+        DownloaderUtils.onActivityResult(this, requestCode, resultCode, data);\n     }\n \n     private void setTracks(final Route route) {"
  }
]
