[
  {
    "sha": "f861e1154aaea8898f35102f5b2e7d00dd88b830",
    "filename": "src/main/java/org/folio/rest/impl/TenantRefAPI.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/impl/TenantRefAPI.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/impl/TenantRefAPI.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/main/java/org/folio/rest/impl/TenantRefAPI.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -9,6 +9,7 @@\n import org.apache.logging.log4j.Logger;\n import org.folio.rest.annotations.Validate;\n import org.folio.rest.jaxrs.model.TenantAttributes;\n+import org.folio.rest.support.ShelvingOrderUpdate;\n import org.folio.rest.tools.utils.TenantLoading;\n import org.folio.services.kafka.topic.KafkaAdminClientService;\n \n@@ -120,6 +121,7 @@ String servicePointUserFilter(String s) {\n               .add(\"users\", \"service-points-users\");\n           }\n           return tl.perform(attributes, headers, vertxContext, superRecordsLoaded);\n-        });\n+        }).compose(loaded -> ShelvingOrderUpdate\n+          .getInstance().updateItems(attributes, headers, vertxContext));\n   }\n }"
  },
  {
    "sha": "c4179cfad85c41680f171402a0a1284beb6edbb0",
    "filename": "src/main/java/org/folio/rest/support/EffectiveCallNumberComponentsUtil.java",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/support/EffectiveCallNumberComponentsUtil.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/support/EffectiveCallNumberComponentsUtil.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/main/java/org/folio/rest/support/EffectiveCallNumberComponentsUtil.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -21,6 +21,12 @@ public static void setCallNumberComponents(Item item, HoldingsRecord hr) {\n     item.setEffectiveCallNumberComponents(buildComponents(item, hr));\n   }\n \n+  public static Item getCalculateAndSetEffectiveShelvingOrder(Item item) {\n+    // Calculate item's shelving order\n+    calculateAndSetEffectiveShelvingOrder(item);\n+    return item;\n+  }\n+\n   public static void calculateAndSetEffectiveShelvingOrder(Item item) {\n     if (isNotBlank(item.getEffectiveCallNumberComponents().getCallNumber())) {\n       Optional<String> shelfKey\n@@ -35,7 +41,7 @@ public static void calculateAndSetEffectiveShelvingOrder(Item item) {\n           .map(StringUtils::trim)\n           .collect(Collectors.joining(\" \"))\n       );\n-//      String suffixValue = Objects.toString(item.getEffectiveCallNumberComponents().getSuffix(), \"\").trim();\n+\n       String suffixValue =\n         Objects.toString(Optional.ofNullable(item.getEffectiveCallNumberComponents())\n           .orElse(new EffectiveCallNumberComponents()).getSuffix(), \"\")"
  },
  {
    "sha": "39ff2f122010e6f6e295f3508b37e3a7dd31a918",
    "filename": "src/main/java/org/folio/rest/support/ShelvingOrderUpdate.java",
    "status": "added",
    "additions": 276,
    "deletions": 0,
    "changes": 276,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/support/ShelvingOrderUpdate.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/main/java/org/folio/rest/support/ShelvingOrderUpdate.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/main/java/org/folio/rest/support/ShelvingOrderUpdate.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -0,0 +1,276 @@\n+package org.folio.rest.support;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.pgclient.PgConnection;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.Transaction;\n+import io.vertx.sqlclient.Tuple;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import org.folio.dbschema.Versioned;\n+import org.folio.rest.jaxrs.model.Item;\n+import org.folio.rest.jaxrs.model.TenantAttributes;\n+import org.folio.rest.persist.PgUtil;\n+import org.folio.rest.persist.PostgresClient;\n+\n+public class ShelvingOrderUpdate {\n+\n+  private static final Logger log = LogManager.getLogger();\n+\n+  private static final String SQL_SELECT_ITEMS =\n+      new StringBuilder()\n+          .append(\"SELECT id AS \\\"id\\\", \")\n+          .append(\"jsonb AS \\\"itemJson\\\" \")\n+          .append(\"FROM item WHERE not (jsonb ? 'effectiveShelvingOrder') \")\n+          .append(\" FOR UPDATE \")\n+          .append(\"LIMIT $1\").toString();\n+\n+\n+  private static final String SQL_UPDATE_ITEMS = new StringBuilder()\n+      .append(\"UPDATE ITEM \")\n+      .append(\"SET jsonb = $1 \")\n+      .append(\"WHERE id = $2\").toString();\n+\n+  // Defines version threshold where this property was introduces from\n+  private static final String FROM_VERSION_SHELVING_ORDER = \"20.1.0\";\n+\n+  public static int DEF_FETCH_SIZE = 5000;\n+\n+  private static ShelvingOrderUpdate instance;\n+  private Versioned versionChecker;\n+  private int rowsBunchSize;\n+  private AtomicInteger totalUpdatedRows;\n+\n+  public static ShelvingOrderUpdate getInstance() {\n+    return getInstance(DEF_FETCH_SIZE);\n+  }\n+\n+  public static ShelvingOrderUpdate getInstance(int rowsBunchSize) {\n+    if (Objects.isNull(instance)) {\n+      instance = new ShelvingOrderUpdate(rowsBunchSize);\n+    }\n+    return instance;\n+  }\n+\n+  private ShelvingOrderUpdate(int rowsBunchSize) {\n+    this.versionChecker = new Versioned() {};\n+    this.versionChecker.setFromModuleVersion(FROM_VERSION_SHELVING_ORDER);\n+    this.rowsBunchSize = rowsBunchSize;\n+    this.totalUpdatedRows = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Entry routine of items updates. Invokes the process recursively until no items to update\n+   *\n+   * @param attributes\n+   * @param headers\n+   * @param vertxContext\n+   * @return\n+   */\n+  public Future<Integer> updateItems(TenantAttributes attributes, Map<String, String> headers,\n+      Context vertxContext) {\n+    final Promise updateItemsPromise = Promise.promise();\n+    final Vertx vertx = vertxContext.owner();\n+    \n+    vertx.executeBlocking(blockingHandler -> {\n+      \n+      if (ShelvingOrderUpdate.getInstance().isAllowedToUpdate(attributes)) {\n+        // Updates items with shelving order property.\n+        // This should be triggered once for particular version only.\n+        PostgresClient postgresClient = PgUtil.postgresClient(vertxContext, headers);\n+\n+        final long startTime = System.currentTimeMillis();\n+        fetchAndUpdatesItems(vertx, postgresClient)\n+            .onSuccess(rowsAffected -> {\n+\n+                totalUpdatedRows.addAndGet(rowsAffected);\n+                // If previous updates returns affected rows, try it again\n+                if (rowsAffected > 0) {\n+                  fetchAndUpdatesItems(vertx, postgresClient);\n+                } else {\n+                  // No rows affected, just set accumulated amount of rows to result\n+                  log.info(\"Items update with shelving order property completed in {} seconds\",\n+                      (System.currentTimeMillis() - startTime) / 1000);\n+                  updateItemsPromise.complete(totalUpdatedRows.get());\n+                  blockingHandler.complete();\n+                }\n+            })\n+            .onFailure(h -> {\n+              updateItemsPromise.fail(h.getCause());\n+              blockingHandler.fail(h.getCause());\n+              log.error(\"Error updating items: {}\" + h.getCause().getMessage());\n+            });\n+\n+      } else {\n+        // Not allowed to perform items updates, just returns\n+        updateItemsPromise.complete();\n+      }  \n+      \n+    });\n+\n+    return updateItemsPromise.future();\n+  }\n+\n+  /**\n+   * Performs fetching items by fixed bunches of rows with further property calculations and\n+   * updating in database\n+   *\n+   * @param vertx\n+   * @param postgresClient\n+   * @return\n+   */\n+  private Future<Integer> fetchAndUpdatesItems(Vertx vertx, PostgresClient postgresClient) {\n+    Promise<Integer> fetchAndUpdatePromise = Promise.promise();\n+\n+    postgresClient.getConnection(ar -> {\n+\n+      if (ar.failed()) {\n+        fetchAndUpdatePromise.fail(\"Connection acquiring failure : \" + ar.cause().getMessage());\n+\n+      } else {\n+        PgConnection connection = ar.result();\n+        // Starts a new transaction (acquiring and updating of items performs in single transaction)\n+        connection\n+            .begin()\n+            .compose(tx -> connection\n+                // Acquiring current bunch of items\n+                .preparedQuery(SQL_SELECT_ITEMS)\n+                .execute(Tuple.of(rowsBunchSize))\n+\n+                .compose(fetchedRows -> {\n+                  // Read items and fill them into data structures for further processing\n+                  return aggregateRow2List(fetchedRows)\n+\n+                      // Calculate items shelving order\n+                      .compose(ShelvingOrderUpdate.this::calculateShelvingOrder)\n+\n+                      // Prepare items update parameters\n+                      .compose(ShelvingOrderUpdate.this::prepareItemsUpdate)\n+\n+                      // Updates of items\n+                      .compose(listOfTuple -> updateItems(listOfTuple, connection));\n+                })\n+\n+                // Finish transaction\n+                .compose(updatedRows -> completeTransaction(tx, updatedRows.size(), fetchAndUpdatePromise))\n+\n+                // Close connection\n+                .eventually(v -> connection.close()));\n+        }\n+\n+      });\n+\n+    return fetchAndUpdatePromise.future();\n+  }\n+\n+  /**\n+   * Completes transaction and set common update promise with affected rows count\n+   *\n+   * @param tx\n+   * @param updatedRowsCount\n+   * @param itemsUpdatePromise\n+   * @return\n+   */\n+  private Future<Void> completeTransaction(Transaction tx, Integer updatedRowsCount,\n+      Promise<Integer> itemsUpdatePromise) {\n+    tx.commit()\n+        .onSuccess(h -> itemsUpdatePromise.complete(updatedRowsCount))\n+        .onFailure(h -> itemsUpdatePromise.fail(h.getCause().getMessage()));\n+    return Future.succeededFuture();\n+  }\n+  \n+  /**\n+   * Read items and fill them into data structures for further processing\n+   * \n+   * @param rowSet\n+   * @return\n+   */\n+  private Future<List<Item>> aggregateRow2List(RowSet<Row> rowSet) {\n+    List<Item> targetList = new ArrayList<>();\n+    rowSet.forEach(row -> {\n+      JsonObject itemJsonObject = row.getJsonObject(\"itemJson\");\n+      Item item = itemJsonObject.mapTo(Item.class);\n+      targetList.add(item);\n+    });\n+    return Future.succeededFuture(targetList);\n+  }\n+\n+  /**\n+   * Calculate items shelving order\n+   * \n+   * @return\n+   */\n+  private Future<Map<UUID, JsonObject>> calculateShelvingOrder(List<Item> itemList) {\n+    Map<UUID, JsonObject> updatedItemsMap = itemList.stream()\n+        .map(EffectiveCallNumberComponentsUtil::getCalculateAndSetEffectiveShelvingOrder)\n+        .collect(Collectors.toMap(item -> UUID.fromString(item.getId()), JsonObject::mapFrom));\n+    return Future.succeededFuture(updatedItemsMap);\n+  }\n+\n+  /**\n+   * Prepare items update parameters\n+   * \n+   * @param itemIdMap\n+   * @return\n+   */\n+  private Future<List<Tuple>> prepareItemsUpdate(Map<UUID, JsonObject> itemIdMap) {\n+    List<Tuple> itemsUpdateParams = new ArrayList<>();\n+    itemIdMap.entrySet().stream()\n+        .map(entry -> itemsUpdateParams.add(Tuple.of(entry.getValue(), entry.getKey())))\n+        .collect(Collectors.toList());\n+    return Future.succeededFuture(itemsUpdateParams);\n+  }\n+\n+  /**\n+   * Updates of items\n+   * \n+   * @param itemsParams\n+   * @param connection\n+   * @return\n+   */\n+  private Future<RowSet<Row>> updateItems(List<Tuple> itemsParams, PgConnection connection) {\n+    Promise<RowSet<Row>> promise = Promise.promise();\n+    connection.preparedQuery(SQL_UPDATE_ITEMS).executeBatch(itemsParams, res -> {\n+      if (res.succeeded()) {\n+        int updatedItemsCount = res.result().rowCount();\n+        log.info(\"There were {} items updated\", updatedItemsCount);\n+        promise.complete(res.result());\n+      } else {\n+        log.error(\"Items updates failed {}\", res.cause());\n+        promise.fail(res.cause().getMessage());\n+      }\n+    });\n+    return promise.future();\n+  }\n+\n+  /**\n+   * Determine conditions of starting items updates\n+   * \n+   * @param attributes\n+   * @return\n+   */\n+  private boolean isAllowedToUpdate(TenantAttributes attributes) {\n+    String fromModuleVersion = Optional.ofNullable(attributes.getModuleFrom()).orElse(StringUtils.EMPTY).trim();\n+    log.debug(\"fromModuleVersion is: {}\", fromModuleVersion);\n+\n+    return (StringUtils.isNotBlank(fromModuleVersion)\n+        && !versionChecker.isNewForThisInstall(fromModuleVersion));\n+  }\n+\n+}"
  },
  {
    "sha": "9ef06223cada26f46ff964dca0e3542b3345a338",
    "filename": "src/test/java/org/folio/rest/api/StorageTestSuite.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/rest/api/StorageTestSuite.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/rest/api/StorageTestSuite.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/test/java/org/folio/rest/api/StorageTestSuite.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -23,6 +23,7 @@\n import org.folio.rest.tools.utils.NetworkUtils;\n import org.folio.rest.unit.ItemDamagedStatusAPIUnitTest;\n import org.folio.services.CallNumberUtilsTest;\n+import org.folio.services.ShelvingOrderUpdateTest;\n import org.folio.services.kafka.KafkaProperties;\n import org.junit.AfterClass;\n import org.junit.Assert;\n@@ -44,6 +45,7 @@\n @RunWith(Suite.class)\n @Suite.SuiteClasses({\n   CallNumberUtilsTest.class,\n+  ShelvingOrderUpdateTest.class,\n   InstanceStorageTest.class,\n   RecordBulkTest.class,\n   HoldingsStorageTest.class,\n@@ -282,7 +284,7 @@ static void prepareTenant(String tenantId, boolean loadSample)\n     prepareTenant(tenantId, null, \"mod-inventory-storage-1.0.0\", loadSample);\n   }\n \n-  static void removeTenant(String tenantId) throws InterruptedException, ExecutionException, TimeoutException {\n+  public static void removeTenant(String tenantId) throws InterruptedException, ExecutionException, TimeoutException {\n \n     JsonObject jo = new JsonObject();\n     jo.put(\"purge\", Boolean.TRUE);"
  },
  {
    "sha": "dcadda1afaf6e5e2e72620563a609e361f819347",
    "filename": "src/test/java/org/folio/services/CallNumberUtilsTest.java",
    "status": "modified",
    "additions": 55,
    "deletions": 8,
    "changes": 63,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/services/CallNumberUtilsTest.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/services/CallNumberUtilsTest.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/test/java/org/folio/services/CallNumberUtilsTest.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -48,20 +48,67 @@ public void inputForShelvingNumber(\n     String copy,\n     String suffix\n   ) {\n+    Item item = prepareAnItem(prefix, callNumber, volume, enumeration, chronology, copy, suffix);\n+    HoldingsRecord holdingsRecord = new HoldingsRecord();\n+    EffectiveCallNumberComponentsUtil.setCallNumberComponents(item, holdingsRecord);\n+    EffectiveCallNumberComponentsUtil.calculateAndSetEffectiveShelvingOrder(item);\n+\n+    assertThat(item.getEffectiveShelvingOrder(),is (desiredShelvingOrder));\n+  }  \n+  \n+  @Parameters({\n+    \"PN 12 A6,PN12 .A6,,PN2 .A6,,,,,\",\n+    \"PN 12 A6 V 13 NO 12 41999,PN2 .A6 v.3 no.2 1999,,PN2 .A6,v. 3,no. 2,1999,,\",\n+    \"PN 12 A6 41999,PN12 .A6 41999,,PN2 .A6 1999,,,,,\",\n+    \"PN 12 A6 41999 CD,PN12 .A6 41999 CD,,PN2 .A6 1999,,,,,CD\",\n+    \"PN 12 A6 41999 12,PN12 .A6 41999 C.12,,PN2 .A6 1999,,,,2,\",\n+    \"PN 12 A69 41922 12,PN12 .A69 41922 C.12,,PN2 .A69,,,1922,2,\",\n+    \"PN 12 A69 NO 12,PN12 .A69 NO.12,,PN2 .A69,,no. 2,,,\",\n+    \"PN 12 A69 NO 12 41922 11,PN12 .A69 NO.12 41922 C.11,,PN2 .A69,,no. 2,1922,1,\",\n+    \"PN 12 A69 NO 12 41922 12,PN12 .A69 NO.12 41922 C.12,Wordsworth,PN2 .A69,,no. 2,1922,2,\",\n+    \"PN 12 A69 V 11 NO 11,PN12 .A69 V.11 NO.11,,PN2 .A69,v.1,no. 1,,,\",\n+    \"PN 12 A69 V 11 NO 11 +,PN12 .A69 V.11 NO.11 +,Over,PN2 .A69,v.1,no. 1,,,+\",\n+    \"PN 12 A69 V 11 NO 11 41921,PN12 .A69 V.11 NO.11 41921,,PN2 .A69,v.1,no. 1,1921,,\",\n+    \"PR 49199.3 41920 L33 41475 A6,PR 49199.3 41920 .L33 41475 .A6,,PR9199.3 1920 .L33 1475 .A6,,,,,\",\n+    \"PQ 42678 K26 P54,PQ 42678 .K26 P54,,PQ2678.K26 P54,,,,,\",\n+    \"PQ 48550.21 R57 V5 41992,PQ 48550.21 .R57 V15 41992,,PQ8550.21.R57 V5 1992,,,,,\",\n+    \"PQ 48550.21 R57 V5 41992,PQ 48550.21 .R57 V15 41992,,PQ8550.21.R57 V5,,,1992,,\",\n+    \"PR 3919 L33 41990,PR 3919 .L33 41990,,PR919 .L33 1990,,,,,\",\n+    \"PR 49199 A39,PR 49199 .A39,,PR9199 .A39,,,,,\",\n+    \"PR 49199.48 B3,PR 49199.48 .B3,,PR9199.48 .B3,,,,,\"\n+  })\n+  @Test\n+  public void shouldReturnsItemsWithShelvingNumber(\n+    String desiredShelvingOrder,\n+    String initiallyDesiredShelvesOrder,\n+    String prefix,\n+    String callNumber,\n+    String volume,\n+    String enumeration,\n+    String chronology,\n+    String copy,\n+    String suffix\n+  ) {\n+    Item item = prepareAnItem(prefix, callNumber, volume, enumeration, chronology, copy, suffix);\n+    HoldingsRecord holdingsRecord = new HoldingsRecord();\n+    EffectiveCallNumberComponentsUtil.setCallNumberComponents(item, holdingsRecord);\n \n+    assertThat(EffectiveCallNumberComponentsUtil.getCalculateAndSetEffectiveShelvingOrder(item)\n+      .getEffectiveShelvingOrder(), is(desiredShelvingOrder));\n+  }\n+  \n+  private Item prepareAnItem(String callNumberPrefix, String callNumber, String volume,\n+      String enumeration, String chronology, String copyNumber, String callNumberSuffix) {\n     Item item = new Item();\n-    item.setItemLevelCallNumberPrefix(prefix);\n+    item.setItemLevelCallNumberPrefix(callNumberPrefix);\n     item.setItemLevelCallNumber(callNumber);\n     item.setVolume(volume);\n     item.setEnumeration(enumeration);\n     item.setChronology(chronology);\n-    item.setCopyNumber(copy);\n-    item.setItemLevelCallNumberSuffix(suffix);\n+    item.setCopyNumber(copyNumber);\n+    item.setItemLevelCallNumberSuffix(callNumberSuffix);\n \n-    HoldingsRecord holdingsRecord = new HoldingsRecord();\n-    EffectiveCallNumberComponentsUtil.setCallNumberComponents(item,holdingsRecord);\n-    EffectiveCallNumberComponentsUtil.calculateAndSetEffectiveShelvingOrder(item);\n-\n-    assertThat(item.getEffectiveShelvingOrder(),is (desiredShelvingOrder));\n+    return item;\n   }\n+  \n }"
  },
  {
    "sha": "cbc4a6dffbbf029a3018a90431e26d8589c127db",
    "filename": "src/test/java/org/folio/services/ShelvingOrderUpdateTest.java",
    "status": "added",
    "additions": 105,
    "deletions": 0,
    "changes": 105,
    "blob_url": "https://github.com/folio-org/mod-inventory-storage/blob/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/services/ShelvingOrderUpdateTest.java",
    "raw_url": "https://github.com/folio-org/mod-inventory-storage/raw/b32960fb70bd60cd7f4fcc7b51a67149b2b5baae/src/test/java/org/folio/services/ShelvingOrderUpdateTest.java",
    "contents_url": "https://api.github.com/repos/folio-org/mod-inventory-storage/contents/src/test/java/org/folio/services/ShelvingOrderUpdateTest.java?ref=b32960fb70bd60cd7f4fcc7b51a67149b2b5baae",
    "patch": "@@ -0,0 +1,105 @@\n+package org.folio.services;\n+\n+import static org.folio.rest.api.StorageTestSuite.removeTenant;\n+import static org.folio.rest.api.StorageTestSuite.tenantOp;\n+\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.unit.TestContext;\n+import io.vertx.ext.unit.junit.VertxUnitRunner;\n+import lombok.SneakyThrows;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.folio.rest.api.TestBase;\n+import org.folio.rest.jaxrs.model.TenantAttributes;\n+\n+@RunWith(VertxUnitRunner.class)\n+public class ShelvingOrderUpdateTest extends TestBase {\n+\n+  private static final Logger log = LogManager.getLogger();\n+\n+  private static final String FROM_MODULE_EXPECTED_VALUE = \"mod-inventory-storage-20.1.0\";\n+  private static final String FROM_MODULE_UNEXPECTED_VALUE = \"mod-inventory-storage-21.0.0\";\n+  private static final String BASE_MODULE_VALUE = \"mod-inventory-storage-1.0.0\";\n+\n+  private static String defaultTenant;\n+\n+  @BeforeClass\n+  @SneakyThrows\n+  public static void beforeClass(TestContext context) {\n+    defaultTenant = generateTenantValue();\n+    tenantOp(defaultTenant,\n+        JsonObject.mapFrom(new TenantAttributes().withModuleTo((BASE_MODULE_VALUE))));\n+  }\n+\n+  @AfterClass\n+  @SneakyThrows\n+  public static void afterClass(TestContext context) {\n+    deleteTenant(defaultTenant);\n+  }\n+\n+  @Test\n+  public void shouldSucceedItemsUpdateForExpectedModuleVersion() {\n+    String tenant = generateTenantValue();\n+    log.info(\"Tenant generated: {}\", tenant);\n+\n+    log.info(\"Tenant initialization started: {}\", tenant);\n+    initTenant(tenant);\n+    log.info(\"Tenant initialization finished\");\n+\n+    log.info(\"Module upgrade started, fromModuleVersion: {}\", FROM_MODULE_EXPECTED_VALUE);\n+//    postTenantOperation(tenant, FROM_MODULE_EXPECTED_VALUE);\n+    log.info(\"Module upgrade completed\");\n+\n+    log.info(\"Tenant deletion started: {}\", tenant);\n+    deleteTenant(tenant);\n+    log.info(\"Tenant deletion finished\");\n+  }\n+\n+  @Ignore\n+  @Test\n+  public void shouldFailItemsUpdateForUnexpectedModuleVersion() {\n+    String tenant = generateTenantValue();\n+    log.info(\"Tenant generated: {}\", tenant);\n+\n+    log.info(\"Tenant initialization started: {}\", tenant);\n+    initTenant(tenant);\n+    log.info(\"Tenant initialization finished\");\n+\n+    log.info(\"Module upgrade started, fromModuleVersion: {}\", FROM_MODULE_UNEXPECTED_VALUE);\n+//    postTenantOperation(tenant, FROM_MODULE_UNEXPECTED_VALUE);\n+    log.info(\"Module upgrade completed\");\n+\n+    log.info(\"Tenant deletion started: {}\", tenant);\n+    deleteTenant(tenant);\n+    log.info(\"Tenant deletion finished\");\n+  }\n+\n+  private static String generateTenantValue() {\n+    String tenant = String.format(\"tenant_%s\", RandomStringUtils.randomAlphanumeric(7));\n+    log.info(\"*** net tenant generated: {}\", tenant);\n+    return tenant;\n+  }\n+\n+  @SneakyThrows\n+  private static void postTenantOperation(String tenant, String fromModuleValue) {\n+    tenantOp(tenant, JsonObject.mapFrom(new TenantAttributes().withModuleFrom(fromModuleValue)));\n+  }\n+\n+  @SneakyThrows\n+  private static void deleteTenant(String tenant) {\n+    removeTenant(tenant);\n+  }\n+\n+  @SneakyThrows\n+  private void initTenant(String tenant) {\n+    tenantOp(tenant, JsonObject.mapFrom(new TenantAttributes().withModuleTo(BASE_MODULE_VALUE)));\n+  }\n+\n+}"
  }
]
