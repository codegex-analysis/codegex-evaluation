[
  {
    "sha": "1549bf249ae2904fd5e003bf1e0eb34754c59d7f",
    "filename": "common.hocon",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/common.hocon",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/common.hocon",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/common.hocon?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -173,6 +173,10 @@ svm-common-windows-jdk11: ${svm-common} ${windows-amd64} ${devkits.windows-jdk11\n   timelimit: \"45:00\"\n }\n \n+svm-common-windows-jdk16: ${svm-common} ${windows-amd64} ${devkits.windows-jdk16} {\n+  timelimit: \"45:00\"\n+}\n+\n svm-common-sulong: {\n   packages: {\n     llvm: \"==6.0.1\""
  },
  {
    "sha": "1c4f6e5ae948ec16c458191b1c37e09fff1f1443",
    "filename": "compiler/CHANGELOG.md",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/CHANGELOG.md",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/CHANGELOG.md",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/CHANGELOG.md?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -3,6 +3,7 @@\n This changelog summarizes newly introduced optimizations that may be relevant to other teams.\n \n ## Version 21.1.0\n+* (GR-29126) Unify box optimizations in the compiler. Remove `-Dgraal.ReuseOutOfCacheBoxedValues=false`.\n * (GR-28523) Optimize Box nodes: Optimizes box operations by re-using boxed representations \n if the value of the boxed primitive is outside of the cache range of the Int/Long/Short/Char caches.\n Box node optimization is enabled per default. Disable it with `-Dgraal.ReuseOutOfCacheBoxedValues=false`."
  },
  {
    "sha": "9e2503597f47ade78fe8622a4fd4834d6fad8009",
    "filename": "compiler/mx.compiler/mx_compiler.py",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/mx.compiler/mx_compiler.py",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/mx.compiler/mx_compiler.py",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/mx.compiler/mx_compiler.py?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -1414,7 +1414,7 @@ def _jvmci_jars():\n         ],\n         jvmci_jars=_jvmci_jars(),\n         graal_compiler='graal',\n-        supported=True,\n+        stability=\"supported\",\n     ),\n     mx_sdk_vm.GraalVmComponent(\n         suite=_suite,"
  },
  {
    "sha": "8822a19094a75840c3858af248496b68f0192a9e",
    "filename": "compiler/mx.compiler/suite.py",
    "status": "modified",
    "additions": 24,
    "deletions": 3,
    "changes": 27,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/mx.compiler/suite.py",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/mx.compiler/suite.py",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/mx.compiler/suite.py?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -1,5 +1,5 @@\n suite = {\n-  \"mxversion\" : \"5.287.0\",\n+  \"mxversion\" : \"5.288.5\",\n   \"name\" : \"compiler\",\n   \"sourceinprojectwhitelist\" : [],\n \n@@ -227,13 +227,34 @@\n         ],\n       },\n       \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"13+\",\n+      \"javaCompliance\" : \"13..15\",\n       \"checkPackagePrefix\" : \"false\",\n       \"overlayTarget\" : \"org.graalvm.compiler.serviceprovider\",\n       \"multiReleaseJarVersion\" : \"13\",\n       \"workingSets\" : \"API,Graal\",\n     },\n \n+    \"org.graalvm.compiler.serviceprovider.jdk16\" : {\n+      \"subDir\" : \"src\",\n+      \"sourceDirs\" : [\"src\"],\n+      \"dependencies\" : [\"org.graalvm.compiler.serviceprovider\"],\n+      \"requiresConcealed\" : {\n+        \"jdk.internal.vm.ci\" : [\n+          \"jdk.vm.ci.meta\",\n+          \"jdk.vm.ci.code\",\n+          \"jdk.vm.ci.code.site\",\n+          \"jdk.vm.ci.services\",\n+          \"jdk.vm.ci.runtime\",\n+        ],\n+      },\n+      \"checkstyle\" : \"org.graalvm.compiler.graph\",\n+      \"javaCompliance\" : \"16+\",\n+      \"checkPackagePrefix\" : \"false\",\n+      \"overlayTarget\" : \"org.graalvm.compiler.serviceprovider\",\n+      \"multiReleaseJarVersion\" : \"16\",\n+      \"workingSets\" : \"API,Graal\",\n+    },\n+\n     \"org.graalvm.compiler.processor\" : {\n       \"subDir\" : \"src\",\n       \"sourceDirs\" : [\"src\"],\n@@ -570,7 +591,7 @@\n       \"overlayTarget\" : \"org.graalvm.compiler.hotspot\",\n       \"multiReleaseJarVersion\" : \"13\",\n       \"checkstyle\" : \"org.graalvm.compiler.graph\",\n-      \"javaCompliance\" : \"13+\",\n+      \"javaCompliance\" : \"13..14\",\n       \"workingSets\" : \"Graal,HotSpot\",\n     },\n "
  },
  {
    "sha": "9d360ce59d0b015f21952159be8e7fbe487599ed",
    "filename": "compiler/src/org.graalvm.compiler.api.directives/src/org/graalvm/compiler/api/directives/GraalDirectives.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.api.directives/src/org/graalvm/compiler/api/directives/GraalDirectives.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.api.directives/src/org/graalvm/compiler/api/directives/GraalDirectives.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.api.directives/src/org/graalvm/compiler/api/directives/GraalDirectives.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -94,6 +94,14 @@ public static void sideEffect() {\n \n     }\n \n+    /**\n+     * Inject information into the compiler to assume that the input is an object created via a\n+     * primitive boxing operation.\n+     */\n+    public static <P> P trustedBox(P o) {\n+        return o;\n+    }\n+\n     /**\n      * A call to this method will force the compiler to assume this instruction has a visible memory\n      * effect killing all memory locations."
  },
  {
    "sha": "62fde941601baffcd92315cbbbd4f6bf98b6c708",
    "filename": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/spi/JavaConstantFieldProvider.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/spi/JavaConstantFieldProvider.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/spi/JavaConstantFieldProvider.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/spi/JavaConstantFieldProvider.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -119,6 +119,9 @@ protected boolean isFinalFieldValueConstant(ResolvedJavaField field, JavaConstan\n \n     @SuppressWarnings(\"unused\")\n     protected boolean isStableField(ResolvedJavaField field, ConstantFieldTool<?> tool) {\n+        if (isPrimitiveBoxingCacheField(field)) {\n+            return true;\n+        }\n         if (isSyntheticEnumSwitchMap(field)) {\n             return true;\n         }\n@@ -131,6 +134,18 @@ protected boolean isStableField(ResolvedJavaField field, ConstantFieldTool<?> to\n         return false;\n     }\n \n+    protected boolean isPrimitiveBoxingCacheField(ResolvedJavaField field) {\n+        if (isArray(field) && field.isFinal() && field.getName().equals(\"cache\")) {\n+            ResolvedJavaType type = field.getDeclaringClass();\n+            String typeName = type.getName();\n+            if (typeName.equals(\"Ljava/lang/Character$CharacterCache;\") || typeName.equals(\"Ljava/lang/Byte$ByteCache;\") || typeName.equals(\"Ljava/lang/Short$ShortCache;\") ||\n+                            typeName.equals(\"Ljava/lang/Integer$IntegerCache;\") || typeName.equals(\"Ljava/lang/Long$LongCache;\")) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     protected boolean isDefaultStableField(ResolvedJavaField field, ConstantFieldTool<?> tool) {\n         assert isStableField(field, tool);\n         if (isSyntheticEnumSwitchMap(field)) {"
  },
  {
    "sha": "9ca3198f4abf9b8700b733c20d5ab50013263101",
    "filename": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/OptimizedBoxNodeTest.java",
    "status": "modified",
    "additions": 118,
    "deletions": 32,
    "changes": 150,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/OptimizedBoxNodeTest.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/OptimizedBoxNodeTest.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/OptimizedBoxNodeTest.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -26,13 +26,19 @@\n \n import java.util.ArrayList;\n \n+import org.graalvm.compiler.api.directives.GraalDirectives;\n+import org.graalvm.compiler.loop.phases.LoopFullUnrollPhase;\n+import org.graalvm.compiler.nodes.IfNode;\n import org.graalvm.compiler.nodes.StructuredGraph;\n import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n import org.graalvm.compiler.nodes.extended.BoxNode;\n+import org.graalvm.compiler.nodes.loop.DefaultLoopPolicies;\n import org.graalvm.compiler.options.OptionValues;\n import org.graalvm.compiler.phases.common.BoxNodeOptimizationPhase;\n+import org.graalvm.compiler.phases.common.CanonicalizerPhase;\n import org.graalvm.compiler.phases.util.GraphOrder;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n import jdk.vm.ci.code.InstalledCode;\n@@ -56,7 +62,7 @@ public static Integer boxStructural2(Object o) {\n         // unbox here dominates box below\n         int i = (Integer) o;\n         S = o;\n-        // box again with optimized box\n+        // re-use unbox\n         return i;\n     }\n \n@@ -70,23 +76,27 @@ public static Integer boxStructural3(int i) {\n \n     @Test\n     public void testStructure() {\n-        parseOptimizeCheck(\"boxStructural1\", 2, 0);\n-        parseOptimizeCheck(\"boxStructural2\", 1, 0);\n-        parseOptimizeCheck(\"boxStructural3\", 0, 1);\n+        // can re-use one dominating box node\n+        parseOptimizeCheck(\"boxStructural1\", 1);\n+        // can do nothing, the unbox input is a parameter which might not be from valueOf\n+        // path\n+        parseOptimizeCheck(\"boxStructural2\", 1);\n+        // can remove second box\n+        parseOptimizeCheck(\"boxStructural3\", 1);\n     }\n \n-    private void parseOptimizeCheck(String boxSnippet, int nrOptimizedAfter, int nrBoxAfter) {\n-        StructuredGraph g = parseEager(getResolvedJavaMethod(boxSnippet), AllowAssumptions.NO);\n-        createCanonicalizerPhase().apply(g, getDefaultHighTierContext());\n+    private void parseOptimizeCheck(String boxSnippet, int nrBoxAfter) {\n+        StructuredGraph g = parseEager(getResolvedJavaMethod(boxSnippet), AllowAssumptions.NO, getInitialOptions());\n+        CanonicalizerPhase.create().apply(g, getDefaultHighTierContext());\n         new BoxNodeOptimizationPhase().apply(g, getDefaultHighTierContext());\n         Assert.assertTrue(GraphOrder.assertNonCyclicGraph(g));\n-        Assert.assertEquals(\"expected number optimized box nodes\", nrOptimizedAfter, g.getNodes().filter(BoxNode.OptimizedAllocatingBoxNode.class).count());\n-        Assert.assertEquals(\"expected number of regular box nodes\", nrBoxAfter + nrOptimizedAfter, g.getNodes().filter(BoxNode.class).count());\n+        Assert.assertEquals(\"expected number of regular box nodes\", nrBoxAfter, g.getNodes().filter(BoxNode.class).count());\n     }\n \n     public static Integer intBoxOptimized(Object o) {\n-        int i = (Integer) o;\n-        S = o;\n+        Integer trusted = GraalDirectives.trustedBox((Integer) GraalDirectives.guardingNonNull(o));\n+        int i = trusted;\n+        S = trusted;\n         // box again, reuse if existing\n         return i;\n     }\n@@ -104,8 +114,9 @@ public Object produceBox(int i) {\n     }\n \n     public static Long longBoxOptimized(Object o) {\n-        long i = (Long) o;\n-        S = o;\n+        Long trusted = GraalDirectives.trustedBox((Long) GraalDirectives.guardingNonNull(o));\n+        long i = trusted;\n+        S = trusted;\n         // box again, reuse if existing\n         return i;\n     }\n@@ -123,8 +134,9 @@ public Object produceBox(int i) {\n     }\n \n     public static Short shortBoxOptimized(Object o) {\n-        short i = (Short) o;\n-        S = o;\n+        Short trusted = GraalDirectives.trustedBox((Short) GraalDirectives.guardingNonNull(o));\n+        short i = trusted;\n+        S = trusted;\n         // box again, reuse if existing\n         return i;\n     }\n@@ -142,8 +154,9 @@ public Object produceBox(int i) {\n     }\n \n     public static Character charBoxOptimized(Object o) {\n-        char i = (char) o;\n-        S = o;\n+        Character trusted = GraalDirectives.trustedBox((Character) GraalDirectives.guardingNonNull(o));\n+        char i = trusted;\n+        S = trusted;\n         // box again, reuse if existing\n         return i;\n     }\n@@ -165,6 +178,12 @@ public Object produceBox(int i) {\n         Object produceBox(int i);\n     }\n \n+    private InstalledCode compileWithBoxOptimizationPhase(String snippet) {\n+        StructuredGraph g = parseEager(getResolvedJavaMethod(snippet), AllowAssumptions.YES, getInitialOptions());\n+        InstalledCode i = getCode(getResolvedJavaMethod(snippet), g);\n+        return i;\n+    }\n+\n     public void testType(String typePrefix, int lowBound, int highBound, BoxProducer producer, long cacheLow, long cacheHigh) throws InvalidInstalledCodeException {\n         final int listLength = Math.abs(lowBound) + highBound;\n         ArrayList<Object> integersInterpreter = new ArrayList<>();\n@@ -174,8 +193,7 @@ public void testType(String typePrefix, int lowBound, int highBound, BoxProducer\n             integersInterpreter.add(boxed);\n         }\n \n-        InstalledCode codeReuseExistingBox = getCode(getResolvedJavaMethod(typePrefix + \"BoxOptimized\"),\n-                        new OptionValues(getInitialOptions(), BoxNodeOptimizationPhase.Options.ReuseOutOfCacheBoxedValues, true));\n+        InstalledCode codeReuseExistingBox = compileWithBoxOptimizationPhase(typePrefix + \"BoxOptimized\");\n         ArrayList<Object> integersReuse = new ArrayList<>();\n         for (int i = -listLength; i < listLength; i++) {\n             Object boxed = integersInterpreter.get(i + listLength);\n@@ -185,19 +203,9 @@ public void testType(String typePrefix, int lowBound, int highBound, BoxProducer\n \n         resetCache();\n \n-        ArrayList<Object> integersNoReuse = new ArrayList<>();\n-        InstalledCode codeNoReuse = getCode(getResolvedJavaMethod(typePrefix + \"BoxOptimized\"),\n-                        new OptionValues(getInitialOptions(), BoxNodeOptimizationPhase.Options.ReuseOutOfCacheBoxedValues, false));\n-        for (int i = -listLength; i < listLength; i++) {\n-            Object boxed = integersInterpreter.get(i + listLength);\n-            // cache values in range, re-use if out of range\n-            integersNoReuse.add(codeNoReuse.executeVarargs(boxed));\n-        }\n-\n         for (int i = 0; i < integersInterpreter.size(); i++) {\n             Object interpreterObject = integersInterpreter.get(i);\n             Object objectReuse = integersReuse.get(i);\n-            Object objectNoReuse = integersNoReuse.get(i);\n             long originalVal;\n             if (interpreterObject instanceof Character) {\n                 originalVal = ((Character) interpreterObject);\n@@ -208,14 +216,92 @@ public void testType(String typePrefix, int lowBound, int highBound, BoxProducer\n             if (originalVal >= cacheLow && originalVal <= cacheHigh) {\n                 // in cache, all must be the same objects\n                 Assert.assertTrue(\"val=\" + originalVal + \" optimized version must remain cached object identities\", interpreterObject == objectReuse);\n-                Assert.assertTrue(\"val=\" + originalVal + \" unoptimized version must remain cached object identities\", interpreterObject == objectNoReuse);\n             } else {\n-                Assert.assertTrue(\"val=\" + originalVal + \" out of cache, unoptimized version must not reuse the argument from the call and thus be different than the interpreter object\",\n-                                interpreterObject != objectNoReuse);\n                 Assert.assertTrue(\"val=\" + originalVal + \" out of cache, optimized version must re-use the argument from the call and thus be the same as the interpreter object\",\n                                 interpreterObject == objectReuse);\n             }\n         }\n+    }\n+\n+    static int snippetConstantCompare(int a) {\n+        int res = a;\n+        for (int i = -200; i < 200; i++) {\n+            if (a(i) == b(i + 1)) {\n+                GraalDirectives.sideEffect(1);\n+                res = i;\n+            }\n+            GraalDirectives.sideEffect(123);\n+        }\n+        GraalDirectives.sideEffect(2);\n+        return res;\n+    }\n+\n+    static Integer a(int i) {\n+        GraalDirectives.sideEffect(3);\n+        return Integer.valueOf(i);\n+    }\n+\n+    static Integer b(int i) {\n+        GraalDirectives.sideEffect(4);\n+        return Integer.valueOf(i);\n+    }\n+\n+    @Test\n+    public void testCompare() throws InvalidInstalledCodeException {\n+        final OptionValues testOptions = new OptionValues(getInitialOptions(), DefaultLoopPolicies.Options.FullUnrollMaxNodes, 10000, DefaultLoopPolicies.Options.ExactFullUnrollMaxNodes, 10000);\n+        StructuredGraph g = parseEager(getResolvedJavaMethod(\"snippetConstantCompare\"), AllowAssumptions.NO, testOptions);\n+        CanonicalizerPhase.create().apply(g, getDefaultHighTierContext());\n+        new LoopFullUnrollPhase(createCanonicalizerPhase(), new DefaultLoopPolicies()).apply(g, getDefaultHighTierContext());\n+        CanonicalizerPhase.create().apply(g, getDefaultHighTierContext());\n+        Assert.assertEquals(\"All ifs must be removed\", 0, g.getNodes(IfNode.TYPE).count());\n+        int[] res = new int[200 * 2];\n+        int[] resCompiled = new int[200 * 2];\n+        for (int i = -200; i < 200; i++) {\n+            res[i + 200] = snippetConstantCompare(i);\n+        }\n+        InstalledCode code = getCode(getResolvedJavaMethod(\"snippetConstantCompare\"), testOptions);\n+        for (int i = -200; i < 200; i++) {\n+            resCompiled[i + 200] = (int) code.executeVarargs(i);\n+        }\n+        Assert.assertArrayEquals(res, resCompiled);\n+    }\n+\n+    static int testPEASnippet() {\n+        if (Integer.valueOf(1024) == Integer.valueOf(1024)) {\n+            return 0;\n+        }\n+        return 1;\n+    }\n+\n+    @Test\n+    @Ignore\n+    public void testPEA() {\n+        test(\"testPEASnippet\");\n+    }\n \n+    static Integer testNonBoxInput(Integer integer) {\n+        int i = integer;\n+        return Integer.valueOf(i);\n     }\n+\n+    @Test\n+    @SuppressWarnings(\"deprecation\")\n+    public void testBoxCanon() throws InvalidInstalledCodeException {\n+        final Integer nonCacheZero = new Integer(0);\n+\n+        final Integer resultInterpreter = testNonBoxInput(nonCacheZero);\n+\n+        InstalledCode codeNoReuse = getCode(getResolvedJavaMethod(\"testNonBoxInput\"), getInitialOptions());\n+\n+        final Integer resultGraal = (Integer) codeNoReuse.executeVarargs(nonCacheZero);\n+\n+        if (nonCacheZero == resultInterpreter) {\n+            Assert.assertEquals(\"Objects must be the same\", nonCacheZero, resultGraal);\n+        } else {\n+            if (nonCacheZero == resultGraal) {\n+                Assert.fail(\"Objects must not be the same ctor=\" + System.identityHashCode(nonCacheZero) + \" boxResult=\" + System.identityHashCode(resultGraal));\n+            }\n+        }\n+    }\n+\n }"
  },
  {
    "sha": "c347f69f30894a652d4133bdf0769940eaacfbc5",
    "filename": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest2.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest2.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest2.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/inlining/NestedLoopEffectsPhaseComplexityTest2.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -173,7 +173,7 @@ public void testNoNewAllocationsEnsureVirtualized() {\n          * 2 remaining allocations = 1 times the >= depth level allocation of a and one allocations\n          * of b inside\n          */\n-        testAndTimeFixedDepth(\"method20LevelNoNewAllocationsEnsureVirtualized\", 1);\n+        testAndTimeFixedDepth(\"method20LevelNoNewAllocationsEnsureVirtualized\", 2);\n     }\n \n     /**"
  },
  {
    "sha": "5f95dad366fdb872cf2f2686aa5084a183826680",
    "filename": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/CEOptimization.java",
    "status": "modified",
    "additions": 2,
    "deletions": 3,
    "changes": 5,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/CEOptimization.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/CEOptimization.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/phases/CEOptimization.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -284,10 +284,9 @@\n      * phase tries to re-use dominating boxed/unboxed values to avoid repetitive boxing while it\n      * respects the caching behavior specified by {@link Integer#valueOf(int)}.\n      *\n-     * This phase is enabled by default and can be disabled with\n-     * {@link org.graalvm.compiler.phases.common.BoxNodeOptimizationPhase.Options#ReuseOutOfCacheBoxedValues}.\n+     * This phase is enabled by default.\n      */\n-    BoxNodeOptimization(BoxNodeOptimizationPhase.Options.ReuseOutOfCacheBoxedValues, BoxNodeOptimizationPhase.class);\n+    BoxNodeOptimization(null, BoxNodeOptimizationPhase.class);\n \n     private final OptionKey<?> option;\n     private final Class<? extends BasePhase<?>> optimization;"
  },
  {
    "sha": "10c5c16ecc367fba4c864c590b06d7113491ad08",
    "filename": "compiler/src/org.graalvm.compiler.hotspot.jdk15/src/org/graalvm/compiler/hotspot/HotSpotGraalServices.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot.jdk15/src/org/graalvm/compiler/hotspot/HotSpotGraalServices.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot.jdk15/src/org/graalvm/compiler/hotspot/HotSpotGraalServices.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot.jdk15/src/org/graalvm/compiler/hotspot/HotSpotGraalServices.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -34,7 +34,7 @@\n import jdk.vm.ci.services.Services;\n \n /**\n- * JDK 15 version of {@code HotSpotGraalServices}.\n+ * JDK 15+ version of {@code HotSpotGraalServices}.\n  */\n public class HotSpotGraalServices {\n "
  },
  {
    "sha": "26b532f9e27dd43f5cbf8b875717a6417a756f16",
    "filename": "compiler/src/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/HotSpotInvokeJavaMethodTest.java",
    "status": "modified",
    "additions": 0,
    "deletions": 43,
    "changes": 43,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/HotSpotInvokeJavaMethodTest.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/HotSpotInvokeJavaMethodTest.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/HotSpotInvokeJavaMethodTest.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -32,7 +32,6 @@\n import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;\n import org.junit.Assume;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n import jdk.vm.ci.meta.JavaKind;\n@@ -90,22 +89,6 @@ public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Inv\n                 return true;\n             }\n         }, HotSpotInvokeJavaMethodTest.class, \"longReturnsLong\", long.class);\n-        invocationPlugins.register(new InvocationPlugin() {\n-            @Override\n-            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg) {\n-                ForeignCallNode node = new ForeignCallNode(HotSpotHostForeignCallsProvider.TestForeignCalls.FLOAT_RETURNS_FLOAT, arg);\n-                b.addPush(JavaKind.Float, node);\n-                return true;\n-            }\n-        }, HotSpotInvokeJavaMethodTest.class, \"floatReturnsFloat\", float.class);\n-        invocationPlugins.register(new InvocationPlugin() {\n-            @Override\n-            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg) {\n-                ForeignCallNode node = new ForeignCallNode(HotSpotHostForeignCallsProvider.TestForeignCalls.DOUBLE_RETURNS_DOUBLE, arg);\n-                b.addPush(JavaKind.Double, node);\n-                return true;\n-            }\n-        }, HotSpotInvokeJavaMethodTest.class, \"doubleReturnsDouble\", double.class);\n         invocationPlugins.register(new InvocationPlugin() {\n             @Override\n             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode arg) {\n@@ -235,32 +218,6 @@ public static float floatReturnsFloatSnippet(float arg) {\n         return floatReturnsFloat(arg);\n     }\n \n-    @Test\n-    @Ignore // currently failing on JDK 16\n-    public void testFloatReturnsFloat() {\n-        for (float value : floatValues) {\n-            test(\"floatReturnsFloatSnippet\", value);\n-        }\n-    }\n-\n-    static double[] doubleValues = new double[]{Double.MAX_VALUE, -1, 0, 1, Double.MIN_VALUE};\n-\n-    static double doubleReturnsDouble(double arg) {\n-        return arg;\n-    }\n-\n-    public static double doubleReturnsDoubleSnippet(double arg) {\n-        return doubleReturnsDouble(arg);\n-    }\n-\n-    @Test\n-    @Ignore // currently failing on JDK 16\n-    public void testDoubleReturnsDouble() {\n-        for (double value : doubleValues) {\n-            test(\"doubleReturnsDoubleSnippet\", value);\n-        }\n-    }\n-\n     static Object[] objectValues = new Object[]{null, \"String\", Integer.valueOf(-1)};\n \n     static Object objectReturnsObject(Object arg) {"
  },
  {
    "sha": "93bce7486f34b550152b96cd9c83de47c22e6f50",
    "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -213,7 +213,9 @@ public void invokeJavaMethodStub(OptionValues options,\n         HotSpotForeignCallLinkage targetLinkage = stub.getTargetLinkage();\n         linkage.setCompiledStub(stub);\n         register(linkage);\n-        register(targetLinkage);\n+        if (!foreignCalls.containsKey(targetLinkage.getDescriptor().getSignature())) {\n+            register(targetLinkage);\n+        }\n     }\n \n     public static final boolean PREPEND_THREAD = true;"
  },
  {
    "sha": "b6399e12cbcfd8c848847bef692c5514eb7c2564",
    "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java",
    "status": "modified",
    "additions": 3,
    "deletions": 12,
    "changes": 15,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -152,6 +152,9 @@\n     public static final HotSpotForeignCallDescriptor NOTIFY = new HotSpotForeignCallDescriptor(LEAF_NO_VZERO, NOT_REEXECUTABLE, any(), \"object_notify\", boolean.class, Object.class);\n     public static final HotSpotForeignCallDescriptor NOTIFY_ALL = new HotSpotForeignCallDescriptor(LEAF_NO_VZERO, NOT_REEXECUTABLE, any(), \"object_notifyAll\", boolean.class, Object.class);\n \n+    public static final HotSpotForeignCallDescriptor INVOKE_STATIC_METHOD_ONE_ARG = new HotSpotForeignCallDescriptor(SAFEPOINT, REEXECUTABLE, NO_LOCATIONS,\n+                    \"JVMCIRuntime::invoke_static_method_one_arg\", long.class, Word.class, Word.class, long.class);\n+\n     public static class TestForeignCalls {\n         public static final HotSpotForeignCallDescriptor BOOLEAN_RETURNS_BOOLEAN = new HotSpotForeignCallDescriptor(SAFEPOINT, REEXECUTABLE, NO_LOCATIONS, \"boolean returns boolean\",\n                         Boolean.TYPE, Boolean.TYPE);\n@@ -196,14 +199,6 @@ static long longReturnsLong(long arg) {\n             return arg;\n         }\n \n-        static float floatReturnsFloat(float arg) {\n-            return arg;\n-        }\n-\n-        static double doubleReturnsDouble(double arg) {\n-            return arg;\n-        }\n-\n         static Object objectReturnsObject(Object arg) {\n             return arg;\n         }\n@@ -280,10 +275,6 @@ private boolean registerStubCallFunctions(OptionValues options, HotSpotProviders\n         invokeJavaMethodStub(options, providers, TestForeignCalls.INT_RETURNS_INT, config.invokeJavaMethodAddress, intReturnsInt);\n         ResolvedJavaMethod longReturnsLong = SnippetTemplate.AbstractTemplates.findMethod(providers.getMetaAccess(), TestForeignCalls.class, \"longReturnsLong\");\n         invokeJavaMethodStub(options, providers, TestForeignCalls.LONG_RETURNS_LONG, config.invokeJavaMethodAddress, longReturnsLong);\n-        ResolvedJavaMethod floatReturnsFloat = SnippetTemplate.AbstractTemplates.findMethod(providers.getMetaAccess(), TestForeignCalls.class, \"floatReturnsFloat\");\n-        invokeJavaMethodStub(options, providers, TestForeignCalls.FLOAT_RETURNS_FLOAT, config.invokeJavaMethodAddress, floatReturnsFloat);\n-        ResolvedJavaMethod doubleReturnsDouble = SnippetTemplate.AbstractTemplates.findMethod(providers.getMetaAccess(), TestForeignCalls.class, \"doubleReturnsDouble\");\n-        invokeJavaMethodStub(options, providers, TestForeignCalls.DOUBLE_RETURNS_DOUBLE, config.invokeJavaMethodAddress, doubleReturnsDouble);\n         ResolvedJavaMethod objectReturnsObject = SnippetTemplate.AbstractTemplates.findMethod(providers.getMetaAccess(), TestForeignCalls.class, \"objectReturnsObject\");\n         invokeJavaMethodStub(options, providers, TestForeignCalls.OBJECT_RETURNS_OBJECT, config.invokeJavaMethodAddress, objectReturnsObject);\n "
  },
  {
    "sha": "49fab75cac2b5133bcc1574b75b179885d82a428",
    "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/AbstractForeignCallStub.java",
    "status": "modified",
    "additions": 4,
    "deletions": 7,
    "changes": 11,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/AbstractForeignCallStub.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/AbstractForeignCallStub.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/AbstractForeignCallStub.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -46,7 +46,6 @@\n import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallDescriptor.Transition;\n import org.graalvm.compiler.hotspot.meta.HotSpotLoweringProvider;\n import org.graalvm.compiler.hotspot.meta.HotSpotProviders;\n-import org.graalvm.compiler.hotspot.nodes.StubForeignCallNode;\n import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets.Templates;\n import org.graalvm.compiler.nodes.InvokeNode;\n import org.graalvm.compiler.nodes.ParameterNode;\n@@ -105,22 +104,20 @@ public AbstractForeignCallStub(OptionValues options, HotSpotJVMCIRuntime runtime\n         this.jvmciRuntime = runtime;\n         this.prependThread = prependThread;\n         MetaAccessProvider metaAccess = providers.getMetaAccess();\n-        Class<?>[] targetParameterTypes = createTargetParameters(descriptor);\n-        HotSpotForeignCallDescriptor targetSig = new HotSpotForeignCallDescriptor(descriptor.getTransition(), descriptor.getReexecutability(), descriptor.getKilledLocations(),\n-                        descriptor.getName() + \":C\", descriptor.getResultType(), targetParameterTypes);\n+        HotSpotForeignCallDescriptor targetSig = getTargetSignature(descriptor);\n         target = HotSpotForeignCallLinkageImpl.create(metaAccess, providers.getCodeCache(), providers.getWordTypes(), providers.getForeignCalls(), targetSig, address,\n                         DESTROYS_ALL_CALLER_SAVE_REGISTERS, NativeCall, NativeCall);\n     }\n \n+    protected abstract HotSpotForeignCallDescriptor getTargetSignature(HotSpotForeignCallDescriptor descriptor);\n+\n     /**\n      * Gets the linkage information for the call from this stub.\n      */\n     public final HotSpotForeignCallLinkage getTargetLinkage() {\n         return target;\n     }\n \n-    protected abstract Class<?>[] createTargetParameters(ForeignCallDescriptor descriptor);\n-\n     @Override\n     protected final ResolvedJavaMethod getInstalledCodeOwner() {\n         return null;\n@@ -286,5 +283,5 @@ private ResolvedJavaMethod getGraphMethod() {\n         return params;\n     }\n \n-    protected abstract StubForeignCallNode createTargetCall(GraphKit kit, ReadRegisterNode thread);\n+    protected abstract ValueNode createTargetCall(GraphKit kit, ReadRegisterNode thread);\n }"
  },
  {
    "sha": "58c16a91aef9ddebba63ced26cc423f88ccd9c0e",
    "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java",
    "status": "modified",
    "additions": 9,
    "deletions": 2,
    "changes": 11,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -66,7 +66,14 @@ public ForeignCallStub(OptionValues options, HotSpotJVMCIRuntime runtime, HotSpo\n     }\n \n     @Override\n-    protected Class<?>[] createTargetParameters(ForeignCallDescriptor descriptor) {\n+    protected HotSpotForeignCallDescriptor getTargetSignature(HotSpotForeignCallDescriptor descriptor) {\n+        Class<?>[] targetParameterTypes = createTargetParameters(descriptor);\n+        HotSpotForeignCallDescriptor targetSig = new HotSpotForeignCallDescriptor(descriptor.getTransition(), descriptor.getReexecutability(), descriptor.getKilledLocations(),\n+                        descriptor.getName() + \":C\", descriptor.getResultType(), targetParameterTypes);\n+        return targetSig;\n+    }\n+\n+    private Class<?>[] createTargetParameters(ForeignCallDescriptor descriptor) {\n         Class<?>[] parameters = descriptor.getArgumentTypes();\n         if (prependThread) {\n             Class<?>[] newParameters = new Class<?>[parameters.length + 1];\n@@ -88,7 +95,7 @@ protected boolean shouldClearException() {\n     }\n \n     @Override\n-    protected StubForeignCallNode createTargetCall(GraphKit kit, ReadRegisterNode thread) {\n+    protected ValueNode createTargetCall(GraphKit kit, ReadRegisterNode thread) {\n         ParameterNode[] params = createParameters(kit);\n         Stamp stamp = StampFactory.forKind(JavaKind.fromJavaClass(target.getDescriptor().getResultType()));\n         if (prependThread) {"
  },
  {
    "sha": "dca66041825ee616302d2acb81075e9022857b6d",
    "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/InvokeJavaMethodStub.java",
    "status": "modified",
    "additions": 12,
    "deletions": 8,
    "changes": 20,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/InvokeJavaMethodStub.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/InvokeJavaMethodStub.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/InvokeJavaMethodStub.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -25,13 +25,14 @@\n package org.graalvm.compiler.hotspot.stubs;\n \n import static org.graalvm.compiler.core.common.type.PrimitiveStamp.getBits;\n+import static org.graalvm.compiler.hotspot.meta.HotSpotHostForeignCallsProvider.INVOKE_STATIC_METHOD_ONE_ARG;\n \n-import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;\n import org.graalvm.compiler.core.common.type.FloatStamp;\n import org.graalvm.compiler.core.common.type.ObjectStamp;\n import org.graalvm.compiler.core.common.type.PrimitiveStamp;\n import org.graalvm.compiler.core.common.type.Stamp;\n import org.graalvm.compiler.core.common.type.StampFactory;\n+import org.graalvm.compiler.debug.GraalError;\n import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallDescriptor;\n import org.graalvm.compiler.hotspot.meta.HotSpotProviders;\n import org.graalvm.compiler.hotspot.nodes.StubForeignCallNode;\n@@ -44,7 +45,6 @@\n import org.graalvm.compiler.options.OptionValues;\n import org.graalvm.compiler.replacements.GraphKit;\n import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;\n-import org.graalvm.compiler.word.Word;\n import org.graalvm.compiler.word.WordCastNode;\n \n import jdk.vm.ci.code.site.ConstantReference;\n@@ -72,11 +72,14 @@ public InvokeJavaMethodStub(OptionValues options, HotSpotJVMCIRuntime runtime, H\n                     ResolvedJavaMethod staticMethod) {\n         super(options, runtime, providers, address, descriptor, true);\n         this.javaMethod = staticMethod;\n+        // This stub is compiled to kill no registers which interferes with returning float and\n+        // double through a long. For simplicity disallow that case until it's required.\n+        GraalError.guarantee(!javaMethod.getSignature().getReturnKind().isNumericFloat(), \"float/double returns don't work with register save/restore logic: %s\", javaMethod);\n     }\n \n     @Override\n-    protected Class<?>[] createTargetParameters(ForeignCallDescriptor descriptor) {\n-        return new Class<?>[]{Word.class, Word.class, Long.TYPE};\n+    protected HotSpotForeignCallDescriptor getTargetSignature(HotSpotForeignCallDescriptor descriptor) {\n+        return INVOKE_STATIC_METHOD_ONE_ARG;\n     }\n \n     @Override\n@@ -90,8 +93,7 @@ protected boolean shouldClearException() {\n     }\n \n     @Override\n-    protected StubForeignCallNode createTargetCall(GraphKit kit, ReadRegisterNode thread) {\n-        Stamp stamp = StampFactory.forKind(javaMethod.getSignature().getReturnKind());\n+    protected ValueNode createTargetCall(GraphKit kit, ReadRegisterNode thread) {\n         ParameterNode[] params = createParameters(kit);\n         ValueNode[] targetArguments = new ValueNode[2 + params.length];\n         targetArguments[0] = thread;\n@@ -119,8 +121,10 @@ protected StubForeignCallNode createTargetCall(GraphKit kit, ReadRegisterNode th\n             }\n             targetArguments[2] = value;\n         }\n-\n-        return kit.append(new StubForeignCallNode(providers.getForeignCalls(), stamp, target.getDescriptor(), targetArguments));\n+        assert INVOKE_STATIC_METHOD_ONE_ARG.getResultType() == long.class;\n+        Stamp returnStamp = StampFactory.forKind(JavaKind.Long);\n+        ValueNode result = kit.append(new StubForeignCallNode(providers.getForeignCalls(), returnStamp, INVOKE_STATIC_METHOD_ONE_ARG, targetArguments));\n+        return result;\n     }\n \n     @Override"
  },
  {
    "sha": "e9d1e17947c0b4cc286f2549d33e55fae18b7dee",
    "filename": "compiler/src/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -1607,7 +1607,8 @@ public AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean\n     }\n \n     protected ValueNode genArrayLength(ValueNode x) {\n-        return ArrayLengthNode.create(x, getConstantReflection());\n+        ValueNode array = maybeEmitExplicitNullCheck(x);\n+        return ArrayLengthNode.create(array, getConstantReflection());\n     }\n \n     protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {\n@@ -5442,7 +5443,7 @@ public final void processBytecode(int bci, int opcode) {\n     }\n \n     private void genArrayLength() {\n-        ValueNode array = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));\n+        ValueNode array = frameState.pop(JavaKind.Object);\n         frameState.push(JavaKind.Int, append(genArrayLength(array)));\n     }\n "
  },
  {
    "sha": "c413c152945d04f01ae1e8404646ddcd85f15aba",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/MergeNode.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/MergeNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/MergeNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/MergeNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -45,8 +45,8 @@ public static void removeMergeIfDegenerated(MergeNode node) {\n             node.setNext(null);\n             EndNode forwardEnd = node.forwardEndAt(0);\n             forwardEnd.replaceAtPredecessor(currentNext);\n-            node.markDeleted();\n-            forwardEnd.markDeleted();\n+            node.safeDelete();\n+            forwardEnd.safeDelete();\n         }\n     }\n "
  },
  {
    "sha": "c9f36b08720d672b0b8e4695bbddac6f22829930",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/PointerEqualsNode.java",
    "status": "modified",
    "additions": 21,
    "deletions": 3,
    "changes": 24,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/PointerEqualsNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/PointerEqualsNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/PointerEqualsNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -37,6 +37,7 @@\n import org.graalvm.compiler.nodes.LogicNode;\n import org.graalvm.compiler.nodes.NodeView;\n import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.extended.BoxNode;\n import org.graalvm.compiler.nodes.extended.LoadHubNode;\n import org.graalvm.compiler.nodes.extended.LoadMethodNode;\n import org.graalvm.compiler.nodes.type.StampTool;\n@@ -114,7 +115,8 @@ private static boolean isAlwaysFailingVirtualDispatchTest(CanonicalCondition con\n         }\n \n         @Override\n-        public LogicNode canonical(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth, CanonicalCondition condition,\n+        public LogicNode canonical(ConstantReflectionProvider constantReflection, MetaAccessProvider metaAccess, OptionValues options, Integer smallestCompareWidth,\n+                        CanonicalCondition condition,\n                         boolean unorderedIsTrue, ValueNode forX, ValueNode forY, NodeView view) {\n             LogicNode result = findSynonym(forX, forY, view);\n             if (result != null) {\n@@ -141,9 +143,25 @@ public static LogicNode findSynonym(ValueNode forX, ValueNode forY, NodeView vie\n             return nullSynonym(forY, forX);\n         } else if (forY.stamp(view) instanceof AbstractPointerStamp && ((AbstractPointerStamp) forY.stamp(view)).alwaysNull()) {\n             return nullSynonym(forX, forY);\n-        } else {\n-            return null;\n+        } else if (forX instanceof BoxNode && forY instanceof BoxNode) {\n+            /*\n+             * We have a fast path here for box comparisons of constants to avoid wasting time in\n+             * PEA / lowering later.\n+             */\n+            BoxNode boxX = (BoxNode) forX;\n+            BoxNode boxY = (BoxNode) forY;\n+            if (boxX.getValue().isConstant() && boxY.getValue().isConstant()) {\n+                if (boxX.getBoxingKind() != boxY.getBoxingKind()) {\n+                    return LogicConstantNode.contradiction();\n+                }\n+                if (boxX.getValue().asConstant().equals(boxY.getValue().asConstant())) {\n+                    return LogicConstantNode.tautology();\n+                } else {\n+                    return LogicConstantNode.contradiction();\n+                }\n+            }\n         }\n+        return null;\n     }\n \n     private static LogicNode nullSynonym(ValueNode nonNullValue, ValueNode nullValue) {"
  },
  {
    "sha": "efe0cbeb6f348a89ecebc26f6369758a6f722c04",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/BoxNode.java",
    "status": "modified",
    "additions": 60,
    "deletions": 23,
    "changes": 83,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/BoxNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/BoxNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/BoxNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -33,22 +33,29 @@\n import org.graalvm.compiler.core.common.type.StampFactory;\n import org.graalvm.compiler.core.common.type.TypeReference;\n import org.graalvm.compiler.graph.IterableNodeType;\n+import org.graalvm.compiler.graph.Node;\n+import org.graalvm.compiler.graph.Node.IndirectCanonicalization;\n import org.graalvm.compiler.graph.NodeClass;\n import org.graalvm.compiler.graph.spi.Canonicalizable;\n import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n import org.graalvm.compiler.nodeinfo.InputType;\n import org.graalvm.compiler.nodeinfo.NodeCycles;\n import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodeinfo.NodeSize;\n import org.graalvm.compiler.nodes.FieldLocationIdentity;\n import org.graalvm.compiler.nodes.NodeView;\n import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.FloatingNode;\n import org.graalvm.compiler.nodes.java.MonitorIdNode;\n import org.graalvm.compiler.nodes.memory.SingleMemoryKill;\n import org.graalvm.compiler.nodes.spi.Lowerable;\n+import org.graalvm.compiler.nodes.spi.LoweringTool;\n+import org.graalvm.compiler.nodes.spi.Virtualizable;\n import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;\n import org.graalvm.compiler.nodes.spi.VirtualizerTool;\n import org.graalvm.compiler.nodes.type.StampTool;\n import org.graalvm.compiler.nodes.virtual.VirtualBoxingNode;\n+import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;\n import org.graalvm.word.LocationIdentity;\n \n import jdk.vm.ci.meta.JavaKind;\n@@ -59,7 +66,7 @@\n  * methods in Integer, Long, etc.\n  */\n @NodeInfo(cycles = NodeCycles.CYCLES_8, size = SIZE_16, allowedUsageTypes = {InputType.Memory, InputType.Value})\n-public abstract class BoxNode extends AbstractBoxingNode implements IterableNodeType, VirtualizableAllocation, Lowerable, Canonicalizable.Unary<ValueNode> {\n+public abstract class BoxNode extends AbstractBoxingNode implements IterableNodeType, VirtualizableAllocation, Lowerable, Canonicalizable.Unary<ValueNode>, IndirectCanonicalization {\n \n     public static final NodeClass<BoxNode> TYPE = NodeClass.create(BoxNode.class);\n \n@@ -89,6 +96,22 @@ public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {\n         if (tool.allUsagesAvailable() && hasNoUsages()) {\n             return null;\n         }\n+        if (forValue instanceof UnboxNode) {\n+            UnboxNode unbox = (UnboxNode) forValue;\n+            if (unbox.getBoxingKind() == getBoxingKind()) {\n+                ValueNode unboxInput = unbox.getValue();\n+                // box goes through valueOf path\n+                if (unboxInput instanceof BoxNode) {\n+                    if (((BoxNode) unboxInput).getBoxingKind() == getBoxingKind()) {\n+                        return unboxInput;\n+                    }\n+                }\n+                // trusted to have taken the valueOf path\n+                if (unboxInput instanceof TrustedBoxedValue) {\n+                    return ((TrustedBoxedValue) unboxInput).getValue();\n+                }\n+            }\n+        }\n         return this;\n     }\n \n@@ -116,11 +139,6 @@ public void virtualize(VirtualizerTool tool) {\n         protected PureBoxNode(ValueNode value, ResolvedJavaType resultType, JavaKind boxingKind) {\n             super(TYPE, value, resultType, boxingKind);\n         }\n-\n-        @Override\n-        public BoxNode createOptimizedBox(ValueNode dominatingBoxedValue) {\n-            return this;\n-        }\n     }\n \n     @NodeInfo(cycles = NodeCycles.CYCLES_8, size = SIZE_8, allowedUsageTypes = {InputType.Memory, InputType.Value})\n@@ -147,32 +165,51 @@ public LocationIdentity getKilledLocationIdentity() {\n \n     }\n \n-    public BoxNode createOptimizedBox(ValueNode dominatingBoxedValue) {\n-        return new OptimizedAllocatingBoxNode(getValue(), dominatingBoxedValue, boxingKind, stamp(NodeView.DEFAULT), getLocationIdentity());\n-    }\n-\n-    @NodeInfo(cycles = NodeCycles.CYCLES_8, size = SIZE_8, allowedUsageTypes = {InputType.Memory, InputType.Value})\n-    public static class OptimizedAllocatingBoxNode extends AllocatingBoxNode implements SingleMemoryKill {\n-        public static final NodeClass<OptimizedAllocatingBoxNode> TYPE = NodeClass.create(OptimizedAllocatingBoxNode.class);\n-        @Input protected ValueNode dominatingBoxedValue;\n+    /**\n+     * This nodes wraps value nodes representing objects that are known (due to some external\n+     * knowledge injected into the compiler) to have been created by a call to\n+     * Integer/Long/Short/...#valueOf methods. Thus, the wrapped value is subject to primitive box\n+     * caching.\n+     */\n+    @NodeInfo(cycles = NodeCycles.CYCLES_IGNORED, size = NodeSize.SIZE_IGNORED)\n+    public static class TrustedBoxedValue extends FloatingNode implements Canonicalizable, Virtualizable, Lowerable {\n+        public static final NodeClass<TrustedBoxedValue> TYPE = NodeClass.create(TrustedBoxedValue.class);\n+\n+        @Input protected ValueNode value;\n+\n+        public TrustedBoxedValue(ValueNode value) {\n+            super(TYPE, value.stamp(NodeView.DEFAULT));\n+            this.value = value;\n+        }\n \n-        protected OptimizedAllocatingBoxNode(ValueNode value, ValueNode dominatingBoxedValue, JavaKind boxingKind, Stamp s, LocationIdentity location) {\n-            super(TYPE, value, boxingKind, s, location);\n-            this.dominatingBoxedValue = dominatingBoxedValue;\n+        public ValueNode getValue() {\n+            return value;\n         }\n \n-        public ValueNode getDominatingBoxedValue() {\n-            return dominatingBoxedValue;\n+        @Override\n+        public void lower(LoweringTool tool) {\n+            if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.MID_TIER) {\n+                replaceAtAllUsages(value, this);\n+            }\n         }\n \n         @Override\n-        public LocationIdentity getLocationIdentity() {\n-            return LocationIdentity.INIT_LOCATION;\n+        public Node canonical(CanonicalizerTool tool) {\n+            if (tool.allUsagesAvailable()) {\n+                if (hasNoUsages()) {\n+                    return value;\n+                }\n+            }\n+            return this;\n         }\n \n         @Override\n-        public LocationIdentity getKilledLocationIdentity() {\n-            return getLocationIdentity();\n+        public void virtualize(VirtualizerTool tool) {\n+            ValueNode alias = tool.getAlias(value);\n+            if (alias instanceof VirtualObjectNode) {\n+                tool.replaceWith(alias);\n+            }\n         }\n+\n     }\n }"
  },
  {
    "sha": "c0481c0c93f3ac9aba383e7e1b5332ffa15471c0",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java",
    "status": "modified",
    "additions": 8,
    "deletions": 6,
    "changes": 14,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/IntegerSwitchNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -607,12 +607,14 @@ private boolean tryOptimizeEnumSwitch(SimplifierTool tool) {\n         int newDefaultSuccessor = addNewSuccessor(defaultSuccessor(), newSuccessors);\n         double newDefaultProbability = keyProbabilities[keyProbabilities.length - 1];\n \n-        /*\n-         * We remove the array load, but we still need to preserve exception semantics by keeping\n-         * the bounds check. Fortunately the array length is a constant.\n-         */\n-        LogicNode boundsCheck = graph().unique(new IntegerBelowNode(newValue, ConstantNode.forInt(arrayLength, graph())));\n-        graph().addBeforeFixed(this, graph().add(new FixedGuardNode(boundsCheck, DeoptimizationReason.BoundsCheckException, DeoptimizationAction.InvalidateReprofile)));\n+        if (loadIndexed.getBoundsCheck() == null) {\n+            /*\n+             * We remove the array load, but we still need to preserve exception semantics by\n+             * keeping the bounds check. Fortunately the array length is a constant.\n+             */\n+            LogicNode boundsCheck = graph().unique(new IntegerBelowNode(newValue, ConstantNode.forInt(arrayLength, graph())));\n+            graph().addBeforeFixed(this, graph().add(new FixedGuardNode(boundsCheck, DeoptimizationReason.BoundsCheckException, DeoptimizationAction.InvalidateReprofile)));\n+        }\n \n         /*\n          * Build the low-level representation of the new switch keys and replace ourself with a new"
  },
  {
    "sha": "cae950f8f7679244d7bb522d1fd9e070b64a6f57",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnboxNode.java",
    "status": "modified",
    "additions": 17,
    "deletions": 4,
    "changes": 21,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnboxNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnboxNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/extended/UnboxNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -40,6 +40,7 @@\n import org.graalvm.compiler.nodes.spi.Virtualizable;\n import org.graalvm.compiler.nodes.spi.VirtualizerTool;\n import org.graalvm.compiler.nodes.type.StampTool;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;\n \n import jdk.vm.ci.meta.ConstantReflectionProvider;\n@@ -110,10 +111,22 @@ private static ValueNode findSynonym(MetaAccessProvider metaAccess, ConstantRefl\n             if (unboxed != null && unboxed.getJavaKind() == boxingKind) {\n                 return ConstantNode.forConstant(unboxed, metaAccess);\n             }\n-        } else if (forValue instanceof BoxNode) {\n-            BoxNode box = (BoxNode) forValue;\n-            if (boxingKind == box.getBoxingKind()) {\n-                return box.getValue();\n+        } else {\n+            ValueNode inputUnPi = GraphUtil.skipPi(forValue);\n+            if (inputUnPi instanceof BoxNode) {\n+                BoxNode box = (BoxNode) inputUnPi;\n+                if (boxingKind == box.getBoxingKind()) {\n+                    return box.getValue();\n+                }\n+            }\n+            // unproxify constant box (only do it for constants as they are leaf nodes and thus\n+            // outside a loop)\n+            ValueNode inputUnProxyify = GraphUtil.unproxify(forValue);\n+            if (inputUnProxyify instanceof BoxNode && ((BoxNode) inputUnProxyify).getValue().isConstant()) {\n+                BoxNode box = (BoxNode) inputUnProxyify;\n+                if (boxingKind == box.getBoxingKind()) {\n+                    return box.getValue();\n+                }\n             }\n         }\n         return null;"
  },
  {
    "sha": "40c3b0108e68abe2f5eba62d956019c6632bbcc7",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/LoadIndexedNode.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/LoadIndexedNode.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/LoadIndexedNode.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/LoadIndexedNode.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -152,6 +152,9 @@ public Node canonical(CanonicalizerTool tool) {\n         if (constant != null) {\n             return constant;\n         }\n+        if (tool.allUsagesAvailable() && hasNoUsages() && getBoundsCheck() != null) {\n+            return null;\n+        }\n         return this;\n     }\n "
  },
  {
    "sha": "3f79e1529d23456db80150e4e72aecd2ae938e7b",
    "filename": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/loop/DerivedOffsetInductionVariable.java",
    "status": "modified",
    "additions": 6,
    "deletions": 2,
    "changes": 8,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/loop/DerivedOffsetInductionVariable.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/loop/DerivedOffsetInductionVariable.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/loop/DerivedOffsetInductionVariable.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -54,10 +54,14 @@ public ValueNode getOffset() {\n \n     @Override\n     public Direction direction() {\n+        Direction baseDirection = base.direction();\n+        if (baseDirection == null) {\n+            return null;\n+        }\n         if (value instanceof SubNode && base.valueNode() == value.getY()) {\n-            return base.direction().opposite();\n+            return baseDirection.opposite();\n         }\n-        return base.direction();\n+        return baseDirection;\n     }\n \n     @Override"
  },
  {
    "sha": "f5bf5773a39ce65d579f8e4222a579e8a8cd8506",
    "filename": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/BoxNodeOptimizationPhase.java",
    "status": "modified",
    "additions": 42,
    "deletions": 167,
    "changes": 209,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/BoxNodeOptimizationPhase.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/BoxNodeOptimizationPhase.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/BoxNodeOptimizationPhase.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -24,181 +24,92 @@\n  */\n package org.graalvm.compiler.phases.common;\n \n-import static org.graalvm.compiler.options.OptionType.Debug;\n-\n-import java.util.EnumSet;\n-\n-import org.graalvm.compiler.core.common.GraalOptions;\n import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;\n import org.graalvm.compiler.debug.DebugContext;\n import org.graalvm.compiler.graph.Graph;\n import org.graalvm.compiler.graph.Node;\n-import org.graalvm.compiler.nodeinfo.InputType;\n-import org.graalvm.compiler.nodes.ConstantNode;\n import org.graalvm.compiler.nodes.FixedNode;\n import org.graalvm.compiler.nodes.StructuredGraph;\n import org.graalvm.compiler.nodes.ValueNode;\n-import org.graalvm.compiler.nodes.calc.FloatingNode;\n import org.graalvm.compiler.nodes.cfg.Block;\n import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;\n import org.graalvm.compiler.nodes.extended.BoxNode;\n-import org.graalvm.compiler.nodes.extended.BoxNode.OptimizedAllocatingBoxNode;\n-import org.graalvm.compiler.nodes.extended.UnboxNode;\n import org.graalvm.compiler.nodes.spi.CoreProviders;\n import org.graalvm.compiler.nodes.util.GraphUtil;\n-import org.graalvm.compiler.options.Option;\n-import org.graalvm.compiler.options.OptionKey;\n import org.graalvm.compiler.phases.BasePhase;\n \n-import jdk.vm.ci.meta.ConstantReflectionProvider;\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.JavaKind;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-\n /**\n- * Phase that tries to optimize Java boxing (auto-boxing of primitive values) operations.\n- *\n- * This phase performs two distinct optimizations that are grouped into one phase for simplicity.\n- *\n- * (PART 1) First Transformation: Box node canonicalization\n- *\n- * Perform canonicalization of box nodes before lowering. We do not perform box canonicalization\n- * directly in the node since we want virtualization of box nodes. Creating a boxed constant early\n- * on inhibits PEA so we do it after PEA but before lowering.\n- *\n- *\n- * (PART 2) Second Transformation: Out-of-cache boxed value reuse\n- *\n- * Try to replace box operations with dominating box/unbox values. There are two distinct cases\n- * covered in this phase (they are marked in the code of the phase below)\n- *\n- * PART 2.1:\n- *\n- * <pre>\n- * unboxedVal = unbox(a)\n- * ...\n- * boxedVal = box(unboxedVal)\n- * </pre>\n- *\n- * can be rewritten to\n- *\n- * <pre>\n- * unboxedVal = unbox(a)\n- * ...\n- * boxedVal;\n- * if (primitiveCacheHit(unboxedVal)) { // e.g. unboxed>=IntegerCache.low && unboxed <= IntegerCache.high\n- *     boxedVal = queryPrimitiveCache(unboxedVal); // e.g. Integer.valueOf(unboxedVal)\n- * } else {\n- *     boxedVal = a; // previously boxed value, no identity needed\n- * }\n- * </pre>\n- *\n- *\n+ * Try to replace box operations with dominating box operations.\n  *\n- * PART 2.2:\n+ * Consider the following code snippet:\n  *\n  * <pre>\n  * boxedVal1 = box(primitiveVal)\n  * ...\n  * boxedVal2 = box(primitiveVal)\n  * </pre>\n  *\n- * can be rewritten to (if the assignment to boxedVal1 dominates the assignment to boxedVal2)\n+ * which can be rewritten to (if the assignment to boxedVal1 dominates the assignment to boxedVal2)\n  *\n  * <pre>\n  * boxedVal1 = box(primitiveVal)\n  * ...\n  * boxedVal2 = boxedVal1;\n  * </pre>\n- *\n  */\n public class BoxNodeOptimizationPhase extends BasePhase<CoreProviders> {\n \n-    public static class Options {\n-        //@formatter:off\n-        @Option(help = \"\", type = Debug)\n-        public static final OptionKey<Boolean> ReuseOutOfCacheBoxedValues = new OptionKey<>(true);\n-        //@formatter:on\n-    }\n-\n-    public static final EnumSet<JavaKind> OptimizedBoxVersions = EnumSet.of(JavaKind.Int, JavaKind.Long, JavaKind.Char, JavaKind.Short);\n-\n     @Override\n     protected void run(StructuredGraph graph, CoreProviders context) {\n         ControlFlowGraph cfg = null;\n         Graph.Mark before = graph.getMark();\n         boxLoop: for (BoxNode box : graph.getNodes(BoxNode.TYPE)) {\n-            FloatingNode canonical = canonicalizeBoxing(box, context.getMetaAccess(), context.getConstantReflection());\n-            if (canonical != null) {\n-                // PART 1\n-                box.replaceAtUsages((ValueNode) box.getLastLocationAccess(), InputType.Memory);\n-                graph.replaceFixedWithFloating(box, canonical);\n-            }\n-            if (box.isAlive() && OptimizedBoxVersions.contains(box.getBoxingKind())) {\n-                // PART 2\n-                if (box instanceof OptimizedAllocatingBoxNode) {\n-                    continue;\n-                }\n-                if (Options.ReuseOutOfCacheBoxedValues.getValue(graph.getOptions())) {\n-                    final ValueNode boxedVal = box.getValue();\n-                    assert boxedVal != null : \"Box \" + box + \" has no value\";\n-                    // try to optimize with dominating unbox of the same value\n-                    if (boxedVal instanceof UnboxNode && ((UnboxNode) boxedVal).getBoxingKind() == box.getBoxingKind()) {\n-                        // PART 2.1\n-                        optimizeBoxed(box, ((UnboxNode) boxedVal).getValue());\n-                        continue boxLoop;\n+            if (box.isAlive()) {\n+                final ValueNode primitiveVal = box.getValue();\n+                assert primitiveVal != null : \"Box \" + box + \" has no value\";\n+                // try to optimize with dominating box of the same value\n+                boxedValUsageLoop: for (Node usage : primitiveVal.usages().snapshot()) {\n+                    if (usage == box) {\n+                        continue;\n                     }\n-                    // try to optimize with dominating box of the same value\n-                    if (box.isAlive()) {\n-                        // PART 2.2\n-                        boxedValUsageLoop: for (Node usage : boxedVal.usages().snapshot()) {\n-                            if (usage == box) {\n-                                continue;\n+                    if (usage instanceof BoxNode) {\n+                        final BoxNode boxUsageOnBoxedVal = (BoxNode) usage;\n+                        if (boxUsageOnBoxedVal.getBoxingKind() == box.getBoxingKind()) {\n+                            if (cfg == null) {\n+                                cfg = ControlFlowGraph.compute(graph, true, true, true, false);\n                             }\n-                            if (usage instanceof OptimizedAllocatingBoxNode) {\n-                                // already an optimized usage\n-                                continue;\n+                            if (graph.isNew(before, boxUsageOnBoxedVal) || graph.isNew(before, box)) {\n+                                continue boxedValUsageLoop;\n                             }\n-                            if (usage instanceof BoxNode) {\n-                                final BoxNode boxUsageOnBoxedVal = (BoxNode) usage;\n-                                if (boxUsageOnBoxedVal.getBoxingKind() == box.getBoxingKind()) {\n-                                    if (cfg == null) {\n-                                        cfg = ControlFlowGraph.compute(graph, true, true, true, false);\n-                                    }\n-                                    if (graph.isNew(before, boxUsageOnBoxedVal) || graph.isNew(before, box)) {\n-                                        continue boxedValUsageLoop;\n-                                    }\n-                                    Block boxUsageOnBoxedValBlock = cfg.blockFor(boxUsageOnBoxedVal);\n-                                    Block originalBoxBlock = cfg.blockFor(box);\n-                                    if (boxUsageOnBoxedValBlock.getLoop() != null) {\n-                                        if (originalBoxBlock.getLoop() != boxUsageOnBoxedValBlock.getLoop()) {\n-                                            // avoid proxy creation for now\n+                            Block boxUsageOnBoxedValBlock = cfg.blockFor(boxUsageOnBoxedVal);\n+                            Block originalBoxBlock = cfg.blockFor(box);\n+                            if (boxUsageOnBoxedValBlock.getLoop() != null) {\n+                                if (originalBoxBlock.getLoop() != boxUsageOnBoxedValBlock.getLoop()) {\n+                                    // avoid proxy creation for now\n+                                    continue boxedValUsageLoop;\n+                                }\n+                            }\n+                            if (AbstractControlFlowGraph.dominates(boxUsageOnBoxedValBlock, originalBoxBlock)) {\n+                                if (boxUsageOnBoxedValBlock == originalBoxBlock) {\n+                                    // check dominance within one block\n+                                    for (FixedNode f : boxUsageOnBoxedValBlock.getNodes()) {\n+                                        if (f == boxUsageOnBoxedVal) {\n+                                            // we found the usage first, it dominates \"box\"\n+                                            break;\n+                                        } else if (f == box) {\n+                                            // they are within the same block but the\n+                                            // usage block does not dominate the box\n+                                            // block, that scenario will still be\n+                                            // optimizable but for the usage block node\n+                                            // later in the outer box loop\n                                             continue boxedValUsageLoop;\n                                         }\n                                     }\n-                                    if (AbstractControlFlowGraph.dominates(boxUsageOnBoxedValBlock, originalBoxBlock)) {\n-                                        if (boxUsageOnBoxedValBlock == originalBoxBlock) {\n-                                            // check dominance within one block\n-                                            for (FixedNode f : boxUsageOnBoxedValBlock.getNodes()) {\n-                                                if (f == boxUsageOnBoxedVal) {\n-                                                    // we found the usage first, it dominates \"box\"\n-                                                    break;\n-                                                } else if (f == box) {\n-                                                    // they are within the same block but the\n-                                                    // usage block does not dominate the box\n-                                                    // block, that scenario will still be\n-                                                    // optimizable but for the usage block node\n-                                                    // later in the outer box loop\n-                                                    continue boxedValUsageLoop;\n-                                                }\n-                                            }\n-                                        }\n-                                        box.replaceAtUsages(boxUsageOnBoxedVal);\n-                                        graph.getDebug().dump(DebugContext.VERY_DETAILED_LEVEL, graph, \"After replacing %s with %s\", box, boxUsageOnBoxedVal);\n-                                        GraphUtil.removeFixedWithUnusedInputs(box);\n-                                        continue boxLoop;\n-                                    }\n                                 }\n+                                box.replaceAtUsages(boxUsageOnBoxedVal);\n+                                graph.getDebug().dump(DebugContext.VERY_DETAILED_LEVEL, graph, \"After replacing %s with %s\", box, boxUsageOnBoxedVal);\n+                                GraphUtil.removeFixedWithUnusedInputs(box);\n+                                continue boxLoop;\n                             }\n                         }\n                     }\n@@ -207,40 +118,4 @@ protected void run(StructuredGraph graph, CoreProviders context) {\n         }\n     }\n \n-    private static void optimizeBoxed(BoxNode toBeOptimzied, ValueNode boxedDominatingValueToUse) {\n-        ValueNode other = toBeOptimzied.createOptimizedBox(boxedDominatingValueToUse);\n-        if (other != toBeOptimzied) {\n-            final StructuredGraph graph = toBeOptimzied.graph();\n-            graph.replaceFixed(toBeOptimzied, graph.add(other));\n-            graph.getDebug().dump(DebugContext.VERY_DETAILED_LEVEL, graph, \"After replacing %s with %s\", toBeOptimzied, other);\n-        }\n-    }\n-\n-    public static FloatingNode canonicalizeBoxing(BoxNode box, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection) {\n-        ValueNode value = box.getValue();\n-        if (value.isConstant() && !GraalOptions.ImmutableCode.getValue(box.getOptions())) {\n-            JavaConstant sourceConstant = value.asJavaConstant();\n-            if (sourceConstant.getJavaKind() != box.getBoxingKind() && sourceConstant.getJavaKind().isNumericInteger()) {\n-                switch (box.getBoxingKind()) {\n-                    case Boolean:\n-                        sourceConstant = JavaConstant.forBoolean(sourceConstant.asLong() != 0L);\n-                        break;\n-                    case Byte:\n-                        sourceConstant = JavaConstant.forByte((byte) sourceConstant.asLong());\n-                        break;\n-                    case Char:\n-                        sourceConstant = JavaConstant.forChar((char) sourceConstant.asLong());\n-                        break;\n-                    case Short:\n-                        sourceConstant = JavaConstant.forShort((short) sourceConstant.asLong());\n-                        break;\n-                }\n-            }\n-            JavaConstant boxedConstant = constantReflection.boxPrimitive(sourceConstant);\n-            if (boxedConstant != null && sourceConstant.getJavaKind() == box.getBoxingKind()) {\n-                return ConstantNode.forConstant(boxedConstant, metaAccess, box.graph());\n-            }\n-        }\n-        return null;\n-    }\n }"
  },
  {
    "sha": "3f4d12c1d8e210159e3da22d469fe09114285d1b",
    "filename": "compiler/src/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java",
    "status": "modified",
    "additions": 7,
    "deletions": 4,
    "changes": 11,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -229,16 +229,19 @@ private ArrayCompareToPlugin(JavaKind valueKind, JavaKind otherKind) {\n \n         @Override\n         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value, ValueNode other) {\n-            ValueNode valueLength = b.add(new ArrayLengthNode(value));\n-            ValueNode otherLength = b.add(new ArrayLengthNode(other));\n+            ValueNode nonNullValue = b.nullCheckedValue(value);\n+            ValueNode nonNullOther = b.nullCheckedValue(other);\n+\n+            ValueNode valueLength = b.add(new ArrayLengthNode(nonNullValue));\n+            ValueNode otherLength = b.add(new ArrayLengthNode(nonNullOther));\n             if (swapped) {\n                 /*\n                  * Swapping array arguments because intrinsic expects order to be byte[]/char[] but\n                  * kind arguments stay in original order.\n                  */\n-                b.addPush(JavaKind.Int, new ArrayCompareToNode(other, value, otherLength, valueLength, valueKind, otherKind));\n+                b.addPush(JavaKind.Int, new ArrayCompareToNode(nonNullOther, nonNullValue, otherLength, valueLength, valueKind, otherKind));\n             } else {\n-                b.addPush(JavaKind.Int, new ArrayCompareToNode(value, other, valueLength, otherLength, valueKind, otherKind));\n+                b.addPush(JavaKind.Int, new ArrayCompareToNode(nonNullValue, nonNullOther, valueLength, otherLength, valueKind, otherKind));\n             }\n             return true;\n         }"
  },
  {
    "sha": "afde4a95c782824a8f5ee1cb6ae2313e0e82ab03",
    "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/BoxingSnippets.java",
    "status": "modified",
    "additions": 3,
    "deletions": 171,
    "changes": 174,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/BoxingSnippets.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/BoxingSnippets.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/BoxingSnippets.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -26,27 +26,22 @@\n \n import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;\n \n-import java.lang.reflect.Field;\n import java.util.EnumMap;\n \n import org.graalvm.compiler.api.replacements.Snippet;\n import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;\n import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;\n import org.graalvm.compiler.debug.DebugHandlersFactory;\n import org.graalvm.compiler.debug.GraalError;\n-import org.graalvm.compiler.nodes.ConstantNode;\n import org.graalvm.compiler.nodes.FieldLocationIdentity;\n import org.graalvm.compiler.nodes.NamedLocationIdentity;\n import org.graalvm.compiler.nodes.PiNode;\n-import org.graalvm.compiler.nodes.StructuredGraph;\n import org.graalvm.compiler.nodes.extended.AbstractBoxingNode;\n import org.graalvm.compiler.nodes.extended.BoxNode;\n-import org.graalvm.compiler.nodes.extended.BoxNode.OptimizedAllocatingBoxNode;\n import org.graalvm.compiler.nodes.extended.UnboxNode;\n import org.graalvm.compiler.nodes.spi.CoreProviders;\n import org.graalvm.compiler.nodes.spi.LoweringTool;\n import org.graalvm.compiler.options.OptionValues;\n-import org.graalvm.compiler.phases.common.BoxNodeOptimizationPhase;\n import org.graalvm.compiler.phases.util.Providers;\n import org.graalvm.compiler.replacements.SnippetCounter.Group;\n import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;\n@@ -55,8 +50,6 @@\n import org.graalvm.word.LocationIdentity;\n \n import jdk.vm.ci.code.TargetDescription;\n-import jdk.vm.ci.meta.ConstantReflectionProvider;\n-import jdk.vm.ci.meta.JavaConstant;\n import jdk.vm.ci.meta.JavaKind;\n import jdk.vm.ci.meta.ResolvedJavaField;\n \n@@ -110,45 +103,6 @@ public static Object shortValueOf(short value, @ConstantParameter SnippetCounter\n         return PiNode.piCastToSnippetReplaceeStamp(Short.valueOf(value));\n     }\n \n-    /**\n-     * Note: This list of optimized box versions should be kept in sync with\n-     * {@link BoxNodeOptimizationPhase#OptimizedBoxVersions}.\n-     */\n-    @Snippet\n-    public static Object intValueOfOptimized(int value, Integer boxedVersion, int cacheLow, int cacheHigh) {\n-        if (value >= cacheLow && value <= cacheHigh) {\n-            return PiNode.piCastToSnippetReplaceeStamp(Integer.valueOf(value));\n-        }\n-        return boxedVersion;\n-    }\n-\n-    @Snippet\n-    public static Object longValueOfOptimized(long value, Long boxedVersion, long cacheLow, long cacheHigh) {\n-        if (value >= cacheLow && value <= cacheHigh) {\n-            return PiNode.piCastToSnippetReplaceeStamp(Long.valueOf(value));\n-        }\n-        return boxedVersion;\n-    }\n-\n-    @Snippet\n-    public static Object shortValueOfOptimized(short value, Short boxedVersion, short cacheLow, short cacheHigh) {\n-        int sAsInt = value;\n-        int iCacheLow = cacheLow;\n-        int iCacheHigh = cacheHigh;\n-        if (sAsInt >= iCacheLow && sAsInt <= iCacheHigh) {\n-            return PiNode.piCastToSnippetReplaceeStamp(Short.valueOf(value));\n-        }\n-        return boxedVersion;\n-    }\n-\n-    @Snippet\n-    public static Object charValueOfOptimized(char value, Character boxedVersion, char cacheLow, char cacheHigh) {\n-        if (value >= cacheLow && value <= cacheHigh) {\n-            return PiNode.piCastToSnippetReplaceeStamp(Character.valueOf(value));\n-        }\n-        return boxedVersion;\n-    }\n-\n     @Snippet\n     public static boolean booleanValue(Boolean value, @ConstantParameter SnippetCounter valueCounter) {\n         valueCounter.inc();\n@@ -200,99 +154,7 @@ public static short shortValue(Short value, @ConstantParameter SnippetCounter va\n     public static class Templates extends AbstractTemplates {\n \n         private final EnumMap<JavaKind, SnippetInfo> boxSnippets = new EnumMap<>(JavaKind.class);\n-        private final EnumMap<JavaKind, SnippetInfo> boxSnippetsOptimized = new EnumMap<>(JavaKind.class);\n         private final EnumMap<JavaKind, SnippetInfo> unboxSnippets = new EnumMap<>(JavaKind.class);\n-        private final EnumMap<JavaKind, ResolvedJavaField> kindToCache = new EnumMap<>(JavaKind.class);\n-\n-        /**\n-         * We would like to have a lazy bulk caching of all constants for the\n-         * IntegerCache/LongCache/CharacterCache/ShortCache classes. However, we cannot guarantee\n-         * that if one cache is accessed the other cache classes are initialized already and we do\n-         * not want to force initialize them. Additionally, we cannot use a EnumMap caching to have\n-         * just one allocated map field that is lazily initialized per kind in the map because\n-         * EnumMap is not synchronized in its implementation.\n-         */\n-        private volatile JavaConstant intCacheLow;\n-        private volatile JavaConstant intCacheHigh;\n-        private volatile JavaConstant shortCacheLow;\n-        private volatile JavaConstant shortCacheHigh;\n-        private volatile JavaConstant charCacheLow;\n-        private volatile JavaConstant charCacheHigh;\n-        private volatile JavaConstant longCacheLow;\n-        private volatile JavaConstant longCacheHigh;\n-\n-        private void propagateCacheBounds(JavaKind boxingKind, ConstantReflectionProvider constantReflection, Arguments args, StructuredGraph graph) {\n-            JavaConstant cacheLow;\n-            JavaConstant cacheHigh;\n-            switch (boxingKind) {\n-                case Int:\n-                    if (intCacheLow == null) {\n-                        synchronized (BoxingSnippets.Templates.class) {\n-                            if (intCacheLow == null) {\n-                                intCacheHigh = getCacheHigh(boxingKind, constantReflection);\n-                                intCacheLow = getCacheLow(boxingKind, constantReflection);\n-                            }\n-                        }\n-                    }\n-                    cacheLow = intCacheLow;\n-                    cacheHigh = intCacheHigh;\n-                    break;\n-                case Short:\n-                    if (shortCacheLow == null) {\n-                        synchronized (BoxingSnippets.Templates.class) {\n-                            if (shortCacheLow == null) {\n-                                shortCacheHigh = getCacheHigh(boxingKind, constantReflection);\n-                                shortCacheLow = getCacheLow(boxingKind, constantReflection);\n-                            }\n-                        }\n-                    }\n-                    cacheLow = shortCacheLow;\n-                    cacheHigh = shortCacheHigh;\n-                    break;\n-                case Char:\n-                    if (charCacheLow == null) {\n-                        synchronized (BoxingSnippets.Templates.class) {\n-                            if (charCacheLow == null) {\n-                                charCacheHigh = getCacheHigh(boxingKind, constantReflection);\n-                                charCacheLow = getCacheLow(boxingKind, constantReflection);\n-                            }\n-                        }\n-                    }\n-                    cacheLow = charCacheLow;\n-                    cacheHigh = charCacheHigh;\n-                    break;\n-                case Long:\n-                    if (longCacheLow == null) {\n-                        synchronized (BoxingSnippets.Templates.class) {\n-                            if (longCacheLow == null) {\n-                                longCacheHigh = getCacheHigh(boxingKind, constantReflection);\n-                                longCacheLow = getCacheLow(boxingKind, constantReflection);\n-                            }\n-                        }\n-                    }\n-                    cacheLow = longCacheLow;\n-                    cacheHigh = longCacheHigh;\n-                    break;\n-                default:\n-                    throw GraalError.shouldNotReachHere();\n-            }\n-            args.add(\"cacheLow\", ConstantNode.forConstant(cacheLow, getMetaAccess(), graph));\n-            args.add(\"cacheHigh\", ConstantNode.forConstant(cacheHigh, getMetaAccess(), graph));\n-        }\n-\n-        private JavaConstant getCacheLow(JavaKind boxingKind, ConstantReflectionProvider constantReflection) {\n-            ResolvedJavaField cacheField = kindToCache.get(boxingKind);\n-            assert cacheField != null;\n-            JavaConstant cacheConstant = constantReflection.readFieldValue(cacheField, null);\n-            return constantReflection.unboxPrimitive(constantReflection.readArrayElement(cacheConstant, 0));\n-        }\n-\n-        private JavaConstant getCacheHigh(JavaKind boxingKind, ConstantReflectionProvider constantReflection) {\n-            ResolvedJavaField cacheField = kindToCache.get(boxingKind);\n-            assert cacheField != null;\n-            JavaConstant cacheConstant = constantReflection.readFieldValue(cacheField, null);\n-            return constantReflection.unboxPrimitive(constantReflection.readArrayElement(cacheConstant, constantReflection.readArrayLength(cacheConstant) - 1));\n-        }\n \n         private final SnippetCounter valueOfCounter;\n         private final SnippetCounter valueCounter;\n@@ -344,25 +206,6 @@ public Templates(OptionValues options, Iterable<DebugHandlersFactory> factories,\n                     if (cacheLocation != null) {\n                         boxSnippets.put(kind, snippet(BoxingSnippets.class, kind.getJavaName() + \"ValueOf\", LocationIdentity.INIT_LOCATION, accessedLocation, cacheLocation,\n                                         NamedLocationIdentity.getArrayLocation(JavaKind.Object)));\n-                        if (BoxNodeOptimizationPhase.Options.ReuseOutOfCacheBoxedValues.getValue(options) && BoxNodeOptimizationPhase.OptimizedBoxVersions.contains(kind)) {\n-                            boxSnippetsOptimized.put(kind, snippet(BoxingSnippets.class, kind.getJavaName() + \"ValueOfOptimized\", LocationIdentity.INIT_LOCATION, accessedLocation, cacheLocation,\n-                                            NamedLocationIdentity.getArrayLocation(JavaKind.Object)));\n-                            Class<?> boxingClass = kind.toBoxedJavaClass();\n-                            Class<?> cacheClass = boxingClass.getDeclaredClasses()[0];\n-                            Field f = null;\n-                            try {\n-                                f = cacheClass.getDeclaredField(\"cache\");\n-                            } catch (Throwable t) {\n-                                throw GraalError.shouldNotReachHere(t);\n-                            }\n-                            ResolvedJavaField cacheField = metaAccess.lookupJavaField(f);\n-                            kindToCache.put(kind, cacheField);\n-                            /*\n-                             * Ideally we would like to actually cache the values of the caches in\n-                             * here already, however, the cache classes might not be initialized\n-                             * yet.\n-                             */\n-                        }\n                     } else {\n                         boxSnippets.put(kind, snippet(BoxingSnippets.class, kind.getJavaName() + \"ValueOf\", LocationIdentity.INIT_LOCATION, accessedLocation,\n                                         NamedLocationIdentity.getArrayLocation(JavaKind.Object)));\n@@ -389,21 +232,10 @@ private static LocationIdentity getCacheLocation(CoreProviders providers, JavaKi\n         }\n \n         public void lower(BoxNode box, LoweringTool tool) {\n-            final ConstantReflectionProvider constantReflection = tool.getConstantReflection();\n             Arguments args = null;\n-            if (box instanceof OptimizedAllocatingBoxNode) {\n-                assert BoxNodeOptimizationPhase.OptimizedBoxVersions.contains(box.getBoxingKind());\n-                SnippetInfo info = boxSnippetsOptimized.get(box.getBoxingKind());\n-                GraalError.guarantee(info != null, \"Snippet info for boxing kind %s must not be null\", box.getBoxingKind());\n-                args = new Arguments(info, box.graph().getGuardsStage(), tool.getLoweringStage());\n-                args.add(\"value\", box.getValue());\n-                args.add(\"boxedVersion\", ((OptimizedAllocatingBoxNode) box).getDominatingBoxedValue());\n-                propagateCacheBounds(box.getBoxingKind(), constantReflection, args, box.graph());\n-            } else {\n-                args = new Arguments(boxSnippets.get(box.getBoxingKind()), box.graph().getGuardsStage(), tool.getLoweringStage());\n-                args.add(\"value\", box.getValue());\n-                args.addConst(\"valueOfCounter\", valueOfCounter);\n-            }\n+            args = new Arguments(boxSnippets.get(box.getBoxingKind()), box.graph().getGuardsStage(), tool.getLoweringStage());\n+            args.add(\"value\", box.getValue());\n+            args.addConst(\"valueOfCounter\", valueOfCounter);\n             SnippetTemplate template = template(box, args);\n             box.getDebug().log(\"Lowering integerValueOf in %s: node=%s, template=%s, arguments=%s\", box.graph(), box, template, args);\n             template.instantiate(providers.getMetaAccess(), box, DEFAULT_REPLACER, args);"
  },
  {
    "sha": "81b7aa85897b59fccc3bdb25dd2e5dfc2e937ea2",
    "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java",
    "status": "modified",
    "additions": 48,
    "deletions": 56,
    "changes": 104,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -63,6 +63,7 @@\n import org.graalvm.compiler.nodes.LogicNode;\n import org.graalvm.compiler.nodes.MergeNode;\n import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StateSplit;\n import org.graalvm.compiler.nodes.StructuredGraph;\n import org.graalvm.compiler.nodes.UnwindNode;\n import org.graalvm.compiler.nodes.ValueNode;\n@@ -281,19 +282,24 @@ public InvokeNode createInvoke(ResolvedJavaMethod method, InvokeKind invokeKind,\n             MethodCallTargetNode callTarget = graph.add(createMethodCallTarget(invokeKind, method, args, returnStamp, bci));\n             InvokeNode invoke = append(new InvokeNode(callTarget, bci));\n \n-            if (frameStateBuilder != null) {\n-                if (invoke.getStackKind() != JavaKind.Void) {\n-                    frameStateBuilder.push(invoke.getStackKind(), invoke);\n-                }\n-                invoke.setStateAfter(frameStateBuilder.create(bci, invoke));\n-                if (invoke.getStackKind() != JavaKind.Void) {\n-                    frameStateBuilder.pop(invoke.getStackKind());\n-                }\n-            }\n+            pushForStateSplit(frameStateBuilder, bci, invoke);\n             return invoke;\n         }\n     }\n \n+    private static void pushForStateSplit(FrameStateBuilder frameStateBuilder, int bci, StateSplit stateSplit) {\n+        if (frameStateBuilder != null) {\n+            JavaKind stackKind = stateSplit.asNode().getStackKind();\n+            if (stackKind != JavaKind.Void) {\n+                frameStateBuilder.push(stackKind, stateSplit.asNode());\n+            }\n+            stateSplit.setStateAfter(frameStateBuilder.create(bci, stateSplit));\n+            if (stackKind != JavaKind.Void) {\n+                frameStateBuilder.pop(stackKind);\n+            }\n+        }\n+    }\n+\n     public InvokeNode createIntrinsicInvoke(ResolvedJavaMethod method, ValueNode... args) {\n         return createInvoke(method, Static, null, UNKNOWN_BCI, args);\n     }\n@@ -520,35 +526,39 @@ public AbstractMergeNode endIf() {\n \n         FixedWithNextNode thenPart = s.thenPart instanceof FixedWithNextNode ? (FixedWithNextNode) s.thenPart : null;\n         FixedWithNextNode elsePart = s.elsePart instanceof FixedWithNextNode ? (FixedWithNextNode) s.elsePart : null;\n-        AbstractMergeNode merge = null;\n+        AbstractMergeNode merge = mergeControlSplitBranches(thenPart, elsePart);\n+        s.state = IfState.FINISHED;\n+        popStructure();\n+        return merge;\n+    }\n \n-        if (thenPart != null && elsePart != null) {\n+    private AbstractMergeNode mergeControlSplitBranches(FixedWithNextNode x, FixedWithNextNode y) {\n+        AbstractMergeNode merge = null;\n+        if (x != null && y != null) {\n             /* Both parts are alive, we need a real merge. */\n-            EndNode thenEnd = graph.add(new EndNode());\n-            graph.addAfterFixed(thenPart, thenEnd);\n-            EndNode elseEnd = graph.add(new EndNode());\n-            graph.addAfterFixed(elsePart, elseEnd);\n+            EndNode xEnd = graph.add(new EndNode());\n+            graph.addAfterFixed(x, xEnd);\n+            EndNode yEnd = graph.add(new EndNode());\n+            graph.addAfterFixed(y, yEnd);\n \n             merge = graph.add(new MergeNode());\n-            merge.addForwardEnd(thenEnd);\n-            merge.addForwardEnd(elseEnd);\n+            merge.addForwardEnd(xEnd);\n+            merge.addForwardEnd(yEnd);\n \n             lastFixedNode = merge;\n \n-        } else if (thenPart != null) {\n-            /* elsePart ended with a control sink, so we can continue with thenPart. */\n-            lastFixedNode = thenPart;\n+        } else if (x != null) {\n+            /* y ended with a control sink, so we can continue with x. */\n+            lastFixedNode = x;\n \n-        } else if (elsePart != null) {\n-            /* thenPart ended with a control sink, so we can continue with elsePart. */\n-            lastFixedNode = elsePart;\n+        } else if (y != null) {\n+            /* x ended with a control sink, so we can continue with y. */\n+            lastFixedNode = y;\n \n         } else {\n-            /* Both parts ended with a control sink, so no nodes can be added after the if. */\n+            /* Both parts ended with a control sink, so no nodes can be added afterwards. */\n             assert lastFixedNode == null;\n         }\n-        s.state = IfState.FINISHED;\n-        popStructure();\n         return merge;\n     }\n \n@@ -586,15 +596,7 @@ public InvokeWithExceptionNode startInvokeWithException(MethodCallTargetNode cal\n         InvokeWithExceptionNode invoke = append(new InvokeWithExceptionNode(callTarget, exceptionObject, invokeBci));\n         AbstractBeginNode noExceptionEdge = graph.add(KillingBeginNode.create(LocationIdentity.any()));\n         invoke.setNext(noExceptionEdge);\n-        if (frameStateBuilder != null) {\n-            if (invoke.getStackKind() != JavaKind.Void) {\n-                frameStateBuilder.push(invoke.getStackKind(), invoke);\n-            }\n-            invoke.setStateAfter(frameStateBuilder.create(invokeBci, invoke));\n-            if (invoke.getStackKind() != JavaKind.Void) {\n-                frameStateBuilder.pop(invoke.getStackKind());\n-            }\n-        }\n+        pushForStateSplit(frameStateBuilder, invokeBci, invoke);\n         lastFixedNode = null;\n \n         InvokeWithExceptionStructure s = new InvokeWithExceptionStructure();\n@@ -609,14 +611,20 @@ public InvokeWithExceptionNode startInvokeWithException(MethodCallTargetNode cal\n \n     protected ExceptionObjectNode createExceptionObjectNode(FrameStateBuilder frameStateBuilder, int exceptionEdgeBci) {\n         ExceptionObjectNode exceptionObject = add(new ExceptionObjectNode(getMetaAccess()));\n+        setStateAfterException(frameStateBuilder, exceptionEdgeBci, exceptionObject, true);\n+        return exceptionObject;\n+    }\n+\n+    protected void setStateAfterException(FrameStateBuilder frameStateBuilder, int exceptionEdgeBci, StateSplit exceptionObject, boolean rethrow) {\n         if (frameStateBuilder != null) {\n             FrameStateBuilder exceptionState = frameStateBuilder.copy();\n-            exceptionState.clearStack();\n-            exceptionState.push(JavaKind.Object, exceptionObject);\n-            exceptionState.setRethrowException(true);\n+            if (rethrow) {\n+                exceptionState.clearStack();\n+                exceptionState.setRethrowException(true);\n+            }\n+            exceptionState.push(JavaKind.Object, exceptionObject.asNode());\n             exceptionObject.setStateAfter(exceptionState.create(exceptionEdgeBci, exceptionObject));\n         }\n-        return exceptionObject;\n     }\n \n     private InvokeWithExceptionStructure saveLastInvokeWithExceptionNode() {\n@@ -666,23 +674,7 @@ public AbstractMergeNode endInvokeWithException() {\n         InvokeWithExceptionStructure s = saveLastInvokeWithExceptionNode();\n         FixedWithNextNode noExceptionEdge = s.noExceptionEdge instanceof FixedWithNextNode ? (FixedWithNextNode) s.noExceptionEdge : null;\n         FixedWithNextNode exceptionEdge = s.exceptionEdge instanceof FixedWithNextNode ? (FixedWithNextNode) s.exceptionEdge : null;\n-        AbstractMergeNode merge = null;\n-        if (noExceptionEdge != null && exceptionEdge != null) {\n-            EndNode noExceptionEnd = graph.add(new EndNode());\n-            graph.addAfterFixed(noExceptionEdge, noExceptionEnd);\n-            EndNode exceptionEnd = graph.add(new EndNode());\n-            graph.addAfterFixed(exceptionEdge, exceptionEnd);\n-            merge = graph.add(new MergeNode());\n-            merge.addForwardEnd(noExceptionEnd);\n-            merge.addForwardEnd(exceptionEnd);\n-            lastFixedNode = merge;\n-        } else if (noExceptionEdge != null) {\n-            lastFixedNode = noExceptionEdge;\n-        } else if (exceptionEdge != null) {\n-            lastFixedNode = exceptionEdge;\n-        } else {\n-            assert lastFixedNode == null;\n-        }\n+        AbstractMergeNode merge = mergeControlSplitBranches(noExceptionEdge, exceptionEdge);\n         s.state = InvokeWithExceptionStructure.State.FINISHED;\n         popStructure();\n         return merge;"
  },
  {
    "sha": "11671875ed8877c28f0a90997a0d61417444705e",
    "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IsArraySnippets.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IsArraySnippets.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IsArraySnippets.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/IsArraySnippets.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -41,12 +41,12 @@\n public abstract class IsArraySnippets implements Snippets {\n \n     @Snippet\n-    Object objectIsArraySnippet(Object object, Object trueValue, Object falseValue) {\n+    Object objectIsArraySnippet(@Snippet.NonNullParameter Object object, Object trueValue, Object falseValue) {\n         return classIsArray(object.getClass()) ? trueValue : falseValue;\n     }\n \n     @Snippet\n-    Object classIsArraySnippet(Class<?> clazz, Object trueValue, Object falseValue) {\n+    Object classIsArraySnippet(@Snippet.NonNullParameter Class<?> clazz, Object trueValue, Object falseValue) {\n         return classIsArray(clazz) ? trueValue : falseValue;\n     }\n "
  },
  {
    "sha": "c20209a13c92d2d010443f945ca836887a1779b0",
    "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/Mu-L/graal/blob/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java",
    "raw_url": "https://github.com/Mu-L/graal/raw/14ee97735dab6b8dc4b81087fe9dbd8dd250b264/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java",
    "contents_url": "https://api.github.com/repos/Mu-L/graal/contents/compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java?ref=14ee97735dab6b8dc4b81087fe9dbd8dd250b264",
    "patch": "@@ -143,6 +143,7 @@\n import org.graalvm.compiler.nodes.spi.LoweringTool;\n import org.graalvm.compiler.nodes.spi.MemoryEdgeProxy;\n import org.graalvm.compiler.nodes.spi.SnippetParameterInfo;\n+import org.graalvm.compiler.nodes.type.StampTool;\n import org.graalvm.compiler.nodes.util.GraphUtil;\n import org.graalvm.compiler.options.Option;\n import org.graalvm.compiler.options.OptionKey;\n@@ -1195,6 +1196,17 @@ private static boolean checkVarargs(MetaAccessProvider metaAccess, final Resolve\n         return true;\n     }\n \n+    private static boolean checkNonNull(ResolvedJavaMethod method, String parameterName, Object arg) {\n+        if (arg instanceof ValueNode) {\n+            assert StampTool.isPointerNonNull((ValueNode) arg) : method + \": non-null Node for argument \" + parameterName + \" must have non-null stamp: \" + arg;\n+        } else if (arg instanceof Constant) {\n+            assert JavaConstant.isNull((Constant) arg) : method + \": non-null Constant for argument \" + parameterName + \" must not represent null\";\n+        } else {\n+            assert arg != null : method + \": non-null object for argument \" + parameterName + \" must not be null\";\n+        }\n+        return true;\n+    }\n+\n     /**\n      * The graph built from the snippet method.\n      */\n@@ -2093,6 +2105,9 @@ private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments ar\n                 assert args.values[i] instanceof Varargs;\n                 Varargs varargs = (Varargs) args.values[i];\n                 assert IS_IN_NATIVE_IMAGE || checkVarargs(metaAccess, method, signature, i - offset, args.info.getParameterName(i), varargs);\n+\n+            } else if (args.info.isNonNullParameter(i)) {\n+                assert checkNonNull(method, args.info.getParameterName(i), args.values[i]);\n             }\n         }\n         return true;"
  }
]
