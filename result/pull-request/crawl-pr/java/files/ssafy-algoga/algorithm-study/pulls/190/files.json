[
  {
    "sha": "6bb1e097127baa05fbb53235262f77d81182b9f0",
    "filename": "minkue777/BOJ/1000/1991/README.md",
    "status": "added",
    "additions": 166,
    "deletions": 0,
    "changes": 166,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/d24762f66ad2f5d7ca9afbbdd274e455e33caf6c/minkue777/BOJ/1000/1991/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/d24762f66ad2f5d7ca9afbbdd274e455e33caf6c/minkue777/BOJ/1000/1991/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/minkue777/BOJ/1000/1991/README.md?ref=d24762f66ad2f5d7ca9afbbdd274e455e33caf6c",
    "patch": "@@ -0,0 +1,166 @@\n+# 1991번 트리 순회\n+[문제 보러가기](https://www.acmicpc.net/problem/1991)\n+\n+## 🅰 설계\n+문제를 크게 두 가지로 쪼갰습니다.\n+1. 입력이 들어왔을 때 트리에 새로운 노드를 추가하는 문제\n+2. 트리가 완성되었을 때 세 가지 방법으로 순회하는 문제\n+\n+사실 2번은 어렵지 않은 문제이기 때문에 1번에 좀 더 많은 시간을 쏟았습니다.\n+1번 문제를 2가지 메소드로 나누어서 구현했습니다.\n+1. 입력된 데이터를 바탕으로 해당 노드를 찾는 searchNode 메소드\n+2. 찾은 노드에 자식 노드를 추가하는 insert 메소드\n+\n+일단 문제 전반에 사용했던 Node 클래스입니다.\n+\n+```java\n+static class Node {\n+    String data;\n+    Node left;\n+    Node right;\n+\n+    Node(String data) {\n+        this.data = data;\n+    }\n+}\n+```\n+\n+### searchFind 메소드\n+\n+```java \n+static Node searchNode(Node node, String target) {\n+    if(node == null) return null;\n+    if(node.data.equals(target)) return node;\n+    // 재귀 호출을 통해 모든 노드를 탐색\n+    Node searchLeft = searchNode(node.left, target);\n+    Node searchRight = searchNode(node.right, target);\n+    Node ret = null;\n+    if(searchLeft != null) ret = searchLeft;\n+    else if(searchRight != null) ret = searchRight;\n+    return ret;\n+}\n+```\n+\n+트리의 모든 노드를 탐색하는 방법은 dfs의 일종으로 필연적으로 재귀호출을 사용하게 됩니다.\n+왼쪽 노드 -> 오른쪽 노드 순서로 방문하면서 만약 전체를 순회해도 노드를 찾지 못한다면\n+null을 리턴합니다.\n+\n+### insert 메소드\n+\n+```java \n+static void insert(String parent, String left, String right) {\n+    Node parentNode = searchNode(root, parent);\n+    if(!left.equals(\".\")) {\n+        parentNode.left = new Node(left);\n+    }\n+    if(!right.equals(\".\")) {\n+        parentNode.right = new Node(right);\n+    }\n+}\n+```\n+\n+트리 탐색의 시작은 항상 root 노드입니다. 입력 문자열이 `.`인 경우는 자식 노드가\n+없는 케이스이므로 이 상황만 예외처리를 해줍니다.\n+트리를 전위, 중위, 후위순회하는 코드는 특별할 것이 없습니다.\n+\n+### 전체 코드\n+```java\n+import java.util.*;\n+import java.io.*;\n+\n+public class Main {\n+    // 이진 트리를 위한 Node 클래스\n+    static class Node {\n+        String data;\n+        Node left;\n+        Node right;\n+        // left와 right 노드는 항상 null로 초기화\n+        Node(String data) {\n+            this.data = data;\n+        }\n+    }\n+    \n+    // target을 데이터로 갖는 node를 리턴하는 메소드\n+    static Node searchNode(Node node, String target) {\n+        // 만약 node가 null이라면 null을 반환\n+        if(node == null) return null;\n+        // 지금 노드의 데이터가 target이라면 현재노드를 반환\n+        if(node.data.equals(target)) return node;\n+        // 왼쪽 노드와 오른쪽 노드를 방문하는 재귀호출\n+        Node searchLeft = searchNode(node.left, target);\n+        Node searchRight = searchNode(node.right, target);\n+        Node ret = null;\n+        // 왼쪽 노드에서 원하는 노드를 찾은 경우\n+        if(searchLeft != null) ret = searchLeft;\n+        // 오른쪽 노드에서 원하는 노드를 찾은 경우\n+        else if(searchRight != null) ret = searchRight;\n+        return ret;\n+    }\n+\n+    static void insert(String parent, String left, String right) {\n+        // parent 데이터를 갖는 노드를 찾은 후\n+        Node parentNode = searchNode(root, parent);\n+        // 자식이 있다면 자식 노드를 추가\n+        if(!left.equals(\".\")) {\n+            parentNode.left = new Node(left);\n+        }\n+        if(!right.equals(\".\")) {\n+            parentNode.right = new Node(right);\n+        }\n+    }\n+\n+    static void preorder(Node node) {\n+        if(node == null) return;\n+        sb.append(node.data);\n+        preorder(node.left);\n+        preorder(node.right);\n+    }\n+\n+    static void inorder(Node node) {\n+        if(node == null) return;\n+        inorder(node.left);\n+        sb.append(node.data);\n+        inorder(node.right);\n+    }\n+\n+    static void postorder(Node node) {\n+        if(node == null) return;\n+        postorder(node.left);\n+        postorder(node.right);\n+        sb.append(node.data);\n+    }\n+\n+    static Node root;\n+    static StringBuilder sb = new StringBuilder();\n+\n+    public static void main(String[] args) throws IOException {\n+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+        int numOfNodes = Integer.parseInt(br.readLine());\n+        root = new Node(\"A\");\n+        for(int i=0; i<numOfNodes; i++) {\n+            StringTokenizer st = new StringTokenizer(br.readLine());\n+            insert(st.nextToken(), st.nextToken(), st.nextToken());\n+        }\n+\n+        preorder(root);\n+        sb.append(\"\\n\");\n+        inorder(root);\n+        sb.append(\"\\n\");\n+        postorder(root);\n+        System.out.println(sb);\n+    }\n+}\n+```\n+\n+## ✅ 후기\n+이 문제는 3주 정도 전에 트리 관련된 문제를 몰아서 풀면서 풀었던 문제였습니다.\n+그 당시엔 트리에 익숙하지 않아서 꽤 힘들게 문제를 풀었었는데요. \n+그때 풀었던 솔루션으로 pr을 작성하려고 코드를 찬찬히 살펴보니 정답만 맞았지\n+코드가 너무 엉망이라 그대로 pr을 쓸수가 없겠더군요. 다시 풀면서 훨씬 깔끔한\n+로직과 코드로 완성이 되었습니다. 그리고 3주 전에 스스로 잘 풀었다는 생각에\n+뿌듯했던 모습이 떠올라 피식했습니다. 사실 알고리즘 같이 긴 시간 실력을 키워야 하는\n+과목에서 3주는 스스로 변화를 느끼지 못할 정도로 짧은 시간이라고 생각합니다.\n+그래도 이번에 다시 문제를 풀면서 3주 전 보다 꽤 많이 성장했구나라는 생각이 들었습니다.\n+알고리즘 스터디 덕분이겠죠? ㅎㅎ 여유시간이 많지 않아서 할지말지 많이 고민했었는데\n+하길 잘했다는 생각이 듭니다.\n+"
  },
  {
    "sha": "01153ef4672d6c8fb7093cca4a84c1893e4da0c8",
    "filename": "minkue777/BOJ/1000/1991/answer.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/d24762f66ad2f5d7ca9afbbdd274e455e33caf6c/minkue777/BOJ/1000/1991/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/d24762f66ad2f5d7ca9afbbdd274e455e33caf6c/minkue777/BOJ/1000/1991/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/minkue777/BOJ/1000/1991/answer.java?ref=d24762f66ad2f5d7ca9afbbdd274e455e33caf6c",
    "patch": "@@ -0,0 +1,76 @@\n+import java.util.*;\n+import java.io.*;\n+\n+public class Main {\n+    static class Node {\n+        String data;\n+        Node left;\n+        Node right;\n+\n+        Node(String data) {\n+            this.data = data;\n+        }\n+    }\n+\n+    static Node searchNode(Node node, String target) {\n+        if(node == null) return null;\n+        if(node.data.equals(target)) return node;\n+        Node searchLeft = searchNode(node.left, target);\n+        Node searchRight = searchNode(node.right, target);\n+        Node ret = null;\n+        if(searchLeft != null) ret = searchLeft;\n+        else if(searchRight != null) ret = searchRight;\n+        return ret;\n+    }\n+\n+    static void insert(String parent, String left, String right) {\n+        Node parentNode = searchNode(root, parent);\n+        if(!left.equals(\".\")) {\n+            parentNode.left = new Node(left);\n+        }\n+        if(!right.equals(\".\")) {\n+            parentNode.right = new Node(right);\n+        }\n+    }\n+\n+    static void preorder(Node node) {\n+        if(node == null) return;\n+        sb.append(node.data);\n+        preorder(node.left);\n+        preorder(node.right);\n+    }\n+\n+    static void inorder(Node node) {\n+        if(node == null) return;\n+        inorder(node.left);\n+        sb.append(node.data);\n+        inorder(node.right);\n+    }\n+\n+    static void postorder(Node node) {\n+        if(node == null) return;\n+        postorder(node.left);\n+        postorder(node.right);\n+        sb.append(node.data);\n+    }\n+\n+    static Node root;\n+    static StringBuilder sb = new StringBuilder();\n+\n+    public static void main(String[] args) throws IOException {\n+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+        int numOfNodes = Integer.parseInt(br.readLine());\n+        root = new Node(\"A\");\n+        for(int i=0; i<numOfNodes; i++) {\n+            StringTokenizer st = new StringTokenizer(br.readLine());\n+            insert(st.nextToken(), st.nextToken(), st.nextToken());\n+        }\n+\n+        preorder(root);\n+        sb.append(\"\\n\");\n+        inorder(root);\n+        sb.append(\"\\n\");\n+        postorder(root);\n+        System.out.println(sb);\n+    }\n+}\n\\ No newline at end of file"
  }
]
