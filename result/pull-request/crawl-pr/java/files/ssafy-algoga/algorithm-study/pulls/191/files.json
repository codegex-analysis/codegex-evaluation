[
  {
    "sha": "31fb57dbee5600036cf5ab40292f0123cdce54ae",
    "filename": "lktgt15/BOJ/1000/1202/README.md",
    "status": "added",
    "additions": 119,
    "deletions": 0,
    "changes": 119,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/1000/1202/README.md?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,119 @@\n+# 1202번 보석 도둑\n+[문제 보러가기](https://www.acmicpc.net/problem/1202)\n+\n+## 🅰 설계\n+\n+일단 그림을 그려서 이해해보려고 했습니다.  \n+![](./img/1.png)  \n+무게를 x축, 가치를 y축으로 보면 위와 같은 그림을 만들 수 있습니다.  \n+\n+처음에 떠오른건 세그먼트 트리였으나.. 구현도 귀찮고 까먹어서 다른 방법을 생각했습니다.  \n+\n+가방을 오름차순으로 정렬하면 그보다 무게가 작은 보석은 모두 꺼낼 수 있고, 그 중에서 가치가 가장 큰 보석을 찾아서 가방에 담으면 됩니다.  \n+\n+이를 그대로 코드로 구현하기만 하면 됩니다.  \n+\n+### 1. 입력-소팅\n+```java\n+List<jewelry> jewelries = new ArrayList<>();\n+for(int i=0;i<n;i++) {\n+\tst = new StringTokenizer(br.readLine());\n+\tjewelries.add(new jewelry(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));\n+\t\n+}\n+\n+Collections.sort(jewelries);\n+int[] ks = new int[k];\n+for(int i=0;i<k;i++) {\n+\tks[i] = Integer.parseInt(br.readLine());\n+}\n+\n+Arrays.sort(ks);\n+```\n+보석 list와 가방 array를 오름차순으로 정렬합니다.  \n+\n+\n+### 2. 가방의 무게 제한에 맞춰서 꺼내기\n+```java\n+int jsize = jewelries.size();\n+int jidx = 0;\n+long ans = 0;\n+PriorityQueue<jewelry> pq = new PriorityQueue<>((o1,o2) -> o2.y-o1.y);\n+for(int i=0;i<k;i++) {\n+\tint xlimit = ks[i];\n+\twhile(jidx < jsize && jewelries.get(jidx).x <= xlimit) {\n+\t\tpq.add(jewelries.get(jidx++));\n+\t}\n+\tif(!pq.isEmpty()) ans += pq.poll().y;\n+}\n+System.out.println(ans);\n+```\n+`PriorityQueue`는 보석의 가치가 큰 보석이 위로 오게 되는 `max heap`입니다.  \n+\n+가방의 현재 제한 무게를 기준으로 그보다 무게가 작거나 같은 보석을 모두 `PriorityQueue`에 담아둡니다.  \n+\n+이 작업을 한 후 `PriorityQueue`에서 보석을 꺼내면 그 가방이 담을 수 있는 최고 가치의 보석이 됩니다.  \n+\n+### 전체코드\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic List<jewelry> jewelries = new ArrayList<>();\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\t\n+\t\tint n = Integer.parseInt(st.nextToken());\n+\t\tint k = Integer.parseInt(st.nextToken());\n+\t\t\n+\t\tfor(int i=0;i<n;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tjewelries.add(new jewelry(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));\n+\t\t\t\n+\t\t}\n+\t\t\n+\t\tCollections.sort(jewelries);\n+\t\tint[] ks = new int[k];\n+\t\tfor(int i=0;i<k;i++) {\n+\t\t\tks[i] = Integer.parseInt(br.readLine());\n+\t\t}\n+\t\t\n+\t\tArrays.sort(ks);\n+\t\t\n+\t\tint jsize = jewelries.size();\n+\t\tint jidx = 0;\n+\t\tlong ans = 0;\n+\t\tPriorityQueue<jewelry> pq = new PriorityQueue<>((o1,o2) -> o2.y-o1.y);\n+\t\tfor(int i=0;i<k;i++) {\n+\t\t\tint xlimit = ks[i];\n+\t\t\twhile(jidx < jsize && jewelries.get(jidx).x <= xlimit) {\n+\t\t\t\tpq.add(jewelries.get(jidx++));\n+\t\t\t}\n+\t\t\tif(!pq.isEmpty()) ans += pq.poll().y;\n+\t\t}\n+\t\tSystem.out.println(ans);\n+\t}\n+\t\n+\tstatic class jewelry implements Comparable<jewelry>{\n+\t\tint x,y;\n+\t\tpublic jewelry(int x,int y) {\n+\t\t\tthis.x = x;\n+\t\t\tthis.y = y;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic int compareTo(jewelry o) {\n+\t\t\treturn this.x - o.x;\n+\t\t}\n+\t\t\n+\t}\n+}\n+```\n+\n+## ✅ 후기\n+xlimit 에 `<=`를 `<`로 써서 한번, ans가 int범위를 초과해서 또 틀렸네요.. 좀 더 생각해보고 답을 제출하는 공부를 해야 할것 같습니다."
  },
  {
    "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
    "filename": "lktgt15/BOJ/1000/1202/answer.java",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/1000/1202/answer.java?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48"
  },
  {
    "sha": "a2a99126ec3410410f3c309604dacdc14b4c8829",
    "filename": "lktgt15/BOJ/1000/1202/img/1.png",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/img/1.png",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/1000/1202/img/1.png",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/1000/1202/img/1.png?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48"
  },
  {
    "sha": "aced2cb830d8335bce5b56d48b8cb36741ec899e",
    "filename": "lktgt15/BOJ/11000/11559/README.md",
    "status": "added",
    "additions": 192,
    "deletions": 0,
    "changes": 192,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/11000/11559/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/11000/11559/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/11000/11559/README.md?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,192 @@\n+# 11559번 Puyo Puyo\n+[문제 보러가기](https://www.acmicpc.net/problem/11559)\n+\n+## 🅰 설계\n+문제에서 시키는 대로 시뮬레이션을 돌리면 되는 문제였습니다.  \n+\n+\n+### 1. 싸이클\n+```java\n+while(play()) {\n+\tans++;\n+\tmove();\n+\treset();\n+};\n+System.out.println(ans);\n+```\n+`play()`는 블럭이 연쇄될 수 있는지 체크하고, 터지는 블럭이 있으면 true, 없으면 false를 리턴하는 함수입니다. 동시에 터질 수 있는 블럭은 터뜨립니다.  \n+\n+`move()`는 블럭이 터진 후 남은 블럭을 아래쪽으로 정렬할 때 사용됩니다.\n+`reset()`은 탐색할 때 사용했던 boolean배열을 초기화하는데 사용합니다.  \n+\n+### 2. play()\n+\n+```java\n+static boolean play() { // 터지는 블럭이 있는지 체크하고 터뜨림\n+\tboolean ret = false;\n+\t\n+\tfor(int i=0;i<12;i++) {\n+\t\tfor(int j=0;j<6;j++) {\n+\t\t\tif(map[i][j] != '.' && chk1[i][j] == false) { // i,j위치의 블럭을 체크\n+\t\t\t\tchk1[i][j] = true;\n+\t\t\t\tif(chain(i,j) < 4) continue; // i,j위치의 블럭과 같은 블럭이 4개 이상 인접한 블럭이 있는지 체크\n+\t\t\t\tret = true;\n+\t\t\t\tchk2[i][j] = true;\n+\t\t\t\tboom(i,j); // 4개 이상이면 터뜨림\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\treturn ret;\n+}\n+```\n+맵을 확인하고 터지는 블럭이 있으면 터뜨립니다.  \n+\n+\n+### 3. chain(int y,int x)\n+\n+```java\n+static int chain(int y,int x) { // 같은 블럭이 상,하,좌,우로 몇 개 있는지 체크\n+\tint ret = 1;\n+\tfor(int i=0;i<4;i++) {\n+\t\tint nxty = y+dy[i];\n+\t\tint nxtx = x+dx[i];\n+\t\tif (isValid(nxty,nxtx) && !chk1[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\tchk1[nxty][nxtx] = true;\n+\t\t\tret += chain(nxty,nxtx);\n+\t\t}\n+\t}\n+\treturn ret;\n+}\n+```\n+상,하,좌,우로 연결된 블럭이 몇개인지 리턴합니다.  \n+\n+### 4. boom(int y,int x)\n+\n+```java\n+static void boom(int y,int x) { // 블럭을 터뜨림\n+\tfor(int i=0;i<4;i++) {\n+\t\tint nxty = y+dy[i];\n+\t\tint nxtx = x+dx[i];\n+\t\tif(isValid(nxty,nxtx) && !chk2[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\tchk2[nxty][nxtx] = true;\n+\t\t\tboom(nxty,nxtx);\n+\t\t}\n+\t}\n+\tmap[y][x] = '.';\n+}\n+```\n+`chain(int y,int x)`에서 4개이상 연결된 블럭이 확인되면 그 블럭들을 터뜨립니다.  \n+\n+### 5. reset()\n+\n+```java\n+static void reset() { // chk1, chk2배열을 초기화\n+\tfor(int i=0;i<12;i++) for(int j=0;j<6;j++) {\n+\t\tchk1[i][j] = false;\n+\t\tchk2[i][j] = false;\n+\t}\n+}\n+```\n+`chain(int y,int x)`와 `boom(int y,int x)`에서 사용한 boolean배열을 초기화합니다.  \n+\n+### 전체코드\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic char[][] map = new char[12][]; // 맵\n+\t// chk1 은 블럭이 터지는지 체크할 때, chk2는 블럭을 터뜨려 없앨때 사용\n+\tstatic boolean[][] chk1 = new boolean[12][6],chk2 = new boolean[12][6];\n+\tstatic int[] dy = {1,-1,0,0}, dx = {0,0,1,-1};\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tfor(int i=0;i<12;i++) {\n+\t\t\tmap[i] = br.readLine().toCharArray();\n+\t\t}\n+\t\t\n+\t\tint ans = 0;\n+\t\twhile(play()) {\n+\t\t\tans++;\n+\t\t\tmove();\n+\t\t\treset();\n+\t\t};\n+\t\tSystem.out.println(ans);\n+\t}\n+\t\n+\tstatic void move() { // 맵에서 블럭을 터뜨린 후 블럭을 내릴 때 사용\n+\t\tfor(int j=0;j<6;j++) {\n+\t\t\tint idx = 11;\n+\t\t\tfor(int i=11;i>=0;i--) {\n+\t\t\t\tif(map[i][j] != '.') {\n+\t\t\t\t\tchar tmp = map[i][j];\n+\t\t\t\t\tmap[i][j] = '.';\n+\t\t\t\t\tmap[idx--][j] = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic void reset() { // chk1, chk2배열을 초기화\n+\t\tfor(int i=0;i<12;i++) for(int j=0;j<6;j++) {\n+\t\t\tchk1[i][j] = false;\n+\t\t\tchk2[i][j] = false;\n+\t\t}\n+\t}\n+\t\n+\tstatic boolean play() { // 터지는 블럭이 있는지 체크하고 터뜨림\n+\t\tboolean ret = false;\n+\t\t\n+\t\tfor(int i=0;i<12;i++) {\n+\t\t\tfor(int j=0;j<6;j++) {\n+\t\t\t\tif(map[i][j] != '.' && chk1[i][j] == false) { // i,j위치의 블럭을 체크\n+\t\t\t\t\tchk1[i][j] = true;\n+\t\t\t\t\tif(chain(i,j) < 4) continue; // i,j위치의 블럭과 같은 블럭이 4개 이상 인접한 블럭이 있는지 체크\n+\t\t\t\t\tret = true;\n+\t\t\t\t\tchk2[i][j] = true;\n+\t\t\t\t\tboom(i,j); // 4개 이상이면 터뜨림\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn ret;\n+\t}\n+\t\n+\tstatic void boom(int y,int x) { // 블럭을 터뜨림\n+\t\tfor(int i=0;i<4;i++) {\n+\t\t\tint nxty = y+dy[i];\n+\t\t\tint nxtx = x+dx[i];\n+\t\t\tif(isValid(nxty,nxtx) && !chk2[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\t\tchk2[nxty][nxtx] = true;\n+\t\t\t\tboom(nxty,nxtx);\n+\t\t\t}\n+\t\t}\n+\t\tmap[y][x] = '.';\n+\t}\n+\t\n+\tstatic boolean isValid(int y,int x) { // 범위 체크\n+\t\treturn y>=0 && y<12 && x>=0 && x<6;\n+\t}\n+\t\n+\tstatic int chain(int y,int x) { // 같은 블럭이 상,하,좌,우로 몇 개 있는지 체크\n+\t\tint ret = 1;\n+\t\tfor(int i=0;i<4;i++) {\n+\t\t\tint nxty = y+dy[i];\n+\t\t\tint nxtx = x+dx[i];\n+\t\t\tif (isValid(nxty,nxtx) && !chk1[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\t\tchk1[nxty][nxtx] = true;\n+\t\t\t\tret += chain(nxty,nxtx);\n+\t\t\t}\n+\t\t}\n+\t\treturn ret;\n+\t}\n+}\n+```\n+\n+\n+## ✅ 후기\n+시뮬레이션을 연습하기 좋은 문제였습니다."
  },
  {
    "sha": "961fc9e84e9fff6e9aacf3d18209683357b05de2",
    "filename": "lktgt15/BOJ/11000/11559/answer.java",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/11000/11559/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/11000/11559/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/11000/11559/answer.java?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,93 @@\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic char[][] map = new char[12][]; // 맵\n+\t// chk1 은 블럭이 터지는지 체크할 때, chk2는 블럭을 터뜨려 없앨때 사용\n+\tstatic boolean[][] chk1 = new boolean[12][6],chk2 = new boolean[12][6];\n+\tstatic int[] dy = {1,-1,0,0}, dx = {0,0,1,-1};\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tfor(int i=0;i<12;i++) {\n+\t\t\tmap[i] = br.readLine().toCharArray();\n+\t\t}\n+\t\t\n+\t\tint ans = 0;\n+\t\twhile(play()) {\n+\t\t\tans++;\n+\t\t\tmove();\n+\t\t\treset();\n+\t\t};\n+\t\tSystem.out.println(ans);\n+\t}\n+\t\n+\tstatic void move() { // 맵에서 블럭을 터뜨린 후 블럭을 내릴 때 사용\n+\t\tfor(int j=0;j<6;j++) {\n+\t\t\tint idx = 11;\n+\t\t\tfor(int i=11;i>=0;i--) {\n+\t\t\t\tif(map[i][j] != '.') {\n+\t\t\t\t\tchar tmp = map[i][j];\n+\t\t\t\t\tmap[i][j] = '.';\n+\t\t\t\t\tmap[idx--][j] = tmp;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic void reset() { // chk1, chk2배열을 초기화\n+\t\tfor(int i=0;i<12;i++) for(int j=0;j<6;j++) {\n+\t\t\tchk1[i][j] = false;\n+\t\t\tchk2[i][j] = false;\n+\t\t}\n+\t}\n+\t\n+\tstatic boolean play() { // 터지는 블럭이 있는지 체크하고 터뜨림\n+\t\tboolean ret = false;\n+\t\t\n+\t\tfor(int i=0;i<12;i++) {\n+\t\t\tfor(int j=0;j<6;j++) {\n+\t\t\t\tif(map[i][j] != '.' && chk1[i][j] == false) { // i,j위치의 블럭을 체크\n+\t\t\t\t\tchk1[i][j] = true;\n+\t\t\t\t\tif(chain(i,j) < 4) continue; // i,j위치의 블럭과 같은 블럭이 4개 이상 인접한 블럭이 있는지 체크\n+\t\t\t\t\tret = true;\n+\t\t\t\t\tchk2[i][j] = true;\n+\t\t\t\t\tboom(i,j); // 4개 이상이면 터뜨림\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn ret;\n+\t}\n+\t\n+\tstatic void boom(int y,int x) { // 블럭을 터뜨림\n+\t\tfor(int i=0;i<4;i++) {\n+\t\t\tint nxty = y+dy[i];\n+\t\t\tint nxtx = x+dx[i];\n+\t\t\tif(isValid(nxty,nxtx) && !chk2[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\t\tchk2[nxty][nxtx] = true;\n+\t\t\t\tboom(nxty,nxtx);\n+\t\t\t}\n+\t\t}\n+\t\tmap[y][x] = '.';\n+\t}\n+\t\n+\tstatic boolean isValid(int y,int x) { // 범위 체크\n+\t\treturn y>=0 && y<12 && x>=0 && x<6;\n+\t}\n+\t\n+\tstatic int chain(int y,int x) { // 같은 블럭이 상,하,좌,우로 몇 개 있는지 체크\n+\t\tint ret = 1;\n+\t\tfor(int i=0;i<4;i++) {\n+\t\t\tint nxty = y+dy[i];\n+\t\t\tint nxtx = x+dx[i];\n+\t\t\tif (isValid(nxty,nxtx) && !chk1[nxty][nxtx] && map[nxty][nxtx] == map[y][x]) {\n+\t\t\t\tchk1[nxty][nxtx] = true;\n+\t\t\t\tret += chain(nxty,nxtx);\n+\t\t\t}\n+\t\t}\n+\t\treturn ret;\n+\t}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "b03da1c4d75b1b4b7763e545c19036be77d7144c",
    "filename": "lktgt15/BOJ/14000/14594/README.md",
    "status": "added",
    "additions": 178,
    "deletions": 0,
    "changes": 178,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/14000/14594/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/14000/14594/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/14000/14594/README.md?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,178 @@\n+# 14594번 동방 프로젝트 (Small)\n+[문제 보러가기](https://www.acmicpc.net/problem/14594)\n+\n+## 🅰 설계\n+처음에 Small버전을 보고 Large버전이 어떤걸 요구할지 예상이 되서 Large버전으로 풀었습니다.  \n+\n+입력을 보고 떠오른 방법은 두가지였습니다.  \n+\n+### 1. 스위핑\n+*빅-종빈빌런*의 행동은 겹칠 수 있습니다.  \n+\n+예를 들어 `1 6`을 한 후에 `3 5`를 다시 처리하는 것은 의미가 없습니다. 이미 `1 6`에서 `3 5`를 포함하여 벽을 부숴버렸으니까요.  \n+\n+#### 1-1. 행동을 합칠 수 있을 때\n+*빅-종빈빌런*의 행동을 [l,r]이라고 하면 l 을 오름차순으로 정렬한 후 이 l이 이전의 r에 포함되면 하나의 행동으로 합쳐버릴 수 있습니다.  \n+\n+```java\n+for(int i=0;i<=m;i++) {\n+\tint curl = arr[i].l;\n+\tint curr = arr[i].r;\n+\t\n+\tif(r < curl) { // 방이 하나가 될 수 없음( [...,r] - [...] - [curl,curr] )\n+\t\t// ...\n+\t}\n+\telse r = Math.max(r, curr); // [...,r]에 [curl,curr]이 포함되면 하나로 합침\n+}\n+```\n+\n+l을 오름차순으로 정렬했기 때문에 r의 범위는 계속해서 늘어날 수 있습니다. 그래서 하나의 행동으로 합쳐질 때 r은 더 큰범위로 확장됩니다.  \n+\n+#### 1-2. 행동을 합칠 수 없을 때\n+```java\n+for(int i=0;i<=m;i++) {\n+\tint curl = arr[i].l;\n+\tint curr = arr[i].r;\n+\t\n+\tif(r < curl) { // 방이 하나가 될 수 없음( [...,r] - [...] - [curl,curr] )\n+\t\tcnt += curl-r-1; // r 부터 curl 사이의 방의 개수\n+\t\tcnt++; // 다음으로 하나가 되는 방  ( [curl,r] )\n+\t\tr = curr; // 다음으로 하나가 되는 방의 끝 범위\n+\t}\n+\telse r = Math.max(r, curr); // [...,r]에 [curl,curr]이 포함되면 하나로 합침\n+}\n+```\n+\n+방을 합칠 수 없다면 현재 curl보다 작고 r보다 큰 방들은 벽이 부숴지지 않으므로 해당 방의 개수를 계산해줍니다.  \n+\n+그리고 다음으로 하나가 되는 방의 범위 [curl,r]은 하나가 될 것이므로 방의 개수를 하나 추가해줍니다.  \n+\n+이렇게 끝내면 마지막 [l,r]의 범위가 N을 포함하지 않으면  r ~ N사이의 방은 계산하지 못하므로 [n,n]범위를 가지는 행동을 더미로 넣어줍니다.  \n+\n+```java\n+p[] arr = new p[m+1]; // 종빈빌런의 행동\n+for(int i=0;i<m;i++) {\n+\tst = new StringTokenizer(br.readLine());\n+\tarr[i] = new p(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()));\n+}\n+arr[m] = new p(n,n); // 마지막 [curl,curr]을 처리하기 위해 dummy 넣음\n+```\n+\n+#### 코드\n+\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tint n = Integer.parseInt(br.readLine());\n+\t\tint m = Integer.parseInt(br.readLine());\n+\t\t\n+\t\tp[] arr = new p[m+1]; // 종빈빌런의 행동\n+\t\tfor(int i=0;i<m;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tarr[i] = new p(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()));\n+\t\t}\n+\t\tarr[m] = new p(n,n); // 마지막 [curl,curr]을 처리하기 위해 dummy 넣음\n+\t\t\n+\t\tArrays.sort(arr); // l을 기준으로 오름차순 정렬\n+\t\t\n+\t\tint r = 0;\n+\t\tint cnt = 0;\n+\t\tfor(int i=0;i<=m;i++) {\n+\t\t\tint curl = arr[i].l;\n+\t\t\tint curr = arr[i].r;\n+\t\t\t\n+\t\t\tif(r < curl) { // 방이 하나가 될 수 없음( [...,r] - [...] - [curl,curr] )\n+\t\t\t\tcnt += curl-r-1; // r 부터 curl 사이의 방의 개수\n+\t\t\t\tcnt++; // 다음으로 하나가 되는 방  ( [curl,r] )\n+\t\t\t\tr = curr; // 다음으로 하나가 되는 방의 끝 범위\n+\t\t\t}\n+\t\t\telse r = Math.max(r, curr); // [...,r]에 [curl,curr]이 포함되면 하나로 합침\n+\t\t}\n+\t\tSystem.out.println(cnt);\n+\t}\n+\t\n+\tstatic class p implements Comparable<p>{\n+\t\tint l,r;\n+\t\tpublic p(int l,int r) {\n+\t\t\tthis.l = l;\n+\t\t\tthis.r = r;\n+\t\t}\n+\t\t@Override\n+\t\tpublic int compareTo(p o) {\n+\t\t\treturn this.l-o.l;\n+\t\t}\n+\t}\n+}\n+```\n+\n+### 2. 유니온 파인드\n+방이 합쳐진다 -> 같은 집합이 된다라고 생각하면 유니온 파인드를 생각할 수 있습니다.  \n+\n+하지만 구체적인 방식이 떠오르지 않아서 위의 방법으로 푼 후 다른사람의 코드를 참고해서 풀었습니다.  \n+\n+보통 유니온 파인드는 하나의 집합으로 만드는것에만 집중해서 `union(a,b)`와 `union(b,a)`의 순서가 상관이 없습니다.  \n+\n+그러나 이 문제에서는 위에서 말씀드렸다시피 반복되는 행동은 할 필요가 없으므로 이걸 처리하는데 `union(a,b)`의 순서가 중요해집니다.  \n+\n+유니온 파인드를 이용해서 `[l,r]`을 하나의 집합으로 만들 때, `i=parent[l] to r parent[i] = parent[r]`로 만들면 이 `[l,r]` 집합의 `parent`는 가장 오른쪽 범위인 `parent[r]`을 가리키게 됩니다.  \n+\n+이렇게 모든 `[l,r]`을 합쳐주고 자신이 `parent`인 방의 개수를 세어주면 답이 됩니다.  \n+\n+#### 코드\n+\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic int[] parent = new int[1000001];\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tint n = Integer.parseInt(br.readLine());\n+\t\tint m = Integer.parseInt(br.readLine());\n+\t\tfor(int i=0;i<m;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint a = Integer.parseInt(st.nextToken());\n+\t\t\tint b = Integer.parseInt(st.nextToken());\n+\t\t\tint pa = find(a);\n+\t\t\tint pb = find(b);\n+\t\t\tfor(int j=pa;j<=b;j++) {\n+\t\t\t\tmerge(pb,j);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tint cnt = 0;\n+\t\tfor(int i=1;i<=n;i++) {\n+\t\t\tif(parent[i] == 0) cnt++;\n+\t\t}\n+\t\tSystem.out.println(cnt);\n+\t}\n+\t\n+\tstatic int find(int x) {\n+\t\tif(parent[x] == 0) return x;\n+\t\treturn parent[x] = find(parent[x]);\n+\t}\n+\t\n+\tstatic void merge(int pb,int j) {\n+\t\tint pj = find(j);\n+\t\tif(pb != pj) parent[pj] = pb;\n+\t}\n+}\n+```\n+\n+\n+\n+## ✅ 후기\n+유니온 파인드 문제라는걸 알아도 사용하기 까다로운 경우가 종종 있는데 이 문제가 살짝 그런종류였던 것 같습니다.  \n+1번 방법으로 풀 경우 정올 냉장고 문제와 비슷하다는 느낌을 받았습니다.  \n+"
  },
  {
    "sha": "ce93d4522feb55f3d13a61256be43705e05afb30",
    "filename": "lktgt15/BOJ/14000/14594/answer.java",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/14000/14594/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/14000/14594/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/14000/14594/answer.java?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,49 @@\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tint n = Integer.parseInt(br.readLine());\n+\t\tint m = Integer.parseInt(br.readLine());\n+\t\t\n+\t\tp[] arr = new p[m+1];\n+\t\tfor(int i=0;i<m;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tarr[i] = new p(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()));\n+\t\t}\n+\t\tarr[m] = new p(n,n); // 마지막 [curl,curr]을 처리하기 위해 dummy 넣음\n+\t\t\n+\t\tArrays.sort(arr); // l을 기준으로 오름차순 정렬\n+\t\t\n+\t\tint r = 0;\n+\t\tint cnt = 0;\n+\t\tfor(int i=0;i<=m;i++) {\n+\t\t\tint curl = arr[i].l;\n+\t\t\tint curr = arr[i].r;\n+\t\t\t\n+\t\t\tif(r < curl) { // 방이 하나가 될 수 없음( [...,r] - [...] - [curl,curr] )\n+\t\t\t\tcnt += curl-r-1; // r 부터 curl 사이의 방의 개수\n+\t\t\t\tcnt++; // 다음으로 하나가 되는 방  ( [curl,r] )\n+\t\t\t\tr = curr; // 다음으로 하나가 되는 방의 끝 범위\n+\t\t\t}\n+\t\t\telse r = Math.max(r, curr); // [...,r]에 [curl,curr]이 포함되면 하나로 합침\n+\t\t}\n+\t\tSystem.out.println(cnt);\n+\t}\n+\t\n+\tstatic class p implements Comparable<p>{\n+\t\tint l,r;\n+\t\tpublic p(int l,int r) {\n+\t\t\tthis.l = l;\n+\t\t\tthis.r = r;\n+\t\t}\n+\t\t@Override\n+\t\tpublic int compareTo(p o) {\n+\t\t\treturn this.l-o.l;\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "f1d6deef33b6b420d70943bf9f7aba3c2b5e6b6d",
    "filename": "lktgt15/BOJ/17000/17143/README.md",
    "status": "added",
    "additions": 339,
    "deletions": 0,
    "changes": 339,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/17000/17143/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/17000/17143/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/17000/17143/README.md?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,339 @@\n+# 17143번 낚시왕\n+[문제 보러가기](https://www.acmicpc.net/problem/17143)\n+\n+## 🅰 설계\n+처음 이 문제를 봤을때부터 한눈에 봐도 복잡해보여서 '언젠간 풀겠다'라고 생각하고 미뤄왔던 문제였습니다.  \n+\n+### 1. map과 update\n+\n+제가 생각한 방식은 map\\[r]\\[c]에 상어 객체를 넣어주는 것이었습니다.  \n+\n+모든 상어객체는 `List<shark> sharks`에 존재하고, map\\[r]\\[c]에는 해당 좌표에 존재하는 상어만 있게 됩니다.  \n+\n+상어 객체는 *크기*,*속력*과 같은 정보에 추가로 *dead*라는 정보도 포함됩니다. 이를 통해 유효한 상어에 대해서만 작업을 할 수 있게 됩니다.  \n+\n+이렇게 하면 낚시왕이 상어를 잡는 것을 구현할 때 직관적으로 열에서 한칸씩 내려가면서 상어를 잡을 수 있습니다.  \n+\n+문제는 상어가 움직일 때 모든 상어를 한번에 움직일 수 없다는 겁니다.  \n+\n+예를 들어 모든 상어가 움직일 때, map\\[1]\\[1]에 있던 상어를 움직여서 map\\[2]\\[1]에 도착했을 때 이미 map\\[2]\\[1]에 있는 상어는 원래 거기에 있던 상어인가? 아니면 움직여줘야 하는 상어인가? 를 생각해줘야 합니다.  \n+\n+원래 거기에 있던 상어라면 두 상어가 동시에 map\\[2]\\[1]에 존재하는 것이 가능합니다. 그게 아니고 방금 map\\[1]\\[1]에 있던 상어가 움직여서 온 것처럼 이번에 움직여서 map\\[2]\\[1]에 온 상어라면 크기가 큰 상어만 남겨야합니다.  \n+\n+이를 해결하는 방법은 2가지가 있을것 같습니다.  \n+\n+#### i. next map\\[r]\\[c]를 만든다\n+\n+현재 cur map\\[r]\\[c]에서 움직인 상어를 next map\\[r]\\[c]에 표시하고 이 next map을 cur map으로 바꿔주면 간단하게 해결할 수 있습니다.  \n+\n+#### ii. cur map\\[r]\\[c]에 추가로 updated\\[r]\\[c]를 만든다\n+\n+(r,c) 좌표에 업데이트된 시간을 표시하면 그 좌표에 있는 상어가 움직인 상어인지 움직여야하는 상어인지 판단할 수 있습니다.  \n+이렇게 하면 map\\[r]\\[c]에 추가로 updated\\[r]\\[c]까지 확인하여 그 (r,c)에 있는 상어가 유효한 상어인지 확인이 가능합니다.  \n+\n+```java\n+map = new shark[r][c];\n+updated = new int[r][c];\n+r--;\n+c--;\n+\n+for(int i=0;i<m;i++) {\n+\tst = new StringTokenizer(br.readLine());\n+\tint cr = Integer.parseInt(st.nextToken())-1;\n+\tint cc = Integer.parseInt(st.nextToken())-1;\n+\tint cs = Integer.parseInt(st.nextToken());\n+\tint cd = Integer.parseInt(st.nextToken());\n+\tint cz = Integer.parseInt(st.nextToken());\n+\tsharks.add(new shark(cr,cc,cs,cd,cz));\n+\tmap[cr][cc] = sharks.get(i);\n+\tupdated[cr][cc] = time;\n+}\n+```\n+제가 선택한 방법은 2번 방법입니다.  \n+\n+`List<shark> sharks`에 모든 상어를 넣고 `map[r][c]`에 그 좌표에 있는 상어 레퍼런스를 넣어주고 `updated[r][c]`에 업데이트된 시간을 표시합니다.  \n+\n+### 2. 행동 쪼개기\n+\n+직접 만들어야 할 행동들을 순서대로 쪼개보면 다음과 같습니다.  \n+\n+1. 낚시왕이 오른쪽으로 한 칸 움직인다.  \n+2. 낚시왕이 같은 열에 있는 상어 중 가장 가까운 상어를 잡는다.  \n+3. 모든 상어가 각각의 *속력*, *방향*을 가지고 움직인다.  \n+4. 만약 같은 칸에 상어가 있을 경우 크기가 큰 상어만 남는다.  \n+\n+```java\n+while(++fishking<=c) { // 낚시왕이 오른쪽으로 한칸 움직이고 격자판을 벗어나지 않음\n+\tkill(); // 낚시왕이 해당 열에서 가장 가까운 상어를 잡음\n+\ttime++; // updated 배열을 위한 시간 증가\n+\tmoveall(); // 모든 상어가 움직임\n+}\n+```\n+\n+이 부분만 떼어서 보면 위와 같은 코드가 됩니다.  \n+\n+### 2-1. kill()\n+\n+```java\n+static void kill() { // 낚시왕이 map[i = 0 to r][fishking]에서 상어를 잡음\n+\tfor(int i=0;i<=r;i++) {\n+\t\tif(map[i][fishking] != null && !map[i][fishking].dead && updated[i][fishking] == time) {\n+\t\t\tans += map[i][fishking].cz;\n+\t\t\tmap[i][fishking].dead = true;\n+\t\t\tmap[i][fishking] = null;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+```\n+낚시왕의 column에서 row를 늘려가면서 map\\[r]\\[c]에 상어가 죽은 상태가 아니고 updated\\[r]\\[c]가 현재 시간과 같다면 그 상어를 잡습니다.  \n+\n+### 2-2. moveall()\n+\n+```java\n+static void moveall() { // 죽은 상어가 아닌 모든 상어가 움직임\n+\tfor(shark sk : sharks) {\n+\t\tif(!sk.dead) {\n+\t\t\tsk.move();\n+\t\t}\n+\t}\n+}\n+```\n+상어 List에서 상어가 죽어있지 않으면 `move()`메소드를 호출합니다.  \n+\n+### 2-3. shark와 move()\n+```java\n+static class shark{\n+\tint cr,cc,cs,cd,cz;\n+\tboolean dead;\n+\tpublic shark(int cr,int cc,int cs,int cd,int cz) {\n+\t\tthis.cr = cr;\n+\t\tthis.cc = cc;\n+\t\tthis.cs = cs;\n+\t\tthis.cd = cd;\n+\t\tthis.cz = cz;\n+\t}\n+```\n+상어 List에 들어갈 shark 객체입니다. 각자 행,열,속도,방향,크기, 죽음 여부의 정보를 가지고 있습니다.  \n+\n+```java\n+public void move() {\n+\tif(cd == 1) { // up\n+\t\tint dr = Math.min(cr, cs); // 현재 방향의 끝 or 속도\n+\t\tcr -= dr; // 그만큼 이동\n+\t\tint tmpcs = cs - dr; // 이동한 뒤 남은 이동 수\n+\t\tif(tmpcs > 0) {\n+\t\t\tif((tmpcs/r)%2 == 0) { // r로 나눈 몫이 짝수면 현재 칸에서 남은만큼 이동\n+\t\t\t\tcd = 2;\n+\t\t\t\tcr = 0;\n+\t\t\t\tcr += tmpcs%r;\n+\t\t\t}\n+\t\t\telse { // r로 나눈 몫이 홀수면 현재 칸의 정반대쪽에서 남은만큼 이동\n+\t\t\t\tcd = 1;\n+\t\t\t\tcr = r;\n+\t\t\t\tcr -= tmpcs%r;\n+\t\t\t}\n+\t\t}\n+\t}\n+```\n+\n+`moveall()`에서 호출한 상어의 `move()`메소드입니다.  \n+\n+현재 방향의 끝까지 간 다음 남은 칸을 방향에 따라 row 또는 column으로 나누고 남은 나머지만큼 이동시키는 방법을 사용했습니다.  \n+\n+### 2-4 update와 fight\n+\n+```java\n+if(map[cr][cc] != null && !map[cr][cc].dead && updated[cr][cc] == time) { // 이동한 (r,c)에 업데이트된 상어가 있는지 확인\n+\tfight(map[cr][cc],this); // 크기가 큰 상어가 살아남음\n+}\n+else {\n+\tmap[cr][cc] = this; // 상어가 없으면 자신이 (r,c)에 남게됨\n+}\n+updated[cr][cc] = time; // updated[r][c]는 위의 결과와 관계없이 무조건 업데이트됨\n+```\n+위의 `move()`메소드에서 이어지는 코드입니다.  \n+\n+이동한 상어가 낚시왕의 `kill()`메소드와 같이 이동한 (r,c)에 상어가 있는지 확인하고 싸우게 됩니다.  \n+\n+```java\n+static void fight(shark a,shark b) {\n+\tif(a.cz > b.cz) b.dead = true; // a가 크면 b가 죽음\n+\telse { // b가 크면 a가 죽고 (r,c)에는 b가 남음\n+\t\ta.dead = true;\n+\t\tmap[a.cr][a.cc] = b;\n+\t}\n+}\n+```\n+\n+`fight(shark a,shark b)`는 크기가 큰 상어가 map\\[r]\\[c]에 남게 되는 메소드입니다.\n+\n+### 전체 코드\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic int r,c,m,time = 1,fishking = -1,ans;\n+\tstatic shark[][] map;\n+\tstatic int[][] updated;\n+\tstatic List<shark> sharks = new ArrayList<shark>();\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\tr = Integer.parseInt(st.nextToken());\n+\t\tc = Integer.parseInt(st.nextToken());\n+\t\tm = Integer.parseInt(st.nextToken());\n+\t\t\n+\t\tmap = new shark[r][c];\n+\t\tupdated = new int[r][c];\n+\t\tr--;\n+\t\tc--;\n+\t\t\n+\t\tfor(int i=0;i<m;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint cr = Integer.parseInt(st.nextToken())-1;\n+\t\t\tint cc = Integer.parseInt(st.nextToken())-1;\n+\t\t\tint cs = Integer.parseInt(st.nextToken());\n+\t\t\tint cd = Integer.parseInt(st.nextToken());\n+\t\t\tint cz = Integer.parseInt(st.nextToken());\n+\t\t\tsharks.add(new shark(cr,cc,cs,cd,cz));\n+\t\t\tmap[cr][cc] = sharks.get(i);\n+\t\t\tupdated[cr][cc] = time;\n+\t\t}\n+\t\t\n+\t\twhile(++fishking<=c) { // 낚시왕이 오른쪽으로 한칸 움직이고 격자판을 벗어나지 않음\n+\t\t\tkill(); // 낚시왕이 해당 열에서 가장 가까운 상어를 잡음\n+\t\t\ttime++; // updated 배열을 위한 시간 증가\n+\t\t\tmoveall(); // 모든 상어가 움직임\n+\t\t}\n+\t\tSystem.out.println(ans);\n+\t\t\n+\t}\n+\tstatic void moveall() { // 죽은 상어가 아닌 모든 상어가 움직임\n+\t\tfor(shark sk : sharks) {\n+\t\t\tif(!sk.dead) {\n+\t\t\t\tsk.move();\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic void kill() { // 낚시왕이 map[i = 0 to r][fishking]에서 상어를 잡음\n+\t\tfor(int i=0;i<=r;i++) {\n+\t\t\tif(map[i][fishking] != null && !map[i][fishking].dead && updated[i][fishking] == time) {\n+\t\t\t\tans += map[i][fishking].cz;\n+\t\t\t\tmap[i][fishking].dead = true;\n+\t\t\t\tmap[i][fishking] = null;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic class shark{\n+\t\tint cr,cc,cs,cd,cz;\n+\t\tboolean dead;\n+\t\tpublic shark(int cr,int cc,int cs,int cd,int cz) {\n+\t\t\tthis.cr = cr;\n+\t\t\tthis.cc = cc;\n+\t\t\tthis.cs = cs;\n+\t\t\tthis.cd = cd;\n+\t\t\tthis.cz = cz;\n+\t\t}\n+\t\t\n+\t\tpublic void move() {\n+\t\t\tif(cd == 1) { // up\n+\t\t\t\tint dr = Math.min(cr, cs);\n+\t\t\t\tcr -= dr;\n+\t\t\t\tint tmpcs = cs - dr;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/r)%2 == 0) {\n+\t\t\t\t\t\tcd = 2;\n+\t\t\t\t\t\tcr = 0;\n+\t\t\t\t\t\tcr += tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 1;\n+\t\t\t\t\t\tcr = r;\n+\t\t\t\t\t\tcr -= tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t}\n+\t\t\telse if(cd == 2) { // down\n+\t\t\t\tint dr = Math.min(r-cr, cs);\n+\t\t\t\tcr += dr;\n+\t\t\t\tint tmpcs = cs - dr;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/r)%2 == 0) {\n+\t\t\t\t\t\tcd = 1;\n+\t\t\t\t\t\tcr = r;\n+\t\t\t\t\t\tcr -= tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 2;\n+\t\t\t\t\t\tcr = 0;\n+\t\t\t\t\t\tcr += tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if(cd == 3) { // right\n+\t\t\t\tint dc = Math.min(c-cc, cs);\n+\t\t\t\tcc += dc;\n+\t\t\t\tint tmpcs = cs - dc;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/c)%2 == 0) {\n+\t\t\t\t\t\tcd = 4;\n+\t\t\t\t\t\tcc = c;\n+\t\t\t\t\t\tcc -= tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 3;\n+\t\t\t\t\t\tcc = 0;\n+\t\t\t\t\t\tcc += tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse { // left\n+\t\t\t\tint dc = Math.min(cc, cs);\n+\t\t\t\tcc -= dc;\n+\t\t\t\tint tmpcs = cs - dc;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/c)%2 == 0) {\n+\t\t\t\t\t\tcd = 3;\n+\t\t\t\t\t\tcc = 0;\n+\t\t\t\t\t\tcc += tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 4;\n+\t\t\t\t\t\tcc = c;\n+\t\t\t\t\t\tcc -= tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(map[cr][cc] != null && !map[cr][cc].dead && updated[cr][cc] == time) { // 이동한 (r,c)에 업데이트된 상어가 있는지 확인\n+\t\t\t\tfight(map[cr][cc],this); // 크기가 큰 상어가 살아남음\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tmap[cr][cc] = this; // 상어가 없으면 자신이 (r,c)에 남게됨\n+\t\t\t}\n+\t\t\tupdated[cr][cc] = time; // updated[r][c]는 위의 결과와 관계없이 무조건 업데이트됨\n+\t\t}\n+\t}\n+\t\n+\tstatic void fight(shark a,shark b) {\n+\t\tif(a.cz > b.cz) b.dead = true; // a가 크면 b가 죽음\n+\t\telse { // b가 크면 a가 죽고 (r,c)에는 b가 남음\n+\t\t\ta.dead = true;\n+\t\t\tmap[a.cr][a.cc] = b;\n+\t\t}\n+\t}\n+}\n+```\n+\n+## ✅ 후기\n+처음에 딱 보고 쉽지않겠다 라고 생각했던 문제였습니다. 그러나 문제를 잘게 쪼개서 생각해보면 어려웠던 부분은 `move()`가 전부인 그런 문제였습니다. 이렇게 척 보고 쉽지 않아보이는 문제를 풀었을 때 더 성장하는 부분이 많은것 같습니다.  \n+\n+"
  },
  {
    "sha": "e73adf3d82a52214289a02109201b180d9782748",
    "filename": "lktgt15/BOJ/17000/17143/answer.java",
    "status": "added",
    "additions": 161,
    "deletions": 0,
    "changes": 161,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/17000/17143/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/17000/17143/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/17000/17143/answer.java?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,161 @@\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic int r,c,m,time = 1,fishking = -1,ans;\n+\tstatic shark[][] map;\n+\tstatic int[][] updated;\n+\tstatic List<shark> sharks = new ArrayList<shark>();\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tst = new StringTokenizer(br.readLine());\n+\t\tr = Integer.parseInt(st.nextToken());\n+\t\tc = Integer.parseInt(st.nextToken());\n+\t\tm = Integer.parseInt(st.nextToken());\n+\t\t\n+\t\tmap = new shark[r][c];\n+\t\tupdated = new int[r][c];\n+\t\tr--;\n+\t\tc--;\n+\t\t\n+\t\tfor(int i=0;i<m;i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint cr = Integer.parseInt(st.nextToken())-1;\n+\t\t\tint cc = Integer.parseInt(st.nextToken())-1;\n+\t\t\tint cs = Integer.parseInt(st.nextToken());\n+\t\t\tint cd = Integer.parseInt(st.nextToken());\n+\t\t\tint cz = Integer.parseInt(st.nextToken());\n+\t\t\tsharks.add(new shark(cr,cc,cs,cd,cz));\n+\t\t\tmap[cr][cc] = sharks.get(i);\n+\t\t\tupdated[cr][cc] = time;\n+\t\t}\n+\t\t\n+\t\twhile(++fishking<=c) { // 낚시왕이 오른쪽으로 한칸 움직이고 격자판을 벗어나지 않음\n+\t\t\tkill(); // 낚시왕이 해당 열에서 가장 가까운 상어를 잡음\n+\t\t\ttime++; // updated 배열을 위한 시간 증가\n+\t\t\tmoveall(); // 모든 상어가 움직임\n+\t\t}\n+\t\tSystem.out.println(ans);\n+\t\t\n+\t}\n+\tstatic void moveall() { // 죽은 상어가 아닌 모든 상어가 움직임\n+\t\tfor(shark sk : sharks) {\n+\t\t\tif(!sk.dead) {\n+\t\t\t\tsk.move();\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic void kill() { // 낚시왕이 map[i = 0 to r][fishking]에서 상어를 잡음\n+\t\tfor(int i=0;i<=r;i++) {\n+\t\t\tif(map[i][fishking] != null && !map[i][fishking].dead && updated[i][fishking] == time) {\n+\t\t\t\tans += map[i][fishking].cz;\n+\t\t\t\tmap[i][fishking].dead = true;\n+\t\t\t\tmap[i][fishking] = null;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tstatic class shark{\n+\t\tint cr,cc,cs,cd,cz;\n+\t\tboolean dead;\n+\t\tpublic shark(int cr,int cc,int cs,int cd,int cz) {\n+\t\t\tthis.cr = cr;\n+\t\t\tthis.cc = cc;\n+\t\t\tthis.cs = cs;\n+\t\t\tthis.cd = cd;\n+\t\t\tthis.cz = cz;\n+\t\t}\n+\t\t\n+\t\tpublic void move() {\n+\t\t\tif(cd == 1) { // up\n+\t\t\t\tint dr = Math.min(cr, cs);\n+\t\t\t\tcr -= dr;\n+\t\t\t\tint tmpcs = cs - dr;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/r)%2 == 0) {\n+\t\t\t\t\t\tcd = 2;\n+\t\t\t\t\t\tcr = 0;\n+\t\t\t\t\t\tcr += tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 1;\n+\t\t\t\t\t\tcr = r;\n+\t\t\t\t\t\tcr -= tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t}\n+\t\t\telse if(cd == 2) { // down\n+\t\t\t\tint dr = Math.min(r-cr, cs);\n+\t\t\t\tcr += dr;\n+\t\t\t\tint tmpcs = cs - dr;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/r)%2 == 0) {\n+\t\t\t\t\t\tcd = 1;\n+\t\t\t\t\t\tcr = r;\n+\t\t\t\t\t\tcr -= tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 2;\n+\t\t\t\t\t\tcr = 0;\n+\t\t\t\t\t\tcr += tmpcs%r;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if(cd == 3) { // right\n+\t\t\t\tint dc = Math.min(c-cc, cs);\n+\t\t\t\tcc += dc;\n+\t\t\t\tint tmpcs = cs - dc;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/c)%2 == 0) {\n+\t\t\t\t\t\tcd = 4;\n+\t\t\t\t\t\tcc = c;\n+\t\t\t\t\t\tcc -= tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 3;\n+\t\t\t\t\t\tcc = 0;\n+\t\t\t\t\t\tcc += tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse { // left\n+\t\t\t\tint dc = Math.min(cc, cs);\n+\t\t\t\tcc -= dc;\n+\t\t\t\tint tmpcs = cs - dc;\n+\t\t\t\tif(tmpcs > 0) {\n+\t\t\t\t\tif((tmpcs/c)%2 == 0) {\n+\t\t\t\t\t\tcd = 3;\n+\t\t\t\t\t\tcc = 0;\n+\t\t\t\t\t\tcc += tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tcd = 4;\n+\t\t\t\t\t\tcc = c;\n+\t\t\t\t\t\tcc -= tmpcs%c;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(map[cr][cc] != null && !map[cr][cc].dead && updated[cr][cc] == time) { // 이동한 (r,c)에 업데이트된 상어가 있는지 확인\n+\t\t\t\tfight(map[cr][cc],this); // 크기가 큰 상어가 살아남음\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tmap[cr][cc] = this; // 상어가 없으면 자신이 (r,c)에 남게됨\n+\t\t\t}\n+\t\t\tupdated[cr][cc] = time; // updated[r][c]는 위의 결과와 관계없이 무조건 업데이트됨\n+\t\t}\n+\t}\n+\t\n+\tstatic void fight(shark a,shark b) {\n+\t\tif(a.cz > b.cz) b.dead = true; // a가 크면 b가 죽음\n+\t\telse { // b가 크면 a가 죽고 (r,c)에는 b가 남음\n+\t\t\ta.dead = true;\n+\t\t\tmap[a.cr][a.cc] = b;\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "36c3873ae8a175c912e2c2a2dc439872751ef84a",
    "filename": "lktgt15/BOJ/9000/9020/README.md",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "changes": 87,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/9000/9020/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/9000/9020/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/9000/9020/README.md?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,87 @@\n+# 9020번 골드바흐의 추측\n+[문제 보러가기](https://www.acmicpc.net/problem/9020)\n+\n+## 🅰 설계\n+10000 이하의 소수를 먼저 구해놓고 탐색을 돌리면 되는데, 저는 이분탐색을 사용했습니다.  \n+\n+### 1. 소수 구하기\n+```java\n+for(int i=2;i<=LIMIT;i++) {\n+\tif(!chk[i]) {\n+\t\tprimes.add(i);\n+\t\tfor(int j=i*2;j<=LIMIT;j+=i) {\n+\t\t\tchk[j] = true;\n+\t\t}\n+\t}\n+}\n+```\n+\n+에라토스테네스의 체를 이용해서 primes 리스트를 만듭니다.  \n+\n+### 2. 골드바흐 파티션 만들기\n+```java\n+int n = Integer.parseInt(br.readLine());\n+int a = 0;\n+int b = Integer.MAX_VALUE;\n+for(int i=0;i<primes.size();i++) {\n+\tif(primes.get(i) > n/2) break;\n+\tint idx = Collections.binarySearch(primes, n-primes.get(i));\n+\tif(idx>=0) {\n+\t\ta = primes.get(i);\n+\t\tb = primes.get(idx);\n+\t}\n+}\n+System.out.println(a+\" \"+b);\n+```\n+**n-primes.get(i)**라는 원소가 primes에 존재하는지 이분탐색을 통해 알아냅니다.  \n+idx가 음수면 **primes.get(i)**로는 골드바흐 파티션을 만들 수 없습니다.  \n+\n+### 3. 전체코드\n+```java\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic List<Integer> primes = new ArrayList<>();\n+\tstatic boolean[] chk = new boolean[10001];\n+\tstatic int LIMIT = 10000;\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tfor(int i=2;i<=LIMIT;i++) {\n+\t\t\tif(!chk[i]) {\n+\t\t\t\tprimes.add(i);\n+\t\t\t\tfor(int j=i*2;j<=LIMIT;j+=i) {\n+\t\t\t\t\tchk[j] = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tint t = Integer.parseInt(br.readLine());\n+\t\tfor(int i=0;i<t;i++) solve();\n+\t}\n+\t\n+\tstatic void solve() throws IOException {\n+\t\t\n+\t\tint n = Integer.parseInt(br.readLine());\n+\t\tint a = 0;\n+\t\tint b = Integer.MAX_VALUE;\n+\t\tfor(int i=0;i<primes.size();i++) {\n+\t\t\tif(primes.get(i) > n/2) break;\n+\t\t\tint idx = Collections.binarySearch(primes, n-primes.get(i));\n+\t\t\tif(idx>=0) {\n+\t\t\t\ta = primes.get(i);\n+\t\t\t\tb = primes.get(idx);\n+\t\t\t}\n+\t\t}\n+\t\tSystem.out.println(a+\" \"+b);\n+\t}\n+}\n+```\n+\n+\n+## ✅ 후기\n+다른 사람들은 `primes`리스트가 아니라 boolean 배열으로 isPrime을 만들고 n/2부터 투포인터같은 느낌으로 한번에 찾을 수 있게 풀던데 굉장히 좋은것 같습니다.  \n+"
  },
  {
    "sha": "db492eba15c1486de30ee02c7012bacca92a807b",
    "filename": "lktgt15/BOJ/9000/9020/answer.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/9000/9020/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/763e1cd0ce42ad08ef13ab6817736566a1d41c48/lktgt15/BOJ/9000/9020/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/lktgt15/BOJ/9000/9020/answer.java?ref=763e1cd0ce42ad08ef13ab6817736566a1d41c48",
    "patch": "@@ -0,0 +1,41 @@\n+import java.io.*;\n+import java.util.*;\n+\n+public class Main {\n+\tstatic BufferedReader br;\n+\tstatic StringTokenizer st;\n+\n+\tstatic List<Integer> primes = new ArrayList<>();\n+\tstatic boolean[] chk = new boolean[10001];\n+\tstatic int LIMIT = 10000;\n+\tpublic static void main(String[] args) throws IOException {\n+\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n+\t\tfor(int i=2;i<=LIMIT;i++) {\n+\t\t\tif(!chk[i]) {\n+\t\t\t\tprimes.add(i);\n+\t\t\t\tfor(int j=i*2;j<=LIMIT;j+=i) {\n+\t\t\t\t\tchk[j] = true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tint t = Integer.parseInt(br.readLine());\n+\t\tfor(int i=0;i<t;i++) solve();\n+\t}\n+\t\n+\tstatic void solve() throws IOException {\n+\t\t\n+\t\tint n = Integer.parseInt(br.readLine());\n+\t\tint a = 0;\n+\t\tint b = Integer.MAX_VALUE;\n+\t\tfor(int i=0;i<primes.size();i++) {\n+\t\t\tif(primes.get(i) > n/2) break;\n+\t\t\tint idx = Collections.binarySearch(primes, n-primes.get(i));\n+\t\t\tif(idx>=0) {\n+\t\t\t\ta = primes.get(i);\n+\t\t\t\tb = primes.get(idx);\n+\t\t\t}\n+\t\t}\n+\t\tSystem.out.println(a+\" \"+b);\n+\t}\n+}\n\\ No newline at end of file"
  }
]
