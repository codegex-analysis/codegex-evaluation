[
  {
    "sha": "b30d072dde19ac1302ae8a982cd23e2bd083048b",
    "filename": "JoEuiSang/BOJ/1000/1991_재귀/README.md",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md?ref=abbbf4c06cd84b94ae4e93f2db3b1241942b666d",
    "patch": "@@ -0,0 +1,88 @@\n+# 1991 트리 순회\n+[문제 보러가기](https://www.acmicpc.net/problem/1991)\n+\n+## 🅰 설계\n+1. 각 노드의 값, 자식들에 대한 정보를 나타내는 Node 클래스를 사용했습니다.\n+2. 각 알파벳을 A : 1 ~ Z: 26 인덱스값으로 가지고 자신의 자식을 나타내는 배열을 활용하였습니다.\n+\n+\n+\n+\n+## 주요 코드 설명\n+### 알파벳 노드 클래스\n+```java\n+class Node {\n+\tint root, left, right;\n+\n+\tpublic Node(int root, int left, int right) {\n+\t\tsuper();\n+\t\tthis.root = root;\n+\t\tthis.left = left;\n+\t\tthis.right = right;\n+\t}\n+\n+}\n+```\n+\n+\n+\n+\n+### 알파벳 노드간의 관계 생성하기\n+\n+```java\n+for (int tc = 1; tc <= N; tc++) {\n+    st = new StringTokenizer(br.readLine());\n+    int idx = st.nextToken().charAt(0) - 'A' + 1; // . : -18 A~Z : 1~26\n+    int left = st.nextToken().charAt(0) - 'A' + 1;\n+    int right = st.nextToken().charAt(0) - 'A' + 1;\n+\n+    tree[idx] = new Node(idx, left, right);\n+}\n+```\n+\n+\n+\n+### 전위순회\n+\n+```java\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+\n+if (left > 0) {// 왼쪽자식이 있으면\n+    preOrder(tree, left);\n+}\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    preOrder(tree, right);\n+}\n+```\n+\n+### 후위순회\n+\n+```java\n+if (left > 0) {// 왼쪽자식이 있으면\n+\t\t\tpostOrder(tree, left);\n+}\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    postOrder(tree, right);\n+}\n+\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+```\n+\n+### 중위순회\n+\n+```java\n+if (left > 0) {// 왼쪽자식이 있으면\n+    inOrder(tree, left);\n+}\n+\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    inOrder(tree, right);\n+}\n+```\n+\n+## ✅ 후기\n+### 특별히 어려웠던 점은 없었고 캐릭터타입과 아스키 코드값을 변환하는게 좀 헷갈렸습니다.\n\\ No newline at end of file"
  },
  {
    "sha": "68ace60221083dcb5918b604027c12f26a9b1080",
    "filename": "JoEuiSang/BOJ/1000/1991_재귀/answer.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java?ref=abbbf4c06cd84b94ae4e93f2db3b1241942b666d",
    "patch": "@@ -0,0 +1,114 @@\n+package _3월_1주차;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.StringTokenizer;\n+\n+class Node {\n+\tint root, left, right;\n+\n+\tpublic Node(int root, int left, int right) {\n+\t\tsuper();\n+\t\tthis.root = root;\n+\t\tthis.left = left;\n+\t\tthis.right = right;\n+\t}\n+\n+}\n+\n+public class Boj1991트리순회 {\n+\tstatic int N;\n+\tstatic StringBuilder sb = new StringBuilder();\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st;\n+\n+\t\tN = Integer.parseInt(br.readLine());\n+\t\tNode[] tree = new Node[32];\n+\n+\t\ttree[1] = new Node(1, 2, 3);\n+\t\tfor (int tc = 1; tc <= N; tc++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint idx = st.nextToken().charAt(0) - 'A' + 1; // . : -18 A~Z : 1~26\n+\t\t\tint left = st.nextToken().charAt(0) - 'A' + 1;\n+\t\t\tint right = st.nextToken().charAt(0) - 'A' + 1;\n+\n+\t\t\ttree[idx] = new Node(idx, left, right);\n+\n+\t\t}\n+\t\tpreOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t\tsb.setLength(0);\n+\t\tinOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t\tsb.setLength(0);\n+\t\tpostOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t}\n+\n+\t// 전위 : 루트가 먼저\n+\tpublic static void preOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\t\tif (idx < 32) {\n+\t\t\tchar a = (char) (tree[idx].root + 'A' - 1);\n+\t\t\tsb.append(a);\n+\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tpreOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tpreOrder(tree, right);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\n+\t}\n+\n+\t// 후위\n+\tpublic static void postOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\n+\t\tif (right < 32) { // 트리범위 안에있으면\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tpostOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tpostOrder(tree, right);\n+\t\t\t}\n+\n+\t\t\tsb.append((char) (tree[idx].root + 'A' - 1));\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t// 중위 : root가 중간\n+\tpublic static void inOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\n+\t\tif (right < 32) { // 트리범위 안에있으면\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tinOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tsb.append((char) (tree[idx].root + 'A' - 1));\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tinOrder(tree, right);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+}"
  },
  {
    "sha": "7a1f5ab5df47482c1de70079caffe3dbef9697de",
    "filename": "JoEuiSang/BOJ/2000/2533_dp/README.md",
    "status": "added",
    "additions": 66,
    "deletions": 0,
    "changes": 66,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/2000/2533_dp/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/2000/2533_dp/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/2000/2533_dp/README.md?ref=abbbf4c06cd84b94ae4e93f2db3b1241942b666d",
    "patch": "@@ -0,0 +1,66 @@\n+# 2533 사회망 서비스(SNS)\n+[문제 보러가기](https://www.acmicpc.net/problem/2533)\n+\n+## 🅰 설계\n+\n+다음 사람이 얼리어답터가 될 수 있는 조건을 생각해보았습니다.\n+\n+1. 본인이 얼리어답터가 아니라면 친구는 무조건 얼리어답터이다.\n+2. 본인이 얼리어답터이면 친구는 뭐가되든 상관없다.\n+\n+\n+\n+위 조건을 고려하여, 시작노드가 얼리어답터일 때와 레이트어답터일 때의 2가지 경우를 나누어 풀이하는 문제입니다.\n+\n+\n+\n+\n+## 주요 코드 설명\n+### 친구관계 생성\n+```java\n+static LinkedList<Integer>[] graph;\t\t//각 노드들의 연결정보\t\n+\n+//그래프 관계 생성\n+for (int i = 0; i < N - 1; i++) {\n+    st = new StringTokenizer(br.readLine());\n+    int u = Integer.parseInt(st.nextToken());\n+    int v = Integer.parseInt(st.nextToken());\n+    graph[u].add(v);\n+    graph[v].add(u);\n+}\n+```\n+\n+\n+\n+### dfs를 통해 dp구현, 친구의 상태를 최소값으로 처리합니다.\n+\n+```java\n+private static void dfs(int value) {\n+    visited[value] = true;\t\t//방문처리\n+    dp[value][EARLY] = EARLY;\t//얼리어답터 1처리\n+    dp[value][LATE] = LATE;\t\t//레이트어답터 0처리\n+\n+    //현재 노드의 연결링크들 모두 확인\n+    for (int link : graph[value]) {\n+        //이미 방문한곳이면 패스\n+        if (visited[link])\n+            continue;\n+        dfs(link);\t//재귀\n+        \n+        //내가 얼리어답터면 다음 친구는 얼리어답터 또는 레이트어답터가 될 수 있다.\n+        dp[value][EARLY] += Math.min(dp[link][EARLY], dp[link][LATE]);\t\n+        \n+        //내가 레이트어답터면 다음친구는 무조건 얼리어답터여야한다.\n+        dp[value][LATE] += dp[link][EARLY];\t\t\t\t\t\t\t\t\n+    }\n+}\n+```\n+\n+\n+\n+## ✅ 후기\n+\n+#### 설명이 다소 부족하다고 느껴지는데요.. 잘 모르겠어서 아이디어를 살짝 보고 풀었습니다.\n+#### 이해한거 같으면서도 완벽하게 이해한거 같지 않은듯한 느낌이 듭니다.\n+#### 메모리를 상당히 많이 잡아먹는데 좀 더 고민해볼 필요성이 있습니다.\n+#### DP 문제를 풀면 항상 문제한테 지는 느낌이 듭니다. 대충 어떻게 접근해야겠다라는 생각조차도 들지 않으니 말이에요.. 다양한 문제를 풀면서 실력을 키워나가야 겠습니다..\n\\ No newline at end of file"
  },
  {
    "sha": "997984160ec09d86ba0195dc7750e071eaf30b42",
    "filename": "JoEuiSang/BOJ/2000/2533_dp/answer.java",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/2000/2533_dp/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/abbbf4c06cd84b94ae4e93f2db3b1241942b666d/JoEuiSang/BOJ/2000/2533_dp/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/2000/2533_dp/answer.java?ref=abbbf4c06cd84b94ae4e93f2db3b1241942b666d",
    "patch": "@@ -0,0 +1,56 @@\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.LinkedList;\n+import java.util.StringTokenizer;\n+\n+public class Main {\n+\tstatic int N;\t\n+\tstatic boolean[] visited;\t\t\t\t//방문 체크 배열\n+\tstatic LinkedList<Integer>[] graph;\t\t//각 노드들의 연결정보\t\t\n+\tstatic int[][] dp;\t\t\t\t\t\t//얼리어답터일때와, 아닐때의 최소값을 저장할 DP배열\n+\tstatic final int EARLY = 1, LATE = 0;\t//얼리와, 레이트의 상수\n+\n+\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st;\n+\t\tN = Integer.parseInt(br.readLine());\n+\t\tvisited = new boolean[N + 1];\n+\t\tgraph = new LinkedList[N + 1];\n+\t\tdp = new int[N + 1][2];\n+\n+\t\tfor (int i = 0; i < N + 1; i++) {\n+\t\t\tgraph[i] = new LinkedList<>();\t\t//그래프 초기화\n+\t\t}\n+\n+\t\t//그래프 관계 생성\n+\t\tfor (int i = 0; i < N - 1; i++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint u = Integer.parseInt(st.nextToken());\n+\t\t\tint v = Integer.parseInt(st.nextToken());\n+\t\t\tgraph[u].add(v);\n+\t\t\tgraph[v].add(u);\n+\t\t}\n+\n+\t\t//시작\n+\t\tdfs(1);\n+\n+\t\tSystem.out.println(Math.min(dp[1][EARLY], dp[1][LATE]));\n+\t}\n+\n+\tprivate static void dfs(int value) {\n+\t\tvisited[value] = true;\t\t//방문처리\n+\t\tdp[value][EARLY] = EARLY;\t//얼리어답터 1처리\n+\t\tdp[value][LATE] = LATE;\t\t//레이트어답터 0처리\n+\n+\t\t//현재 노드의 연결링크들 모두 확인\n+\t\tfor (int link : graph[value]) {\n+\t\t\t//이미 방문한곳이면 패스\n+\t\t\tif (visited[link])\n+\t\t\t\tcontinue;\n+\t\t\tdfs(link);\t//재귀\n+\t\t\tdp[value][EARLY] += Math.min(dp[link][EARLY], dp[link][LATE]);\t//내가 얼리어답터면 다음 친구는 얼리어답터 또는 레이트어답터가 될 수 있다.\n+\t\t\tdp[value][LATE] += dp[link][EARLY];\t\t\t\t\t\t\t\t//내가 레이트어답터면 다음친구는 무조건 얼리어답터여야한다.\n+\t\t}\n+\t}\n+}"
  }
]
