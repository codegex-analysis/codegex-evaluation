[
  {
    "sha": "b30d072dde19ac1302ae8a982cd23e2bd083048b",
    "filename": "JoEuiSang/BOJ/1000/1991_재귀/README.md",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/README.md?ref=bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4",
    "patch": "@@ -0,0 +1,88 @@\n+# 1991 트리 순회\n+[문제 보러가기](https://www.acmicpc.net/problem/1991)\n+\n+## 🅰 설계\n+1. 각 노드의 값, 자식들에 대한 정보를 나타내는 Node 클래스를 사용했습니다.\n+2. 각 알파벳을 A : 1 ~ Z: 26 인덱스값으로 가지고 자신의 자식을 나타내는 배열을 활용하였습니다.\n+\n+\n+\n+\n+## 주요 코드 설명\n+### 알파벳 노드 클래스\n+```java\n+class Node {\n+\tint root, left, right;\n+\n+\tpublic Node(int root, int left, int right) {\n+\t\tsuper();\n+\t\tthis.root = root;\n+\t\tthis.left = left;\n+\t\tthis.right = right;\n+\t}\n+\n+}\n+```\n+\n+\n+\n+\n+### 알파벳 노드간의 관계 생성하기\n+\n+```java\n+for (int tc = 1; tc <= N; tc++) {\n+    st = new StringTokenizer(br.readLine());\n+    int idx = st.nextToken().charAt(0) - 'A' + 1; // . : -18 A~Z : 1~26\n+    int left = st.nextToken().charAt(0) - 'A' + 1;\n+    int right = st.nextToken().charAt(0) - 'A' + 1;\n+\n+    tree[idx] = new Node(idx, left, right);\n+}\n+```\n+\n+\n+\n+### 전위순회\n+\n+```java\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+\n+if (left > 0) {// 왼쪽자식이 있으면\n+    preOrder(tree, left);\n+}\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    preOrder(tree, right);\n+}\n+```\n+\n+### 후위순회\n+\n+```java\n+if (left > 0) {// 왼쪽자식이 있으면\n+\t\t\tpostOrder(tree, left);\n+}\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    postOrder(tree, right);\n+}\n+\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+```\n+\n+### 중위순회\n+\n+```java\n+if (left > 0) {// 왼쪽자식이 있으면\n+    inOrder(tree, left);\n+}\n+\n+sb.append((char) (tree[idx].root + 'A' - 1));\n+\n+if (right > 0) {// 오른쪽 자식이 있으면\n+    inOrder(tree, right);\n+}\n+```\n+\n+## ✅ 후기\n+### 특별히 어려웠던 점은 없었고 캐릭터타입과 아스키 코드값을 변환하는게 좀 헷갈렸습니다.\n\\ No newline at end of file"
  },
  {
    "sha": "68ace60221083dcb5918b604027c12f26a9b1080",
    "filename": "JoEuiSang/BOJ/1000/1991_재귀/answer.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/ssafy-algoga/algorithm-study/blob/bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java",
    "raw_url": "https://github.com/ssafy-algoga/algorithm-study/raw/bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java",
    "contents_url": "https://api.github.com/repos/ssafy-algoga/algorithm-study/contents/JoEuiSang/BOJ/1000/1991_%EC%9E%AC%EA%B7%80/answer.java?ref=bef8a1b6304f7c7d1b808bc9279c6fe9d87efec4",
    "patch": "@@ -0,0 +1,114 @@\n+package _3월_1주차;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.util.StringTokenizer;\n+\n+class Node {\n+\tint root, left, right;\n+\n+\tpublic Node(int root, int left, int right) {\n+\t\tsuper();\n+\t\tthis.root = root;\n+\t\tthis.left = left;\n+\t\tthis.right = right;\n+\t}\n+\n+}\n+\n+public class Boj1991트리순회 {\n+\tstatic int N;\n+\tstatic StringBuilder sb = new StringBuilder();\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+\t\tStringTokenizer st;\n+\n+\t\tN = Integer.parseInt(br.readLine());\n+\t\tNode[] tree = new Node[32];\n+\n+\t\ttree[1] = new Node(1, 2, 3);\n+\t\tfor (int tc = 1; tc <= N; tc++) {\n+\t\t\tst = new StringTokenizer(br.readLine());\n+\t\t\tint idx = st.nextToken().charAt(0) - 'A' + 1; // . : -18 A~Z : 1~26\n+\t\t\tint left = st.nextToken().charAt(0) - 'A' + 1;\n+\t\t\tint right = st.nextToken().charAt(0) - 'A' + 1;\n+\n+\t\t\ttree[idx] = new Node(idx, left, right);\n+\n+\t\t}\n+\t\tpreOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t\tsb.setLength(0);\n+\t\tinOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t\tsb.setLength(0);\n+\t\tpostOrder(tree, 1);\n+\t\tSystem.out.println(sb);\n+\t}\n+\n+\t// 전위 : 루트가 먼저\n+\tpublic static void preOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\t\tif (idx < 32) {\n+\t\t\tchar a = (char) (tree[idx].root + 'A' - 1);\n+\t\t\tsb.append(a);\n+\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tpreOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tpreOrder(tree, right);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\n+\t}\n+\n+\t// 후위\n+\tpublic static void postOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\n+\t\tif (right < 32) { // 트리범위 안에있으면\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tpostOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tpostOrder(tree, right);\n+\t\t\t}\n+\n+\t\t\tsb.append((char) (tree[idx].root + 'A' - 1));\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t// 중위 : root가 중간\n+\tpublic static void inOrder(Node[] tree, int idx) {\n+\t\tint left = tree[idx].left;\n+\t\tint right = tree[idx].right;\n+\n+\n+\t\tif (right < 32) { // 트리범위 안에있으면\n+\t\t\tif (left > 0) {// 왼쪽자식이 있으면\n+\t\t\t\tinOrder(tree, left);\n+\t\t\t}\n+\n+\t\t\tsb.append((char) (tree[idx].root + 'A' - 1));\n+\n+\t\t\tif (right > 0) {// 오른쪽 자식이 있으면\n+\t\t\t\tinOrder(tree, right);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+}"
  }
]
