[
  {
    "sha": "32422faf284a127243907b2b2deaf2cfb046065a",
    "filename": ".travis.yml",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/.travis.yml",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/.travis.yml",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/.travis.yml?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -7,6 +7,7 @@ language:\n \n jdk:\n   - openjdk11\n+node_js: 12.16\n \n sudo: false\n \n@@ -24,6 +25,9 @@ cache:\n     - gradle-container\n \n before_install:\n+  # Switch to newer NodeJS to prevent SNYK scan issues\n+  - nvm install v12.16.0\n+  - nvm use v12.16.0\n   # Get used Gradle version and download URL from file 'gradle-wrapper.properties'\n   - while IFS='=' read -r key value; do key=$(echo $key | tr '.' '_'); eval ${key}=\\${value}; done < \"gradle/wrapper/gradle-wrapper.properties\"; gradleUrl=$(echo ${distributionUrl} | tr -d \\\\)\n   # Get gradle zip file name and gradle directory name"
  },
  {
    "sha": "5f4ae5a0436e48862929ef3f075f94b349c0ea44",
    "filename": "README.md",
    "status": "modified",
    "additions": 239,
    "deletions": 224,
    "changes": 463,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/README.md",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/README.md",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/README.md?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -13,29 +13,29 @@ For Maven users please add this section to your dependencies list\n <dependency>\n   <groupId>com.incountry</groupId>\n   <artifactId>incountry-java-client</artifactId>\n-  <version>3.1.0</version>\n+  <version>3.4.0</version>\n </dependency>\n ```\n \n For Gradle users please add this line to your dependencies list\n ```groovy\n-compile \"com.incountry:incountry-java-client:3.0.0\"\n+compile \"com.incountry:incountry-java-client:3.4.0\"\n ```\n \n ## Countries List\n For a full list of supported countries and their codes please [follow this link](countries.md).\n \n \n ## Quickstart guide\n-To access your data in InCountry Platform by using Java SDK, you need to create an instance of the `Storage` class using the `getInstance` method and pass `StorageConfig` object to it. You can retrieve the `CLIENT_ID`, `CLIENT_SECRET` and `ENV_ID` variables from your dashboard on InCountry Portal.\n+To access your data in InCountry Platform by using Java SDK, you need to create an instance of the `Storage` class using the `getInstance` method and pass `StorageConfig` object to it. You can retrieve the `clientId`, `clientSecret` and `environmentId` values from your dashboard on InCountry Portal.\n ```java\n SecretsData secretsData = SecretsDataGenerator.fromPassword(\"<encryption_secret>\");\n StorageConfig config = new StorageConfig()\n-        .setEnvId(\"<environment_id>\")\n-        .setClientId(\"client_id\")\n+        .setEnvironmentId(\"<environment_id>\")\n+        .setClientId(\"<client_id>\")\n         .setClientSecret(\"<client_secret>\")\n         .setSecretKeyAccessor(() -> secretsData);\n-Storage storage = StorageImpl.getInstance(config);\n+Storage storage = StorageImpl.newStorage(config);\n ```\n \n ## Storage Configuration\n@@ -44,14 +44,15 @@ Below you can find a full list of possible configuration options for creating a\n ```java\n public class StorageImpl implements Storage {\n   /**\n-   * creating Storage instance\n+   * create new Storage instance\n    *\n    * @param config A container with configuration for Storage initialization\n    * @return instance of Storage\n-   * @throws StorageClientException if configuration validation finished with errors   \n+   * @throws StorageClientException if configuration validation finished with errors\n+   * @throws StorageCryptoException if custom cipher validation fails\n    */\n-  public static Storage getInstance(StorageConfig config)\n-                                    throws StorageClientException, StorageServerException  {...}\n+  public static Storage newStorage(StorageConfig config)\n+                                    throws StorageClientException, StorageCryptoException  {...}\n //...\n }\n ```\n@@ -74,8 +75,9 @@ public class StorageConfig {\n    private String endPoint;\n    /** Instance of SecretKeyAccessor class. Used to fetch encryption secret */\n    private SecretKeyAccessor secretKeyAccessor;\n-   /** Optional. List of custom encryption configurations */\n-   private List<Crypto> customEncryptionConfigsList;\n+   /** Optional. Provider of encryption ciphers. Allows to register custom ciphers\n+    * for encrypting stored data. If null - default AES GCM cipher will be used */\n+   private CryptoProvider cryptoProvider;\n    /** Optional. If true - all keys will be stored as lower cased. default is false */\n    private boolean normalizeKeys;\n    /** Optional. Parameter endpointMask is used for switching from `default` InCountry host\n@@ -100,9 +102,13 @@ public class StorageConfig {\n     * Expected value - null or positive integer.\n     * Default value == {@link #maxHttpPoolSize}. */\n    private Integer maxHttpConnectionsPerRoute;\n-   /** Optional. If false - key1-key10 will be not hashed. Default is true */\n+   /** Optional. If false - key1-key20 will be not hashed. Default is true */\n    private boolean hashSearchKeys = true;\n+   /** Optional. For using of a previously acquired oAuth token for OAuth2 authorization or\n+    * for an external acquiring of oAuth2 tokens for OAuth2 authorization */\n+   private OauthTokenAccessor oauthTokenAccessor;\n    //...\n+}\n ```\n \n ---\n@@ -114,10 +120,10 @@ Below you can find API Key authorization usage example:\n ```java\n SecretsData secretsData = SecretsDataGenerator.fromPassword(\"<password>\");\n StorageConfig config = new StorageConfig()\n-    .setEnvId(\"<env_id>\")\n+    .setEnvironmentId(\"<environment_id>\")\n     .setApiKey(\"<api_key>\")\n     .setSecretKeyAccessor(() -> secretsData);\n-Storage storage=StorageImpl.getInstance(config);\n+Storage storage=StorageImpl.newStorage(config);\n ```\n ---\n \n@@ -138,8 +144,8 @@ StorageConfig config = new StorageConfig()\n    .setAuthEndpoints(authEndpointsMap)\n    .setDefaultAuthEndpoint(\"https://auth-server-default.com\")\n    .setEndpointMask(ENDPOINT_MASK)\n-   .setEnvId(ENV_ID)\n-Storage storage = StorageImpl.getInstance(config);\n+   .setEnvironmentId(ENVIRONMENT_ID)\n+Storage storage = StorageImpl.newStorage(config);\n ```\n \n Note: parameter endpointMask is used for switching from default InCountry host family (api.incountry.io) to a different one. For example setting `endpointMask`==`-private.incountry.io` will make all further requests to be sent to `https://{COUNTRY_CODE}-private.incountry.io`\n@@ -148,12 +154,32 @@ If your PoPAPI configuration relies on a custom PoPAPI server (rather than the d\n StorageConfig config = new StorageConfig()\n    .setCountriesEndpoint(countriesEndpoint)\n    //...\n-Storage storage = StorageImpl.getInstance(config);\n+Storage storage = StorageImpl.newStorage(config);\n+```\n+\n+The SDK also allows using previously acquired oAuth tokens if needed or pass token getting function. In this mode SDK is not responsible for oAuth a token renewal, and it should be done by SDK user himself.\n+\n+Below you can find the example of how to specify OAuth token while creating a Storage instance:\n+```java\n+//pass a constant token\n+String oauthToken = yourGetTokenFunction();\n+StorageConfig config = new StorageConfig()\n+        .setEnvironmentId(\"<environment_id>\")\n+        .setOauthToken(oauthToken);\n+Storage storage = StorageImpl.newStorage(config);\n+\n+//pass an external acquiring of oAuth2 tokens for OAuth2 authorization \n+StorageConfig config = new StorageConfig()\n+        .setEnvironmentId(\"<environment_id>\")\n+        .setOauthTokenAccessor(() -> yourGetTokenFunction());\n+Storage storage = StorageImpl.newStorage(config);\n ```\n \n ### Encryption key/secret\n \n-SDK provides `SecretKeyAccessor` interface which allows you to pass your own secrets/keys to the SDK.\n+`StorageConfig` contains parameter `SecretKeyAccessor`. It is an interface which allows you to pass your own secrets/keys to\n+the SDK.\n+\n ```java\n /**\n  * Secrets accessor. Method {@link SecretKeyAccessor#getSecretsData()} is invoked \n@@ -172,76 +198,67 @@ public interface SecretKeyAccessor {\n \n \n public class SecretsData {\n-    /**\n-     * creates a container with secrets\n-     *\n-     * @param secrets non-empty list of secrets. One of the secrets must have\n-     *        same version as currentVersion in SecretsData\n-     * @param currentVersion Should be a non-negative integer\n-     * @throws StorageClientException when parameter validation fails\n-     */\n-     public SecretsData(List<SecretKey> secrets, int currentVersion)\n-                throws StorageClientException {...}\n-    //...\n-}\n-\n-\n-public class SecretKey {\n-    /**\n-    * Creates a secret key\n+   /**\n+    * creates a container with secrets\n     *\n-    * @param secret  secret/key as byte array\n-    * @param version secret version, should be a non-negative integer\n-    * @param isKey   should be True only for user-defined encryption keys\n+    * @param secrets non-empty list of secrets. One of the secrets should \n+    *                be the second parameter {@link #currentSecret}\n+    * @param currentSecret Should be a non-negative integer\n     * @throws StorageClientException when parameter validation fails\n     */\n-    public SecretKey(byte[] secret, int version, boolean isKey)\n-              throws StorageClientException {...}\n+    public SecretsData(List<Secret> secrets, Secret currentSecret) \n+            throws StorageClientException {\n+    //...\n+}\n+\n+public abstract class Secret {\n+    private final int version;\n+    private final byte[] secretBytes;\n     //...\n }\n ```\n \n You can implement `SecretKeyAccessor` interface and pass secrets/keys in multiple ways:\n \n 1. As a constant SecretsData object\n-    ```java\n-    SecretsData secretsData = new SecretsData(secretsList, currentVersion);\n-    SecretKeyAccessor accessor = () -> secretsData;\n-    ```\n+```java\n+SecretsData secretsData = new SecretsData(secretsList, currentSecret);\n+SecretKeyAccessor accessor = () -> secretsData;\n+```\n \n 2. As a function that dynamically fetches secrets\n-    ```java\n-    SecretKeyAccessor accessor = () -> loadSecretsData();\n+```java\n+SecretKeyAccessor accessor = () -> loadSecretsData();\n \n-    private SecretsData loadSecretsData()  {\n-       String url = \"<your_secret_url>\";\n-       String responseJson = loadFromUrl(url).asJson();\n-       return SecretsDataGenerator.fromJson(responseJson);\n-    }\n-    ```\n+private SecretsData loadSecretsData()  {\n+    String url = \"<your_secret_url>\";\n+    String responseJson = loadFromUrl(url).asJson();\n+    return SecretsDataGenerator.fromJson(responseJson);\n+}\n+```\n \n You can also use `SecretsDataGenerator` class for creating `SecretsData` instances:\n \n 1. from a String password\n-    ```java\n-    SecretsData secretsData = SecretsDataGenerator.fromPassword(\"<password>\");\n-    ```\n+```java\n+SecretsData secretsData = SecretsDataGenerator.fromPassword(\"<password>\");\n+```\n \n 2. from a JSON string representing SecretsData object\n-    ```java\n-    SecretsData secretsData = SecretsDataGenerator.fromJson(jsonString);\n-    ```\n+```java\n+SecretsData secretsData = SecretsDataGenerator.fromJson(jsonString);\n+```\n \n ```javascript\n {\n     \"secrets\": [\n         {\n-            \"secret\": \"secret0\",\n+            \"secret\": \"secret_password_0\",\n             \"version\": 0,\n             \"isKey\": false\n         },\n         {\n-            \"secret\": \"secret1\",\n+            \"secret\": \"secret_password_1\",\n             \"version\": 1,\n             \"isKey\": false\n         }\n@@ -252,7 +269,7 @@ You can also use `SecretsDataGenerator` class for creating `SecretsData` instanc\n \n `SecretsData` allows you to specify multiple keys/secrets which SDK will use for decryption based on the version of the key or secret used for encryption.\n \n-Meanwhile SDK will encrypt only using key/secret that matches `currentVersion` provided in `SecretsData` object. This enables the flexibility required to support Key Rotation policies when secrets/keys need to be changed with time.\n+Meanwhile SDK will encrypt only using key/secret that matches `currentSecret` provided in `SecretsData` object. This enables the flexibility required to support Key Rotation policies when secrets/keys need to be changed with time.\n \n SDK will encrypt data using current secret/key while maintaining the ability to decrypt records encrypted with old keys/secrets.\n SDK also provides a method for data migration which allows to re-encrypt data with the newest key/secret. For details please see [migrate](#Data-Migration-and-Key-Rotation-support) method.\n@@ -325,6 +342,9 @@ public class Record {\n     private String profileKey;\n     private String serviceKey1;\n     private String serviceKey2;\n+    private String serviceKey3;\n+    private String serviceKey4;\n+    private String serviceKey5;\n    //String fields, hashed or original\n     private String key1;\n     private String key2;\n@@ -360,6 +380,8 @@ public class Record {\n     private Long rangeKey8;\n     private Long rangeKey9;\n     private Long rangeKey10;\n+    //Date field\n+    private Date expiresAt;\n     //Readonly service fields, date\n     protected Date createdAt;\n     protected Date updatedAt;\n@@ -376,7 +398,8 @@ record.setProfileKey(\"customer\")\n ```\n \n #### Date fields\n-Use `createdAt` and `updatedAt` fields to access date-related information about records. `createdAt` indicates date when the record was initially created in the target country. `updatedAt` shows the date of the latest write operation for the given `recordKey`\n+Use `createdAt` and `updatedAt` fields to access date-related information about records. `createdAt` indicates date when the record was initially created in the target country. `UpdatedAt` shows the date of the latest write operation for the given `RecordKey`.\n+Field `expiresAt` can be set by user, value is stored and returned in UTC+0.\n \n ### Batches\n \n@@ -444,28 +467,28 @@ public interface Storage {\n     * Find records in remote storage according to filters\n     *\n     * @param country country identifier\n-    * @param builder object representing find filters and search options\n-    * @return BatchRecord object which contains required records\n+    * @param filter object representing find filters and search options\n+    * @return FindResult object which contains required records\n     * @throws StorageClientException if validation finished with errors\n     * @throws StorageServerException if server connection failed or server response error\n     * @throws StorageCryptoException if decryption failed\n     */\n-    BatchRecord find(String country, FindFilterBuilder builder)\n+    FindResult find(String country, FindFilter filter)\n          throws StorageClientException, StorageServerException, StorageCryptoException;\n     //...\n }\n ```\n \n-Use `FindFilterBuilder` class to refine your find request.\n+Use `FindFilter` class to refine your find request.\n \n-Below is the example how to use `find` method along with `FindFilterBuilder`:\n+Below is the example how to use `find` method along with `FindFilter`:\n ```java\n-FindFilterBuilder builder = FindFilterBuilder.create()\n+FindFilter filter = new FindFilter()\n                   .keyEq(StringField.KEY2, \"someKey\")\n                   .keyEq(StringField.KEY3, \"firstValue\", \"secondValue\")\n                   .keyEq(NumberField.RANGE_KEY1, 123L, 456L);\n \n-BatchRecord findResult = storage.find(\"us\", builder);\n+FindResult findResult = storage.find(\"us\", filter);\n if (findResult.getCount() > 0) {\n     Record record = findResult.getRecords().get(0);\n     //...\n@@ -477,14 +500,14 @@ The request will return records, filtered according to the following pseudo-sql\n key2 = 'someKey' AND key3 in ('firstValue' , 'secondValue') AND (123 < = `rangeKey1` < = 456)\n ```\n \n-All conditions added via `FindFilterBuilder` are joined using logical `AND`. You may not add multiple conditions for the same key - if you do only the last one will be used.\n+All conditions added via `FindFilter` are joined using logical `AND`. You may not add multiple conditions for the same key - if you do only the last one will be used.\n \n SDK returns 100 records at most. Use `limit` and `offset` to iterate through the records.\n ```java\n-FindFilterBuilder builder = FindFilterBuilder.create()\n+FindFilter filter = new FindFilter()\n                   //...\n                   .limitAndOffset(20, 80);\n-BatchRecord records = storage.find(\"us\", builder);\n+FindResult findResult = storage.find(\"us\", filter);\n ```\n \n ---\n@@ -496,11 +519,11 @@ Sorting find results is currently available for InCountry dedicated instances on\n \n By default, data at a find result is not sorted. To sort the returned records by one or multiple keys use method `sortBy` of `FindFilterBuilder` .\n ```java\n-FindFilterBuilder builder = FindFilterBuilder.create()\n+FindFilter builder = new FindFilter()\n                   //...\n                   .sortBy(SortField.CREATED_AT, SortOrder.ASC)\n                   .sortBy(SortField.RANGE_KEY1, SortOrder.DESC)\n-BatchRecord records = storage.find(\"us\", builder);\n+FindResult findResult = storage.find(\"us\", filter);\n ```\n The request will return records, sorted according to the following pseudo-sql\n ```sql\n@@ -509,7 +532,7 @@ SELECT * FROM record WHERE ...  ORDER BY created_at asc, range_key1 desc\n \n ##### Fields that records can be sorted by:\n ```java\n-public enum SortFields {\n+public enum SortField {\n    KEY1,\n    KEY2,\n    KEY3,\n@@ -541,35 +564,40 @@ public enum SortFields {\n    RANGE_KEY9,\n    RANGE_KEY10,\n    CREATED_AT,\n-   UPDATED_AT\n+   UPDATED_AT,\n+   EXPIRES_AT\n }\n ```\n \n Next predicate types are available for each string key field of class `Record` via individual methods of `FindFilterBuilder`:\n ```java\n-EQUALS              (FindFilterBuilder::keyEq)\n-NOT_EQUALS          (FindFilterBuilder::keyNotEq)\n-IS_NULL             (FindFilterBuilder::keyIsNull)\n-IS_NOT_NULL         (FindFilterBuilder::keyIsNotNull)\n-\n+EQUALS              (FindFilter::keyEq)\n+NOT_EQUALS          (FindFilter::keyNotEq)\n+IS_NULL             (FindFilter::keyIsNull)\n+IS_NOT_NULL         (FindFilter::keyIsNotNull)\n ```\n \n You can use the following builder methods for filtering by numerical fields:\n ```java\n-EQUALS              (FindFilterBuilder::keyEq)\n-IS_NULL             (FindFilterBuilder::keyIsNull)\n-IS_NOT_NULL         (FindFilterBuilder::keyIsNotNull)\n-IN                  (FindFilterBuilder::keyIn)\n-GREATER             (FindFilterBuilder::keyGT)\n-GREATER OR EQUALS   (FindFilterBuilder::keyGTE)\n-LESS                (FindFilterBuilder::keyLT)\n-LESS OR EQUALS      (FindFilterBuilder::keyLTE)\n-BETWEEN             (FindFilterBuilder::keyBetween)\n-```\n-\n-Method `find` returns `BatchRecord` object which contains a list of `Record` and some metadata:\n+EQUALS              (FindFilter::keyEq)\n+NOT_EQUALS          (FindFilter::keyNotEq)\n+IS_NULL             (FindFilter::keyIsNull)\n+IS_NOT_NULL         (FindFilter::keyIsNotNull)\n+GREATER             (FindFilter::keyGreater)\n+LESS                (FindFilter::keyLess)\n+BETWEEN             (FindFilter::keyBetween)\n+```\n+\n+You can use the following builder methods for filtering by date fields:\n+```java\n+EQUALS              (FindFilter::keyEq)\n+IS_NULL             (FindFilter::keyIsNull)\n+IS_NOT_NULL         (FindFilter::keyIsNotNull)\n+```\n+\n+Method `find` returns `FindResult` object which contains a list of `Record` and some metadata:\n ```java\n-class BatchRecord {\n+class FindResult {\n     private int count;\n     private int limit;\n     private int offset;\n@@ -582,10 +610,66 @@ class BatchRecord {\n These fields can be accessed using getters, for example:\n \n ```java\n-int limit = records.getTotal();\n+int total = findResult.getTotal();\n+```\n+\n+`FindResult.getErrors()` allows you to get a List of `RecordException` objects which contains detailed information about records that failed to be processed correctly during `find` request.\n+\n+##### Partial text match search\n+\n+You can also look up for data records by partial match using the `searchKeysLike` method of `FindFilter` which performs\n+partial match search (similar to the `LIKE` SQL operator, without special characters) within records text\n+fields `key1, key2, ..., Key20`.\n+\n+```java\n+// Matches all records where \n+// Record.key1 LIKE 'abc' OR Record.key2 LIKE 'abc' OR ... OR Record.key20 LIKE 'abc'\n+FindFilter filter = new FindFilter()\n+    .searchKeysLike(\"abc\");\n+```\n+\n+**Please note:** The `searchKeys` filter cannot be used in combination with any of `key1, key2, ..., key20` filters and\n+works only in combination with the non-hashing Storage mode (`hashSearchKeys` param at `StorageConfig`).\n+\n+```java\n+// Matches all records where \n+// (Record.key1 LIKE 'abc' OR Record.key2 LIKE 'abc' OR ... OR Record.key20 LIKE 'abc') \n+// AND (Record.rangeKey1 = 1 OR Record.rangeKey1 = 2)\n+FindFilter filter = new FindFilter()\n+    .searchKeysLike(\"abc\")\n+    .keyEq(NumberField.RANGE_KEY1, 1L, 2L);\n+\n+// Causes validation error (StorageClientException)\n+FindFilter filter = new FindFilter()\n+    .searchKeysLike(\"abc\")\n+    .keyEq(StringField.KEY1, \"def\");\n+```\n+\n+##### Partial text match search\n+You can also look up for data records by partial match using the `searchKeysLike` method of `FindFilter` which performs partial match search (similar to the `LIKE` SQL operator, without special characters) within records text fields `key1, key2, ..., key20`.\n+```java\n+// Matches all records where \n+// Record.key1 LIKE 'abc' OR Record.key2 LIKE 'abc' OR ... OR Record.key20 LIKE 'abc'\n+FindFilterBuilder builder = FindFilterBuilder.create()\n+    .searchKeysLike(\"abc\");\n ```\n \n-`BatchRecord.getErrors()` allows you to get a List of `RecordException` objects which contains detailed information about records that failed to be processed correctly during `find` request.\n+**Please note:** The `searchKeys` filter cannot be used in combination with any of `key1, key2, ..., key20` filters and\n+works only in combination with the non-hashing Storage mode (`hashSearchKeys` param at `StorageConfig`).\n+```java\n+// Matches all records where \n+// (Record.key1 LIKE 'abc' OR Record.key2 LIKE 'abc' OR ... OR Record.key20 LIKE 'abc') \n+// AND (Record.rangeKey1 = 1 OR Record.rangeKey1 = 2)\n+FindFilter filter = new FindFilter()\n+    .searchKeysLike(\"abc\")\n+    .keyEq(NumberField.RANGE_KEY1, 1L, 2L);\n+storage.find(\"us\", builder);\n+\n+// Causes validation error (StorageClientException)\n+FindFilter filter = new FindFilter()\n+    .searchKeysLike(\"abc\")\n+    .keyEq(StringField.KEY1, \"def\");\n+```\n \n ### Find one record matching filter\n \n@@ -596,13 +680,13 @@ public interface Storage {\n     * Find only one first record in remote storage according to filters\n     *\n     * @param country country identifier\n-    * @param builder object representing find filters\n+    * @param filter object representing find filters\n     * @return founded record or null\n     * @throws StorageClientException if validation finished with errors\n     * @throws StorageServerException if server connection failed or server response error\n     * @throws StorageCryptoException if decryption failed\n     */\n-    Record findOne(String country, FindFilterBuilder builder)\n+    Record findOne(String country, FindFilter filter)\n            throws StorageClientException, StorageServerException, StorageCryptoException;\n     //...\n }\n@@ -612,12 +696,12 @@ It works the same way as `find` but returns the first record or `null` if no rec\n \n Here is the example of how `findOne` method can be used:\n ```java\n-FindFilterBuilder builder = FindFilterBuilder.create()\n+FindFilter filter = new FindFilter()\n                   .keyEq(StringField.KEY2, \"someKey\")\n                   .keyEq(StringField.KEY3, \"firstValue\", \"secondValue\")\n                   .keyEq(NumberField.RANGE_KEY1, 123L, 456L);\n \n-Record record = storage.findOne(\"us\", builder);\n+Record record = storage.findOne(\"us\", filter);\n //...\n ```\n \n@@ -897,88 +981,65 @@ public void test() {\n \n SDK supports the ability to provide custom encryption/decryption methods if you decide to use your own algorithm instead of the default one.\n \n-Use method `setCustomEncryptionConfigsList` of `StorageConfig` for passing a list of custom encryption implementations:\n+Set `cryptoProvider` of `StorageConfig` with registered custom cipher implementations:\n \n ```java\n-public class StorageConfig {\n-  //...\n-  /**\n-   * for custom encryption\n-   *\n-   * @param customEncryptionConfigsList List with custom encryption functions\n-   * @return StorageConfig\n-   */\n-  public StorageConfig setCustomEncryptionConfigsList(List<Crypto> customEncryptionConfigsList) {\n-      this.customEncryptionConfigsList = customEncryptionConfigsList;\n-      return this;\n-  }\n-  //...\n-}\n+Cipher customCipher = new FernetCipher(\"Fernet cipher demo\");\n+Cipher anotherCipher = new AnotherCustomCipher();\n+CryptoProvider provider = new CryptoProvider(customCipher);\n+provider.registerCipher(anotherCipher);\n+StorageConfig config = new StorageConfig();\n+//...\n+config.setCryptoProvider(provider);\n+Storage storage = StorageImpl.newStorage(config);\n+\n ```\n \n-For using of custom encryption you need to implement the following interface:\n+For using of custom encryption you need to create an implementation the following abstract class:\n ```java\n-public interface Crypto {\n+public abstract class AbstractCipher implements Cipher {\n+\n+    protected AbstractCipher(String name) throws StorageClientException {\n+        //...\n+    }\n+    \n     /**\n-     * encrypts data with secret\n+     * encrypts data with secretKey\n      *\n-     * @param text      data for encryption\n+     * @param textBytes data for encryption\n      * @param secretKey secret\n      * @return encrypted data as String\n      * @throws StorageClientException when parameters validation fails\n-     * @throws StorageCryptoException when decryption fails\n+     * @throws StorageCryptoException when encryption fails\n      */\n-    String encrypt(String text, SecretKey secretKey)\n+    public abstract String encrypt(byte[] textBytes, CustomEncryptionKey secretKey) \n             throws StorageClientException, StorageCryptoException;\n \n     /**\n      * decrypts data with Secret\n      *\n-     * @param cipherText encrypted data\n-     * @param secretKey  secret\n+     * @param cipherTextBytes encrypted data\n+     * @param secretKey       secret\n      * @return decrypted data as String\n      * @throws StorageClientException when parameters validation fails\n      * @throws StorageCryptoException when decryption fails\n      */\n-    String decrypt(String cipherText, SecretKey secretKey)\n+    public abstract String decrypt(byte[] cipherTextBytes, CustomEncryptionKey secretKey) \n             throws StorageClientException, StorageCryptoException;\n-\n-    /**\n-     * version of encryption algorithm as String\n-     *\n-     * @return version\n-     */\n-    String getVersion();\n-\n-    /**\n-     * only one CustomCrypto can be current. This parameter\n-     * used only during {@link com.incountry.residence.sdk.Storage}\n-     * initialisation. Changing this parameter will be ignored after initialization\n-     *\n-     * @return is current or not\n-     */\n-    boolean isCurrent();\n+    //...\n }\n ```\n \n ---\n **NOTE**\n \n-You should provide a specific `SecretKey` via `SecretsData` passed to `SecretKeyAccessor`. This secret should have flag `isForCustomEncryption` set to `true` and flag `isKey` set to `false`:\n+You should provide an instance of `CustomEncryptionKey` via `SecretsData` passed to `SecretKeyAccessor`.\n ```java\n-public class SecretKey {\n-    /**\n-     * @param secret secret/key as byte array\n-     * @param version secret version, should be a non-negative integer\n-     * @param isKey should be True only for user-defined encryption keys\n-     * @param isForCustomEncryption should be True for using this key in custom encryption\n-     *                              implementations. Either ({@link #isKey} or\n-     *                              {@link #isForCustomEncryption}) can be True at the same\n-     *                              moment, not both\n-     * @throws StorageClientException when parameter validation fails\n-     */\n-    public SecretKey(byte[] secret, int version, boolean isKey, boolean isForCustomEncryption)\n-              throws StorageClientException {...}\n+public class CustomEncryptionKey extends Secret {\n+    public CustomEncryptionKey(int version, byte[] secretBytes) \n+            throws StorageClientException {\n+        //...\n+    }\n     //...\n }\n ```\n@@ -997,65 +1058,15 @@ secrets_data = {\n ```\n ---\n \n-`version` attribute is used to differ one custom encryption from another and from the default encryption as well.\n-This way SDK will be able to successfully decrypt any old data if encryption changes with time.\n-\n-`isCurrent` attribute allows to specify one of the custom encryption implementations that will be used for encryption. Only one implementation can be set as `isCurrent() == true`.\n+Parameter `name` of `AbstractCipher` constructor is used to differ one custom encryption from another and from the default encryption as well. This way SDK will be able to successfully decrypt any old data if encryption changes with time.\n \n-If none of the configurations have `isCurrent() == true` then the SDK will use default encryption to encrypt stored data. At the same time it will keep the ability to decrypt old data, encrypted with custom encryption (if any).\n-\n-Here's an example of how you can set up SDK to use custom encryption (using Fernet encryption from https://github.com/l0s/fernet-java8 )\n-\n-```java\n-/**\n- * Example of custom implementation of {@link Crypto} using Fernet algorithm\n- */\n-public class FernetCrypto implements Crypto {\n-    private static final String VERSION = \"fernet custom encryption\";\n-    private boolean current;\n-    private Validator<String> validator;\n-\n-    public FernetCrypto(boolean current) {\n-        this.current = current;\n-        this.validator = new StringValidator() {\n-        };\n-    }\n+You can set current cipher implementation via a constructor of `CryptoProvider`. Such cipher will be used for encryption.\n \n-    @Override\n-    public String encrypt(String text, SecretKey secretKey)\n-            throws StorageCryptoException {\n-        try {\n-            Key key = new Key(secretKey.getSecret());\n-            Token result = Token.generate(key, text);\n-            return result.serialise();\n-        } catch (IllegalStateException ex) {\n-            throw new StorageCryptoException(\"Encryption error\", ex);\n-        }\n-    }\n+If none of the custom implementations of `AbstractCipher` then the SDK will use default encryption to encrypt stored data. At the same time it will keep the ability to decrypt old data, encrypted with custom encryption (if any).\n \n-    @Override\n-    public String decrypt(String cipherText, SecretKey secretKey)\n-            throws StorageCryptoException {\n-        try {\n-            Key key = new Key(secretKey.getSecret());\n-            Token result = Token.fromString(cipherText);\n-            return result.validateAndDecrypt(key, validator);\n-        } catch (PayloadValidationException ex) {\n-            throw new StorageCryptoException(\"Decryption error\", ex);\n-        }\n-    }\n+You can see an example of an implementation of custom encryption (using Fernet encryption from https://github.com/l0s/fernet-java8) by [following this link](/src/test/java/com/incountry/residence/sdk/crypto/testimpl/FernetCipher.java)\n \n-    @Override\n-    public String getVersion() {\n-        return VERSION;\n-    }\n \n-    @Override\n-    public boolean isCurrent() {\n-        return current;\n-    }\n-}\n-```\n \n ## Project dependencies\n \n@@ -1065,12 +1076,13 @@ The following is a list of compile dependencies for this project. These dependen\n | :---:                     | :---:                | :---:       | :---:    |\n | javax.xml.bind            | jaxb-api             | 2.3.1       | jar      |\n | javax.activation          | javax.activation-api | 1.2.0       | jar      |\n-| commons-codec             | commons-codec        | 1.14        | jar      |\n+| commons-codec             | commons-codec        | 1.15        | jar      |\n | commons-logging           | commons-logging      | 1.2         | jar      |\n-| org.apache.logging.log4j  | log4j-api            | 2.13.3      | jar      |\n-| org.apache.logging.log4j  | log4j-core           | 2.13.3      | jar      |\n-| org.apache.logging.log4j  | log4j-core-jcl       | 2.13.3      | jar      |\n-| org.apache.httpcomponents | httpclient           | 4.5.12      | jar      |\n+| commons-io                | commons-io           | 2.8.0       | jar      |\n+| org.apache.logging.log4j  | log4j-api            | 2.14.0      | jar      |\n+| org.apache.logging.log4j  | log4j-core           | 2.14.0      | jar      |\n+| org.apache.logging.log4j  | log4j-core-jcl       | 2.14.0      | jar      |\n+| org.apache.httpcomponents | httpclient           | 4.5.13      | jar      |\n | org.apache.httpcomponents | httpcore             | 4.4.13      | jar      |\n | com.google.code.gson      | gson                 | 2.8.6       | jar      |\n \n@@ -1079,18 +1091,21 @@ The following is a list of compile dependencies for this project. These dependen\n compileClasspath\n +--- javax.xml.bind:jaxb-api:2.3.1\n |    \\--- javax.activation:javax.activation-api:1.2.0\n-+--- commons-codec:commons-codec:1.14\n++--- commons-codec:commons-codec:1.15\n +--- com.google.code.gson:gson:2.8.6\n-+--- org.apache.logging.log4j:log4j-api:2.13.3\n-+--- org.apache.logging.log4j:log4j-core:2.13.3\n-|    \\--- org.apache.logging.log4j:log4j-api:2.13.3\n-+--- org.apache.logging.log4j:log4j-jcl:2.13.3\n++--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.logging.log4j:log4j-core:2.14.0\n+|    \\--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.logging.log4j:log4j-jcl:2.14.0\n+|    +--- commons-logging:commons-logging:1.2\n+|    \\--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.httpcomponents:httpclient:4.5.13\n+|    +--- org.apache.httpcomponents:httpcore:4.4.13\n |    +--- commons-logging:commons-logging:1.2\n-|    \\--- org.apache.logging.log4j:log4j-api:2.13.3\n-\\--- org.apache.httpcomponents:httpclient:4.5.12\n-     +--- org.apache.httpcomponents:httpcore:4.4.13\n-     +--- commons-logging:commons-logging:1.2\n-     \\--- commons-codec:commons-codec:1.11 -> 1.14\n+|    \\--- commons-codec:commons-codec:1.11 -> 1.15\n++--- commons-io:commons-io:2.8.0\n+\\--- org.apache.httpcomponents:httpmime:4.5.13\n+     \\--- org.apache.httpcomponents:httpclient:4.5.13 (*)\n ```\n \n ### Minimal JVM memory options"
  },
  {
    "sha": "32594f4fbc9c7ba41b38edbe8536cb2dfa114f35",
    "filename": "config/spotbugs/exclude.xml",
    "status": "modified",
    "additions": 28,
    "deletions": 2,
    "changes": 30,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/config/spotbugs/exclude.xml",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/config/spotbugs/exclude.xml",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/config/spotbugs/exclude.xml?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -3,9 +3,11 @@\n     <Match>\n         <Or>\n             <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferPop\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferFilterContainer\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferRecordList\"/>\n             <Class name=\"com.incountry.residence.sdk.StorageImpl\"/>\n-            <Class name=\"com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator\"/>\n-            <Class name=\"com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator$SecretKeyContainer\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsDataGenerator\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsDataGenerator$SecretKeyContainer\"/>\n         </Or>\n         <Bug code=\"NP,SIC,SS,ST,UrF,UuF,UwF\"/>\n     </Match>\n@@ -24,6 +26,12 @@\n         <Bug pattern=\"NP_NULL_ON_SOME_PATH\" />\n     </Match>\n \n+    <Match>\n+        <Class name=\"com.incountry.residence.sdk.tools.http.impl.HttpAgentImpl\" />\n+        <Method name=\"request\" />\n+        <Bug code=\"RCN\" />\n+    </Match>\n+\n     <Match>\n         <Or>\n             <Class name=\"com.incountry.residence.sdk.tools.dao.impl.HttpDaoImpl\"/>\n@@ -38,4 +46,22 @@\n         <Bug code=\"SECPR\"/>\n     </Match>\n \n+    <Match>\n+        <Or>\n+            <Class name=\"com.incountry.residence.sdk.crypto.Secret\"/>\n+            <Class name=\"com.incountry.residence.sdk.dto.search.internal.DateFilter\"/>\n+        </Or>\n+        <Bug code=\"EI,EI2,MS\"/>\n+    </Match>\n+\n+    <Match>\n+        <Or>\n+            <Class name=\"com.incountry.residence.sdk.crypto.AbstractCipher\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsData\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.crypto.CryptoProvider\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.crypto.cipher.AesGcmPbkdfCipher\"/>\n+        </Or>\n+        <Bug code=\"NP,RCN\"/>\n+    </Match>\n+\n </FindBugsFilter>"
  },
  {
    "sha": "151f1ef16c0d4d8989b0bf0c88c40ddef0fc052e",
    "filename": "gradle.properties",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/gradle.properties",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/gradle.properties",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/gradle.properties?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,20 +1,20 @@\n group=com.incountry\n-version=3.1.0-SNAPSHOT\n+version=3.4.0-SNAPSHOT\n gsonVersion=2.8.6\n-jupiterVersion=5.6.0\n+jupiterVersion=5.7.0\n jaxbApiVersion=2.3.1\n-commonsCodecVersion=1.14\n-log4jVersion=2.13.3\n-checkStyleVersion=8.29\n-spotbugsVersion=4.4.3\n-spotBugsToolVersion=4.0.6\n-findsecbugsVersion=1.10.1\n-nexusStagingVersion=0.11.0\n-sonarQubeVersion=3.0\n-jacocoVersion=0.8.5\n+log4jVersion=2.14.0\n+checkStyleVersion=8.39\n+spotbugsVersion=4.6.0\n+spotBugsToolVersion=4.1.1\n+findsecbugsVersion=1.11.0\n+nexusStagingVersion=0.22.0\n+sonarQubeVersion=3.1\n+jacocoVersion=0.8.6\n fernetVersion=1.4.2\n-apacheHttpClientVersion=4.5.13\n commonsIoVersion=2.8.0\n+commonsCodecVersion=1.15\n+apacheHttpClientVersion=4.5.13\n apacheHttpMimeVersion=4.5.13\n nexusUsername=\n nexusPassword="
  },
  {
    "sha": "895cb62b382d5c07cd4c5614a2fc42f0dd54258e",
    "filename": "gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/gradle/wrapper/gradle-wrapper.properties?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,5 +1,5 @@\n #Tue Jun 23 13:23:54 MSK 2020\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8-bin.zip\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n zipStorePath=wrapper/dists"
  },
  {
    "sha": "a30e228b1f4efb4e780287b4e438fb7b3b24180c",
    "filename": "src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "status": "modified",
    "additions": 16,
    "deletions": 10,
    "changes": 26,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,26 +1,32 @@\n package com.incountry.residence.sdk;\n \n+import com.incountry.residence.sdk.crypto.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretsDataGenerator;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.tools.exceptions.StorageException;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator;\n \n public class FullMigrationExample {\n \n+    private static final String ENVIRONMENT_ID = \"<environment_id>\";\n+    private static final String CLIENT_ID = \"<client_id>\";\n+    private static final String CLIENT_SECRET = \"<client_secret>\";\n+\n     public void startMigration() throws StorageException {\n         String secretsDataInJson = \"{\\n\" +\n                 \"    \\\"currentVersion\\\": 1,\\n\" +\n                 \"    \\\"secrets\\\": [\\n\" +\n                 \"        {\\\"secret\\\": \\\"password0\\\", \\\"version\\\": 0},\\n\" +\n-                \"        {\\\"secret\\\": \\\"password1\\\", \\\"version\\\": 1},\\n\" +\n-                \"    ],\\n\" +\n+                \"        {\\\"secret\\\": \\\"password1\\\", \\\"version\\\": 1}\\n\" +\n+                \"    ]\\n\" +\n                 \"}\";\n-        SecretKeyAccessor secretKeyAccessor = () -> SecretsDataGenerator.fromJson(secretsDataInJson);\n-        String endPoint = \"https://us-mt-01.api.incountry.example\";\n+        SecretsData secretsData = SecretsDataGenerator.fromJson(secretsDataInJson);\n+        StorageConfig config = new StorageConfig()\n+                .setEnvironmentId(ENVIRONMENT_ID)\n+                .setClientId(CLIENT_ID)\n+                .setClientSecret(CLIENT_SECRET)\n+                .setSecretKeyAccessor(() -> secretsData);\n+        Storage storage = StorageImpl.newStorage(config);\n         String country = \"US\";\n-        String envId = \"someEnvironmentId\";\n-        String apiKey = \"someApiKey\";\n-        Storage storage = StorageImpl.getInstance(envId, apiKey, endPoint, secretKeyAccessor);\n         boolean migrationComplete = false;\n         while (!migrationComplete) {\n             MigrateResult migrationResult = storage.migrate(country, 50);\n@@ -29,4 +35,4 @@ public void startMigration() throws StorageException {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "a1c68f3a7a5c8503f4ac6398840b951a76626625",
    "filename": "src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "status": "modified",
    "additions": 35,
    "deletions": 11,
    "changes": 46,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/OAuthTest.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -6,9 +6,9 @@\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n import com.incountry.residence.sdk.tools.http.TokenClient;\n import com.incountry.residence.sdk.tools.http.impl.OAuthTokenClient;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n+import com.incountry.residence.sdk.crypto.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretsDataGenerator;\n import com.incountry.residence.sdk.tools.proxy.ProxyUtils;\n import org.apache.http.conn.HttpHostConnectException;\n import org.apache.http.impl.client.HttpClients;\n@@ -33,6 +33,7 @@\n import static com.incountry.residence.sdk.StorageIntegrationTest.loadFromEnv;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n@@ -56,16 +57,16 @@ public OAuthTest() throws StorageClientException {\n         accessor = () -> secretsData;\n     }\n \n-    private Storage initStorage() throws StorageClientException {\n+    private Storage initStorage() throws StorageClientException, StorageCryptoException {\n         StorageConfig config = new StorageConfig()\n                 .setClientId(CLIENT_ID)\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n                 .setEndpointMask(ENDPOINT_MASK)\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setSecretKeyAccessor(accessor)\n                 .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT);\n-        return StorageImpl.getInstance(config);\n+        return StorageImpl.newStorage(config);\n     }\n \n     @Test\n@@ -88,26 +89,26 @@ public void testStorageWithAuthClient() throws StorageServerException, StorageCl\n     public void positiveAuthTest() throws StorageServerException, StorageClientException {\n         TokenClient client = new OAuthTokenClient(DEFAULT_AUTH_ENDPOINT, null, ENV_ID, CLIENT_ID, SECRET, HttpClients.createDefault());\n         TokenClient tokenClient = ProxyUtils.createLoggingProxyForPublicMethods(client, true);\n-        assertNotNull(tokenClient.getToken(END_POINT, null));\n-        assertNotNull(tokenClient.getToken(END_POINT, null));\n+        assertNotNull(tokenClient.refreshToken(false, END_POINT, null));\n+        assertNotNull(tokenClient.refreshToken(false, END_POINT, null));\n         assertNotNull(tokenClient.refreshToken(true, END_POINT, null));\n         assertNotNull(tokenClient.refreshToken(true, END_POINT, null));\n     }\n \n     @Test\n-    public void authRegionTest() throws StorageClientException {\n+    public void authRegionTest() throws StorageClientException, StorageCryptoException {\n         Map<String, String> authEndpoints = new HashMap<>();\n         authEndpoints.put(\"emea\", \"https://emea.localhost\");\n         authEndpoints.put(\"apac\", \"https://apac.localhost\");\n         StorageConfig config = new StorageConfig()\n-                .setEnvId(\"envId\")\n+                .setEnvironmentId(\"envId\")\n                 .setClientId(\"clientId\")\n                 .setClientSecret(\"clientSecret\")\n                 .setEndpointMask(\"-localhost.localhost:8765\")\n                 .setAuthEndpoints(authEndpoints)\n                 .setDefaultAuthEndpoint(\"https://emea.localhost\");\n \n-        Storage prodStorage = StorageImpl.getInstance(config);\n+        Storage prodStorage = StorageImpl.newStorage(config);\n         String errorMessage = \"Unexpected exception during authorization, params [OAuth URL=\";\n         Record record = new Record(\"someKey\", \"someBody\");\n \n@@ -137,4 +138,27 @@ public void authRegionTest() throws StorageClientException {\n         Assertions.assertTrue(expectedClasses.contains(ex.getCause().getClass()));\n         assertTrue(ex.getCause().getMessage().contains(errorEmea));\n     }\n+\n+    @Test\n+    void tokenAccessorTest() throws StorageClientException, StorageServerException, StorageCryptoException {\n+        TokenClient tokenClient = new OAuthTokenClient(DEFAULT_AUTH_ENDPOINT, null, ENV_ID, CLIENT_ID, SECRET, HttpClients.createDefault());\n+        String audience = \"https://\" + COUNTRY.toLowerCase() + ENDPOINT_MASK;\n+        String oauthToken = tokenClient.refreshToken(false, audience, \"emea\");\n+\n+        StorageConfig config = new StorageConfig()\n+                .setEnvironmentId(ENV_ID)\n+                .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n+                .setEndpointMask(ENDPOINT_MASK)\n+                .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT)\n+                .setOauthToken(oauthToken);\n+        Storage storage = StorageImpl.newStorage(config);\n+        Record record = new Record(UUID.randomUUID().toString(), UUID.randomUUID().toString());\n+        storage.write(COUNTRY, record);\n+        Record readRecord = storage.read(COUNTRY, record.getRecordKey());\n+        assertEquals(record.getRecordKey(), readRecord.getRecordKey());\n+        assertEquals(record.getBody(), readRecord.getBody());\n+        storage.delete(COUNTRY, record.getRecordKey());\n+        readRecord = storage.read(COUNTRY, record.getRecordKey());\n+        assertNull(readRecord);\n+    }\n }"
  },
  {
    "sha": "66f0e5a2a7b13c0851e1971c176614a7197a978b",
    "filename": "src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "status": "modified",
    "additions": 201,
    "deletions": 142,
    "changes": 343,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,20 +1,23 @@\n package com.incountry.residence.sdk;\n \n-import com.incountry.residence.sdk.crypto.testimpl.FernetCrypto;\n+import com.incountry.residence.sdk.crypto.CustomEncryptionKey;\n+import com.incountry.residence.sdk.crypto.EncryptionSecret;\n+import com.incountry.residence.sdk.crypto.Secret;\n+import com.incountry.residence.sdk.crypto.testimpl.FernetCipher;\n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n+import com.incountry.residence.sdk.dto.search.DateField;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n import com.incountry.residence.sdk.dto.search.NumberField;\n import com.incountry.residence.sdk.dto.search.SortField;\n import com.incountry.residence.sdk.dto.search.SortOrder;\n import com.incountry.residence.sdk.dto.search.StringField;\n-import com.incountry.residence.sdk.tools.crypto.Crypto;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretKey;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n+import com.incountry.residence.sdk.crypto.SecretsData;\n import com.incountry.residence.sdk.tools.exceptions.StorageException;\n import org.apache.commons.io.IOUtils;\n import org.apache.logging.log4j.LogManager;\n@@ -30,13 +33,15 @@\n import org.junit.jupiter.params.provider.MethodSource;\n \n import java.io.ByteArrayInputStream;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n+import java.util.Calendar;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n@@ -53,6 +58,10 @@\n \n import static com.incountry.residence.sdk.dto.search.StringField.SERVICE_KEY1;\n import static com.incountry.residence.sdk.dto.search.StringField.SERVICE_KEY2;\n+import static com.incountry.residence.sdk.dto.search.StringField.SERVICE_KEY3;\n+import static com.incountry.residence.sdk.dto.search.StringField.SERVICE_KEY4;\n+import static com.incountry.residence.sdk.dto.search.StringField.SERVICE_KEY5;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -125,6 +134,10 @@\n     private static final String KEY_20 = \"Key20_\" + TEMP;\n     private static final String SERVICE_KEY_1 = \"ServiceKey1_\" + TEMP;\n     private static final String SERVICE_KEY_2 = \"ServiceKey2_\" + TEMP;\n+    private static final String SERVICE_KEY_3 = \"ServiceKey3_\" + TEMP;\n+    private static final String SERVICE_KEY_4 = \"ServiceKey4_\" + TEMP;\n+    private static final String SERVICE_KEY_5 = \"ServiceKey5_\" + TEMP;\n+    private static final Date EXPIRES_AT = new Date(System.currentTimeMillis() + 300_000);\n     private static final String PRECOMMIT_BODY = \"PreommitBody_\" + TEMP;\n     private static final Long BATCH_WRITE_RANGE_KEY_1 = 2L;\n     private static final Long WRITE_RANGE_KEY_1 = 1L;\n@@ -171,22 +184,24 @@ public static String loadFromEnv(String key, String defaultValue) {\n \n     @BeforeAll\n     public void initializeStorages() throws StorageException {\n-        SecretKey secretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false);\n-        List<SecretKey> secretKeyList = new ArrayList<>();\n-        secretKeyList.add(secretKey);\n-        SecretsData secretsData = new SecretsData(secretKeyList, VERSION);\n+        Secret secret = new EncryptionSecret(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList = new ArrayList<>();\n+        secretList.add(secret);\n+        SecretsData secretsData = new SecretsData(secretList, secret);\n         SecretKeyAccessor secretKeyAccessor = () -> secretsData;\n         StorageConfig config = new StorageConfig()\n-                .setEnvId(loadFromEnv(INT_INC_ENVIRONMENT_ID))\n+                .setEnvironmentId(loadFromEnv(INT_INC_ENVIRONMENT_ID))\n                 .setApiKey(loadFromEnv(INT_INC_API_KEY))\n-                .setEndPoint(loadFromEnv(INT_INC_ENDPOINT))\n+                .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n+                .setEndpointMask(ENDPOINT_MASK)\n+                .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT)\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n-        storageWithApiKey = StorageImpl.getInstance(config);\n+        storageWithApiKey = StorageImpl.newStorage(config);\n \n         config = new StorageConfig()\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setClientId(CLIENT_ID)\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n@@ -195,39 +210,37 @@ public void initializeStorages() throws StorageException {\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n-        storageOrdinary = StorageImpl.getInstance(config);\n+        storageOrdinary = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setSecretKeyAccessor(null);\n-        storageWithoutEncryption = StorageImpl.getInstance(config);\n+        storageWithoutEncryption = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setHashSearchKeys(false);\n-        storageNonHashing = StorageImpl.getInstance(config);\n+        storageNonHashing = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setHashSearchKeys(true)\n                 .setNormalizeKeys(true);\n-        storageIgnoreCase = StorageImpl.getInstance(config);\n+        storageIgnoreCase = StorageImpl.newStorage(config);\n \n-        SecretKey customSecretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false, true);\n-        List<SecretKey> secretKeyList2 = new ArrayList<>();\n-        secretKeyList2.add(customSecretKey);\n-        SecretsData anotherSecretsData = new SecretsData(secretKeyList2, customSecretKey.getVersion());\n+        Secret customSecretKey = new CustomEncryptionKey(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList2 = new ArrayList<>();\n+        secretList2.add(customSecretKey);\n+        SecretsData anotherSecretsData = new SecretsData(secretList2, customSecretKey);\n         SecretKeyAccessor anotherAccessor = () -> anotherSecretsData;\n-        List<Crypto> cryptoList = new ArrayList<>();\n-        cryptoList.add(new FernetCrypto(true));\n \n         config = config\n                 .copy()\n                 .setNormalizeKeys(false)\n                 .setSecretKeyAccessor(anotherAccessor)\n-                .setCustomEncryptionConfigsList(cryptoList);\n-        storageWithCustomCipher = StorageImpl.getInstance(config);\n+                .setCryptoProvider(new CryptoProvider(new FernetCipher(\"Fernet\")));\n+        storageWithCustomCipher = StorageImpl.newStorage(config);\n     }\n \n     private Stream<Arguments> storageProvider() {\n@@ -281,7 +294,11 @@ public void writeTest(Storage storage, String recordKey, String batchRecordKey,\n                 .setKey19(KEY_19).setKey20(KEY_20).setParentKey(PARENT_KEY)\n                 .setPrecommitBody(PRECOMMIT_BODY)\n                 .setServiceKey1(SERVICE_KEY_1)\n-                .setServiceKey2(SERVICE_KEY_2);\n+                .setServiceKey2(SERVICE_KEY_2)\n+                .setServiceKey3(SERVICE_KEY_3)\n+                .setServiceKey4(SERVICE_KEY_4)\n+                .setServiceKey5(SERVICE_KEY_5)\n+                .setExpiresAt(EXPIRES_AT);\n         storage.write(MIDIPOP_COUNTRY, record);\n     }\n \n@@ -317,6 +334,9 @@ public void readTest(Storage storage, String recordKey, String batchRecordKey, S\n         assertEquals(PRECOMMIT_BODY, incomingRecord.getPrecommitBody());\n         assertEquals(SERVICE_KEY_1, incomingRecord.getServiceKey1());\n         assertEquals(SERVICE_KEY_2, incomingRecord.getServiceKey2());\n+        assertEquals(SERVICE_KEY_3, incomingRecord.getServiceKey3());\n+        assertEquals(SERVICE_KEY_4, incomingRecord.getServiceKey4());\n+        assertEquals(SERVICE_KEY_5, incomingRecord.getServiceKey5());\n         assertEquals(WRITE_RANGE_KEY_1, incomingRecord.getRangeKey1());\n         assertEquals(RANGE_KEY_2, incomingRecord.getRangeKey2());\n         assertEquals(RANGE_KEY_3, incomingRecord.getRangeKey3());\n@@ -329,140 +349,159 @@ public void readTest(Storage storage, String recordKey, String batchRecordKey, S\n         assertNotNull(incomingRecord.getRangeKey10());\n         assertNotNull(incomingRecord.getCreatedAt());\n         assertNotNull(incomingRecord.getUpdatedAt());\n+\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.setTime(EXPIRES_AT);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        assertEquals(calendar.getTime(), incomingRecord.getExpiresAt());\n     }\n \n     @ParameterizedTest(name = \"findTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(400)\n     public void findTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.KEY20, KEY_20)\n                 .keyEq(StringField.PARENT_KEY, PARENT_KEY)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n-                .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertNotNull(batchRecord.getRecords().get(0).getCreatedAt());\n-        assertNotNull(batchRecord.getRecords().get(0).getUpdatedAt());\n-\n-        builder.clear()\n+                .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1)\n+                .keyEq(DateField.EXPIRES_AT, EXPIRES_AT);\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertNotNull(findResult.getRecords().get(0).getCreatedAt());\n+        assertNotNull(findResult.getRecords().get(0).getUpdatedAt());\n+\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.setTime(EXPIRES_AT);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        assertEquals(calendar.getTime(), findResult.getRecords().get(0).getExpiresAt());\n+\n+        filter.clear()\n                 .keyEq(StringField.RECORD_KEY, batchRecordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(NumberField.RANGE_KEY1, BATCH_WRITE_RANGE_KEY_1);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n \n-        builder.clear()\n+        filter.clear()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        assertTrue(batchRecord.getRecords().stream().anyMatch(record\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        assertTrue(findResult.getRecords().stream().anyMatch(record\n                 -> record.getRecordKey().equals(batchRecordKey)));\n-        assertTrue(batchRecord.getRecords().stream().anyMatch(record\n+        assertTrue(findResult.getRecords().stream().anyMatch(record\n                 -> record.getRecordKey().equals(recordKey)));\n \n-        builder.clear()\n+        filter.clear()\n                 .keyNotEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n     }\n \n     @ParameterizedTest(name = \"findAdvancedTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(401)\n     public void findAdvancedTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1, BATCH_WRITE_RANGE_KEY_1, WRITE_RANGE_KEY_1 + BATCH_WRITE_RANGE_KEY_1 + 1);\n \n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.RANGE_KEY10, SortOrder.ASC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        Long record1Value = batchRecord.getRecords().get(0).getRangeKey10();\n-        Long record2Value = batchRecord.getRecords().get(1).getRangeKey10();\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.RANGE_KEY10, SortOrder.ASC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        Long record1Value = findResult.getRecords().get(0).getRangeKey10();\n+        Long record2Value = findResult.getRecords().get(1).getRangeKey10();\n         assertTrue(record1Value <= record2Value);\n \n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.RANGE_KEY10, SortOrder.DESC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        record1Value = batchRecord.getRecords().get(0).getRangeKey10();\n-        record2Value = batchRecord.getRecords().get(1).getRangeKey10();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.RANGE_KEY10, SortOrder.DESC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        record1Value = findResult.getRecords().get(0).getRangeKey10();\n+        record2Value = findResult.getRecords().get(1).getRangeKey10();\n         assertTrue(record1Value >= record2Value);\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.CREATED_AT, SortOrder.ASC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        Date record1date = batchRecord.getRecords().get(0).getCreatedAt();\n-        Date record2date = batchRecord.getRecords().get(1).getCreatedAt();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.CREATED_AT, SortOrder.ASC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        Date record1date = findResult.getRecords().get(0).getCreatedAt();\n+        Date record2date = findResult.getRecords().get(1).getCreatedAt();\n         assertTrue(record1date.before(record2date) || record1date.equals(record2date));\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.CREATED_AT, SortOrder.DESC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        record1date = batchRecord.getRecords().get(0).getCreatedAt();\n-        record2date = batchRecord.getRecords().get(1).getCreatedAt();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.CREATED_AT, SortOrder.DESC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        record1date = findResult.getRecords().get(0).getCreatedAt();\n+        record2date = findResult.getRecords().get(1).getCreatedAt();\n         assertTrue(record1date.after(record2date) || record1date.equals(record2date));\n \n-        builder = FindFilterBuilder.create().keyEq(StringField.KEY2, key2);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().keyIsNotNull(StringField.KEY20));\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        filter = new FindFilter().keyEq(StringField.KEY2, key2);\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter\n+                .copy()\n+                .keyIsNotNull(StringField.KEY20)\n+                .keyIsNotNull(DateField.EXPIRES_AT));\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertNotNull(findResult.getRecords().get(0).getExpiresAt());\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().keyIsNull(StringField.KEY20));\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter\n+                .copy()\n+                .keyIsNull(StringField.KEY20)\n+                .keyIsNull(DateField.EXPIRES_AT));\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertNull(findResult.getRecords().get(0).getExpiresAt());\n     }\n \n     @ParameterizedTest(name = \"findByVersionTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(402)\n     public void findByVersionTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n-                .keyEq(StringField.VERSION, String.valueOf(VERSION));\n-        BatchRecord batchRecord1 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord1.getCount());\n-        assertEquals(2, batchRecord1.getRecords().size());\n+                .keyEq(NumberField.VERSION, Long.valueOf(VERSION));\n+        FindResult findResult1 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult1.getCount());\n+        assertEquals(2, findResult1.getRecords().size());\n \n-        builder.keyEq(StringField.VERSION, String.valueOf(VERSION + 10));\n-        BatchRecord batchRecord2 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(0, batchRecord2.getCount());\n-        assertEquals(0, batchRecord2.getRecords().size());\n+        filter.keyEq(NumberField.VERSION, 10L + VERSION);\n+        FindResult findResult2 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(0, findResult2.getCount());\n+        assertEquals(0, findResult2.getRecords().size());\n \n-        builder.keyNotEq(StringField.VERSION, String.valueOf(VERSION));\n-        BatchRecord batchRecord3 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(0, batchRecord3.getCount());\n-        assertEquals(0, batchRecord3.getRecords().size());\n+        filter.keyNotEq(NumberField.VERSION, Long.valueOf(VERSION));\n+        FindResult findResult3 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(0, findResult3.getCount());\n+        assertEquals(0, findResult3.getRecords().size());\n \n-        builder.keyNotEq(StringField.VERSION, String.valueOf(VERSION + 10));\n-        BatchRecord batchRecord4 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord4.getCount());\n-        assertEquals(2, batchRecord4.getRecords().size());\n+        filter.keyNotEq(NumberField.VERSION, 10L + VERSION);\n+        FindResult findResult4 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult4.getCount());\n+        assertEquals(2, findResult4.getRecords().size());\n     }\n \n     @ParameterizedTest(name = \"findByAllFieldsTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(403)\n     public void findByAllFieldsTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY1, KEY_1)\n                 .keyEq(StringField.KEY2, key2)\n@@ -485,12 +524,15 @@ public void findByAllFieldsTest(Storage storage, String recordKey, String batchR\n                 .keyEq(NumberField.RANGE_KEY9, RANGE_KEY_9)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(SERVICE_KEY1, SERVICE_KEY_1)\n-                .keyEq(SERVICE_KEY2, SERVICE_KEY_2);\n-\n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        Record record = batchRecord.getRecords().get(0);\n+                .keyEq(SERVICE_KEY2, SERVICE_KEY_2)\n+                .keyEq(SERVICE_KEY3, SERVICE_KEY_3)\n+                .keyEq(SERVICE_KEY4, SERVICE_KEY_4)\n+                .keyEq(SERVICE_KEY5, SERVICE_KEY_5);\n+\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        Record record = findResult.getRecords().get(0);\n         assertEquals(recordKey, record.getRecordKey());\n         assertEquals(KEY_1, record.getKey1());\n         assertEquals(key2, record.getKey2());\n@@ -514,16 +556,19 @@ public void findByAllFieldsTest(Storage storage, String recordKey, String batchR\n         assertEquals(PROFILE_KEY, record.getProfileKey());\n         assertEquals(SERVICE_KEY_1, record.getServiceKey1());\n         assertEquals(SERVICE_KEY_2, record.getServiceKey2());\n+        assertEquals(SERVICE_KEY_3, record.getServiceKey3());\n+        assertEquals(SERVICE_KEY_4, record.getServiceKey4());\n+        assertEquals(SERVICE_KEY_5, record.getServiceKey5());\n     }\n \n     @ParameterizedTest(name = \"findOneTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(404)\n     public void findOneTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        Record record = storage.findOne(MIDIPOP_COUNTRY, builder);\n+        Record record = storage.findOne(MIDIPOP_COUNTRY, filter);\n         assertEquals(recordKey, record.getRecordKey());\n         assertEquals(RECORD_BODY, record.getBody());\n     }\n@@ -570,38 +615,38 @@ public void readIgnoreCaseTest() throws StorageException {\n     @Test\n     @Order(702)\n     public void findIgnoreCaseTest() throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE)\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        BatchRecord batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        FindResult findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n \n-        builder = builder.clear()\n+        filter = filter.clear()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE.toLowerCase())\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY.toLowerCase())\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n \n-        builder = builder.clear()\n+        filter = filter.clear()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE.toUpperCase())\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY.toUpperCase())\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n     }\n \n     @Test\n@@ -744,6 +789,22 @@ public void addAttachmentWithUnusualFileNameTest() throws StorageException, IOEx\n         Files.delete(tempFile);\n     }\n \n+    @Test\n+    @Order(813)\n+    void addBinaryFilesTest() throws StorageException, IOException {\n+        String filePath = \"./gradle/wrapper/gradle-wrapper.jar\";\n+        String fileName = \"gradle-wrapper.jar\";\n+        try (InputStream inputStream = new FileInputStream(filePath)) {\n+            AttachmentMeta meta = storageOrdinary.addAttachment(MIDIPOP_COUNTRY, ATTACHMENT_RECORD_KEY, inputStream, fileName, false);\n+            assertNotNull(meta);\n+            assertNotNull(meta.getFilename());\n+            assertNotNull(meta.getFileId());\n+            AttachedFile file = storageOrdinary.getAttachmentFile(MIDIPOP_COUNTRY, ATTACHMENT_RECORD_KEY, meta.getFileId());\n+            assertArrayEquals(IOUtils.toByteArray(new FileInputStream(filePath)), IOUtils.toByteArray(file.getFileContent()));\n+            assertTrue(storageOrdinary.deleteAttachment(MIDIPOP_COUNTRY, ATTACHMENT_RECORD_KEY, meta.getFileId()));\n+        }\n+    }\n+\n     @Test\n     @Order(899)\n     public void deleteRecordWithAttachment() throws StorageException {\n@@ -768,18 +829,16 @@ public void findWithSearchKeys() throws StorageException {\n                 .setRangeKey9(RANGE_KEY_9)\n                 .setRangeKey10(RANDOM.nextLong())\n                 .setKey1(KEY_1)\n-                .setPrecommitBody(PRECOMMIT_BODY)\n-                .setServiceKey1(SERVICE_KEY_1)\n-                .setServiceKey2(SERVICE_KEY_2);\n+                .setPrecommitBody(PRECOMMIT_BODY);\n         storageNonHashing.write(MIDIPOP_COUNTRY_2, record);\n \n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .searchKeysLike(KEY_1.split(\"-\")[2]);\n-        BatchRecord batchRecord = storageNonHashing.find(MIDIPOP_COUNTRY_2, builder);\n+        FindResult findResult = storageNonHashing.find(MIDIPOP_COUNTRY_2, filter);\n \n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertEquals(RECORD_BODY, batchRecord.getRecords().get(0).getBody());\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertEquals(RECORD_BODY, findResult.getRecords().get(0).getBody());\n \n         storageNonHashing.delete(MIDIPOP_COUNTRY_2, recordKey);\n     }\n@@ -797,25 +856,25 @@ public void utf8EncodingTest() throws StorageException {\n                 .setPrecommitBody(PRECOMMIT_BODY);\n         storageNonHashing.write(MIDIPOP_COUNTRY, record);\n \n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY1, key1);\n-        BatchRecord batchRecord = storageNonHashing.find(MIDIPOP_COUNTRY, builder);\n+        FindResult findResult = storageNonHashing.find(MIDIPOP_COUNTRY, filter);\n \n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertEquals(RECORD_BODY, batchRecord.getRecords().get(0).getBody());\n-        assertEquals(key1, batchRecord.getRecords().get(0).getKey1());\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertEquals(RECORD_BODY, findResult.getRecords().get(0).getBody());\n+        assertEquals(key1, findResult.getRecords().get(0).getKey1());\n \n         storageNonHashing.delete(MIDIPOP_COUNTRY, recordKey);\n     }\n \n     @Test\n     @Order(1000)\n     public void connectionPoolTest() throws StorageException, InterruptedException, ExecutionException {\n-        SecretKey secretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false);\n-        List<SecretKey> secretKeyList = new ArrayList<>();\n-        secretKeyList.add(secretKey);\n-        SecretsData secretsData = new SecretsData(secretKeyList, VERSION);\n+        Secret secret = new EncryptionSecret(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList = new ArrayList<>();\n+        secretList.add(secret);\n+        SecretsData secretsData = new SecretsData(secretList, secret);\n         SecretKeyAccessor mySecretKeyAccessor = () -> secretsData;\n \n         Map<String, String> authMap = new HashMap<>();\n@@ -830,15 +889,15 @@ public void connectionPoolTest() throws StorageException, InterruptedException,\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n                 .setEndpointMask(ENDPOINT_MASK)\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setSecretKeyAccessor(mySecretKeyAccessor)\n                 .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n         if (!authMap.isEmpty()) {\n             config.setAuthEndpoints(authMap);\n         }\n-        Storage customStorage = StorageImpl.getInstance(config);\n+        Storage customStorage = StorageImpl.newStorage(config);\n         //http pool size < concurrent threads < count of threads\n         ExecutorService executorService = Executors.newFixedThreadPool(HTTP_POOL_SIZE / 2);\n         List<Future<StorageException>> futureList = new ArrayList<>();"
  },
  {
    "sha": "98c64e069f3bed7b578bdc0b6b8622c1571ec986",
    "filename": "src/main/java/com/incountry/residence/sdk/Storage.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/Storage.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/Storage.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/Storage.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -2,10 +2,10 @@\n \n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n@@ -35,12 +35,12 @@\n      *\n      * @param country country identifier\n      * @param records record list\n-     * @return BatchRecord object which contains list of recorded records\n+     * @return list of recorded records\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if record encryption failed\n      */\n-    BatchRecord batchWrite(String country, List<Record> records) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    List<Record> batchWrite(String country, List<Record> records) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Read data from remote storage\n@@ -69,25 +69,25 @@\n      * Find records in remote storage according to filters\n      *\n      * @param country country identifier\n-     * @param builder object representing find filters and search options\n+     * @param filter object representing find filters and search options\n      * @return BatchRecord object which contains required records\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if decryption failed\n      */\n-    BatchRecord find(String country, FindFilterBuilder builder) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    FindResult find(String country, FindFilter filter) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Find only one first record in remote storage according to filters\n      *\n      * @param country country identifier\n-     * @param builder object representing find filters\n+     * @param filter object representing find filters\n      * @return founded record or null\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if decryption failed\n      */\n-    Record findOne(String country, FindFilterBuilder builder) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    Record findOne(String country, FindFilter filter) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Make batched key-rotation-migration of records"
  },
  {
    "sha": "6be6d487da92681fe8ad84c83919d7161859a70b",
    "filename": "src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "status": "modified",
    "additions": 70,
    "deletions": 28,
    "changes": 98,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/StorageConfig.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,18 +1,28 @@\n package com.incountry.residence.sdk;\n \n-import com.incountry.residence.sdk.tools.crypto.Crypto;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n+import com.incountry.residence.sdk.oauth.OauthTokenAccessor;\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n \n+import static com.incountry.residence.sdk.tools.ValidationHelper.isNullOrEmpty;\n+\n /**\n  * container with Storage configuration, using pattern 'builder'\n  */\n public class StorageConfig {\n \n+    private static final Logger LOG = LogManager.getLogger(StorageConfig.class);\n+    private static final ValidationHelper HELPER = new ValidationHelper(LOG);\n+\n+\n+    public static final String MSG_ERR_NULL_TOKEN = \"OAuth2 token is null or empty\";\n     public static final String MSG_SECURE = \"[SECURE[%s]]\";\n     //params from OS env\n     public static final String PARAM_ENV_ID = \"INC_ENVIRONMENT_ID\";\n@@ -21,11 +31,11 @@\n     public static final String PARAM_CLIENT_ID = \"INC_CLIENT_ID\";\n     public static final String PARAM_CLIENT_SECRET = \"INC_CLIENT_SECRET\";\n \n-    private String envId;\n+    private String environmentId;\n     private String apiKey;\n     private String endPoint;\n     private SecretKeyAccessor secretKeyAccessor;\n-    private List<Crypto> customEncryptionConfigsList;\n+    private CryptoProvider cryptoProvider;\n     private String clientId;\n     private String clientSecret;\n     private boolean normalizeKeys;\n@@ -37,29 +47,30 @@\n     private Integer maxHttpPoolSize;\n     private Integer maxHttpConnectionsPerRoute;\n     private boolean hashSearchKeys = true;\n+    private OauthTokenAccessor oauthTokenAccessor;\n \n-    public String getEnvId() {\n-        return envId;\n+    public String getEnvironmentId() {\n+        return environmentId;\n     }\n \n     /**\n      * sets environment ID\n      *\n-     * @param envId environment ID\n+     * @param environmentId environment ID\n      * @return StorageConfig\n      */\n-    public StorageConfig setEnvId(String envId) {\n-        this.envId = envId;\n+    public StorageConfig setEnvironmentId(String environmentId) {\n+        this.environmentId = environmentId;\n         return this;\n     }\n \n     /**\n-     * load envId from env variable 'INC_ENVIRONMENT_ID'\n+     * load environmentId from env variable 'INC_ENVIRONMENT_ID'\n      *\n      * @return StorageConfig\n      */\n-    public StorageConfig useEnvIdFromEnv() {\n-        this.envId = loadFromEnv(PARAM_ENV_ID);\n+    public StorageConfig useEnvironmentIdFromEnv() {\n+        this.environmentId = loadFromEnv(PARAM_ENV_ID);\n         return this;\n     }\n \n@@ -129,18 +140,19 @@ public StorageConfig setSecretKeyAccessor(SecretKeyAccessor secretKeyAccessor) {\n         return this;\n     }\n \n-    public List<Crypto> getCustomEncryptionConfigsList() {\n-        return customEncryptionConfigsList == null ? null : new ArrayList<>(customEncryptionConfigsList);\n+    public CryptoProvider getCryptoProvider() {\n+        return cryptoProvider;\n     }\n \n     /**\n-     * Optional. For custom encryption\n+     * Optional. Provider of encryption ciphers. Allows to register custom ciphers for encrypting stored data.\n+     * If null - default AES GCM cipher will be used\n      *\n-     * @param customEncryptionConfigsList List with custom encryption functions\n+     * @param cryptoProvider provider\n      * @return StorageConfig\n      */\n-    public StorageConfig setCustomEncryptionConfigsList(List<Crypto> customEncryptionConfigsList) {\n-        this.customEncryptionConfigsList = customEncryptionConfigsList;\n+    public StorageConfig setCryptoProvider(CryptoProvider cryptoProvider) {\n+        this.cryptoProvider = cryptoProvider;\n         return this;\n     }\n \n@@ -165,7 +177,7 @@ public String getClientId() {\n \n     /**\n      * Set login for oAuth authorization, can be also set via environment variable INC_CLIENT_ID.\n-     * Alternative way for authorisation - to use {@link #setApiKey(String)}\n+     * Alternative way for authorization - to use {@link #setApiKey(String)}\n      *\n      * @param clientId login\n      * @return StorageConfig\n@@ -191,7 +203,7 @@ public String getClientSecret() {\n \n     /**\n      * Set user secret for oAuth authorization, can be also set via environment variable INC_CLIENT_SECRET.\n-     * Alternative way for authorisation - to use {@link #setApiKey(String)}\n+     * Alternative way for authorization - to use {@link #setApiKey(String)}\n      *\n      * @param clientSecret password\n      * @return StorageConfig\n@@ -236,7 +248,7 @@ public String getDefaultAuthEndpoint() {\n      * Optional. Set custom oAuth authorization server URL, will be used as default one.\n      * Can't be null when {@link #setAuthEndpoints(Map)} is used\n      *\n-     * @param defaultAuthEndpoint custom authorisation endpoint\n+     * @param defaultAuthEndpoint custom authorization endpoint\n      * @return StorageConfig\n      */\n     public StorageConfig setDefaultAuthEndpoint(String defaultAuthEndpoint) {\n@@ -326,7 +338,7 @@ public boolean isHashSearchKeys() {\n     }\n \n     /**\n-     * Optional. If false - key1-key10 will be not hashed. Default is true\n+     * Optional. If false - key1-key20 will be not hashed. Default is true\n      *\n      * @param hashSearchKeys value\n      * @return StorageConfig\n@@ -336,13 +348,41 @@ public StorageConfig setHashSearchKeys(boolean hashSearchKeys) {\n         return this;\n     }\n \n+    public OauthTokenAccessor getOauthTokenAccessor() {\n+        return oauthTokenAccessor;\n+    }\n+\n+    /**\n+     * Optional. For using of a previously acquired oAuth token for OAuth2 authorization\n+     *\n+     * @param oauthToken non-empty token\n+     * @return StorageConfig config\n+     * @throws StorageClientException when a token is null or empty\n+     */\n+    public StorageConfig setOauthToken(String oauthToken) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(oauthToken), MSG_ERR_NULL_TOKEN);\n+        this.oauthTokenAccessor = () -> oauthToken;\n+        return this;\n+    }\n+\n+    /**\n+     * Optional. For an external acquiring of oAuth2 tokens for OAuth2 authorization\n+     *\n+     * @param oauthTokenAccessor token access function\n+     * @return StorageConfig config\n+     */\n+    public StorageConfig setOauthTokenAccessor(OauthTokenAccessor oauthTokenAccessor) {\n+        this.oauthTokenAccessor = oauthTokenAccessor;\n+        return this;\n+    }\n+\n     public StorageConfig copy() {\n         StorageConfig newInstance = new StorageConfig();\n-        newInstance.setEnvId(getEnvId());\n+        newInstance.setEnvironmentId(getEnvironmentId());\n         newInstance.setApiKey(getApiKey());\n         newInstance.setEndPoint(getEndPoint());\n         newInstance.setSecretKeyAccessor(getSecretKeyAccessor());\n-        newInstance.setCustomEncryptionConfigsList(getCustomEncryptionConfigsList());\n+        newInstance.setCryptoProvider(getCryptoProvider());\n         newInstance.setNormalizeKeys(isNormalizeKeys());\n         newInstance.setClientId(getClientId());\n         newInstance.setClientSecret(getClientSecret());\n@@ -353,17 +393,18 @@ public StorageConfig copy() {\n         newInstance.setDefaultAuthEndpoint(getDefaultAuthEndpoint());\n         newInstance.setMaxHttpPoolSize(getMaxHttpPoolSize());\n         newInstance.setHashSearchKeys(isHashSearchKeys());\n+        newInstance.setOauthTokenAccessor(getOauthTokenAccessor());\n         return newInstance;\n     }\n \n     @Override\n     public String toString() {\n         return \"StorageConfig{\" +\n-                \"envId='\" + hideParam(envId) + '\\'' +\n+                \"environmentId='\" + hideParam(environmentId) + '\\'' +\n                 \", apiKey='\" + hideParam(apiKey) + '\\'' +\n                 \", endPoint='\" + endPoint + '\\'' +\n                 \", secretKeyAccessor=\" + secretKeyAccessor +\n-                \", customEncryptionConfigsList=\" + customEncryptionConfigsList +\n+                \", cryptoProvider=\" + cryptoProvider +\n                 \", ignoreKeyCase=\" + normalizeKeys +\n                 \", clientId='\" + hideParam(clientId) + '\\'' +\n                 \", clientSecret='\" + hideParam(clientSecret) + '\\'' +\n@@ -374,6 +415,7 @@ public String toString() {\n                 \", httpTimeout='\" + httpTimeout + '\\'' +\n                 \", httpPoolSize='\" + maxHttpPoolSize + '\\'' +\n                 \", ignoreKeysHashing='\" + hashSearchKeys + '\\'' +\n+                \", oauthTokenAccessor=\" + oauthTokenAccessor +\n                 '}';\n     }\n "
  },
  {
    "sha": "0e0bead4de3ac4aef4f314b2ca5b20db53102c31",
    "filename": "src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "status": "modified",
    "additions": 129,
    "deletions": 221,
    "changes": 350,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/StorageImpl.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -2,22 +2,27 @@\n \n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n-import com.incountry.residence.sdk.dto.search.StringField;\n-import com.incountry.residence.sdk.tools.crypto.CryptoManager;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n+import com.incountry.residence.sdk.dto.search.NumberField;\n+import com.incountry.residence.sdk.oauth.OauthTokenAccessor;\n+import com.incountry.residence.sdk.tools.DtoTransformer;\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n+import com.incountry.residence.sdk.tools.crypto.HashUtils;\n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n import com.incountry.residence.sdk.tools.dao.Dao;\n import com.incountry.residence.sdk.tools.http.TokenClient;\n import com.incountry.residence.sdk.tools.http.impl.ApiKeyTokenClient;\n import com.incountry.residence.sdk.tools.http.impl.OAuthTokenClient;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n import com.incountry.residence.sdk.tools.dao.impl.HttpDaoImpl;\n import com.incountry.residence.sdk.tools.proxy.ProxyUtils;\n+import com.incountry.residence.sdk.tools.transfer.TransferFindResult;\n+import com.incountry.residence.sdk.tools.transfer.TransferRecord;\n import org.apache.http.client.config.RequestConfig;\n import org.apache.http.impl.client.CloseableHttpClient;\n import org.apache.http.impl.client.HttpClientBuilder;\n@@ -30,14 +35,17 @@\n import java.io.InputStream;\n import java.util.List;\n \n+import static com.incountry.residence.sdk.tools.ValidationHelper.isNullOrEmpty;\n+\n /**\n  * Basic implementation\n  */\n public class StorageImpl implements Storage {\n     private static final Logger LOG = LogManager.getLogger(StorageImpl.class);\n+    private static final ValidationHelper HELPER = new ValidationHelper(LOG);\n     //error messages\n     private static final String MSG_ERR_PASS_ENV = \"Please pass environment_id param or set INC_ENVIRONMENT_ID env var\";\n-    private static final String MSG_ERR_AUTH_DUPL = \"Either apiKey or clientId/clientSecret can be used at the same moment, not both\";\n+    private static final String MSG_ERR_AUTH = \"Please pass only one parameter combination for authorization: clientId/clientSecret or apiKey or oauthTokenAccessor\";\n     private static final String MSG_ERR_PASS_API_KEY = \"Please pass api_key param or set INC_API_KEY env var\";\n     private static final String MSG_ERR_NULL_BATCH = \"Can't write empty batch\";\n     private static final String MSG_ERR_NULL_COUNTRY = \"Country can't be null\";\n@@ -47,128 +55,78 @@\n     private static final String MSG_ERR_NULL_RECORD = \"Can't write null record\";\n     private static final String MSG_ERR_MIGR_NOT_SUPPORT = \"Migration is not supported when encryption is off\";\n     private static final String MSG_ERR_MIGR_ERROR_LIMIT = \"Limit can't be < 1\";\n-    private static final String MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR = \"Custom encryption can be used only with not null SecretKeyAccessor\";\n     private static final String MSG_ERR_CONFIG = \"Storage configuration is null\";\n-    private static final String MSG_ERR_PASS_CLIENT_ID = \"Please pass clientId in configuration or set INC_CLIENT_ID env var\";\n-    private static final String MSG_ERR_PASS_CLIENT_SECRET = \"Please pass clientSecret in configuration or set INC_CLIENT_SECRET env var\";\n-    private static final String MSG_ERR_PASS_AUTH = \"Please pass (clientId, clientSecret) in configuration or set (INC_CLIENT_ID, INC_CLIENT_SECRET) env vars\";\n+    private static final String MSG_ERR_PASS_CLIENT_ID = \"Please pass clientId in configuration\";\n+    private static final String MSG_ERR_PASS_CLIENT_SECRET = \"Please pass clientSecret in configuration\";\n     private static final String MSG_ERR_ILLEGAL_TIMEOUT = \"Connection timeout can't be <1. Expected 'null' or positive value, received=%d\";\n     private static final String MSG_ERR_CONNECTION_POOL = \"HTTP pool size can't be < 1. Expected 'null' or positive value, received=%d\";\n     private static final String MSG_ERR_MAX_CONNECTIONS_PER_ROUTE = \"Max HTTP connections count per route can't be < 1. Expected 'null' or positive value, received=%d\";\n     private static final String MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE = \"File name and MIME type can't be null\";\n     private static final String MSG_ERR_NULL_FILE_INPUT_STREAM = \"Input stream can't be null\";\n     private static final String MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM = \"Input stream is not available\";\n-    private static final String MSG_ERR_KEY_LENGTH = \"key1-key20 length can't be more than 256 chars\";\n-\n     private static final String MSG_FOUND_NOTHING = \"Nothing was found\";\n+    private static final String MSG_ERR_UNEXPECTED = \"Unexpected error\";\n+    private static final String MSG_ERR_NULL_SECRETS = \"SecretKeyAccessor returns null secret\";\n+\n     private static final int DEFAULT_HTTP_TIMEOUT = 30;\n     private static final int DEFAULT_MAX_HTTP_CONNECTIONS = 20;\n \n-    private CryptoManager cryptoManager;\n-    private Dao dao;\n-    private boolean encrypted;\n-    private boolean hashSearchKeys;\n-\n-    private StorageImpl() {\n-    }\n-\n-    /**\n-     * creating Storage instance with ENV variables without encryption\n-     *\n-     * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n-     */\n-    public static Storage getInstance() throws StorageClientException {\n-        return getInstance((SecretKeyAccessor) null);\n-    }\n+    private final Dao dao;\n+    private final HashUtils hashUtils;\n+    private final DtoTransformer transformer;\n \n-    /**\n-     * creating Storage instance with ENV variables\n-     *\n-     * @param secretKeyAccessor Instance of SecretKeyAccessor class. Used to fetch encryption secret\n-     * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n-     */\n-    public static Storage getInstance(SecretKeyAccessor secretKeyAccessor) throws StorageClientException {\n-        StorageConfig config = new StorageConfig()\n-                .setSecretKeyAccessor(secretKeyAccessor)\n-                .useEnvIdFromEnv()\n-                .useApiKeyFromEnv()\n-                .useEndPointFromEnv()\n-                .useClientIdFromEnv()\n-                .useClientSecretFromEnv();\n-        return getInstance(config);\n+    private StorageImpl(StorageConfig config, Dao dao) throws StorageClientException, StorageCryptoException {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"StorageImpl constructor params config={}\", config);\n+        }\n+        HELPER.check(StorageClientException.class, config == null, MSG_ERR_CONFIG);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(config.getEnvironmentId()), MSG_ERR_PASS_ENV);\n+        int alternativeAuthCount = 0;\n+        alternativeAuthCount += config.getApiKey() != null ? 1 : 0;\n+        alternativeAuthCount += config.getClientId() != null ? 1 : 0;\n+        alternativeAuthCount += config.getOauthTokenAccessor() != null ? 1 : 0;\n+        HELPER.check(StorageClientException.class, alternativeAuthCount != 1, MSG_ERR_AUTH);\n+\n+        this.dao = initDao(config, dao);\n+        this.hashUtils = new HashUtils(config.getEnvironmentId(), config.isNormalizeKeys());\n+        CryptoProvider cryptoProvider = config.getCryptoProvider() == null ? new CryptoProvider(null) : config.getCryptoProvider();\n+        if (config.getSecretKeyAccessor() != null) {\n+            boolean invalidAccessor;\n+            try {\n+                invalidAccessor = config.getSecretKeyAccessor().getSecretsData() == null;\n+            } catch (Exception ex) {\n+                LOG.error(MSG_ERR_UNEXPECTED, ex);\n+                throw new StorageClientException(MSG_ERR_UNEXPECTED, ex);\n+            }\n+            HELPER.check(StorageClientException.class, invalidAccessor, MSG_ERR_NULL_SECRETS);\n+        }\n+        cryptoProvider.validateCustomCiphers(config.getSecretKeyAccessor() == null ? null : config.getSecretKeyAccessor().getSecretsData());\n+        this.transformer = new DtoTransformer(cryptoProvider, hashUtils, config.isHashSearchKeys(), config.getSecretKeyAccessor());\n     }\n \n     /**\n-     * creating Storage instance\n+     * create new Storage instance\n      *\n-     * @param environmentID     Required to be passed in, or as environment variable INC_API_KEY with {@link #getInstance()}\n-     * @param apiKey            Required to be passed in, or as environment variable INC_ENVIRONMENT_ID with {@link #getInstance()}\n-     * @param endpoint          Optional. Defines API URL. Default endpoint will be used if this param is null\n-     * @param secretKeyAccessor Instance of SecretKeyAccessor class. Used to fetch encryption secret\n+     * @param config A container with configuration for Storage initialization\n      * @return instance of Storage\n      * @throws StorageClientException if configuration validation finished with errors\n+     * @throws StorageCryptoException if custom cipher validation fails\n      */\n-    public static Storage getInstance(String environmentID, String apiKey, String endpoint, SecretKeyAccessor secretKeyAccessor)\n-            throws StorageClientException {\n-        StorageConfig config = new StorageConfig()\n-                .setSecretKeyAccessor(secretKeyAccessor)\n-                .setEnvId(environmentID)\n-                .setApiKey(apiKey)\n-                .setEndPoint(endpoint);\n-        return getInstance(config);\n+    public static Storage newStorage(StorageConfig config) throws StorageClientException, StorageCryptoException {\n+        return newStorage(config, null);\n     }\n \n     /**\n-     * creating Storage instance\n+     * overloaded version for tests and debugging\n      *\n      * @param config A container with configuration for Storage initialization\n+     * @param dao    dao, can be mocked for tests\n      * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n+     * @throws StorageClientException if parameter validation finished with errors\n+     * @throws StorageCryptoException if custom cipher validation fails\n      */\n-    public static Storage getInstance(StorageConfig config)\n-            throws StorageClientException {\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"StorageImpl constructor params config={}\", config);\n-        }\n-        if (config == null) {\n-            LOG.error(MSG_ERR_CONFIG);\n-            throw new StorageClientException(MSG_ERR_CONFIG);\n-        }\n-        if (config.getSecretKeyAccessor() == null && !(config.getCustomEncryptionConfigsList() == null || config.getCustomEncryptionConfigsList().isEmpty())) {\n-            LOG.error(MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR);\n-            throw new StorageClientException(MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR);\n-        }\n-        return getInstance(config, null);\n-    }\n-\n-    public static Storage getInstance(String environmentID, SecretKeyAccessor secretKeyAccessor, Dao dao) throws StorageClientException {\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"StorageImpl constructor params (environmentID={} , secretKeyAccessor={} , dao={})\",\n-                    environmentID != null ? String.format(StorageConfig.MSG_SECURE, environmentID.hashCode()) : null,\n-                    secretKeyAccessor,\n-                    dao\n-            );\n-        }\n-        StorageConfig config = new StorageConfig()\n-                .setEnvId(environmentID)\n-                .setSecretKeyAccessor(secretKeyAccessor);\n-        return getInstance(config, dao);\n-    }\n-\n-    private static Storage getInstance(StorageConfig config, Dao dao)\n-            throws StorageClientException {\n-        checkNotNull(config.getEnvId(), MSG_ERR_PASS_ENV);\n-        if (config.getApiKey() != null && config.getClientId() != null) {\n-            LOG.error(MSG_ERR_AUTH_DUPL);\n-            throw new StorageClientException(MSG_ERR_AUTH_DUPL);\n-        }\n-        StorageImpl instance = new StorageImpl();\n-        instance.dao = initDao(config, dao);\n-        instance.encrypted = config.getSecretKeyAccessor() != null;\n-        instance.cryptoManager = new CryptoManager(config.getSecretKeyAccessor(), config.getEnvId(), config.getCustomEncryptionConfigsList(), config.isNormalizeKeys(), config.isHashSearchKeys());\n-        instance.hashSearchKeys = config.isHashSearchKeys();\n+    public static Storage newStorage(StorageConfig config, Dao dao) throws StorageClientException, StorageCryptoException {\n+        Storage instance = new StorageImpl(config, dao);\n         return ProxyUtils.createLoggingProxyForPublicMethods(instance, true);\n     }\n \n@@ -203,25 +161,32 @@ private static Dao initDao(StorageConfig config, Dao dao) throws StorageClientEx\n \n             CloseableHttpClient httpClient = initHttpClient(httpTimeout, httpPoolSize, connectionsPerRoute);\n             TokenClient tokenClient;\n-            if (config.getClientId() != null && config.getClientSecret() != null) {\n-                checkNotNull(config.getClientId(), MSG_ERR_PASS_CLIENT_ID);\n-                checkNotNull(config.getClientSecret(), MSG_ERR_PASS_CLIENT_SECRET);\n+            if (config.getClientId() != null) {\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getClientId()), MSG_ERR_PASS_CLIENT_ID);\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getClientSecret()), MSG_ERR_PASS_CLIENT_SECRET);\n                 tokenClient = new OAuthTokenClient(config.getDefaultAuthEndpoint(),\n                         config.getAuthEndpoints(),\n-                        config.getEnvId(),\n+                        config.getEnvironmentId(),\n                         config.getClientId(),\n                         config.getClientSecret(),\n                         httpClient\n                 );\n                 tokenClient = ProxyUtils.createLoggingProxyForPublicMethods(tokenClient, true);\n             } else if (config.getApiKey() != null) {\n-                checkNotNull(config.getApiKey(), MSG_ERR_PASS_API_KEY);\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getApiKey()), MSG_ERR_PASS_API_KEY);\n                 tokenClient = new ApiKeyTokenClient(config.getApiKey());\n             } else {\n-                LOG.error(MSG_ERR_PASS_AUTH);\n-                throw new StorageClientException(MSG_ERR_PASS_AUTH);\n+                OauthTokenAccessor accessor = config.getOauthTokenAccessor();\n+                tokenClient = (force, audience, region) -> {\n+                    try {\n+                        return accessor.getToken();\n+                    } catch (Exception ex) {\n+                        LOG.error(MSG_ERR_UNEXPECTED, ex);\n+                        throw new StorageServerException(MSG_ERR_UNEXPECTED, ex);\n+                    }\n+                };\n             }\n-            return new HttpDaoImpl(config.getEnvId(),\n+            return new HttpDaoImpl(config.getEnvironmentId(),\n                     config.getEndPoint(),\n                     config.getEndpointMask(),\n                     config.getCountriesEndpoint(),\n@@ -233,146 +198,84 @@ private static Dao initDao(StorageConfig config, Dao dao) throws StorageClientEx\n     }\n \n     private static void checkPositiveOrNull(Integer intValue, String errorMessage) throws StorageClientException {\n-        if (intValue != null && intValue < 1) {\n-            String errMessage = String.format(errorMessage, intValue);\n-            LOG.error(errMessage);\n-            throw new StorageClientException(errMessage);\n-        }\n-    }\n-\n-    private static void checkNotNull(Object parameter, String nullErrorMessage) throws StorageClientException {\n-        if (parameter == null || String.valueOf(parameter).isEmpty()) {\n-            LOG.error(nullErrorMessage);\n-            throw new StorageClientException(nullErrorMessage);\n-        }\n+        boolean invalidParams = intValue != null && intValue < 1;\n+        HELPER.check(StorageClientException.class, invalidParams, errorMessage, intValue);\n     }\n \n     private static void checkFileNameAndMimeType(String fileName, String mimeType) throws StorageClientException {\n-        if ((fileName == null || fileName.isEmpty()) && (mimeType == null || mimeType.isEmpty())) {\n-            LOG.error(MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n-            throw new StorageClientException(MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n-        }\n+        boolean invalidParams = isNullOrEmpty(fileName) && isNullOrEmpty(mimeType);\n+        HELPER.check(StorageClientException.class, invalidParams, MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n     }\n \n     private void checkCountryAndRecordKey(String country, String key) throws StorageClientException {\n-        checkNotNull(country, MSG_ERR_NULL_COUNTRY);\n-        checkNotNull(key, MSG_ERR_NULL_KEY);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(country), MSG_ERR_NULL_COUNTRY);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(key), MSG_ERR_NULL_KEY);\n     }\n \n     private void checkAttachmentParameters(String country, String key, String fileId) throws StorageClientException {\n-        checkNotNull(fileId, MSG_ERR_NULL_FILE_ID);\n+        boolean invalidFileId = isNullOrEmpty(fileId);\n+        HELPER.check(StorageClientException.class, invalidFileId, MSG_ERR_NULL_FILE_ID);\n         checkCountryAndRecordKey(country, key);\n     }\n \n-    private void checkKey(String key) throws StorageClientException {\n-        if (key != null && key.length() > 256) {\n-            LOG.error(MSG_ERR_KEY_LENGTH);\n-            throw new StorageClientException(MSG_ERR_KEY_LENGTH);\n-        }\n-    }\n-\n-    private void checkRecordSearchKeys(Record record) throws StorageClientException {\n-        if (!hashSearchKeys) {\n-            checkKey(record.getKey1());\n-            checkKey(record.getKey2());\n-            checkKey(record.getKey3());\n-            checkKey(record.getKey4());\n-            checkKey(record.getKey5());\n-            checkKey(record.getKey6());\n-            checkKey(record.getKey7());\n-            checkKey(record.getKey8());\n-            checkKey(record.getKey9());\n-            checkKey(record.getKey10());\n-            checkKey(record.getKey11());\n-            checkKey(record.getKey12());\n-            checkKey(record.getKey13());\n-            checkKey(record.getKey14());\n-            checkKey(record.getKey15());\n-            checkKey(record.getKey16());\n-            checkKey(record.getKey17());\n-            checkKey(record.getKey18());\n-            checkKey(record.getKey19());\n-            checkKey(record.getKey20());\n-\n-        }\n-    }\n-\n-    public Record write(String country, Record record) throws\n-            StorageClientException, StorageServerException, StorageCryptoException {\n-        checkNotNull(record, MSG_ERR_NULL_RECORD);\n+    public Record write(String country, Record record) throws StorageClientException, StorageServerException, StorageCryptoException {\n+        HELPER.check(StorageClientException.class, record == null, MSG_ERR_NULL_RECORD);\n         checkCountryAndRecordKey(country, record.getRecordKey());\n-        checkRecordSearchKeys(record);\n-        dao.createRecord(country, record, cryptoManager);\n+        dao.createRecord(country, transformer.getTransferRecord(record));\n         return record;\n     }\n \n \n     public Record read(String country, String recordKey) throws StorageClientException, StorageServerException, StorageCryptoException {\n         checkCountryAndRecordKey(country, recordKey);\n-        return dao.read(country, cryptoManager.createKeyHash(recordKey), cryptoManager);\n+        TransferRecord transferRecord = dao.read(country, hashUtils.getSha256Hash(recordKey));\n+        return transformer.getRecord(transferRecord);\n     }\n \n     public MigrateResult migrate(String country, int limit) throws\n             StorageClientException, StorageServerException, StorageCryptoException {\n-        if (!encrypted) {\n-            LOG.error(MSG_ERR_MIGR_NOT_SUPPORT);\n-            throw new StorageClientException(MSG_ERR_MIGR_NOT_SUPPORT);\n-        }\n-        if (limit < 1) {\n-            LOG.error(MSG_ERR_MIGR_ERROR_LIMIT);\n-            throw new StorageClientException(MSG_ERR_MIGR_ERROR_LIMIT);\n-        }\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        HELPER.check(StorageClientException.class, transformer.getKeyAccessor() == null, MSG_ERR_MIGR_NOT_SUPPORT);\n+        HELPER.check(StorageClientException.class, limit < 1, MSG_ERR_MIGR_ERROR_LIMIT);\n+        FindFilter builder = new FindFilter()\n                 .limitAndOffset(limit, 0)\n-                .keyNotEq(StringField.VERSION, String.valueOf(cryptoManager.getCurrentSecretVersion()));\n-        BatchRecord batchRecord = find(country, builder);\n-        if (!batchRecord.getRecords().isEmpty()) {\n-            batchWrite(country, batchRecord.getRecords());\n+                .keyNotEq(NumberField.VERSION, Long.valueOf(transformer.getKeyAccessor().getSecretsData().getCurrentSecret().getVersion()));\n+        FindResult findResult = find(country, builder);\n+        if (!findResult.getRecords().isEmpty()) {\n+            batchWrite(country, findResult.getRecords());\n         }\n-        return new MigrateResult(batchRecord.getRecords().size(),\n-                batchRecord.getTotal() - batchRecord.getRecords().size(),\n-                batchRecord.getErrors());\n+        return new MigrateResult(findResult.getRecords().size(),\n+                findResult.getTotal() - findResult.getRecords().size(),\n+                findResult.getErrors());\n     }\n \n-    public BatchRecord batchWrite(String country, List<Record> records) throws\n-            StorageClientException, StorageServerException, StorageCryptoException {\n-        if (records == null || records.isEmpty()) {\n-            LOG.error(MSG_ERR_NULL_BATCH);\n-            throw new StorageClientException(MSG_ERR_NULL_BATCH);\n-        } else {\n-            for (Record record : records) {\n-                checkCountryAndRecordKey(country, record.getRecordKey());\n-                checkRecordSearchKeys(record);\n-            }\n-            dao.createBatch(records, country, cryptoManager);\n+    public List<Record> batchWrite(String country, List<Record> records)\n+            throws StorageClientException, StorageServerException, StorageCryptoException {\n+        boolean invalidList = records == null || records.isEmpty();\n+        HELPER.check(StorageClientException.class, invalidList, MSG_ERR_NULL_BATCH);\n+        for (Record record : records) {\n+            HELPER.check(StorageClientException.class, record == null, MSG_ERR_NULL_RECORD);\n+            checkCountryAndRecordKey(country, record.getRecordKey());\n         }\n-        return new BatchRecord(records, 0, 0, 0, 0, null);\n+        dao.createBatch(country, transformer.getTransferRecordList(records));\n+        return records;\n     }\n \n     public boolean delete(String country, String recordKey) throws StorageClientException, StorageServerException {\n         checkCountryAndRecordKey(country, recordKey);\n-        dao.delete(country, cryptoManager.createKeyHash(recordKey));\n+        dao.delete(country, hashUtils.getSha256Hash(recordKey));\n         return true;\n     }\n \n-    public BatchRecord find(String country, FindFilterBuilder builder) throws\n-            StorageClientException, StorageServerException {\n-        checkNotNull(country, MSG_ERR_NULL_COUNTRY);\n-        checkNotNull(builder, MSG_ERR_NULL_FILTERS);\n-        return dao.find(country, builder.build(), cryptoManager);\n+    public FindResult find(String country, FindFilter filter) throws StorageClientException, StorageServerException {\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(country), MSG_ERR_NULL_COUNTRY);\n+        HELPER.check(StorageClientException.class, filter == null, MSG_ERR_NULL_FILTERS);\n+        TransferFindResult transferFindResult = dao.find(country, transformer.getTransferFilterContainer(filter));\n+        return transformer.getFindResult(transferFindResult);\n     }\n \n-    /**\n-     * Find one record in remote storage\n-     *\n-     * @param country country identifier\n-     * @param builder object representing find filters\n-     * @return Record object which contains required data\n-     * @throws StorageServerException if server connection failed or server response error\n-     */\n-    public Record findOne(String country, FindFilterBuilder builder) throws\n+    public Record findOne(String country, FindFilter filter) throws\n             StorageClientException, StorageServerException {\n-        BatchRecord findResults = find(country, builder != null ? builder.copy().limitAndOffset(1, 0) : null);\n+        FindResult findResults = find(country, filter != null ? filter.copy().limitAndOffset(1, 0) : null);\n         List<Record> records = findResults.getRecords();\n         if (records.isEmpty()) {\n             LOG.warn(MSG_FOUND_NOTHING);\n@@ -400,40 +303,45 @@ public AttachmentMeta addAttachment(String country, String recordKey, InputStrea\n     public AttachmentMeta addAttachment(String country, String recordKey, InputStream inputStream, String fileName, boolean upsert, String mimeType) throws StorageClientException, StorageServerException {\n         checkCountryAndRecordKey(country, recordKey);\n         try {\n-            if (inputStream == null || inputStream.available() < 0) {\n-                LOG.error(MSG_ERR_NULL_FILE_INPUT_STREAM);\n-                throw new StorageClientException(MSG_ERR_NULL_FILE_INPUT_STREAM);\n-            }\n+            boolean invalidStream = inputStream == null || inputStream.available() < 0;\n+            HELPER.check(StorageClientException.class, invalidStream, MSG_ERR_NULL_FILE_INPUT_STREAM);\n         } catch (IOException ex) {\n             LOG.error(MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM);\n             throw new StorageClientException(MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM, ex);\n         }\n-        return dao.addAttachment(country, cryptoManager.createKeyHash(recordKey), inputStream, fileName, upsert, mimeType);\n+        return dao.addAttachment(country, hashUtils.getSha256Hash(recordKey), inputStream, fileName, upsert, mimeType);\n     }\n \n     @Override\n     public boolean deleteAttachment(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        dao.deleteAttachment(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        dao.deleteAttachment(country, hashUtils.getSha256Hash(recordKey), fileId);\n         return true;\n     }\n \n     @Override\n     public AttachedFile getAttachmentFile(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.getAttachmentFile(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        return dao.getAttachmentFile(country, hashUtils.getSha256Hash(recordKey), fileId);\n     }\n \n     @Override\n     public AttachmentMeta updateAttachmentMeta(String country, String recordKey, String fileId, String fileName, String mimeType) throws StorageClientException, StorageServerException {\n         checkFileNameAndMimeType(fileName, mimeType);\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.updateAttachmentMeta(country, cryptoManager.createKeyHash(recordKey), fileId, fileName, mimeType);\n+        AttachmentMeta updatedMeta = new AttachmentMeta();\n+        if (!isNullOrEmpty(fileName)) {\n+            updatedMeta.setFilename(fileName);\n+        }\n+        if (!isNullOrEmpty(mimeType)) {\n+            updatedMeta.setMimeType(mimeType);\n+        }\n+        return dao.updateAttachmentMeta(country, hashUtils.getSha256Hash(recordKey), fileId, updatedMeta);\n     }\n \n     @Override\n     public AttachmentMeta getAttachmentMeta(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.getAttachmentMeta(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        return dao.getAttachmentMeta(country, hashUtils.getSha256Hash(recordKey), fileId);\n     }\n }"
  },
  {
    "sha": "df46b3d3f8b8c0610d47eee196c6e24904607c41",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,84 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.crypto.cipher.Cipher;\n+import com.incountry.residence.sdk.tools.crypto.cipher.Ciphertext;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+public abstract class AbstractCipher implements Cipher {\n+\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(AbstractCipher.class));\n+    private static final String PREFIX_CUSTOM_ENCRYPTION = \"c\";\n+\n+    private static final String MSG_ERR_INVALID_KEY_CLASS = \"Used key from secrets data is not instance of CustomEncryptionKey\";\n+    private static final String MSG_ERR_NULL_CIPHER_NAME = \"Cipher has null name\";\n+\n+    private final String name;\n+    private final String nameBase64;\n+\n+    protected Charset charset = StandardCharsets.UTF_8;\n+\n+    @SuppressWarnings(\"java:S2259\")\n+    protected AbstractCipher(String name) throws StorageClientException {\n+        boolean invalidName = name == null || name.isEmpty();\n+        HELPER.check(StorageClientException.class, invalidName, MSG_ERR_NULL_CIPHER_NAME);\n+        this.name = name;\n+        this.nameBase64 = base64(name);\n+    }\n+\n+    private String base64(String name) {\n+        String base64String = Base64.getEncoder().encodeToString(name.getBytes(charset));\n+        return PREFIX_CUSTOM_ENCRYPTION + base64String;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getNameBase64() {\n+        return nameBase64;\n+    }\n+\n+    /**\n+     * encrypts data with secretKey\n+     *\n+     * @param textBytes data for encryption\n+     * @param secretKey secret\n+     * @return encrypted data as String\n+     * @throws StorageClientException when parameters validation fails\n+     * @throws StorageCryptoException when encryption fails\n+     */\n+    public abstract String encrypt(byte[] textBytes, CustomEncryptionKey secretKey) throws StorageClientException, StorageCryptoException;\n+\n+    public Ciphertext encrypt(String text, Secret secret) throws StorageCryptoException, StorageClientException {\n+        boolean correctSecretType = secret instanceof CustomEncryptionKey;\n+        HELPER.check(StorageCryptoException.class, !correctSecretType, MSG_ERR_INVALID_KEY_CLASS);\n+        String cipheredText = encrypt(text.getBytes(charset), (CustomEncryptionKey) secret);\n+        return new Ciphertext(nameBase64 + \":\" + Base64.getEncoder().encodeToString(cipheredText.getBytes(charset)),\n+                secret.getVersion());\n+    }\n+\n+    /**\n+     * decrypts data with Secret\n+     *\n+     * @param cipherTextBytes encrypted data\n+     * @param secretKey       secret\n+     * @return decrypted data as String\n+     * @throws StorageClientException when parameters validation fails\n+     * @throws StorageCryptoException when decryption fails\n+     */\n+    public abstract String decrypt(byte[] cipherTextBytes, CustomEncryptionKey secretKey) throws StorageClientException, StorageCryptoException;\n+\n+    public String decrypt(String cipherText, Secret secret) throws StorageCryptoException, StorageClientException {\n+        boolean correctSecretType = secret instanceof CustomEncryptionKey;\n+        HELPER.check(StorageCryptoException.class, !correctSecretType, MSG_ERR_INVALID_KEY_CLASS);\n+        return decrypt(Base64.getDecoder().decode(cipherText), (CustomEncryptionKey) secret);\n+    }\n+}"
  },
  {
    "sha": "6bb71edc15c9f764b1985c046c7f936731078642",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,14 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+\n+public class CustomEncryptionKey extends Secret {\n+    public CustomEncryptionKey(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(CustomEncryptionKey.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "1c4bf3dbb040d521efe5371b75fe64a3c5d37b9c",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,24 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.LogManager;\n+\n+public class EncryptionKey extends Secret {\n+\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(EncryptionKey.class));\n+    private static final int KEY_LENGTH = 32;\n+    private static final String MSG_ERR_LENGTH = \"Wrong key length for encryption key . Should be \"\n+            + KEY_LENGTH + \"-byte array\";\n+\n+    public EncryptionKey(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+        boolean invalidLength = secretBytes.length != KEY_LENGTH;\n+        HELPER.check(StorageClientException.class, invalidLength, MSG_ERR_LENGTH);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(EncryptionKey.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "5dfa2f397a5c6a84b7aaf4acd989e3247e795953",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,14 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+\n+public class EncryptionSecret extends Secret {\n+    public EncryptionSecret(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(EncryptionSecret.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "82de343753db7f9c13dd4f1e2077fa61075df8ff",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/Secret.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,44 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.Arrays;\n+\n+public abstract class Secret {\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(Secret.class));\n+    private static final String MSG_ERR_VERSION = \"Version must be >= 0\";\n+    private static final String MSG_ERR_NULL_SECRET = \"Secret can't be null or empty\";\n+    private final int version;\n+    private final byte[] secretBytes;\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public byte[] getSecretBytes() {\n+        return secretBytes;\n+    }\n+\n+    protected Secret(int version, byte[] secretBytes) throws StorageClientException {\n+        validateAbstractSecret(version, secretBytes);\n+        this.version = version;\n+        this.secretBytes = secretBytes;\n+    }\n+\n+    private static void validateAbstractSecret(int version, byte[] secretBytes) throws StorageClientException {\n+        boolean invalidVersion = version < 0;\n+        HELPER.check(StorageClientException.class, invalidVersion, MSG_ERR_VERSION);\n+        boolean invalidSecret = secretBytes == null || secretBytes.length == 0;\n+        HELPER.check(StorageClientException.class, invalidSecret, MSG_ERR_NULL_SECRET);\n+    }\n+\n+\n+    protected String toString(String typeName) {\n+        return typeName + \"{\" +\n+                \"version=\" + version +\n+                \", secretBytes=HASH[\" + Arrays.hashCode(secretBytes) + ']' +\n+                '}';\n+    }\n+}"
  },
  {
    "sha": "522bed25f67b44dcdc53b0f694103af3c9d2a1a8",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,7 +1,6 @@\n-package com.incountry.residence.sdk.tools.keyaccessor;\n+package com.incountry.residence.sdk.crypto;\n \n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n \n /**\n  * Secrets accessor. Method {@link SecretKeyAccessor#getSecretsData()} is invoked on each encryption/decryption.",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/tools/keyaccessor/SecretKeyAccessor.java"
  },
  {
    "sha": "5768b292137c41be52e09f92a87390d9a0a17f09",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,84 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class SecretsData {\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(SecretsData.class));\n+\n+    private static final String MSG_ERR_EMPTY_SECRETS = \"Secrets in SecretData are null\";\n+    private static final String MSG_ERR_UNIQUE_VERSIONS = \"Secret versions must be unique. Got duplicates for: %s\";\n+    private static final String MSG_ERR_CURRENT_VERSION = \"There is no current secret at the secrets list\";\n+    private static final String MSG_ERR_NO_SECRET = \"Secret not found for 'version'=%d\";\n+\n+    private final List<Secret> secrets;\n+    private final Secret currentSecret;\n+\n+    /**\n+     * creates a container with secrets\n+     *\n+     * @param secrets       non-empty list of secrets. One of the secrets should be the second parameter {@link #currentSecret}\n+     * @param currentSecret Should be a non-negative integer\n+     * @throws StorageClientException when parameter validation fails\n+     */\n+    public SecretsData(List<Secret> secrets, Secret currentSecret) throws StorageClientException {\n+        validateSecretsData(secrets, currentSecret);\n+        this.currentSecret = currentSecret;\n+        this.secrets = secrets;\n+    }\n+\n+    public List<Secret> getSecrets() {\n+        return secrets;\n+    }\n+\n+    public Secret getCurrentSecret() {\n+        return currentSecret;\n+    }\n+\n+    @SuppressWarnings(\"java:S2259\")\n+    private static void validateSecretsData(List<Secret> secrets, Secret currentSecret) throws StorageClientException {\n+        boolean emptySecrets = secrets == null || secrets.isEmpty();\n+        HELPER.check(StorageClientException.class, emptySecrets, MSG_ERR_EMPTY_SECRETS);\n+        boolean invalidCurrentSecret = currentSecret == null || !secrets.contains(currentSecret);\n+        HELPER.check(StorageClientException.class, invalidCurrentSecret, MSG_ERR_CURRENT_VERSION);\n+\n+        List<Integer> errorList = new ArrayList<>();\n+        Set<Integer> versionSet = new HashSet<>();\n+        for (Secret secret : secrets) {\n+            if (versionSet.contains(secret.getVersion())) {\n+                errorList.add(secret.getVersion());\n+            } else {\n+                versionSet.add(secret.getVersion());\n+            }\n+        }\n+        boolean duplicateVersions = !errorList.isEmpty();\n+        HELPER.check(StorageClientException.class, duplicateVersions, MSG_ERR_UNIQUE_VERSIONS, errorList);\n+    }\n+\n+\n+    @SuppressWarnings(\"java:S3655\")\n+    public Secret getSecret(Integer version) throws StorageCryptoException {\n+        if (version == null) {\n+            return currentSecret;\n+        }\n+        Optional<Secret> secretOpt = secrets.stream().filter(one -> one.getVersion() == version).findFirst();\n+        HELPER.check(StorageCryptoException.class, !secretOpt.isPresent(), MSG_ERR_NO_SECRET, version);\n+        return secretOpt.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SecretsData{\" +\n+                \"secrets=\" + secrets +\n+                \", currentSecret=\" + currentSecret +\n+                '}';\n+    }\n+}"
  },
  {
    "sha": "19c5b11553757dba022fc74a1b54d9a693e77577",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "status": "renamed",
    "additions": 30,
    "deletions": 16,
    "changes": 46,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,4 +1,4 @@\n-package com.incountry.residence.sdk.tools.keyaccessor.key;\n+package com.incountry.residence.sdk.crypto;\n \n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n@@ -13,7 +13,7 @@\n import java.util.List;\n \n /**\n- * Generator for {@link com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData}\n+ * Generator for {@link SecretsData}\n  */\n public class SecretsDataGenerator {\n \n@@ -34,10 +34,10 @@ private SecretsDataGenerator() {\n      * @throws StorageClientException when parameter validation fails\n      */\n     public static SecretsData fromPassword(String password) throws StorageClientException {\n-        SecretKey secretKey = new SecretKey(password.getBytes(StandardCharsets.UTF_8), DEFAULT_VERSION, false);\n-        List<SecretKey> secretKeys = new ArrayList<>();\n-        secretKeys.add(secretKey);\n-        return new SecretsData(secretKeys, DEFAULT_VERSION);\n+        Secret secret = new EncryptionSecret(DEFAULT_VERSION, password.getBytes(StandardCharsets.UTF_8));\n+        List<Secret> secretKeys = new ArrayList<>();\n+        secretKeys.add(secret);\n+        return new SecretsData(secretKeys, secret);\n     }\n \n     /**\n@@ -51,26 +51,40 @@ public static SecretsData fromJson(String secretsDataJson) throws StorageClientE\n         SecretsData result;\n         try {\n             SecretsDataContainer container = new Gson().fromJson(secretsDataJson, SecretsDataContainer.class);\n-            List<SecretKey> secrets = new ArrayList<>();\n+            List<Secret> secrets = new ArrayList<>();\n+            Secret currentSecret = null;\n             if (container.secrets != null) {\n-                for (SecretKeyContainer key : container.secrets) {\n-                    if (key.isForCustomEncryption || key.isKey) {\n-                        base64Validation(key.secret);\n-                        byte[] byteKey = DatatypeConverter.parseBase64Binary(key.secret);\n-                        secrets.add(new SecretKey(byteKey, key.version, key.isKey, key.isForCustomEncryption));\n-                    } else {\n-                        byte[] byteKey = key.secret.getBytes(StandardCharsets.UTF_8);\n-                        secrets.add(new SecretKey(byteKey, key.version, key.isKey, key.isForCustomEncryption));\n+                for (SecretKeyContainer keyContainer : container.secrets) {\n+                    Secret secret = getSecret(keyContainer);\n+                    if (container.currentVersion.equals(keyContainer.version)) {\n+                        currentSecret = secret;\n                     }\n+                    secrets.add(secret);\n                 }\n             }\n-            result = new SecretsData(secrets, container.currentVersion);\n+            result = new SecretsData(secrets, currentSecret);\n         } catch (JsonSyntaxException | NullPointerException e) {\n             throw new StorageClientException(MSG_ERR_INCORRECT_SECRETS, e);\n         }\n         return result;\n     }\n \n+    private static Secret getSecret(SecretKeyContainer keyContainer) throws StorageClientException {\n+        Secret secret;\n+        if (keyContainer.isForCustomEncryption || keyContainer.isKey) {\n+            base64Validation(keyContainer.secret);\n+            byte[] byteKey = DatatypeConverter.parseBase64Binary(keyContainer.secret);\n+            secret = keyContainer.isForCustomEncryption\n+                    ? new CustomEncryptionKey(keyContainer.version, byteKey)\n+                    : new EncryptionKey(keyContainer.version, byteKey);\n+\n+        } else {\n+            byte[] byteKey = keyContainer.secret.getBytes(StandardCharsets.UTF_8);\n+            secret = new EncryptionSecret(keyContainer.version, byteKey);\n+        }\n+        return secret;\n+    }\n+\n     private static void base64Validation(String byteKey) throws StorageClientException {\n         if (!Base64.isBase64(byteKey)) {\n             LOG.error(MSG_ERR_BASE64_SECRET);",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/tools/keyaccessor/key/SecretsDataGenerator.java"
  },
  {
    "sha": "74eb00d662771c839c28f164b83e2733042ffec2",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "status": "modified",
    "additions": 10,
    "deletions": 2,
    "changes": 12,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -12,7 +12,7 @@\n     private String filename;\n     private String hash;\n     private String mimeType;\n-    private int size;\n+    private Integer size;\n \n     public Date getCreatedAt() {\n         return createdAt != null ? new Date(createdAt.getTime()) : null;\n@@ -34,6 +34,10 @@ public String getFilename() {\n         return filename;\n     }\n \n+    public void setFilename(String filename) {\n+        this.filename = filename;\n+    }\n+\n     public String getHash() {\n         return hash;\n     }\n@@ -42,7 +46,11 @@ public String getMimeType() {\n         return mimeType;\n     }\n \n-    public int getSize() {\n+    public void setMimeType(String mimeType) {\n+        this.mimeType = mimeType;\n+    }\n+\n+    public Integer getSize() {\n         return size;\n     }\n "
  },
  {
    "sha": "266e70499e4d11011db5dfa4fb84e268a5f39009",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "status": "renamed",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/FindResult.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -5,15 +5,15 @@\n import java.util.List;\n import java.util.stream.Collectors;\n \n-public class BatchRecord {\n+public class FindResult {\n     private final int count;\n     private final int limit;\n     private final int offset;\n     private final int total;\n     private final List<Record> records;\n     private final List<RecordException> errors;\n \n-    public BatchRecord(List<Record> records, int count, int limit, int offset, int total, List<RecordException> errors) {\n+    public FindResult(List<Record> records, int count, int limit, int offset, int total, List<RecordException> errors) {\n         this.count = count;\n         this.limit = limit;\n         this.offset = offset;\n@@ -48,7 +48,7 @@ public int getTotal() {\n \n     @Override\n     public String toString() {\n-        return \"BatchRecord{\" +\n+        return \"FindResult{\" +\n                 \"count=\" + count +\n                 \", limit=\" + limit +\n                 \", offset=\" + offset +",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/dto/BatchRecord.java"
  },
  {
    "sha": "7d0d3892a77a4569fc2ca2b9e58a388da39b76de",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "status": "modified",
    "additions": 62,
    "deletions": 5,
    "changes": 67,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/Record.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -43,8 +43,13 @@\n     private String precommitBody;\n     private String serviceKey1;\n     private String serviceKey2;\n+    private String serviceKey3;\n+    private String serviceKey4;\n+    private String serviceKey5;\n     protected Date createdAt;\n     protected Date updatedAt;\n+    private Date expiresAt;\n+    protected Integer version;\n     private List<AttachmentMeta> attachments = new ArrayList<>();\n \n     /**\n@@ -400,6 +405,37 @@ public Record setServiceKey2(String serviceKey2) {\n         return this;\n     }\n \n+    public String getServiceKey3() {\n+        return serviceKey3;\n+    }\n+\n+    public Record setServiceKey3(String serviceKey3) {\n+        this.serviceKey3 = serviceKey3;\n+        return this;\n+    }\n+\n+    public String getServiceKey4() {\n+        return serviceKey4;\n+    }\n+\n+    public Record setServiceKey4(String serviceKey4) {\n+        this.serviceKey4 = serviceKey4;\n+        return this;\n+    }\n+\n+    public String getServiceKey5() {\n+        return serviceKey5;\n+    }\n+\n+    public Record setServiceKey5(String serviceKey5) {\n+        this.serviceKey5 = serviceKey5;\n+        return this;\n+    }\n+\n+    public Integer getVersion() {\n+        return version;\n+    }\n+\n     public Date getCreatedAt() {\n         return createdAt != null ? new Date(createdAt.getTime()) : null;\n     }\n@@ -408,10 +444,24 @@ public Date getUpdatedAt() {\n         return updatedAt != null ? new Date(updatedAt.getTime()) : null;\n     }\n \n+    public Date getExpiresAt() {\n+        return expiresAt != null ? new Date(expiresAt.getTime()) : null;\n+    }\n+\n+    public Record setExpiresAt(Date expiresAt) {\n+        this.expiresAt = expiresAt != null ? new Date(expiresAt.getTime()) : null;\n+        return this;\n+    }\n+\n     public List<AttachmentMeta> getAttachments() {\n         return attachments;\n     }\n \n+    protected Record setAttachments(List<AttachmentMeta> attachments) {\n+        this.attachments = attachments;\n+        return this;\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n@@ -458,8 +508,10 @@ public boolean equals(Object obj) {\n                 Objects.equals(precommitBody, record.precommitBody) &&\n                 Objects.equals(serviceKey1, record.serviceKey1) &&\n                 Objects.equals(serviceKey2, record.serviceKey2) &&\n-                Objects.equals(createdAt, record.createdAt) &&\n-                Objects.equals(updatedAt, record.updatedAt) &&\n+                Objects.equals(serviceKey3, record.serviceKey3) &&\n+                Objects.equals(serviceKey4, record.serviceKey4) &&\n+                Objects.equals(serviceKey5, record.serviceKey5) &&\n+                Objects.equals(expiresAt, record.expiresAt) &&\n                 Objects.equals(attachments, record.attachments);\n     }\n \n@@ -468,16 +520,16 @@ public int hashCode() {\n         return Objects.hash(recordKey, parentKey, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10,\n                 key11, key12, key13, key14, key15, key16, key17, key18, key19, key20,\n                 rangeKey1, rangeKey2, rangeKey3, rangeKey4, rangeKey5, rangeKey6, rangeKey7, rangeKey8, rangeKey9, rangeKey10,\n-                body, profileKey, precommitBody, serviceKey1, serviceKey2,\n-                createdAt, updatedAt, attachments);\n+                body, profileKey, precommitBody, serviceKey1, serviceKey2, serviceKey3, serviceKey4, serviceKey5,\n+                expiresAt, attachments, version);\n     }\n \n     /**\n      * get copy of Record immutably\n      *\n      * @return return copy\n      */\n-    protected Record copy() {\n+    public Record copy() {\n         Record newRecord = new Record(recordKey);\n         newRecord.parentKey = parentKey;\n         newRecord.key1 = key1;\n@@ -515,8 +567,13 @@ protected Record copy() {\n         newRecord.precommitBody = precommitBody;\n         newRecord.serviceKey1 = serviceKey1;\n         newRecord.serviceKey2 = serviceKey2;\n+        newRecord.serviceKey3 = serviceKey3;\n+        newRecord.serviceKey4 = serviceKey4;\n+        newRecord.serviceKey5 = serviceKey5;\n         newRecord.createdAt = getCreatedAt();\n         newRecord.updatedAt = getUpdatedAt();\n+        newRecord.expiresAt = getExpiresAt();\n+        newRecord.version = version;\n         newRecord.attachments = attachments == null ? new ArrayList<>() : new ArrayList<>(attachments);\n         return newRecord;\n     }"
  },
  {
    "sha": "f5215f2d53ee8d0b794bef5c70abe87d97647be5",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/DateField.java",
    "status": "renamed",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/DateField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/DateField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/DateField.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,4 +1,5 @@\n package com.incountry.residence.sdk.dto.search;\n \n-public interface RecordField {\n+public enum DateField {\n+    EXPIRES_AT\n }",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/dto/search/RecordField.java"
  },
  {
    "sha": "5f41956da65f4115946242538102dfe7ac407be0",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "status": "added",
    "additions": 261,
    "deletions": 0,
    "changes": 261,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,261 @@\n+package com.incountry.residence.sdk.dto.search;\n+\n+import com.incountry.residence.sdk.dto.search.internal.DateFilter;\n+import com.incountry.residence.sdk.dto.search.internal.Filter;\n+import com.incountry.residence.sdk.dto.search.internal.NullFilter;\n+import com.incountry.residence.sdk.dto.search.internal.NumberFilter;\n+import com.incountry.residence.sdk.dto.search.internal.RangeFilter;\n+import com.incountry.residence.sdk.dto.search.internal.StringFilter;\n+import com.incountry.residence.sdk.dto.search.internal.SortingParam;\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Container for filters to searching of stored data by param values\n+ */\n+public class FindFilter {\n+    private static final Logger LOG = LogManager.getLogger(FindFilter.class);\n+    private static final ValidationHelper HELPER = new ValidationHelper(LOG);\n+\n+    public static final int MAX_LIMIT = 100;\n+    public static final int DEFAULT_OFFSET = 0;\n+    public static final int SEARCH_KEYS_MIN_LENGTH = 3;\n+    public static final int SEARCH_KEYS_MAX_LENGTH = 200;\n+\n+    private static final String MSG_ERR_MAX_LIMIT = \"Max limit is \" + MAX_LIMIT + \". Use offset to populate more\";\n+    private static final String MSG_ERR_NULL_DATE = \"Date filter can't be null\";\n+    private static final String MSG_ERR_NEGATIVE_LIMIT = \"Limit must be more than 1\";\n+    private static final String MSG_ERR_NEGATIVE_OFFSET = \"Offset must be more than 0\";\n+    private static final String MSG_ERR_SEARCH_KEYS_COMBINATION = \"SEARCH_KEYS cannot be used in conjunction with regular KEY1...KEY20 lookup\";\n+    private static final String MSG_ERR_SEARCH_KEYS_LEN = \"SEARCH_KEYS should contain at least \" + SEARCH_KEYS_MIN_LENGTH +\n+            \" characters and be not longer than \" + SEARCH_KEYS_MAX_LENGTH;\n+    private static final String MSG_ERR_NULL_SORT_FIELD = \"Sorting field is null\";\n+    private static final String MSG_ERR_NULL_SORT_ORDER = \"Sorting order is null\";\n+    private static final String MSG_ERR_DUPL_SORT_FIELD = \"Field %s is already in sorting list\";\n+\n+    private static final List<StringField> NON_HASHED_KEY_LIST = Arrays.asList(\n+            StringField.KEY1, StringField.KEY2, StringField.KEY3, StringField.KEY4, StringField.KEY5,\n+            StringField.KEY6, StringField.KEY7, StringField.KEY8, StringField.KEY9, StringField.KEY10,\n+            StringField.KEY11, StringField.KEY12, StringField.KEY13, StringField.KEY14, StringField.KEY15,\n+            StringField.KEY16, StringField.KEY17, StringField.KEY18, StringField.KEY19, StringField.KEY20\n+    );\n+\n+    private int limit = MAX_LIMIT;\n+    private int offset = DEFAULT_OFFSET;\n+    private final Map<StringField, Filter> stringFilters = new EnumMap<>(StringField.class);\n+    private final Map<NumberField, Filter> numberFilters = new EnumMap<>(NumberField.class);\n+    private final Map<DateField, Filter> dateFilters = new EnumMap<>(DateField.class);\n+    private final List<SortingParam> sortingList = new ArrayList<>();\n+    private String searchKeys;\n+\n+    public FindFilter clear() {\n+        stringFilters.clear();\n+        numberFilters.clear();\n+        dateFilters.clear();\n+        sortingList.clear();\n+        limit = MAX_LIMIT;\n+        offset = DEFAULT_OFFSET;\n+        searchKeys = null;\n+        return this;\n+    }\n+\n+    public FindFilter limitAndOffset(int limit, int offset) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, limit > MAX_LIMIT, MSG_ERR_MAX_LIMIT);\n+        HELPER.check(StorageClientException.class, limit < 1, MSG_ERR_NEGATIVE_LIMIT);\n+        HELPER.check(StorageClientException.class, offset < 0, MSG_ERR_NEGATIVE_OFFSET);\n+        this.limit = limit;\n+        this.offset = offset;\n+        return this;\n+    }\n+\n+    public FindFilter keyEq(StringField field, String... keys) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new StringFilter(keys));\n+        return this;\n+    }\n+\n+    public FindFilter keyEq(NumberField field, Long... keys) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(keys, null));\n+        return this;\n+    }\n+\n+    public FindFilter keyEq(DateField field, Date date) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, date == null, MSG_ERR_NULL_DATE);\n+        dateFilters.put(field, new DateFilter(date));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNull(StringField field) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new NullFilter(true));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNull(NumberField field) {\n+        numberFilters.put(field, new NullFilter(true));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNull(DateField field) {\n+        dateFilters.put(field, new NullFilter(true));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNotNull(StringField field) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new NullFilter(false));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNotNull(NumberField field) {\n+        numberFilters.put(field, new NullFilter(false));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNotNull(DateField field) {\n+        dateFilters.put(field, new NullFilter(false));\n+        return this;\n+    }\n+\n+    public FindFilter keyNotEq(StringField field, String... keys) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new StringFilter(keys, true));\n+        return this;\n+    }\n+\n+    public FindFilter keyNotEq(NumberField field, Long... keys) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(keys, Filter.OPERATOR_NOT));\n+        return this;\n+    }\n+\n+    public FindFilter keyGreater(NumberField field, long key) throws StorageClientException {\n+        return keyGreater(field, key, false);\n+    }\n+\n+    public FindFilter keyGreater(NumberField field, long key, boolean includingValue) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(new Long[]{key}, includingValue ? Filter.OPERATOR_GREATER_OR_EQUALS : Filter.OPERATOR_GREATER));\n+        return this;\n+    }\n+\n+    public FindFilter keyLess(NumberField field, long key) throws StorageClientException {\n+        return keyLess(field, key, false);\n+    }\n+\n+    public FindFilter keyLess(NumberField field, long key, boolean includingValue) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(new Long[]{key}, includingValue ? Filter.OPERATOR_LESS_OR_EQUALS : Filter.OPERATOR_LESS));\n+        return this;\n+    }\n+\n+    public FindFilter keyBetween(NumberField field, long fromValue, long toValue) throws StorageClientException {\n+        return keyBetween(field, fromValue, true, toValue, true);\n+    }\n+\n+    public FindFilter keyBetween(NumberField field, long fromValue, boolean includeFrom, long toValue, boolean includeTo) throws StorageClientException {\n+        numberFilters.put(field, new RangeFilter(fromValue,\n+                includeFrom ? Filter.OPERATOR_GREATER_OR_EQUALS : Filter.OPERATOR_GREATER,\n+                toValue,\n+                includeTo ? Filter.OPERATOR_LESS_OR_EQUALS : Filter.OPERATOR_LESS));\n+        return this;\n+    }\n+\n+    public FindFilter searchKeysLike(String value) throws StorageClientException {\n+        if (value != null) {\n+            boolean invalidLength = value.length() < SEARCH_KEYS_MIN_LENGTH || value.length() > SEARCH_KEYS_MAX_LENGTH;\n+            HELPER.check(StorageClientException.class, invalidLength, MSG_ERR_SEARCH_KEYS_LEN);\n+            validateStringFilters(null, value);\n+        }\n+        searchKeys = value;\n+        return this;\n+    }\n+\n+    public FindFilter sortBy(SortField field, SortOrder order) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, field == null, MSG_ERR_NULL_SORT_FIELD);\n+        HELPER.check(StorageClientException.class, order == null, MSG_ERR_NULL_SORT_ORDER);\n+        for (SortingParam param : sortingList) {\n+            boolean alreadyInSorting = param.getField().equals(field);\n+            HELPER.check(StorageClientException.class, alreadyInSorting, MSG_ERR_DUPL_SORT_FIELD, field);\n+        }\n+        sortingList.add(new SortingParam(field, order));\n+        return this;\n+    }\n+\n+    private void validateStringFilters(StringField field, String searchKeysValue) throws StorageClientException {\n+        if (searchKeysValue == null) {\n+            return;\n+        }\n+        if (field != null) {\n+            HELPER.check(StorageClientException.class, NON_HASHED_KEY_LIST.contains(field), MSG_ERR_SEARCH_KEYS_COMBINATION);\n+            return;\n+        }\n+        for (StringField key : stringFilters.keySet()) {\n+            HELPER.check(StorageClientException.class, NON_HASHED_KEY_LIST.contains(key), MSG_ERR_SEARCH_KEYS_COMBINATION);\n+        }\n+    }\n+\n+    public int getLimit() {\n+        return limit;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    public List<SortingParam> getSortingList() {\n+        return sortingList;\n+    }\n+\n+    public Map<StringField, Filter> getStringFilters() {\n+        return stringFilters;\n+    }\n+\n+    public Map<NumberField, Filter> getNumberFilters() {\n+        return numberFilters;\n+    }\n+\n+    public Map<DateField, Filter> getDateFilters() {\n+        return dateFilters;\n+    }\n+\n+    public String getSearchKeys() {\n+        return searchKeys;\n+    }\n+\n+    public FindFilter copy() {\n+        FindFilter newFilter = new FindFilter();\n+        newFilter.limit = limit;\n+        newFilter.offset = offset;\n+        newFilter.searchKeys = searchKeys;\n+        newFilter.sortingList.addAll(sortingList);\n+        newFilter.numberFilters.putAll(numberFilters);\n+        newFilter.stringFilters.putAll(stringFilters);\n+        newFilter.dateFilters.putAll(dateFilters);\n+        return newFilter;\n+    }\n+\n+    public static boolean nonHashedKeysListContains(StringField key) {\n+        return NON_HASHED_KEY_LIST.contains(key);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"FindFilter{\" +\n+                \"stringFilters=\" + stringFilters +\n+                \", numberFilters=\" + numberFilters +\n+                \", dateFilters=\" + dateFilters +\n+                \", searchKeys=\" + searchKeys +\n+                \", limit=\" + limit +\n+                \", offset=\" + offset +\n+                \", sorting=\" + sortingList +\n+                '}';\n+    }\n+}\n+"
  },
  {
    "sha": "990d3bbda9c973bcb76714cc5ce6f065e4583aec",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "status": "removed",
    "additions": 0,
    "deletions": 211,
    "changes": 211,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,211 +0,0 @@\n-package com.incountry.residence.sdk.dto.search;\n-\n-import com.incountry.residence.sdk.dto.search.internal.FilterNumberParam;\n-import com.incountry.residence.sdk.dto.search.internal.FilterStringParam;\n-import com.incountry.residence.sdk.dto.search.internal.FindFilter;\n-import com.incountry.residence.sdk.dto.search.internal.FilterNullParam;\n-import com.incountry.residence.sdk.dto.search.internal.SortingParam;\n-import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-\n-/**\n- * Builder for cosy creation of FindFilter\n- */\n-public class FindFilterBuilder {\n-\n-    private static final Logger LOG = LogManager.getLogger(FindFilterBuilder.class);\n-\n-    private static final String MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS = \"SEARCH_KEYS cannot be used in conjunction with regular KEY1...KEY20 lookup\";\n-    private static final String MSG_ERR_SEARCH_KEYS_LEN = \"SEARCH_KEYS should contain at least 3 characters and be not longer than 200\";\n-    private static final String MSG_ERR_SEARCH_KEYS_ADD = \"SEARCH_KEYS can be used only via searchKeysLike method\";\n-    private static final String MSG_ERR_NULL_SORT_FIELD = \"Sorting field is null\";\n-    private static final String MSG_ERR_DUPL_SORT_FIELD = \"Field %s is already in sorting list\";\n-\n-    public static final String OPER_NOT = \"$not\";\n-    public static final String OPER_GT = \"$gt\";\n-    public static final String OPER_GTE = \"$gte\";\n-    public static final String OPER_LT = \"$lt\";\n-    public static final String OPER_LTE = \"$lte\";\n-\n-    private FindFilter filter;\n-    private static final List<StringField> SEARCHABLE_KEYS = new ArrayList<>();\n-\n-    static {\n-        SEARCHABLE_KEYS.add(StringField.KEY1);\n-        SEARCHABLE_KEYS.add(StringField.KEY2);\n-        SEARCHABLE_KEYS.add(StringField.KEY3);\n-        SEARCHABLE_KEYS.add(StringField.KEY4);\n-        SEARCHABLE_KEYS.add(StringField.KEY5);\n-        SEARCHABLE_KEYS.add(StringField.KEY6);\n-        SEARCHABLE_KEYS.add(StringField.KEY7);\n-        SEARCHABLE_KEYS.add(StringField.KEY8);\n-        SEARCHABLE_KEYS.add(StringField.KEY9);\n-        SEARCHABLE_KEYS.add(StringField.KEY10);\n-        SEARCHABLE_KEYS.add(StringField.KEY11);\n-        SEARCHABLE_KEYS.add(StringField.KEY12);\n-        SEARCHABLE_KEYS.add(StringField.KEY13);\n-        SEARCHABLE_KEYS.add(StringField.KEY14);\n-        SEARCHABLE_KEYS.add(StringField.KEY15);\n-        SEARCHABLE_KEYS.add(StringField.KEY16);\n-        SEARCHABLE_KEYS.add(StringField.KEY17);\n-        SEARCHABLE_KEYS.add(StringField.KEY18);\n-        SEARCHABLE_KEYS.add(StringField.KEY19);\n-        SEARCHABLE_KEYS.add(StringField.KEY20);\n-    }\n-\n-    public static FindFilterBuilder create() {\n-        return new FindFilterBuilder();\n-    }\n-\n-    private FindFilterBuilder() {\n-        filter = new FindFilter();\n-    }\n-\n-    private FindFilterBuilder(FindFilter filter) {\n-        this.filter = filter;\n-    }\n-\n-    public FindFilter build() throws StorageClientException {\n-        return filter.copy();\n-    }\n-\n-    public FindFilterBuilder clear() {\n-        filter = new FindFilter();\n-        return this;\n-    }\n-\n-    public FindFilterBuilder limitAndOffset(int limit, int offset) throws StorageClientException {\n-        filter.setLimit(limit);\n-        filter.setOffset(offset);\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyEq(StringField field, String... keys) throws StorageClientException {\n-        validateStringFilters(field);\n-        filter.setFilter(field, new FilterStringParam(keys));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyEq(NumberField field, Long... keys) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(keys));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNull(StringField field) {\n-        filter.setFilter(field, new FilterNullParam(true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNull(NumberField field) {\n-        filter.setFilter(field, new FilterNullParam(true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNotNull(StringField field) {\n-        filter.setFilter(field, new FilterNullParam(false));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNotNull(NumberField field) {\n-        filter.setFilter(field, new FilterNullParam(false));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyNotEq(StringField field, String... keys) throws StorageClientException {\n-        validateStringFilters(field);\n-        filter.setFilter(field, new FilterStringParam(keys, true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyGT(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_GT, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyGTE(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_GTE, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyLT(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_LT, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyLTE(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_LTE, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyBetween(NumberField field, long fromValue, long toValue) throws StorageClientException {\n-        return keyBetween(field, fromValue, true, toValue, true);\n-    }\n-\n-    public FindFilterBuilder keyBetween(NumberField field, long fromValue, boolean includeFrom, long toValue, boolean includeTo) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(includeFrom ? OPER_GTE : OPER_GT,\n-                fromValue,\n-                includeTo ? OPER_LTE : OPER_LT,\n-                toValue));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder searchKeysLike(String value) throws StorageClientException {\n-        Set<RecordField> searchKeys = filter.getFilterMap().keySet();\n-        for (StringField key : SEARCHABLE_KEYS) {\n-            if (searchKeys.contains(key)) {\n-                LOG.error(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-                throw new StorageClientException(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-            }\n-        }\n-        if (value.length() < 3 || value.length() > 200) {\n-            LOG.error(MSG_ERR_SEARCH_KEYS_LEN);\n-            throw new StorageClientException(MSG_ERR_SEARCH_KEYS_LEN);\n-        }\n-        filter.setFilter(StringField.SEARCH_KEYS, new FilterStringParam(new String[]{value}));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder sortBy(SortField field, SortOrder order) throws StorageClientException {\n-        if (field == null) {\n-            LOG.error(MSG_ERR_NULL_SORT_FIELD);\n-            throw new StorageClientException(MSG_ERR_NULL_SORT_FIELD);\n-        }\n-        for (SortingParam param : filter.getSortingList()) {\n-            if (param.getField().equals(field)) {\n-                String message = String.format(MSG_ERR_DUPL_SORT_FIELD, field);\n-                LOG.error(message);\n-                throw new StorageClientException(message);\n-            }\n-        }\n-        filter.addSorting(new SortingParam(field, order));\n-        return this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"FindFilterBuilder{\" +\n-                \"filter=\" + filter +\n-                '}';\n-    }\n-\n-    public FindFilterBuilder copy() throws StorageClientException {\n-        return new FindFilterBuilder(this.filter.copy());\n-    }\n-\n-    private void validateStringFilters(StringField field) throws StorageClientException {\n-        if (field == StringField.SEARCH_KEYS) {\n-            LOG.error(MSG_ERR_SEARCH_KEYS_ADD);\n-            throw new StorageClientException(MSG_ERR_SEARCH_KEYS_ADD);\n-        }\n-        if (SEARCHABLE_KEYS.contains(field)\n-                && filter.getFilterMap().containsKey(StringField.SEARCH_KEYS)) {\n-            LOG.error(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-            throw new StorageClientException(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-        }\n-    }\n-}"
  },
  {
    "sha": "64a89b16bfb89436828a1e89038fbc6d2759c1a7",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,6 +1,6 @@\n package com.incountry.residence.sdk.dto.search;\n \n-public enum NumberField implements RecordField {\n+public enum NumberField {\n     RANGE_KEY1,\n     RANGE_KEY2,\n     RANGE_KEY3,\n@@ -10,5 +10,6 @@\n     RANGE_KEY7,\n     RANGE_KEY8,\n     RANGE_KEY9,\n-    RANGE_KEY10\n+    RANGE_KEY10,\n+    VERSION\n }"
  },
  {
    "sha": "4889181827643b83c05514ce4980da28b3f4304f",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/SortField.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/SortField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/SortField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/SortField.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -32,5 +32,6 @@\n     RANGE_KEY9,\n     RANGE_KEY10,\n     CREATED_AT,\n-    UPDATED_AT\n+    UPDATED_AT,\n+    EXPIRES_AT\n }"
  },
  {
    "sha": "6fffc2f09ce14c10ac7c7dccaeec7f38b53b98a0",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "status": "modified",
    "additions": 4,
    "deletions": 3,
    "changes": 7,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -1,7 +1,6 @@\n package com.incountry.residence.sdk.dto.search;\n \n-public enum StringField implements RecordField {\n-    VERSION,\n+public enum StringField {\n     RECORD_KEY,\n     PARENT_KEY,\n     KEY1,\n@@ -27,5 +26,7 @@\n     PROFILE_KEY,\n     SERVICE_KEY1,\n     SERVICE_KEY2,\n-    SEARCH_KEYS\n+    SERVICE_KEY3,\n+    SERVICE_KEY4,\n+    SERVICE_KEY5\n }"
  },
  {
    "sha": "921ef26dba4c45d48e0bbdd69678f17e4f62dcd3",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/DateFilter.java",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/internal/DateFilter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/internal/DateFilter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/DateFilter.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,17 @@\n+package com.incountry.residence.sdk.dto.search.internal;\n+\n+import java.util.Date;\n+\n+public class DateFilter extends Filter {\n+\n+    private final Date date;\n+\n+    public DateFilter(Date date) {\n+        this.date = date;\n+    }\n+\n+    @Override\n+    public Object toTransferObject() {\n+        return date;\n+    }\n+}"
  },
  {
    "sha": "f8982501478897acd0a109f4ba4cca9c123a94e8",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/incountry/sdk-java/blob/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java?ref=836ed0c5a11665d0a0eb5bdb3cdc57de097dfef2",
    "patch": "@@ -0,0 +1,11 @@\n+package com.incountry.residence.sdk.dto.search.internal;\n+\n+public abstract class Filter {\n+    public static final String OPERATOR_NOT = \"$not\";\n+    public static final String OPERATOR_GREATER = \"$gt\";\n+    public static final String OPERATOR_GREATER_OR_EQUALS = \"$gte\";\n+    public static final String OPERATOR_LESS = \"$lt\";\n+    public static final String OPERATOR_LESS_OR_EQUALS = \"$lte\";\n+\n+    public abstract Object toTransferObject();\n+}"
  }
]
