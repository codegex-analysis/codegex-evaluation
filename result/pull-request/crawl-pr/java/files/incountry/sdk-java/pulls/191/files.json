[
  {
    "sha": "411b12cc978384cbc1fd19eaed11f3ab00574eee",
    "filename": "README.md",
    "status": "modified",
    "additions": 19,
    "deletions": 15,
    "changes": 34,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/README.md",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/README.md",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/README.md?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1065,12 +1065,13 @@ The following is a list of compile dependencies for this project. These dependen\n | :---:                     | :---:                | :---:       | :---:    |\n | javax.xml.bind            | jaxb-api             | 2.3.1       | jar      |\n | javax.activation          | javax.activation-api | 1.2.0       | jar      |\n-| commons-codec             | commons-codec        | 1.14        | jar      |\n+| commons-codec             | commons-codec        | 1.15        | jar      |\n | commons-logging           | commons-logging      | 1.2         | jar      |\n-| org.apache.logging.log4j  | log4j-api            | 2.13.3      | jar      |\n-| org.apache.logging.log4j  | log4j-core           | 2.13.3      | jar      |\n-| org.apache.logging.log4j  | log4j-core-jcl       | 2.13.3      | jar      |\n-| org.apache.httpcomponents | httpclient           | 4.5.12      | jar      |\n+| commons-io                | commons-io           | 2.8.0       | jar      |\n+| org.apache.logging.log4j  | log4j-api            | 2.14.0      | jar      |\n+| org.apache.logging.log4j  | log4j-core           | 2.14.0      | jar      |\n+| org.apache.logging.log4j  | log4j-core-jcl       | 2.14.0      | jar      |\n+| org.apache.httpcomponents | httpclient           | 4.5.13      | jar      |\n | org.apache.httpcomponents | httpcore             | 4.4.13      | jar      |\n | com.google.code.gson      | gson                 | 2.8.6       | jar      |\n \n@@ -1079,18 +1080,21 @@ The following is a list of compile dependencies for this project. These dependen\n compileClasspath\n +--- javax.xml.bind:jaxb-api:2.3.1\n |    \\--- javax.activation:javax.activation-api:1.2.0\n-+--- commons-codec:commons-codec:1.14\n++--- commons-codec:commons-codec:1.15\n +--- com.google.code.gson:gson:2.8.6\n-+--- org.apache.logging.log4j:log4j-api:2.13.3\n-+--- org.apache.logging.log4j:log4j-core:2.13.3\n-|    \\--- org.apache.logging.log4j:log4j-api:2.13.3\n-+--- org.apache.logging.log4j:log4j-jcl:2.13.3\n++--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.logging.log4j:log4j-core:2.14.0\n+|    \\--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.logging.log4j:log4j-jcl:2.14.0\n |    +--- commons-logging:commons-logging:1.2\n-|    \\--- org.apache.logging.log4j:log4j-api:2.13.3\n-\\--- org.apache.httpcomponents:httpclient:4.5.12\n-     +--- org.apache.httpcomponents:httpcore:4.4.13\n-     +--- commons-logging:commons-logging:1.2\n-     \\--- commons-codec:commons-codec:1.11 -> 1.14\n+|    \\--- org.apache.logging.log4j:log4j-api:2.14.0\n++--- org.apache.httpcomponents:httpclient:4.5.13\n+|    +--- org.apache.httpcomponents:httpcore:4.4.13\n+|    +--- commons-logging:commons-logging:1.2\n+|    \\--- commons-codec:commons-codec:1.11 -> 1.15\n++--- commons-io:commons-io:2.8.0\n+\\--- org.apache.httpcomponents:httpmime:4.5.13\n+     \\--- org.apache.httpcomponents:httpclient:4.5.13 (*)\n ```\n \n ### Minimal JVM memory options"
  },
  {
    "sha": "09b0d29e66787c6c8e18bd914b64eadca7f8c58b",
    "filename": "config/spotbugs/exclude.xml",
    "status": "modified",
    "additions": 21,
    "deletions": 2,
    "changes": 23,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/config/spotbugs/exclude.xml",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/config/spotbugs/exclude.xml",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/config/spotbugs/exclude.xml?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -3,9 +3,11 @@\n     <Match>\n         <Or>\n             <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferPop\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferFilterContainer\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.transfer.TransferRecordList\"/>\n             <Class name=\"com.incountry.residence.sdk.StorageImpl\"/>\n-            <Class name=\"com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator\"/>\n-            <Class name=\"com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator$SecretKeyContainer\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsDataGenerator\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsDataGenerator$SecretKeyContainer\"/>\n         </Or>\n         <Bug code=\"NP,SIC,SS,ST,UrF,UuF,UwF\"/>\n     </Match>\n@@ -38,4 +40,21 @@\n         <Bug code=\"SECPR\"/>\n     </Match>\n \n+    <Match>\n+        <Or>\n+            <Class name=\"com.incountry.residence.sdk.crypto.Secret\"/>\n+        </Or>\n+        <Bug code=\"EI,EI2,MS\"/>\n+    </Match>\n+\n+    <Match>\n+        <Or>\n+            <Class name=\"com.incountry.residence.sdk.crypto.AbstractCipher\"/>\n+            <Class name=\"com.incountry.residence.sdk.crypto.SecretsData\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.crypto.CryptoProvider\"/>\n+            <Class name=\"com.incountry.residence.sdk.tools.crypto.cipher.AesGcmPbkdfCipher\"/>\n+        </Or>\n+        <Bug code=\"NP,RCN\"/>\n+    </Match>\n+\n </FindBugsFilter>"
  },
  {
    "sha": "fb041cb2d3413c66ee1d8c2aa505fcc7e17b0084",
    "filename": "gradle.properties",
    "status": "modified",
    "additions": 12,
    "deletions": 12,
    "changes": 24,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/gradle.properties",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/gradle.properties",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/gradle.properties?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,20 +1,20 @@\n group=com.incountry\n-version=3.1.0-SNAPSHOT\n+version=3.3.0\n gsonVersion=2.8.6\n-jupiterVersion=5.6.0\n+jupiterVersion=5.7.0\n jaxbApiVersion=2.3.1\n-commonsCodecVersion=1.14\n-log4jVersion=2.13.3\n-checkStyleVersion=8.29\n-spotbugsVersion=4.4.3\n-spotBugsToolVersion=4.0.6\n-findsecbugsVersion=1.10.1\n-nexusStagingVersion=0.11.0\n-sonarQubeVersion=3.0\n-jacocoVersion=0.8.5\n+log4jVersion=2.14.0\n+checkStyleVersion=8.39\n+spotbugsVersion=4.6.0\n+spotBugsToolVersion=4.1.1\n+findsecbugsVersion=1.11.0\n+nexusStagingVersion=0.22.0\n+sonarQubeVersion=3.1\n+jacocoVersion=0.8.6\n fernetVersion=1.4.2\n-apacheHttpClientVersion=4.5.13\n commonsIoVersion=2.8.0\n+commonsCodecVersion=1.15\n+apacheHttpClientVersion=4.5.13\n apacheHttpMimeVersion=4.5.13\n nexusUsername=\n nexusPassword="
  },
  {
    "sha": "895cb62b382d5c07cd4c5614a2fc42f0dd54258e",
    "filename": "gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/gradle/wrapper/gradle-wrapper.properties?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,5 +1,5 @@\n #Tue Jun 23 13:23:54 MSK 2020\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-6.8-bin.zip\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n zipStorePath=wrapper/dists"
  },
  {
    "sha": "a30e228b1f4efb4e780287b4e438fb7b3b24180c",
    "filename": "src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "status": "modified",
    "additions": 16,
    "deletions": 10,
    "changes": 26,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/FullMigrationExample.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,26 +1,32 @@\n package com.incountry.residence.sdk;\n \n+import com.incountry.residence.sdk.crypto.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretsDataGenerator;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.tools.exceptions.StorageException;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator;\n \n public class FullMigrationExample {\n \n+    private static final String ENVIRONMENT_ID = \"<environment_id>\";\n+    private static final String CLIENT_ID = \"<client_id>\";\n+    private static final String CLIENT_SECRET = \"<client_secret>\";\n+\n     public void startMigration() throws StorageException {\n         String secretsDataInJson = \"{\\n\" +\n                 \"    \\\"currentVersion\\\": 1,\\n\" +\n                 \"    \\\"secrets\\\": [\\n\" +\n                 \"        {\\\"secret\\\": \\\"password0\\\", \\\"version\\\": 0},\\n\" +\n-                \"        {\\\"secret\\\": \\\"password1\\\", \\\"version\\\": 1},\\n\" +\n-                \"    ],\\n\" +\n+                \"        {\\\"secret\\\": \\\"password1\\\", \\\"version\\\": 1}\\n\" +\n+                \"    ]\\n\" +\n                 \"}\";\n-        SecretKeyAccessor secretKeyAccessor = () -> SecretsDataGenerator.fromJson(secretsDataInJson);\n-        String endPoint = \"https://us-mt-01.api.incountry.example\";\n+        SecretsData secretsData = SecretsDataGenerator.fromJson(secretsDataInJson);\n+        StorageConfig config = new StorageConfig()\n+                .setEnvironmentId(ENVIRONMENT_ID)\n+                .setClientId(CLIENT_ID)\n+                .setClientSecret(CLIENT_SECRET)\n+                .setSecretKeyAccessor(() -> secretsData);\n+        Storage storage = StorageImpl.newStorage(config);\n         String country = \"US\";\n-        String envId = \"someEnvironmentId\";\n-        String apiKey = \"someApiKey\";\n-        Storage storage = StorageImpl.getInstance(envId, apiKey, endPoint, secretKeyAccessor);\n         boolean migrationComplete = false;\n         while (!migrationComplete) {\n             MigrateResult migrationResult = storage.migrate(country, 50);\n@@ -29,4 +35,4 @@ public void startMigration() throws StorageException {\n             }\n         }\n     }\n-}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "e5c346e3d9461f1707934c41677f87118a50ced0",
    "filename": "src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "status": "modified",
    "additions": 9,
    "deletions": 9,
    "changes": 18,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/OAuthTest.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/OAuthTest.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -6,9 +6,9 @@\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n import com.incountry.residence.sdk.tools.http.TokenClient;\n import com.incountry.residence.sdk.tools.http.impl.OAuthTokenClient;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsDataGenerator;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n+import com.incountry.residence.sdk.crypto.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretsDataGenerator;\n import com.incountry.residence.sdk.tools.proxy.ProxyUtils;\n import org.apache.http.conn.HttpHostConnectException;\n import org.apache.http.impl.client.HttpClients;\n@@ -56,16 +56,16 @@ public OAuthTest() throws StorageClientException {\n         accessor = () -> secretsData;\n     }\n \n-    private Storage initStorage() throws StorageClientException {\n+    private Storage initStorage() throws StorageClientException, StorageCryptoException {\n         StorageConfig config = new StorageConfig()\n                 .setClientId(CLIENT_ID)\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n                 .setEndpointMask(ENDPOINT_MASK)\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setSecretKeyAccessor(accessor)\n                 .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT);\n-        return StorageImpl.getInstance(config);\n+        return StorageImpl.newStorage(config);\n     }\n \n     @Test\n@@ -95,19 +95,19 @@ public void positiveAuthTest() throws StorageServerException, StorageClientExcep\n     }\n \n     @Test\n-    public void authRegionTest() throws StorageClientException {\n+    public void authRegionTest() throws StorageClientException, StorageCryptoException {\n         Map<String, String> authEndpoints = new HashMap<>();\n         authEndpoints.put(\"emea\", \"https://emea.localhost\");\n         authEndpoints.put(\"apac\", \"https://apac.localhost\");\n         StorageConfig config = new StorageConfig()\n-                .setEnvId(\"envId\")\n+                .setEnvironmentId(\"envId\")\n                 .setClientId(\"clientId\")\n                 .setClientSecret(\"clientSecret\")\n                 .setEndpointMask(\"-localhost.localhost:8765\")\n                 .setAuthEndpoints(authEndpoints)\n                 .setDefaultAuthEndpoint(\"https://emea.localhost\");\n \n-        Storage prodStorage = StorageImpl.getInstance(config);\n+        Storage prodStorage = StorageImpl.newStorage(config);\n         String errorMessage = \"Unexpected exception during authorization, params [OAuth URL=\";\n         Record record = new Record(\"someKey\", \"someBody\");\n "
  },
  {
    "sha": "e645ef91f6c31a6283311fd126a6606b71f1c923",
    "filename": "src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "status": "modified",
    "additions": 134,
    "deletions": 134,
    "changes": 268,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/integration/java/com/incountry/residence/sdk/StorageIntegrationTest.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,20 +1,22 @@\n package com.incountry.residence.sdk;\n \n-import com.incountry.residence.sdk.crypto.testimpl.FernetCrypto;\n+import com.incountry.residence.sdk.crypto.CustomEncryptionKey;\n+import com.incountry.residence.sdk.crypto.EncryptionSecret;\n+import com.incountry.residence.sdk.crypto.Secret;\n+import com.incountry.residence.sdk.crypto.testimpl.FernetCipher;\n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n import com.incountry.residence.sdk.dto.search.NumberField;\n import com.incountry.residence.sdk.dto.search.SortField;\n import com.incountry.residence.sdk.dto.search.SortOrder;\n import com.incountry.residence.sdk.dto.search.StringField;\n-import com.incountry.residence.sdk.tools.crypto.Crypto;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretKey;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n+import com.incountry.residence.sdk.crypto.SecretsData;\n import com.incountry.residence.sdk.tools.exceptions.StorageException;\n import org.apache.commons.io.IOUtils;\n import org.apache.logging.log4j.LogManager;\n@@ -171,22 +173,22 @@ public static String loadFromEnv(String key, String defaultValue) {\n \n     @BeforeAll\n     public void initializeStorages() throws StorageException {\n-        SecretKey secretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false);\n-        List<SecretKey> secretKeyList = new ArrayList<>();\n-        secretKeyList.add(secretKey);\n-        SecretsData secretsData = new SecretsData(secretKeyList, VERSION);\n+        Secret secret = new EncryptionSecret(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList = new ArrayList<>();\n+        secretList.add(secret);\n+        SecretsData secretsData = new SecretsData(secretList, secret);\n         SecretKeyAccessor secretKeyAccessor = () -> secretsData;\n         StorageConfig config = new StorageConfig()\n-                .setEnvId(loadFromEnv(INT_INC_ENVIRONMENT_ID))\n+                .setEnvironmentId(loadFromEnv(INT_INC_ENVIRONMENT_ID))\n                 .setApiKey(loadFromEnv(INT_INC_API_KEY))\n                 .setEndPoint(loadFromEnv(INT_INC_ENDPOINT))\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n-        storageWithApiKey = StorageImpl.getInstance(config);\n+        storageWithApiKey = StorageImpl.newStorage(config);\n \n         config = new StorageConfig()\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setClientId(CLIENT_ID)\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n@@ -195,39 +197,37 @@ public void initializeStorages() throws StorageException {\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n-        storageOrdinary = StorageImpl.getInstance(config);\n+        storageOrdinary = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setSecretKeyAccessor(null);\n-        storageWithoutEncryption = StorageImpl.getInstance(config);\n+        storageWithoutEncryption = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setSecretKeyAccessor(secretKeyAccessor)\n                 .setHashSearchKeys(false);\n-        storageNonHashing = StorageImpl.getInstance(config);\n+        storageNonHashing = StorageImpl.newStorage(config);\n \n         config = config\n                 .copy()\n                 .setHashSearchKeys(true)\n                 .setNormalizeKeys(true);\n-        storageIgnoreCase = StorageImpl.getInstance(config);\n+        storageIgnoreCase = StorageImpl.newStorage(config);\n \n-        SecretKey customSecretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false, true);\n-        List<SecretKey> secretKeyList2 = new ArrayList<>();\n-        secretKeyList2.add(customSecretKey);\n-        SecretsData anotherSecretsData = new SecretsData(secretKeyList2, customSecretKey.getVersion());\n+        Secret customSecretKey = new CustomEncryptionKey(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList2 = new ArrayList<>();\n+        secretList2.add(customSecretKey);\n+        SecretsData anotherSecretsData = new SecretsData(secretList2, customSecretKey);\n         SecretKeyAccessor anotherAccessor = () -> anotherSecretsData;\n-        List<Crypto> cryptoList = new ArrayList<>();\n-        cryptoList.add(new FernetCrypto(true));\n \n         config = config\n                 .copy()\n                 .setNormalizeKeys(false)\n                 .setSecretKeyAccessor(anotherAccessor)\n-                .setCustomEncryptionConfigsList(cryptoList);\n-        storageWithCustomCipher = StorageImpl.getInstance(config);\n+                .setCryptoProvider(new CryptoProvider(new FernetCipher(\"Fernet\")));\n+        storageWithCustomCipher = StorageImpl.newStorage(config);\n     }\n \n     private Stream<Arguments> storageProvider() {\n@@ -335,134 +335,134 @@ public void readTest(Storage storage, String recordKey, String batchRecordKey, S\n     @MethodSource(\"storageProvider\")\n     @Order(400)\n     public void findTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.KEY20, KEY_20)\n                 .keyEq(StringField.PARENT_KEY, PARENT_KEY)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertNotNull(batchRecord.getRecords().get(0).getCreatedAt());\n-        assertNotNull(batchRecord.getRecords().get(0).getUpdatedAt());\n-\n-        builder.clear()\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertNotNull(findResult.getRecords().get(0).getCreatedAt());\n+        assertNotNull(findResult.getRecords().get(0).getUpdatedAt());\n+\n+        filter.clear()\n                 .keyEq(StringField.RECORD_KEY, batchRecordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(NumberField.RANGE_KEY1, BATCH_WRITE_RANGE_KEY_1);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n \n-        builder.clear()\n+        filter.clear()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        assertTrue(batchRecord.getRecords().stream().anyMatch(record\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        assertTrue(findResult.getRecords().stream().anyMatch(record\n                 -> record.getRecordKey().equals(batchRecordKey)));\n-        assertTrue(batchRecord.getRecords().stream().anyMatch(record\n+        assertTrue(findResult.getRecords().stream().anyMatch(record\n                 -> record.getRecordKey().equals(recordKey)));\n \n-        builder.clear()\n+        filter.clear()\n                 .keyNotEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n     }\n \n     @ParameterizedTest(name = \"findAdvancedTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(401)\n     public void findAdvancedTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1, BATCH_WRITE_RANGE_KEY_1, WRITE_RANGE_KEY_1 + BATCH_WRITE_RANGE_KEY_1 + 1);\n \n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.RANGE_KEY10, SortOrder.ASC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        Long record1Value = batchRecord.getRecords().get(0).getRangeKey10();\n-        Long record2Value = batchRecord.getRecords().get(1).getRangeKey10();\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.RANGE_KEY10, SortOrder.ASC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        Long record1Value = findResult.getRecords().get(0).getRangeKey10();\n+        Long record2Value = findResult.getRecords().get(1).getRangeKey10();\n         assertTrue(record1Value <= record2Value);\n \n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.RANGE_KEY10, SortOrder.DESC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        record1Value = batchRecord.getRecords().get(0).getRangeKey10();\n-        record2Value = batchRecord.getRecords().get(1).getRangeKey10();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.RANGE_KEY10, SortOrder.DESC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        record1Value = findResult.getRecords().get(0).getRangeKey10();\n+        record2Value = findResult.getRecords().get(1).getRangeKey10();\n         assertTrue(record1Value >= record2Value);\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.CREATED_AT, SortOrder.ASC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        Date record1date = batchRecord.getRecords().get(0).getCreatedAt();\n-        Date record2date = batchRecord.getRecords().get(1).getCreatedAt();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.CREATED_AT, SortOrder.ASC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        Date record1date = findResult.getRecords().get(0).getCreatedAt();\n+        Date record2date = findResult.getRecords().get(1).getCreatedAt();\n         assertTrue(record1date.before(record2date) || record1date.equals(record2date));\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().sortBy(SortField.CREATED_AT, SortOrder.DESC));\n-        assertEquals(2, batchRecord.getCount());\n-        assertEquals(2, batchRecord.getRecords().size());\n-        record1date = batchRecord.getRecords().get(0).getCreatedAt();\n-        record2date = batchRecord.getRecords().get(1).getCreatedAt();\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().sortBy(SortField.CREATED_AT, SortOrder.DESC));\n+        assertEquals(2, findResult.getCount());\n+        assertEquals(2, findResult.getRecords().size());\n+        record1date = findResult.getRecords().get(0).getCreatedAt();\n+        record2date = findResult.getRecords().get(1).getCreatedAt();\n         assertTrue(record1date.after(record2date) || record1date.equals(record2date));\n \n-        builder = FindFilterBuilder.create().keyEq(StringField.KEY2, key2);\n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().keyIsNotNull(StringField.KEY20));\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        filter = new FindFilter().keyEq(StringField.KEY2, key2);\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().keyIsNotNull(StringField.KEY20));\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n \n-        batchRecord = storage.find(MIDIPOP_COUNTRY, builder.copy().keyIsNull(StringField.KEY20));\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(batchRecordKey, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storage.find(MIDIPOP_COUNTRY, filter.copy().keyIsNull(StringField.KEY20));\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(batchRecordKey, findResult.getRecords().get(0).getRecordKey());\n     }\n \n     @ParameterizedTest(name = \"findByVersionTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(402)\n     public void findByVersionTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n-                .keyEq(StringField.VERSION, String.valueOf(VERSION));\n-        BatchRecord batchRecord1 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord1.getCount());\n-        assertEquals(2, batchRecord1.getRecords().size());\n+                .keyEq(NumberField.VERSION, Long.valueOf(VERSION));\n+        FindResult findResult1 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult1.getCount());\n+        assertEquals(2, findResult1.getRecords().size());\n \n-        builder.keyEq(StringField.VERSION, String.valueOf(VERSION + 10));\n-        BatchRecord batchRecord2 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(0, batchRecord2.getCount());\n-        assertEquals(0, batchRecord2.getRecords().size());\n+        filter.keyEq(NumberField.VERSION, 10L + VERSION);\n+        FindResult findResult2 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(0, findResult2.getCount());\n+        assertEquals(0, findResult2.getRecords().size());\n \n-        builder.keyNotEq(StringField.VERSION, String.valueOf(VERSION));\n-        BatchRecord batchRecord3 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(0, batchRecord3.getCount());\n-        assertEquals(0, batchRecord3.getRecords().size());\n+        filter.keyNotEq(NumberField.VERSION, Long.valueOf(VERSION));\n+        FindResult findResult3 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(0, findResult3.getCount());\n+        assertEquals(0, findResult3.getRecords().size());\n \n-        builder.keyNotEq(StringField.VERSION, String.valueOf(VERSION + 10));\n-        BatchRecord batchRecord4 = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(2, batchRecord4.getCount());\n-        assertEquals(2, batchRecord4.getRecords().size());\n+        filter.keyNotEq(NumberField.VERSION, 10L + VERSION);\n+        FindResult findResult4 = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(2, findResult4.getCount());\n+        assertEquals(2, findResult4.getRecords().size());\n     }\n \n     @ParameterizedTest(name = \"findByAllFieldsTest [{index}] {arguments}\")\n     @MethodSource(\"storageProvider\")\n     @Order(403)\n     public void findByAllFieldsTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, recordKey)\n                 .keyEq(StringField.KEY1, KEY_1)\n                 .keyEq(StringField.KEY2, key2)\n@@ -487,10 +487,10 @@ public void findByAllFieldsTest(Storage storage, String recordKey, String batchR\n                 .keyEq(SERVICE_KEY1, SERVICE_KEY_1)\n                 .keyEq(SERVICE_KEY2, SERVICE_KEY_2);\n \n-        BatchRecord batchRecord = storage.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        Record record = batchRecord.getRecords().get(0);\n+        FindResult findResult = storage.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        Record record = findResult.getRecords().get(0);\n         assertEquals(recordKey, record.getRecordKey());\n         assertEquals(KEY_1, record.getKey1());\n         assertEquals(key2, record.getKey2());\n@@ -520,10 +520,10 @@ public void findByAllFieldsTest(Storage storage, String recordKey, String batchR\n     @MethodSource(\"storageProvider\")\n     @Order(404)\n     public void findOneTest(Storage storage, String recordKey, String batchRecordKey, String key2) throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY2, key2)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        Record record = storage.findOne(MIDIPOP_COUNTRY, builder);\n+        Record record = storage.findOne(MIDIPOP_COUNTRY, filter);\n         assertEquals(recordKey, record.getRecordKey());\n         assertEquals(RECORD_BODY, record.getBody());\n     }\n@@ -570,38 +570,38 @@ public void readIgnoreCaseTest() throws StorageException {\n     @Test\n     @Order(702)\n     public void findIgnoreCaseTest() throws StorageException {\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE)\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY)\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        BatchRecord batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        FindResult findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n \n-        builder = builder.clear()\n+        filter = filter.clear()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE.toLowerCase())\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY.toLowerCase())\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n \n-        builder = builder.clear()\n+        filter = filter.clear()\n                 .keyEq(StringField.RECORD_KEY, RECORD_KEY_IGNORE_CASE.toUpperCase())\n                 .keyEq(StringField.KEY2, KEY_2)\n                 .keyEq(StringField.KEY3, KEY_3)\n                 .keyEq(StringField.PROFILE_KEY, PROFILE_KEY.toUpperCase())\n                 .keyEq(NumberField.RANGE_KEY1, WRITE_RANGE_KEY_1);\n-        batchRecord = storageIgnoreCase.find(MIDIPOP_COUNTRY, builder);\n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(1, batchRecord.getRecords().size());\n-        assertEquals(RECORD_KEY_IGNORE_CASE, batchRecord.getRecords().get(0).getRecordKey());\n+        findResult = storageIgnoreCase.find(MIDIPOP_COUNTRY, filter);\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(1, findResult.getRecords().size());\n+        assertEquals(RECORD_KEY_IGNORE_CASE, findResult.getRecords().get(0).getRecordKey());\n     }\n \n     @Test\n@@ -773,13 +773,13 @@ public void findWithSearchKeys() throws StorageException {\n                 .setServiceKey2(SERVICE_KEY_2);\n         storageNonHashing.write(MIDIPOP_COUNTRY_2, record);\n \n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .searchKeysLike(KEY_1.split(\"-\")[2]);\n-        BatchRecord batchRecord = storageNonHashing.find(MIDIPOP_COUNTRY_2, builder);\n+        FindResult findResult = storageNonHashing.find(MIDIPOP_COUNTRY_2, filter);\n \n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertEquals(RECORD_BODY, batchRecord.getRecords().get(0).getBody());\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertEquals(RECORD_BODY, findResult.getRecords().get(0).getBody());\n \n         storageNonHashing.delete(MIDIPOP_COUNTRY_2, recordKey);\n     }\n@@ -797,25 +797,25 @@ public void utf8EncodingTest() throws StorageException {\n                 .setPrecommitBody(PRECOMMIT_BODY);\n         storageNonHashing.write(MIDIPOP_COUNTRY, record);\n \n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        FindFilter filter = new FindFilter()\n                 .keyEq(StringField.KEY1, key1);\n-        BatchRecord batchRecord = storageNonHashing.find(MIDIPOP_COUNTRY, builder);\n+        FindResult findResult = storageNonHashing.find(MIDIPOP_COUNTRY, filter);\n \n-        assertEquals(1, batchRecord.getCount());\n-        assertEquals(recordKey, batchRecord.getRecords().get(0).getRecordKey());\n-        assertEquals(RECORD_BODY, batchRecord.getRecords().get(0).getBody());\n-        assertEquals(key1, batchRecord.getRecords().get(0).getKey1());\n+        assertEquals(1, findResult.getCount());\n+        assertEquals(recordKey, findResult.getRecords().get(0).getRecordKey());\n+        assertEquals(RECORD_BODY, findResult.getRecords().get(0).getBody());\n+        assertEquals(key1, findResult.getRecords().get(0).getKey1());\n \n         storageNonHashing.delete(MIDIPOP_COUNTRY, recordKey);\n     }\n \n     @Test\n     @Order(1000)\n     public void connectionPoolTest() throws StorageException, InterruptedException, ExecutionException {\n-        SecretKey secretKey = new SecretKey(ENCRYPTION_SECRET, VERSION, false);\n-        List<SecretKey> secretKeyList = new ArrayList<>();\n-        secretKeyList.add(secretKey);\n-        SecretsData secretsData = new SecretsData(secretKeyList, VERSION);\n+        Secret secret = new EncryptionSecret(VERSION, ENCRYPTION_SECRET);\n+        List<Secret> secretList = new ArrayList<>();\n+        secretList.add(secret);\n+        SecretsData secretsData = new SecretsData(secretList, secret);\n         SecretKeyAccessor mySecretKeyAccessor = () -> secretsData;\n \n         Map<String, String> authMap = new HashMap<>();\n@@ -830,15 +830,15 @@ public void connectionPoolTest() throws StorageException, InterruptedException,\n                 .setClientSecret(SECRET)\n                 .setDefaultAuthEndpoint(DEFAULT_AUTH_ENDPOINT)\n                 .setEndpointMask(ENDPOINT_MASK)\n-                .setEnvId(ENV_ID)\n+                .setEnvironmentId(ENV_ID)\n                 .setSecretKeyAccessor(mySecretKeyAccessor)\n                 .setCountriesEndpoint(COUNTRIES_LIST_ENDPOINT)\n                 .setMaxHttpPoolSize(HTTP_POOL_SIZE)\n                 .setMaxHttpConnectionsPerRoute(HTTP_POOL_SIZE / 2);\n         if (!authMap.isEmpty()) {\n             config.setAuthEndpoints(authMap);\n         }\n-        Storage customStorage = StorageImpl.getInstance(config);\n+        Storage customStorage = StorageImpl.newStorage(config);\n         //http pool size < concurrent threads < count of threads\n         ExecutorService executorService = Executors.newFixedThreadPool(HTTP_POOL_SIZE / 2);\n         List<Future<StorageException>> futureList = new ArrayList<>();"
  },
  {
    "sha": "98c64e069f3bed7b578bdc0b6b8622c1571ec986",
    "filename": "src/main/java/com/incountry/residence/sdk/Storage.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/Storage.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/Storage.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/Storage.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -2,10 +2,10 @@\n \n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n@@ -35,12 +35,12 @@\n      *\n      * @param country country identifier\n      * @param records record list\n-     * @return BatchRecord object which contains list of recorded records\n+     * @return list of recorded records\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if record encryption failed\n      */\n-    BatchRecord batchWrite(String country, List<Record> records) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    List<Record> batchWrite(String country, List<Record> records) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Read data from remote storage\n@@ -69,25 +69,25 @@\n      * Find records in remote storage according to filters\n      *\n      * @param country country identifier\n-     * @param builder object representing find filters and search options\n+     * @param filter object representing find filters and search options\n      * @return BatchRecord object which contains required records\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if decryption failed\n      */\n-    BatchRecord find(String country, FindFilterBuilder builder) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    FindResult find(String country, FindFilter filter) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Find only one first record in remote storage according to filters\n      *\n      * @param country country identifier\n-     * @param builder object representing find filters\n+     * @param filter object representing find filters\n      * @return founded record or null\n      * @throws StorageClientException if validation finished with errors\n      * @throws StorageServerException if server connection failed or server response error\n      * @throws StorageCryptoException if decryption failed\n      */\n-    Record findOne(String country, FindFilterBuilder builder) throws StorageClientException, StorageServerException, StorageCryptoException;\n+    Record findOne(String country, FindFilter filter) throws StorageClientException, StorageServerException, StorageCryptoException;\n \n     /**\n      * Make batched key-rotation-migration of records"
  },
  {
    "sha": "cf45b5ecc110b4f3758a80278481e3bb826c0f54",
    "filename": "src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "status": "modified",
    "additions": 23,
    "deletions": 24,
    "changes": 47,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/StorageConfig.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/StorageConfig.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,11 +1,9 @@\n package com.incountry.residence.sdk;\n \n-import com.incountry.residence.sdk.tools.crypto.Crypto;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n+import com.incountry.residence.sdk.crypto.SecretKeyAccessor;\n \n-import java.util.ArrayList;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n \n /**\n@@ -21,11 +19,11 @@\n     public static final String PARAM_CLIENT_ID = \"INC_CLIENT_ID\";\n     public static final String PARAM_CLIENT_SECRET = \"INC_CLIENT_SECRET\";\n \n-    private String envId;\n+    private String environmentId;\n     private String apiKey;\n     private String endPoint;\n     private SecretKeyAccessor secretKeyAccessor;\n-    private List<Crypto> customEncryptionConfigsList;\n+    private CryptoProvider cryptoProvider;\n     private String clientId;\n     private String clientSecret;\n     private boolean normalizeKeys;\n@@ -38,28 +36,28 @@\n     private Integer maxHttpConnectionsPerRoute;\n     private boolean hashSearchKeys = true;\n \n-    public String getEnvId() {\n-        return envId;\n+    public String getEnvironmentId() {\n+        return environmentId;\n     }\n \n     /**\n      * sets environment ID\n      *\n-     * @param envId environment ID\n+     * @param environmentId environment ID\n      * @return StorageConfig\n      */\n-    public StorageConfig setEnvId(String envId) {\n-        this.envId = envId;\n+    public StorageConfig setEnvironmentId(String environmentId) {\n+        this.environmentId = environmentId;\n         return this;\n     }\n \n     /**\n-     * load envId from env variable 'INC_ENVIRONMENT_ID'\n+     * load environmentId from env variable 'INC_ENVIRONMENT_ID'\n      *\n      * @return StorageConfig\n      */\n-    public StorageConfig useEnvIdFromEnv() {\n-        this.envId = loadFromEnv(PARAM_ENV_ID);\n+    public StorageConfig useEnvironmentIdFromEnv() {\n+        this.environmentId = loadFromEnv(PARAM_ENV_ID);\n         return this;\n     }\n \n@@ -129,18 +127,19 @@ public StorageConfig setSecretKeyAccessor(SecretKeyAccessor secretKeyAccessor) {\n         return this;\n     }\n \n-    public List<Crypto> getCustomEncryptionConfigsList() {\n-        return customEncryptionConfigsList == null ? null : new ArrayList<>(customEncryptionConfigsList);\n+    public CryptoProvider getCryptoProvider() {\n+        return cryptoProvider;\n     }\n \n     /**\n-     * Optional. For custom encryption\n+     * Optional. Provider of encryption ciphers. Allows to register custom ciphers for encrypting stored data.\n+     * If null - default AES GCM cipher will be used\n      *\n-     * @param customEncryptionConfigsList List with custom encryption functions\n+     * @param cryptoProvider provider\n      * @return StorageConfig\n      */\n-    public StorageConfig setCustomEncryptionConfigsList(List<Crypto> customEncryptionConfigsList) {\n-        this.customEncryptionConfigsList = customEncryptionConfigsList;\n+    public StorageConfig setCryptoProvider(CryptoProvider cryptoProvider) {\n+        this.cryptoProvider = cryptoProvider;\n         return this;\n     }\n \n@@ -338,11 +337,11 @@ public StorageConfig setHashSearchKeys(boolean hashSearchKeys) {\n \n     public StorageConfig copy() {\n         StorageConfig newInstance = new StorageConfig();\n-        newInstance.setEnvId(getEnvId());\n+        newInstance.setEnvironmentId(getEnvironmentId());\n         newInstance.setApiKey(getApiKey());\n         newInstance.setEndPoint(getEndPoint());\n         newInstance.setSecretKeyAccessor(getSecretKeyAccessor());\n-        newInstance.setCustomEncryptionConfigsList(getCustomEncryptionConfigsList());\n+        newInstance.setCryptoProvider(getCryptoProvider());\n         newInstance.setNormalizeKeys(isNormalizeKeys());\n         newInstance.setClientId(getClientId());\n         newInstance.setClientSecret(getClientSecret());\n@@ -359,11 +358,11 @@ public StorageConfig copy() {\n     @Override\n     public String toString() {\n         return \"StorageConfig{\" +\n-                \"envId='\" + hideParam(envId) + '\\'' +\n+                \"envId='\" + hideParam(environmentId) + '\\'' +\n                 \", apiKey='\" + hideParam(apiKey) + '\\'' +\n                 \", endPoint='\" + endPoint + '\\'' +\n                 \", secretKeyAccessor=\" + secretKeyAccessor +\n-                \", customEncryptionConfigsList=\" + customEncryptionConfigsList +\n+                \", cryptoProvider=\" + cryptoProvider +\n                 \", ignoreKeyCase=\" + normalizeKeys +\n                 \", clientId='\" + hideParam(clientId) + '\\'' +\n                 \", clientSecret='\" + hideParam(clientSecret) + '\\'' +"
  },
  {
    "sha": "1471b87e10c364801e2a192211b4af0c0d3439a9",
    "filename": "src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "status": "modified",
    "additions": 112,
    "deletions": 214,
    "changes": 326,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/StorageImpl.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/StorageImpl.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -2,22 +2,26 @@\n \n import com.incountry.residence.sdk.dto.AttachedFile;\n import com.incountry.residence.sdk.dto.AttachmentMeta;\n-import com.incountry.residence.sdk.dto.BatchRecord;\n+import com.incountry.residence.sdk.dto.FindResult;\n import com.incountry.residence.sdk.dto.MigrateResult;\n import com.incountry.residence.sdk.dto.Record;\n-import com.incountry.residence.sdk.dto.search.FindFilterBuilder;\n-import com.incountry.residence.sdk.dto.search.StringField;\n-import com.incountry.residence.sdk.tools.crypto.CryptoManager;\n+import com.incountry.residence.sdk.dto.search.FindFilter;\n+import com.incountry.residence.sdk.dto.search.NumberField;\n+import com.incountry.residence.sdk.tools.DtoTransformer;\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.crypto.CryptoProvider;\n+import com.incountry.residence.sdk.tools.crypto.HashUtils;\n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n import com.incountry.residence.sdk.tools.exceptions.StorageServerException;\n import com.incountry.residence.sdk.tools.dao.Dao;\n import com.incountry.residence.sdk.tools.http.TokenClient;\n import com.incountry.residence.sdk.tools.http.impl.ApiKeyTokenClient;\n import com.incountry.residence.sdk.tools.http.impl.OAuthTokenClient;\n-import com.incountry.residence.sdk.tools.keyaccessor.SecretKeyAccessor;\n import com.incountry.residence.sdk.tools.dao.impl.HttpDaoImpl;\n import com.incountry.residence.sdk.tools.proxy.ProxyUtils;\n+import com.incountry.residence.sdk.tools.transfer.TransferFindResult;\n+import com.incountry.residence.sdk.tools.transfer.TransferRecord;\n import org.apache.http.client.config.RequestConfig;\n import org.apache.http.impl.client.CloseableHttpClient;\n import org.apache.http.impl.client.HttpClientBuilder;\n@@ -30,11 +34,14 @@\n import java.io.InputStream;\n import java.util.List;\n \n+import static com.incountry.residence.sdk.tools.ValidationHelper.isNullOrEmpty;\n+\n /**\n  * Basic implementation\n  */\n public class StorageImpl implements Storage {\n     private static final Logger LOG = LogManager.getLogger(StorageImpl.class);\n+    private static final ValidationHelper HELPER = new ValidationHelper(LOG);\n     //error messages\n     private static final String MSG_ERR_PASS_ENV = \"Please pass environment_id param or set INC_ENVIRONMENT_ID env var\";\n     private static final String MSG_ERR_AUTH_DUPL = \"Either apiKey or clientId/clientSecret can be used at the same moment, not both\";\n@@ -47,7 +54,6 @@\n     private static final String MSG_ERR_NULL_RECORD = \"Can't write null record\";\n     private static final String MSG_ERR_MIGR_NOT_SUPPORT = \"Migration is not supported when encryption is off\";\n     private static final String MSG_ERR_MIGR_ERROR_LIMIT = \"Limit can't be < 1\";\n-    private static final String MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR = \"Custom encryption can be used only with not null SecretKeyAccessor\";\n     private static final String MSG_ERR_CONFIG = \"Storage configuration is null\";\n     private static final String MSG_ERR_PASS_CLIENT_ID = \"Please pass clientId in configuration or set INC_CLIENT_ID env var\";\n     private static final String MSG_ERR_PASS_CLIENT_SECRET = \"Please pass clientSecret in configuration or set INC_CLIENT_SECRET env var\";\n@@ -58,117 +64,66 @@\n     private static final String MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE = \"File name and MIME type can't be null\";\n     private static final String MSG_ERR_NULL_FILE_INPUT_STREAM = \"Input stream can't be null\";\n     private static final String MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM = \"Input stream is not available\";\n-    private static final String MSG_ERR_KEY_LENGTH = \"key1-key20 length can't be more than 256 chars\";\n-\n     private static final String MSG_FOUND_NOTHING = \"Nothing was found\";\n+    private static final String MSG_ERR_UNEXPECTED = \"Unexpected error\";\n+    private static final String MSG_ERR_NULL_SECRETS = \"SecretKeyAccessor returns null secret\";\n+\n     private static final int DEFAULT_HTTP_TIMEOUT = 30;\n     private static final int DEFAULT_MAX_HTTP_CONNECTIONS = 20;\n \n-    private CryptoManager cryptoManager;\n-    private Dao dao;\n-    private boolean encrypted;\n-    private boolean hashSearchKeys;\n-\n-    private StorageImpl() {\n-    }\n-\n-    /**\n-     * creating Storage instance with ENV variables without encryption\n-     *\n-     * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n-     */\n-    public static Storage getInstance() throws StorageClientException {\n-        return getInstance((SecretKeyAccessor) null);\n-    }\n+    private final Dao dao;\n+    private final HashUtils hashUtils;\n+    private final DtoTransformer transformer;\n \n-    /**\n-     * creating Storage instance with ENV variables\n-     *\n-     * @param secretKeyAccessor Instance of SecretKeyAccessor class. Used to fetch encryption secret\n-     * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n-     */\n-    public static Storage getInstance(SecretKeyAccessor secretKeyAccessor) throws StorageClientException {\n-        StorageConfig config = new StorageConfig()\n-                .setSecretKeyAccessor(secretKeyAccessor)\n-                .useEnvIdFromEnv()\n-                .useApiKeyFromEnv()\n-                .useEndPointFromEnv()\n-                .useClientIdFromEnv()\n-                .useClientSecretFromEnv();\n-        return getInstance(config);\n+    private StorageImpl(StorageConfig config, Dao dao) throws StorageClientException, StorageCryptoException {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"StorageImpl constructor params config={}\", config);\n+        }\n+        HELPER.check(StorageClientException.class, config == null, MSG_ERR_CONFIG);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(config.getEnvironmentId()), MSG_ERR_PASS_ENV);\n+        boolean invalidAuth = config.getApiKey() != null && config.getClientId() != null;\n+        HELPER.check(StorageClientException.class, invalidAuth, MSG_ERR_AUTH_DUPL);\n+\n+        this.dao = initDao(config, dao);\n+        this.hashUtils = new HashUtils(config.getEnvironmentId(), config.isNormalizeKeys());\n+        CryptoProvider cryptoProvider = config.getCryptoProvider() == null ? new CryptoProvider(null) : config.getCryptoProvider();\n+        if (config.getSecretKeyAccessor() != null) {\n+            boolean invalidAccessor;\n+            try {\n+                invalidAccessor = config.getSecretKeyAccessor().getSecretsData() == null;\n+            } catch (Exception ex) {\n+                LOG.error(MSG_ERR_UNEXPECTED, ex);\n+                throw new StorageClientException(MSG_ERR_UNEXPECTED, ex);\n+            }\n+            HELPER.check(StorageClientException.class, invalidAccessor, MSG_ERR_NULL_SECRETS);\n+        }\n+        cryptoProvider.validateCustomCiphers(config.getSecretKeyAccessor() == null ? null : config.getSecretKeyAccessor().getSecretsData());\n+        this.transformer = new DtoTransformer(cryptoProvider, hashUtils, config.isHashSearchKeys(), config.getSecretKeyAccessor());\n     }\n \n     /**\n-     * creating Storage instance\n+     * create new Storage instance\n      *\n-     * @param environmentID     Required to be passed in, or as environment variable INC_API_KEY with {@link #getInstance()}\n-     * @param apiKey            Required to be passed in, or as environment variable INC_ENVIRONMENT_ID with {@link #getInstance()}\n-     * @param endpoint          Optional. Defines API URL. Default endpoint will be used if this param is null\n-     * @param secretKeyAccessor Instance of SecretKeyAccessor class. Used to fetch encryption secret\n+     * @param config A container with configuration for Storage initialization\n      * @return instance of Storage\n      * @throws StorageClientException if configuration validation finished with errors\n+     * @throws StorageCryptoException if custom cipher validation fails\n      */\n-    public static Storage getInstance(String environmentID, String apiKey, String endpoint, SecretKeyAccessor secretKeyAccessor)\n-            throws StorageClientException {\n-        StorageConfig config = new StorageConfig()\n-                .setSecretKeyAccessor(secretKeyAccessor)\n-                .setEnvId(environmentID)\n-                .setApiKey(apiKey)\n-                .setEndPoint(endpoint);\n-        return getInstance(config);\n+    public static Storage newStorage(StorageConfig config) throws StorageClientException, StorageCryptoException {\n+        return newStorage(config, null);\n     }\n \n     /**\n-     * creating Storage instance\n+     * overloaded version for tests and debugging\n      *\n      * @param config A container with configuration for Storage initialization\n+     * @param dao    dao, can be mocked for tests\n      * @return instance of Storage\n-     * @throws StorageClientException if configuration validation finished with errors\n+     * @throws StorageClientException if parameter validation finished with errors\n+     * @throws StorageCryptoException if custom cipher validation fails\n      */\n-    public static Storage getInstance(StorageConfig config)\n-            throws StorageClientException {\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"StorageImpl constructor params config={}\", config);\n-        }\n-        if (config == null) {\n-            LOG.error(MSG_ERR_CONFIG);\n-            throw new StorageClientException(MSG_ERR_CONFIG);\n-        }\n-        if (config.getSecretKeyAccessor() == null && !(config.getCustomEncryptionConfigsList() == null || config.getCustomEncryptionConfigsList().isEmpty())) {\n-            LOG.error(MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR);\n-            throw new StorageClientException(MSG_ERR_CUSTOM_ENCRYPTION_ACCESSOR);\n-        }\n-        return getInstance(config, null);\n-    }\n-\n-    public static Storage getInstance(String environmentID, SecretKeyAccessor secretKeyAccessor, Dao dao) throws StorageClientException {\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"StorageImpl constructor params (environmentID={} , secretKeyAccessor={} , dao={})\",\n-                    environmentID != null ? String.format(StorageConfig.MSG_SECURE, environmentID.hashCode()) : null,\n-                    secretKeyAccessor,\n-                    dao\n-            );\n-        }\n-        StorageConfig config = new StorageConfig()\n-                .setEnvId(environmentID)\n-                .setSecretKeyAccessor(secretKeyAccessor);\n-        return getInstance(config, dao);\n-    }\n-\n-    private static Storage getInstance(StorageConfig config, Dao dao)\n-            throws StorageClientException {\n-        checkNotNull(config.getEnvId(), MSG_ERR_PASS_ENV);\n-        if (config.getApiKey() != null && config.getClientId() != null) {\n-            LOG.error(MSG_ERR_AUTH_DUPL);\n-            throw new StorageClientException(MSG_ERR_AUTH_DUPL);\n-        }\n-        StorageImpl instance = new StorageImpl();\n-        instance.dao = initDao(config, dao);\n-        instance.encrypted = config.getSecretKeyAccessor() != null;\n-        instance.cryptoManager = new CryptoManager(config.getSecretKeyAccessor(), config.getEnvId(), config.getCustomEncryptionConfigsList(), config.isNormalizeKeys(), config.isHashSearchKeys());\n-        instance.hashSearchKeys = config.isHashSearchKeys();\n+    public static Storage newStorage(StorageConfig config, Dao dao) throws StorageClientException, StorageCryptoException {\n+        Storage instance = new StorageImpl(config, dao);\n         return ProxyUtils.createLoggingProxyForPublicMethods(instance, true);\n     }\n \n@@ -204,24 +159,24 @@ private static Dao initDao(StorageConfig config, Dao dao) throws StorageClientEx\n             CloseableHttpClient httpClient = initHttpClient(httpTimeout, httpPoolSize, connectionsPerRoute);\n             TokenClient tokenClient;\n             if (config.getClientId() != null && config.getClientSecret() != null) {\n-                checkNotNull(config.getClientId(), MSG_ERR_PASS_CLIENT_ID);\n-                checkNotNull(config.getClientSecret(), MSG_ERR_PASS_CLIENT_SECRET);\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getClientId()), MSG_ERR_PASS_CLIENT_ID);\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getClientSecret()), MSG_ERR_PASS_CLIENT_SECRET);\n                 tokenClient = new OAuthTokenClient(config.getDefaultAuthEndpoint(),\n                         config.getAuthEndpoints(),\n-                        config.getEnvId(),\n+                        config.getEnvironmentId(),\n                         config.getClientId(),\n                         config.getClientSecret(),\n                         httpClient\n                 );\n                 tokenClient = ProxyUtils.createLoggingProxyForPublicMethods(tokenClient, true);\n             } else if (config.getApiKey() != null) {\n-                checkNotNull(config.getApiKey(), MSG_ERR_PASS_API_KEY);\n+                HELPER.check(StorageClientException.class, isNullOrEmpty(config.getApiKey()), MSG_ERR_PASS_API_KEY);\n                 tokenClient = new ApiKeyTokenClient(config.getApiKey());\n             } else {\n                 LOG.error(MSG_ERR_PASS_AUTH);\n                 throw new StorageClientException(MSG_ERR_PASS_AUTH);\n             }\n-            return new HttpDaoImpl(config.getEnvId(),\n+            return new HttpDaoImpl(config.getEnvironmentId(),\n                     config.getEndPoint(),\n                     config.getEndpointMask(),\n                     config.getCountriesEndpoint(),\n@@ -233,146 +188,84 @@ private static Dao initDao(StorageConfig config, Dao dao) throws StorageClientEx\n     }\n \n     private static void checkPositiveOrNull(Integer intValue, String errorMessage) throws StorageClientException {\n-        if (intValue != null && intValue < 1) {\n-            String errMessage = String.format(errorMessage, intValue);\n-            LOG.error(errMessage);\n-            throw new StorageClientException(errMessage);\n-        }\n-    }\n-\n-    private static void checkNotNull(Object parameter, String nullErrorMessage) throws StorageClientException {\n-        if (parameter == null || String.valueOf(parameter).isEmpty()) {\n-            LOG.error(nullErrorMessage);\n-            throw new StorageClientException(nullErrorMessage);\n-        }\n+        boolean invalidParams = intValue != null && intValue < 1;\n+        HELPER.check(StorageClientException.class, invalidParams, errorMessage, intValue);\n     }\n \n     private static void checkFileNameAndMimeType(String fileName, String mimeType) throws StorageClientException {\n-        if ((fileName == null || fileName.isEmpty()) && (mimeType == null || mimeType.isEmpty())) {\n-            LOG.error(MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n-            throw new StorageClientException(MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n-        }\n+        boolean invalidParams = isNullOrEmpty(fileName) && isNullOrEmpty(mimeType);\n+        HELPER.check(StorageClientException.class, invalidParams, MSG_ERR_NULL_FILE_NAME_AND_MIME_TYPE);\n     }\n \n     private void checkCountryAndRecordKey(String country, String key) throws StorageClientException {\n-        checkNotNull(country, MSG_ERR_NULL_COUNTRY);\n-        checkNotNull(key, MSG_ERR_NULL_KEY);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(country), MSG_ERR_NULL_COUNTRY);\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(key), MSG_ERR_NULL_KEY);\n     }\n \n     private void checkAttachmentParameters(String country, String key, String fileId) throws StorageClientException {\n-        checkNotNull(fileId, MSG_ERR_NULL_FILE_ID);\n+        boolean invalidFileId = isNullOrEmpty(fileId);\n+        HELPER.check(StorageClientException.class, invalidFileId, MSG_ERR_NULL_FILE_ID);\n         checkCountryAndRecordKey(country, key);\n     }\n \n-    private void checkKey(String key) throws StorageClientException {\n-        if (key != null && key.length() > 256) {\n-            LOG.error(MSG_ERR_KEY_LENGTH);\n-            throw new StorageClientException(MSG_ERR_KEY_LENGTH);\n-        }\n-    }\n-\n-    private void checkRecordSearchKeys(Record record) throws StorageClientException {\n-        if (!hashSearchKeys) {\n-            checkKey(record.getKey1());\n-            checkKey(record.getKey2());\n-            checkKey(record.getKey3());\n-            checkKey(record.getKey4());\n-            checkKey(record.getKey5());\n-            checkKey(record.getKey6());\n-            checkKey(record.getKey7());\n-            checkKey(record.getKey8());\n-            checkKey(record.getKey9());\n-            checkKey(record.getKey10());\n-            checkKey(record.getKey11());\n-            checkKey(record.getKey12());\n-            checkKey(record.getKey13());\n-            checkKey(record.getKey14());\n-            checkKey(record.getKey15());\n-            checkKey(record.getKey16());\n-            checkKey(record.getKey17());\n-            checkKey(record.getKey18());\n-            checkKey(record.getKey19());\n-            checkKey(record.getKey20());\n-\n-        }\n-    }\n-\n-    public Record write(String country, Record record) throws\n-            StorageClientException, StorageServerException, StorageCryptoException {\n-        checkNotNull(record, MSG_ERR_NULL_RECORD);\n+    public Record write(String country, Record record) throws StorageClientException, StorageServerException, StorageCryptoException {\n+        HELPER.check(StorageClientException.class, record == null, MSG_ERR_NULL_RECORD);\n         checkCountryAndRecordKey(country, record.getRecordKey());\n-        checkRecordSearchKeys(record);\n-        dao.createRecord(country, record, cryptoManager);\n+        dao.createRecord(country, transformer.getTransferRecord(record));\n         return record;\n     }\n \n \n     public Record read(String country, String recordKey) throws StorageClientException, StorageServerException, StorageCryptoException {\n         checkCountryAndRecordKey(country, recordKey);\n-        return dao.read(country, cryptoManager.createKeyHash(recordKey), cryptoManager);\n+        TransferRecord transferRecord = dao.read(country, hashUtils.getSha256Hash(recordKey));\n+        return transformer.getRecord(transferRecord);\n     }\n \n     public MigrateResult migrate(String country, int limit) throws\n             StorageClientException, StorageServerException, StorageCryptoException {\n-        if (!encrypted) {\n-            LOG.error(MSG_ERR_MIGR_NOT_SUPPORT);\n-            throw new StorageClientException(MSG_ERR_MIGR_NOT_SUPPORT);\n-        }\n-        if (limit < 1) {\n-            LOG.error(MSG_ERR_MIGR_ERROR_LIMIT);\n-            throw new StorageClientException(MSG_ERR_MIGR_ERROR_LIMIT);\n-        }\n-        FindFilterBuilder builder = FindFilterBuilder.create()\n+        HELPER.check(StorageClientException.class, transformer.getKeyAccessor() == null, MSG_ERR_MIGR_NOT_SUPPORT);\n+        HELPER.check(StorageClientException.class, limit < 1, MSG_ERR_MIGR_ERROR_LIMIT);\n+        FindFilter builder = new FindFilter()\n                 .limitAndOffset(limit, 0)\n-                .keyNotEq(StringField.VERSION, String.valueOf(cryptoManager.getCurrentSecretVersion()));\n-        BatchRecord batchRecord = find(country, builder);\n-        if (!batchRecord.getRecords().isEmpty()) {\n-            batchWrite(country, batchRecord.getRecords());\n+                .keyNotEq(NumberField.VERSION, Long.valueOf(transformer.getKeyAccessor().getSecretsData().getCurrentSecret().getVersion()));\n+        FindResult findResult = find(country, builder);\n+        if (!findResult.getRecords().isEmpty()) {\n+            batchWrite(country, findResult.getRecords());\n         }\n-        return new MigrateResult(batchRecord.getRecords().size(),\n-                batchRecord.getTotal() - batchRecord.getRecords().size(),\n-                batchRecord.getErrors());\n+        return new MigrateResult(findResult.getRecords().size(),\n+                findResult.getTotal() - findResult.getRecords().size(),\n+                findResult.getErrors());\n     }\n \n-    public BatchRecord batchWrite(String country, List<Record> records) throws\n-            StorageClientException, StorageServerException, StorageCryptoException {\n-        if (records == null || records.isEmpty()) {\n-            LOG.error(MSG_ERR_NULL_BATCH);\n-            throw new StorageClientException(MSG_ERR_NULL_BATCH);\n-        } else {\n-            for (Record record : records) {\n-                checkCountryAndRecordKey(country, record.getRecordKey());\n-                checkRecordSearchKeys(record);\n-            }\n-            dao.createBatch(records, country, cryptoManager);\n+    public List<Record> batchWrite(String country, List<Record> records)\n+            throws StorageClientException, StorageServerException, StorageCryptoException {\n+        boolean invalidList = records == null || records.isEmpty();\n+        HELPER.check(StorageClientException.class, invalidList, MSG_ERR_NULL_BATCH);\n+        for (Record record : records) {\n+            HELPER.check(StorageClientException.class, record == null, MSG_ERR_NULL_RECORD);\n+            checkCountryAndRecordKey(country, record.getRecordKey());\n         }\n-        return new BatchRecord(records, 0, 0, 0, 0, null);\n+        dao.createBatch(country, transformer.getTransferRecordList(records));\n+        return records;\n     }\n \n     public boolean delete(String country, String recordKey) throws StorageClientException, StorageServerException {\n         checkCountryAndRecordKey(country, recordKey);\n-        dao.delete(country, cryptoManager.createKeyHash(recordKey));\n+        dao.delete(country, hashUtils.getSha256Hash(recordKey));\n         return true;\n     }\n \n-    public BatchRecord find(String country, FindFilterBuilder builder) throws\n-            StorageClientException, StorageServerException {\n-        checkNotNull(country, MSG_ERR_NULL_COUNTRY);\n-        checkNotNull(builder, MSG_ERR_NULL_FILTERS);\n-        return dao.find(country, builder.build(), cryptoManager);\n+    public FindResult find(String country, FindFilter filter) throws StorageClientException, StorageServerException {\n+        HELPER.check(StorageClientException.class, isNullOrEmpty(country), MSG_ERR_NULL_COUNTRY);\n+        HELPER.check(StorageClientException.class, filter == null, MSG_ERR_NULL_FILTERS);\n+        TransferFindResult transferFindResult = dao.find(country, transformer.getTransferFilterContainer(filter));\n+        return transformer.getFindResult(transferFindResult);\n     }\n \n-    /**\n-     * Find one record in remote storage\n-     *\n-     * @param country country identifier\n-     * @param builder object representing find filters\n-     * @return Record object which contains required data\n-     * @throws StorageServerException if server connection failed or server response error\n-     */\n-    public Record findOne(String country, FindFilterBuilder builder) throws\n+    public Record findOne(String country, FindFilter filter) throws\n             StorageClientException, StorageServerException {\n-        BatchRecord findResults = find(country, builder != null ? builder.copy().limitAndOffset(1, 0) : null);\n+        FindResult findResults = find(country, filter != null ? filter.copy().limitAndOffset(1, 0) : null);\n         List<Record> records = findResults.getRecords();\n         if (records.isEmpty()) {\n             LOG.warn(MSG_FOUND_NOTHING);\n@@ -400,40 +293,45 @@ public AttachmentMeta addAttachment(String country, String recordKey, InputStrea\n     public AttachmentMeta addAttachment(String country, String recordKey, InputStream inputStream, String fileName, boolean upsert, String mimeType) throws StorageClientException, StorageServerException {\n         checkCountryAndRecordKey(country, recordKey);\n         try {\n-            if (inputStream == null || inputStream.available() < 0) {\n-                LOG.error(MSG_ERR_NULL_FILE_INPUT_STREAM);\n-                throw new StorageClientException(MSG_ERR_NULL_FILE_INPUT_STREAM);\n-            }\n+            boolean invalidStream = inputStream == null || inputStream.available() < 0;\n+            HELPER.check(StorageClientException.class, invalidStream, MSG_ERR_NULL_FILE_INPUT_STREAM);\n         } catch (IOException ex) {\n             LOG.error(MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM);\n             throw new StorageClientException(MSG_ERR_NOT_AVAILABLE_FILE_INPUT_STREAM, ex);\n         }\n-        return dao.addAttachment(country, cryptoManager.createKeyHash(recordKey), inputStream, fileName, upsert, mimeType);\n+        return dao.addAttachment(country, hashUtils.getSha256Hash(recordKey), inputStream, fileName, upsert, mimeType);\n     }\n \n     @Override\n     public boolean deleteAttachment(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        dao.deleteAttachment(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        dao.deleteAttachment(country, hashUtils.getSha256Hash(recordKey), fileId);\n         return true;\n     }\n \n     @Override\n     public AttachedFile getAttachmentFile(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.getAttachmentFile(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        return dao.getAttachmentFile(country, hashUtils.getSha256Hash(recordKey), fileId);\n     }\n \n     @Override\n     public AttachmentMeta updateAttachmentMeta(String country, String recordKey, String fileId, String fileName, String mimeType) throws StorageClientException, StorageServerException {\n         checkFileNameAndMimeType(fileName, mimeType);\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.updateAttachmentMeta(country, cryptoManager.createKeyHash(recordKey), fileId, fileName, mimeType);\n+        AttachmentMeta updatedMeta = new AttachmentMeta();\n+        if (!isNullOrEmpty(fileName)) {\n+            updatedMeta.setFilename(fileName);\n+        }\n+        if (!isNullOrEmpty(mimeType)) {\n+            updatedMeta.setMimeType(mimeType);\n+        }\n+        return dao.updateAttachmentMeta(country, hashUtils.getSha256Hash(recordKey), fileId, updatedMeta);\n     }\n \n     @Override\n     public AttachmentMeta getAttachmentMeta(String country, String recordKey, String fileId) throws StorageClientException, StorageServerException {\n         checkAttachmentParameters(country, recordKey, fileId);\n-        return dao.getAttachmentMeta(country, cryptoManager.createKeyHash(recordKey), fileId);\n+        return dao.getAttachmentMeta(country, hashUtils.getSha256Hash(recordKey), fileId);\n     }\n }"
  },
  {
    "sha": "df46b3d3f8b8c0610d47eee196c6e24904607c41",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/AbstractCipher.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,84 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.crypto.cipher.Cipher;\n+import com.incountry.residence.sdk.tools.crypto.cipher.Ciphertext;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+public abstract class AbstractCipher implements Cipher {\n+\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(AbstractCipher.class));\n+    private static final String PREFIX_CUSTOM_ENCRYPTION = \"c\";\n+\n+    private static final String MSG_ERR_INVALID_KEY_CLASS = \"Used key from secrets data is not instance of CustomEncryptionKey\";\n+    private static final String MSG_ERR_NULL_CIPHER_NAME = \"Cipher has null name\";\n+\n+    private final String name;\n+    private final String nameBase64;\n+\n+    protected Charset charset = StandardCharsets.UTF_8;\n+\n+    @SuppressWarnings(\"java:S2259\")\n+    protected AbstractCipher(String name) throws StorageClientException {\n+        boolean invalidName = name == null || name.isEmpty();\n+        HELPER.check(StorageClientException.class, invalidName, MSG_ERR_NULL_CIPHER_NAME);\n+        this.name = name;\n+        this.nameBase64 = base64(name);\n+    }\n+\n+    private String base64(String name) {\n+        String base64String = Base64.getEncoder().encodeToString(name.getBytes(charset));\n+        return PREFIX_CUSTOM_ENCRYPTION + base64String;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getNameBase64() {\n+        return nameBase64;\n+    }\n+\n+    /**\n+     * encrypts data with secretKey\n+     *\n+     * @param textBytes data for encryption\n+     * @param secretKey secret\n+     * @return encrypted data as String\n+     * @throws StorageClientException when parameters validation fails\n+     * @throws StorageCryptoException when encryption fails\n+     */\n+    public abstract String encrypt(byte[] textBytes, CustomEncryptionKey secretKey) throws StorageClientException, StorageCryptoException;\n+\n+    public Ciphertext encrypt(String text, Secret secret) throws StorageCryptoException, StorageClientException {\n+        boolean correctSecretType = secret instanceof CustomEncryptionKey;\n+        HELPER.check(StorageCryptoException.class, !correctSecretType, MSG_ERR_INVALID_KEY_CLASS);\n+        String cipheredText = encrypt(text.getBytes(charset), (CustomEncryptionKey) secret);\n+        return new Ciphertext(nameBase64 + \":\" + Base64.getEncoder().encodeToString(cipheredText.getBytes(charset)),\n+                secret.getVersion());\n+    }\n+\n+    /**\n+     * decrypts data with Secret\n+     *\n+     * @param cipherTextBytes encrypted data\n+     * @param secretKey       secret\n+     * @return decrypted data as String\n+     * @throws StorageClientException when parameters validation fails\n+     * @throws StorageCryptoException when decryption fails\n+     */\n+    public abstract String decrypt(byte[] cipherTextBytes, CustomEncryptionKey secretKey) throws StorageClientException, StorageCryptoException;\n+\n+    public String decrypt(String cipherText, Secret secret) throws StorageCryptoException, StorageClientException {\n+        boolean correctSecretType = secret instanceof CustomEncryptionKey;\n+        HELPER.check(StorageCryptoException.class, !correctSecretType, MSG_ERR_INVALID_KEY_CLASS);\n+        return decrypt(Base64.getDecoder().decode(cipherText), (CustomEncryptionKey) secret);\n+    }\n+}"
  },
  {
    "sha": "6bb71edc15c9f764b1985c046c7f936731078642",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/CustomEncryptionKey.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,14 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+\n+public class CustomEncryptionKey extends Secret {\n+    public CustomEncryptionKey(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(CustomEncryptionKey.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "1c4bf3dbb040d521efe5371b75fe64a3c5d37b9c",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/EncryptionKey.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,24 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.LogManager;\n+\n+public class EncryptionKey extends Secret {\n+\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(EncryptionKey.class));\n+    private static final int KEY_LENGTH = 32;\n+    private static final String MSG_ERR_LENGTH = \"Wrong key length for encryption key . Should be \"\n+            + KEY_LENGTH + \"-byte array\";\n+\n+    public EncryptionKey(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+        boolean invalidLength = secretBytes.length != KEY_LENGTH;\n+        HELPER.check(StorageClientException.class, invalidLength, MSG_ERR_LENGTH);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(EncryptionKey.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "5dfa2f397a5c6a84b7aaf4acd989e3247e795953",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "status": "added",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/EncryptionSecret.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,14 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+\n+public class EncryptionSecret extends Secret {\n+    public EncryptionSecret(int version, byte[] secretBytes) throws StorageClientException {\n+        super(version, secretBytes);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(EncryptionSecret.class.getSimpleName());\n+    }\n+}"
  },
  {
    "sha": "82de343753db7f9c13dd4f1e2077fa61075df8ff",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/Secret.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/Secret.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,44 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.Arrays;\n+\n+public abstract class Secret {\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(Secret.class));\n+    private static final String MSG_ERR_VERSION = \"Version must be >= 0\";\n+    private static final String MSG_ERR_NULL_SECRET = \"Secret can't be null or empty\";\n+    private final int version;\n+    private final byte[] secretBytes;\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    public byte[] getSecretBytes() {\n+        return secretBytes;\n+    }\n+\n+    protected Secret(int version, byte[] secretBytes) throws StorageClientException {\n+        validateAbstractSecret(version, secretBytes);\n+        this.version = version;\n+        this.secretBytes = secretBytes;\n+    }\n+\n+    private static void validateAbstractSecret(int version, byte[] secretBytes) throws StorageClientException {\n+        boolean invalidVersion = version < 0;\n+        HELPER.check(StorageClientException.class, invalidVersion, MSG_ERR_VERSION);\n+        boolean invalidSecret = secretBytes == null || secretBytes.length == 0;\n+        HELPER.check(StorageClientException.class, invalidSecret, MSG_ERR_NULL_SECRET);\n+    }\n+\n+\n+    protected String toString(String typeName) {\n+        return typeName + \"{\" +\n+                \"version=\" + version +\n+                \", secretBytes=HASH[\" + Arrays.hashCode(secretBytes) + ']' +\n+                '}';\n+    }\n+}"
  },
  {
    "sha": "522bed25f67b44dcdc53b0f694103af3c9d2a1a8",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "status": "renamed",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretKeyAccessor.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,7 +1,6 @@\n-package com.incountry.residence.sdk.tools.keyaccessor;\n+package com.incountry.residence.sdk.crypto;\n \n import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData;\n \n /**\n  * Secrets accessor. Method {@link SecretKeyAccessor#getSecretsData()} is invoked on each encryption/decryption.",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/tools/keyaccessor/SecretKeyAccessor.java"
  },
  {
    "sha": "5768b292137c41be52e09f92a87390d9a0a17f09",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "status": "added",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretsData.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,84 @@\n+package com.incountry.residence.sdk.crypto;\n+\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import com.incountry.residence.sdk.tools.exceptions.StorageCryptoException;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class SecretsData {\n+    private static final ValidationHelper HELPER = new ValidationHelper(LogManager.getLogger(SecretsData.class));\n+\n+    private static final String MSG_ERR_EMPTY_SECRETS = \"Secrets in SecretData are null\";\n+    private static final String MSG_ERR_UNIQUE_VERSIONS = \"Secret versions must be unique. Got duplicates for: %s\";\n+    private static final String MSG_ERR_CURRENT_VERSION = \"There is no current secret at the secrets list\";\n+    private static final String MSG_ERR_NO_SECRET = \"Secret not found for 'version'=%d\";\n+\n+    private final List<Secret> secrets;\n+    private final Secret currentSecret;\n+\n+    /**\n+     * creates a container with secrets\n+     *\n+     * @param secrets       non-empty list of secrets. One of the secrets should be the second parameter {@link #currentSecret}\n+     * @param currentSecret Should be a non-negative integer\n+     * @throws StorageClientException when parameter validation fails\n+     */\n+    public SecretsData(List<Secret> secrets, Secret currentSecret) throws StorageClientException {\n+        validateSecretsData(secrets, currentSecret);\n+        this.currentSecret = currentSecret;\n+        this.secrets = secrets;\n+    }\n+\n+    public List<Secret> getSecrets() {\n+        return secrets;\n+    }\n+\n+    public Secret getCurrentSecret() {\n+        return currentSecret;\n+    }\n+\n+    @SuppressWarnings(\"java:S2259\")\n+    private static void validateSecretsData(List<Secret> secrets, Secret currentSecret) throws StorageClientException {\n+        boolean emptySecrets = secrets == null || secrets.isEmpty();\n+        HELPER.check(StorageClientException.class, emptySecrets, MSG_ERR_EMPTY_SECRETS);\n+        boolean invalidCurrentSecret = currentSecret == null || !secrets.contains(currentSecret);\n+        HELPER.check(StorageClientException.class, invalidCurrentSecret, MSG_ERR_CURRENT_VERSION);\n+\n+        List<Integer> errorList = new ArrayList<>();\n+        Set<Integer> versionSet = new HashSet<>();\n+        for (Secret secret : secrets) {\n+            if (versionSet.contains(secret.getVersion())) {\n+                errorList.add(secret.getVersion());\n+            } else {\n+                versionSet.add(secret.getVersion());\n+            }\n+        }\n+        boolean duplicateVersions = !errorList.isEmpty();\n+        HELPER.check(StorageClientException.class, duplicateVersions, MSG_ERR_UNIQUE_VERSIONS, errorList);\n+    }\n+\n+\n+    @SuppressWarnings(\"java:S3655\")\n+    public Secret getSecret(Integer version) throws StorageCryptoException {\n+        if (version == null) {\n+            return currentSecret;\n+        }\n+        Optional<Secret> secretOpt = secrets.stream().filter(one -> one.getVersion() == version).findFirst();\n+        HELPER.check(StorageCryptoException.class, !secretOpt.isPresent(), MSG_ERR_NO_SECRET, version);\n+        return secretOpt.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SecretsData{\" +\n+                \"secrets=\" + secrets +\n+                \", currentSecret=\" + currentSecret +\n+                '}';\n+    }\n+}"
  },
  {
    "sha": "19c5b11553757dba022fc74a1b54d9a693e77577",
    "filename": "src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "status": "renamed",
    "additions": 30,
    "deletions": 16,
    "changes": 46,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/crypto/SecretsDataGenerator.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,4 +1,4 @@\n-package com.incountry.residence.sdk.tools.keyaccessor.key;\n+package com.incountry.residence.sdk.crypto;\n \n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n@@ -13,7 +13,7 @@\n import java.util.List;\n \n /**\n- * Generator for {@link com.incountry.residence.sdk.tools.keyaccessor.key.SecretsData}\n+ * Generator for {@link SecretsData}\n  */\n public class SecretsDataGenerator {\n \n@@ -34,10 +34,10 @@ private SecretsDataGenerator() {\n      * @throws StorageClientException when parameter validation fails\n      */\n     public static SecretsData fromPassword(String password) throws StorageClientException {\n-        SecretKey secretKey = new SecretKey(password.getBytes(StandardCharsets.UTF_8), DEFAULT_VERSION, false);\n-        List<SecretKey> secretKeys = new ArrayList<>();\n-        secretKeys.add(secretKey);\n-        return new SecretsData(secretKeys, DEFAULT_VERSION);\n+        Secret secret = new EncryptionSecret(DEFAULT_VERSION, password.getBytes(StandardCharsets.UTF_8));\n+        List<Secret> secretKeys = new ArrayList<>();\n+        secretKeys.add(secret);\n+        return new SecretsData(secretKeys, secret);\n     }\n \n     /**\n@@ -51,26 +51,40 @@ public static SecretsData fromJson(String secretsDataJson) throws StorageClientE\n         SecretsData result;\n         try {\n             SecretsDataContainer container = new Gson().fromJson(secretsDataJson, SecretsDataContainer.class);\n-            List<SecretKey> secrets = new ArrayList<>();\n+            List<Secret> secrets = new ArrayList<>();\n+            Secret currentSecret = null;\n             if (container.secrets != null) {\n-                for (SecretKeyContainer key : container.secrets) {\n-                    if (key.isForCustomEncryption || key.isKey) {\n-                        base64Validation(key.secret);\n-                        byte[] byteKey = DatatypeConverter.parseBase64Binary(key.secret);\n-                        secrets.add(new SecretKey(byteKey, key.version, key.isKey, key.isForCustomEncryption));\n-                    } else {\n-                        byte[] byteKey = key.secret.getBytes(StandardCharsets.UTF_8);\n-                        secrets.add(new SecretKey(byteKey, key.version, key.isKey, key.isForCustomEncryption));\n+                for (SecretKeyContainer keyContainer : container.secrets) {\n+                    Secret secret = getSecret(keyContainer);\n+                    if (container.currentVersion.equals(keyContainer.version)) {\n+                        currentSecret = secret;\n                     }\n+                    secrets.add(secret);\n                 }\n             }\n-            result = new SecretsData(secrets, container.currentVersion);\n+            result = new SecretsData(secrets, currentSecret);\n         } catch (JsonSyntaxException | NullPointerException e) {\n             throw new StorageClientException(MSG_ERR_INCORRECT_SECRETS, e);\n         }\n         return result;\n     }\n \n+    private static Secret getSecret(SecretKeyContainer keyContainer) throws StorageClientException {\n+        Secret secret;\n+        if (keyContainer.isForCustomEncryption || keyContainer.isKey) {\n+            base64Validation(keyContainer.secret);\n+            byte[] byteKey = DatatypeConverter.parseBase64Binary(keyContainer.secret);\n+            secret = keyContainer.isForCustomEncryption\n+                    ? new CustomEncryptionKey(keyContainer.version, byteKey)\n+                    : new EncryptionKey(keyContainer.version, byteKey);\n+\n+        } else {\n+            byte[] byteKey = keyContainer.secret.getBytes(StandardCharsets.UTF_8);\n+            secret = new EncryptionSecret(keyContainer.version, byteKey);\n+        }\n+        return secret;\n+    }\n+\n     private static void base64Validation(String byteKey) throws StorageClientException {\n         if (!Base64.isBase64(byteKey)) {\n             LOG.error(MSG_ERR_BASE64_SECRET);",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/tools/keyaccessor/key/SecretsDataGenerator.java"
  },
  {
    "sha": "74eb00d662771c839c28f164b83e2733042ffec2",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "status": "modified",
    "additions": 10,
    "deletions": 2,
    "changes": 12,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/AttachmentMeta.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -12,7 +12,7 @@\n     private String filename;\n     private String hash;\n     private String mimeType;\n-    private int size;\n+    private Integer size;\n \n     public Date getCreatedAt() {\n         return createdAt != null ? new Date(createdAt.getTime()) : null;\n@@ -34,6 +34,10 @@ public String getFilename() {\n         return filename;\n     }\n \n+    public void setFilename(String filename) {\n+        this.filename = filename;\n+    }\n+\n     public String getHash() {\n         return hash;\n     }\n@@ -42,7 +46,11 @@ public String getMimeType() {\n         return mimeType;\n     }\n \n-    public int getSize() {\n+    public void setMimeType(String mimeType) {\n+        this.mimeType = mimeType;\n+    }\n+\n+    public Integer getSize() {\n         return size;\n     }\n "
  },
  {
    "sha": "266e70499e4d11011db5dfa4fb84e268a5f39009",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "status": "renamed",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/FindResult.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/FindResult.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -5,15 +5,15 @@\n import java.util.List;\n import java.util.stream.Collectors;\n \n-public class BatchRecord {\n+public class FindResult {\n     private final int count;\n     private final int limit;\n     private final int offset;\n     private final int total;\n     private final List<Record> records;\n     private final List<RecordException> errors;\n \n-    public BatchRecord(List<Record> records, int count, int limit, int offset, int total, List<RecordException> errors) {\n+    public FindResult(List<Record> records, int count, int limit, int offset, int total, List<RecordException> errors) {\n         this.count = count;\n         this.limit = limit;\n         this.offset = offset;\n@@ -48,7 +48,7 @@ public int getTotal() {\n \n     @Override\n     public String toString() {\n-        return \"BatchRecord{\" +\n+        return \"FindResult{\" +\n                 \"count=\" + count +\n                 \", limit=\" + limit +\n                 \", offset=\" + offset +",
    "previous_filename": "src/main/java/com/incountry/residence/sdk/dto/BatchRecord.java"
  },
  {
    "sha": "11549cbf6a7c36d5cbdf672ebec76f23e0d17fb9",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "status": "modified",
    "additions": 13,
    "deletions": 5,
    "changes": 18,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/Record.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/Record.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -45,6 +45,7 @@\n     private String serviceKey2;\n     protected Date createdAt;\n     protected Date updatedAt;\n+    protected Integer version;\n     private List<AttachmentMeta> attachments = new ArrayList<>();\n \n     /**\n@@ -400,6 +401,10 @@ public Record setServiceKey2(String serviceKey2) {\n         return this;\n     }\n \n+    public Integer getVersion() {\n+        return version;\n+    }\n+\n     public Date getCreatedAt() {\n         return createdAt != null ? new Date(createdAt.getTime()) : null;\n     }\n@@ -412,6 +417,11 @@ public Date getUpdatedAt() {\n         return attachments;\n     }\n \n+    protected Record setAttachments(List<AttachmentMeta> attachments) {\n+        this.attachments = attachments;\n+        return this;\n+    }\n+\n     @Override\n     public boolean equals(Object obj) {\n         if (this == obj) {\n@@ -458,8 +468,6 @@ public boolean equals(Object obj) {\n                 Objects.equals(precommitBody, record.precommitBody) &&\n                 Objects.equals(serviceKey1, record.serviceKey1) &&\n                 Objects.equals(serviceKey2, record.serviceKey2) &&\n-                Objects.equals(createdAt, record.createdAt) &&\n-                Objects.equals(updatedAt, record.updatedAt) &&\n                 Objects.equals(attachments, record.attachments);\n     }\n \n@@ -468,16 +476,15 @@ public int hashCode() {\n         return Objects.hash(recordKey, parentKey, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10,\n                 key11, key12, key13, key14, key15, key16, key17, key18, key19, key20,\n                 rangeKey1, rangeKey2, rangeKey3, rangeKey4, rangeKey5, rangeKey6, rangeKey7, rangeKey8, rangeKey9, rangeKey10,\n-                body, profileKey, precommitBody, serviceKey1, serviceKey2,\n-                createdAt, updatedAt, attachments);\n+                body, profileKey, precommitBody, serviceKey1, serviceKey2, attachments, version);\n     }\n \n     /**\n      * get copy of Record immutably\n      *\n      * @return return copy\n      */\n-    protected Record copy() {\n+    public Record copy() {\n         Record newRecord = new Record(recordKey);\n         newRecord.parentKey = parentKey;\n         newRecord.key1 = key1;\n@@ -517,6 +524,7 @@ protected Record copy() {\n         newRecord.serviceKey2 = serviceKey2;\n         newRecord.createdAt = getCreatedAt();\n         newRecord.updatedAt = getUpdatedAt();\n+        newRecord.version = version;\n         newRecord.attachments = attachments == null ? new ArrayList<>() : new ArrayList<>(attachments);\n         return newRecord;\n     }"
  },
  {
    "sha": "938bf8cb8d5163d02e1f91fa440f5550244389f7",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "status": "added",
    "additions": 234,
    "deletions": 0,
    "changes": 234,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/FindFilter.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,234 @@\n+package com.incountry.residence.sdk.dto.search;\n+\n+import com.incountry.residence.sdk.dto.search.internal.Filter;\n+import com.incountry.residence.sdk.dto.search.internal.NullFilter;\n+import com.incountry.residence.sdk.dto.search.internal.NumberFilter;\n+import com.incountry.residence.sdk.dto.search.internal.RangeFilter;\n+import com.incountry.residence.sdk.dto.search.internal.StringFilter;\n+import com.incountry.residence.sdk.dto.search.internal.SortingParam;\n+import com.incountry.residence.sdk.tools.ValidationHelper;\n+import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Container for filters to searching of stored data by param values\n+ */\n+public class FindFilter {\n+    private static final Logger LOG = LogManager.getLogger(FindFilter.class);\n+    private static final ValidationHelper HELPER = new ValidationHelper(LOG);\n+\n+    public static final int MAX_LIMIT = 100;\n+    public static final int DEFAULT_OFFSET = 0;\n+    public static final int SEARCH_KEYS_MIN_LENGTH = 3;\n+    public static final int SEARCH_KEYS_MAX_LENGTH = 200;\n+\n+    private static final String MSG_ERR_MAX_LIMIT = \"Max limit is \" + MAX_LIMIT + \". Use offset to populate more\";\n+    private static final String MSG_ERR_NEGATIVE_LIMIT = \"Limit must be more than 1\";\n+    private static final String MSG_ERR_NEGATIVE_OFFSET = \"Offset must be more than 0\";\n+    private static final String MSG_ERR_SEARCH_KEYS_COMBINATION = \"SEARCH_KEYS cannot be used in conjunction with regular KEY1...KEY20 lookup\";\n+    private static final String MSG_ERR_SEARCH_KEYS_LEN = \"SEARCH_KEYS should contain at least \" + SEARCH_KEYS_MIN_LENGTH +\n+            \" characters and be not longer than \" + SEARCH_KEYS_MAX_LENGTH;\n+    private static final String MSG_ERR_NULL_SORT_FIELD = \"Sorting field is null\";\n+    private static final String MSG_ERR_NULL_SORT_ORDER = \"Sorting order is null\";\n+    private static final String MSG_ERR_DUPL_SORT_FIELD = \"Field %s is already in sorting list\";\n+\n+    private static final List<StringField> NON_HASHED_KEY_LIST = Arrays.asList(\n+            StringField.KEY1, StringField.KEY2, StringField.KEY3, StringField.KEY4, StringField.KEY5,\n+            StringField.KEY6, StringField.KEY7, StringField.KEY8, StringField.KEY9, StringField.KEY10,\n+            StringField.KEY11, StringField.KEY12, StringField.KEY13, StringField.KEY14, StringField.KEY15,\n+            StringField.KEY16, StringField.KEY17, StringField.KEY18, StringField.KEY19, StringField.KEY20\n+    );\n+\n+    private int limit = MAX_LIMIT;\n+    private int offset = DEFAULT_OFFSET;\n+    private final Map<StringField, Filter> stringFilters = new EnumMap<>(StringField.class);\n+    private final Map<NumberField, Filter> numberFilters = new EnumMap<>(NumberField.class);\n+    private final List<SortingParam> sortingList = new ArrayList<>();\n+    private String searchKeys;\n+\n+    public FindFilter clear() {\n+        stringFilters.clear();\n+        numberFilters.clear();\n+        sortingList.clear();\n+        limit = MAX_LIMIT;\n+        offset = DEFAULT_OFFSET;\n+        searchKeys = null;\n+        return this;\n+    }\n+\n+    public FindFilter limitAndOffset(int limit, int offset) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, limit > MAX_LIMIT, MSG_ERR_MAX_LIMIT);\n+        HELPER.check(StorageClientException.class, limit < 1, MSG_ERR_NEGATIVE_LIMIT);\n+        HELPER.check(StorageClientException.class, offset < 0, MSG_ERR_NEGATIVE_OFFSET);\n+        this.limit = limit;\n+        this.offset = offset;\n+        return this;\n+    }\n+\n+    public FindFilter keyEq(StringField field, String... keys) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new StringFilter(keys));\n+        return this;\n+    }\n+\n+    public FindFilter keyEq(NumberField field, Long... keys) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(keys, null));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNull(StringField field) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new NullFilter(true));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNull(NumberField field) {\n+        numberFilters.put(field, new NullFilter(true));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNotNull(StringField field) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new NullFilter(false));\n+        return this;\n+    }\n+\n+    public FindFilter keyIsNotNull(NumberField field) {\n+        numberFilters.put(field, new NullFilter(false));\n+        return this;\n+    }\n+\n+    public FindFilter keyNotEq(StringField field, String... keys) throws StorageClientException {\n+        validateStringFilters(field, searchKeys);\n+        stringFilters.put(field, new StringFilter(keys, true));\n+        return this;\n+    }\n+\n+    public FindFilter keyNotEq(NumberField field, Long... keys) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(keys, Filter.OPERATOR_NOT));\n+        return this;\n+    }\n+\n+    public FindFilter keyGreater(NumberField field, long key) throws StorageClientException {\n+        return keyGreater(field, key, false);\n+    }\n+\n+    public FindFilter keyGreater(NumberField field, long key, boolean includingValue) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(new Long[]{key}, includingValue ? Filter.OPERATOR_GREATER_OR_EQUALS : Filter.OPERATOR_GREATER));\n+        return this;\n+    }\n+\n+    public FindFilter keyLess(NumberField field, long key) throws StorageClientException {\n+        return keyLess(field, key, false);\n+    }\n+\n+    public FindFilter keyLess(NumberField field, long key, boolean includingValue) throws StorageClientException {\n+        numberFilters.put(field, new NumberFilter(new Long[]{key}, includingValue ? Filter.OPERATOR_LESS_OR_EQUALS : Filter.OPERATOR_LESS));\n+        return this;\n+    }\n+\n+    public FindFilter keyBetween(NumberField field, long fromValue, long toValue) throws StorageClientException {\n+        return keyBetween(field, fromValue, true, toValue, true);\n+    }\n+\n+    public FindFilter keyBetween(NumberField field, long fromValue, boolean includeFrom, long toValue, boolean includeTo) throws StorageClientException {\n+        numberFilters.put(field, new RangeFilter(fromValue,\n+                includeFrom ? Filter.OPERATOR_GREATER_OR_EQUALS : Filter.OPERATOR_GREATER,\n+                toValue,\n+                includeTo ? Filter.OPERATOR_LESS_OR_EQUALS : Filter.OPERATOR_LESS));\n+        return this;\n+    }\n+\n+    public FindFilter searchKeysLike(String value) throws StorageClientException {\n+        if (value != null) {\n+            boolean invalidLength = value.length() < SEARCH_KEYS_MIN_LENGTH || value.length() > SEARCH_KEYS_MAX_LENGTH;\n+            HELPER.check(StorageClientException.class, invalidLength, MSG_ERR_SEARCH_KEYS_LEN);\n+            validateStringFilters(null, value);\n+        }\n+        searchKeys = value;\n+        return this;\n+    }\n+\n+    public FindFilter sortBy(SortField field, SortOrder order) throws StorageClientException {\n+        HELPER.check(StorageClientException.class, field == null, MSG_ERR_NULL_SORT_FIELD);\n+        HELPER.check(StorageClientException.class, order == null, MSG_ERR_NULL_SORT_ORDER);\n+        for (SortingParam param : sortingList) {\n+            boolean alreadyInSorting = param.getField().equals(field);\n+            HELPER.check(StorageClientException.class, alreadyInSorting, MSG_ERR_DUPL_SORT_FIELD, field);\n+        }\n+        sortingList.add(new SortingParam(field, order));\n+        return this;\n+    }\n+\n+    private void validateStringFilters(StringField field, String searchKeysValue) throws StorageClientException {\n+        if (searchKeysValue == null) {\n+            return;\n+        }\n+        if (field != null) {\n+            HELPER.check(StorageClientException.class, NON_HASHED_KEY_LIST.contains(field), MSG_ERR_SEARCH_KEYS_COMBINATION);\n+            return;\n+        }\n+        for (StringField key : stringFilters.keySet()) {\n+            HELPER.check(StorageClientException.class, NON_HASHED_KEY_LIST.contains(key), MSG_ERR_SEARCH_KEYS_COMBINATION);\n+        }\n+    }\n+\n+    public int getLimit() {\n+        return limit;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    public List<SortingParam> getSortingList() {\n+        return sortingList;\n+    }\n+\n+    public Map<StringField, Filter> getStringFilters() {\n+        return stringFilters;\n+    }\n+\n+    public Map<NumberField, Filter> getNumberFilters() {\n+        return numberFilters;\n+    }\n+\n+    public String getSearchKeys() {\n+        return searchKeys;\n+    }\n+\n+    public FindFilter copy() {\n+        FindFilter newFilter = new FindFilter();\n+        newFilter.limit = limit;\n+        newFilter.offset = offset;\n+        newFilter.searchKeys = searchKeys;\n+        newFilter.sortingList.addAll(sortingList);\n+        newFilter.numberFilters.putAll(numberFilters);\n+        newFilter.stringFilters.putAll(stringFilters);\n+        return newFilter;\n+    }\n+\n+    public static boolean nonHashedKeysListContains(StringField key) {\n+        return NON_HASHED_KEY_LIST.contains(key);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"FindFilter{\" +\n+                \"stringFilters=\" + stringFilters +\n+                \", numberFilters=\" + numberFilters +\n+                \", searchKeys=\" + searchKeys +\n+                \", limit=\" + limit +\n+                \", offset=\" + offset +\n+                \", sorting=\" + sortingList +\n+                '}';\n+    }\n+}\n+"
  },
  {
    "sha": "990d3bbda9c973bcb76714cc5ce6f065e4583aec",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "status": "removed",
    "additions": 0,
    "deletions": 211,
    "changes": 211,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/FindFilterBuilder.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,211 +0,0 @@\n-package com.incountry.residence.sdk.dto.search;\n-\n-import com.incountry.residence.sdk.dto.search.internal.FilterNumberParam;\n-import com.incountry.residence.sdk.dto.search.internal.FilterStringParam;\n-import com.incountry.residence.sdk.dto.search.internal.FindFilter;\n-import com.incountry.residence.sdk.dto.search.internal.FilterNullParam;\n-import com.incountry.residence.sdk.dto.search.internal.SortingParam;\n-import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-\n-/**\n- * Builder for cosy creation of FindFilter\n- */\n-public class FindFilterBuilder {\n-\n-    private static final Logger LOG = LogManager.getLogger(FindFilterBuilder.class);\n-\n-    private static final String MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS = \"SEARCH_KEYS cannot be used in conjunction with regular KEY1...KEY20 lookup\";\n-    private static final String MSG_ERR_SEARCH_KEYS_LEN = \"SEARCH_KEYS should contain at least 3 characters and be not longer than 200\";\n-    private static final String MSG_ERR_SEARCH_KEYS_ADD = \"SEARCH_KEYS can be used only via searchKeysLike method\";\n-    private static final String MSG_ERR_NULL_SORT_FIELD = \"Sorting field is null\";\n-    private static final String MSG_ERR_DUPL_SORT_FIELD = \"Field %s is already in sorting list\";\n-\n-    public static final String OPER_NOT = \"$not\";\n-    public static final String OPER_GT = \"$gt\";\n-    public static final String OPER_GTE = \"$gte\";\n-    public static final String OPER_LT = \"$lt\";\n-    public static final String OPER_LTE = \"$lte\";\n-\n-    private FindFilter filter;\n-    private static final List<StringField> SEARCHABLE_KEYS = new ArrayList<>();\n-\n-    static {\n-        SEARCHABLE_KEYS.add(StringField.KEY1);\n-        SEARCHABLE_KEYS.add(StringField.KEY2);\n-        SEARCHABLE_KEYS.add(StringField.KEY3);\n-        SEARCHABLE_KEYS.add(StringField.KEY4);\n-        SEARCHABLE_KEYS.add(StringField.KEY5);\n-        SEARCHABLE_KEYS.add(StringField.KEY6);\n-        SEARCHABLE_KEYS.add(StringField.KEY7);\n-        SEARCHABLE_KEYS.add(StringField.KEY8);\n-        SEARCHABLE_KEYS.add(StringField.KEY9);\n-        SEARCHABLE_KEYS.add(StringField.KEY10);\n-        SEARCHABLE_KEYS.add(StringField.KEY11);\n-        SEARCHABLE_KEYS.add(StringField.KEY12);\n-        SEARCHABLE_KEYS.add(StringField.KEY13);\n-        SEARCHABLE_KEYS.add(StringField.KEY14);\n-        SEARCHABLE_KEYS.add(StringField.KEY15);\n-        SEARCHABLE_KEYS.add(StringField.KEY16);\n-        SEARCHABLE_KEYS.add(StringField.KEY17);\n-        SEARCHABLE_KEYS.add(StringField.KEY18);\n-        SEARCHABLE_KEYS.add(StringField.KEY19);\n-        SEARCHABLE_KEYS.add(StringField.KEY20);\n-    }\n-\n-    public static FindFilterBuilder create() {\n-        return new FindFilterBuilder();\n-    }\n-\n-    private FindFilterBuilder() {\n-        filter = new FindFilter();\n-    }\n-\n-    private FindFilterBuilder(FindFilter filter) {\n-        this.filter = filter;\n-    }\n-\n-    public FindFilter build() throws StorageClientException {\n-        return filter.copy();\n-    }\n-\n-    public FindFilterBuilder clear() {\n-        filter = new FindFilter();\n-        return this;\n-    }\n-\n-    public FindFilterBuilder limitAndOffset(int limit, int offset) throws StorageClientException {\n-        filter.setLimit(limit);\n-        filter.setOffset(offset);\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyEq(StringField field, String... keys) throws StorageClientException {\n-        validateStringFilters(field);\n-        filter.setFilter(field, new FilterStringParam(keys));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyEq(NumberField field, Long... keys) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(keys));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNull(StringField field) {\n-        filter.setFilter(field, new FilterNullParam(true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNull(NumberField field) {\n-        filter.setFilter(field, new FilterNullParam(true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNotNull(StringField field) {\n-        filter.setFilter(field, new FilterNullParam(false));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyIsNotNull(NumberField field) {\n-        filter.setFilter(field, new FilterNullParam(false));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyNotEq(StringField field, String... keys) throws StorageClientException {\n-        validateStringFilters(field);\n-        filter.setFilter(field, new FilterStringParam(keys, true));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyGT(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_GT, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyGTE(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_GTE, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyLT(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_LT, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyLTE(NumberField field, long key) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(OPER_LTE, key));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder keyBetween(NumberField field, long fromValue, long toValue) throws StorageClientException {\n-        return keyBetween(field, fromValue, true, toValue, true);\n-    }\n-\n-    public FindFilterBuilder keyBetween(NumberField field, long fromValue, boolean includeFrom, long toValue, boolean includeTo) throws StorageClientException {\n-        filter.setFilter(field, new FilterNumberParam(includeFrom ? OPER_GTE : OPER_GT,\n-                fromValue,\n-                includeTo ? OPER_LTE : OPER_LT,\n-                toValue));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder searchKeysLike(String value) throws StorageClientException {\n-        Set<RecordField> searchKeys = filter.getFilterMap().keySet();\n-        for (StringField key : SEARCHABLE_KEYS) {\n-            if (searchKeys.contains(key)) {\n-                LOG.error(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-                throw new StorageClientException(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-            }\n-        }\n-        if (value.length() < 3 || value.length() > 200) {\n-            LOG.error(MSG_ERR_SEARCH_KEYS_LEN);\n-            throw new StorageClientException(MSG_ERR_SEARCH_KEYS_LEN);\n-        }\n-        filter.setFilter(StringField.SEARCH_KEYS, new FilterStringParam(new String[]{value}));\n-        return this;\n-    }\n-\n-    public FindFilterBuilder sortBy(SortField field, SortOrder order) throws StorageClientException {\n-        if (field == null) {\n-            LOG.error(MSG_ERR_NULL_SORT_FIELD);\n-            throw new StorageClientException(MSG_ERR_NULL_SORT_FIELD);\n-        }\n-        for (SortingParam param : filter.getSortingList()) {\n-            if (param.getField().equals(field)) {\n-                String message = String.format(MSG_ERR_DUPL_SORT_FIELD, field);\n-                LOG.error(message);\n-                throw new StorageClientException(message);\n-            }\n-        }\n-        filter.addSorting(new SortingParam(field, order));\n-        return this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"FindFilterBuilder{\" +\n-                \"filter=\" + filter +\n-                '}';\n-    }\n-\n-    public FindFilterBuilder copy() throws StorageClientException {\n-        return new FindFilterBuilder(this.filter.copy());\n-    }\n-\n-    private void validateStringFilters(StringField field) throws StorageClientException {\n-        if (field == StringField.SEARCH_KEYS) {\n-            LOG.error(MSG_ERR_SEARCH_KEYS_ADD);\n-            throw new StorageClientException(MSG_ERR_SEARCH_KEYS_ADD);\n-        }\n-        if (SEARCHABLE_KEYS.contains(field)\n-                && filter.getFilterMap().containsKey(StringField.SEARCH_KEYS)) {\n-            LOG.error(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-            throw new StorageClientException(MSG_ERR_KEY1_KEY10_AND_SEARCH_KEYS);\n-        }\n-    }\n-}"
  },
  {
    "sha": "64a89b16bfb89436828a1e89038fbc6d2759c1a7",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/NumberField.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,6 +1,6 @@\n package com.incountry.residence.sdk.dto.search;\n \n-public enum NumberField implements RecordField {\n+public enum NumberField {\n     RANGE_KEY1,\n     RANGE_KEY2,\n     RANGE_KEY3,\n@@ -10,5 +10,6 @@\n     RANGE_KEY7,\n     RANGE_KEY8,\n     RANGE_KEY9,\n-    RANGE_KEY10\n+    RANGE_KEY10,\n+    VERSION\n }"
  },
  {
    "sha": "49ab86e5e0d1ec6c3199ff0d52255bcdfa2f79ef",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/RecordField.java",
    "status": "removed",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/RecordField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/RecordField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/RecordField.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,4 +0,0 @@\n-package com.incountry.residence.sdk.dto.search;\n-\n-public interface RecordField {\n-}"
  },
  {
    "sha": "38d92c2dcb28ba1038d67bdd1a3e45663268ad94",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "status": "modified",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/StringField.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -1,7 +1,6 @@\n package com.incountry.residence.sdk.dto.search;\n \n-public enum StringField implements RecordField {\n-    VERSION,\n+public enum StringField {\n     RECORD_KEY,\n     PARENT_KEY,\n     KEY1,\n@@ -26,6 +25,5 @@\n     KEY20,\n     PROFILE_KEY,\n     SERVICE_KEY1,\n-    SERVICE_KEY2,\n-    SEARCH_KEYS\n+    SERVICE_KEY2\n }"
  },
  {
    "sha": "f8982501478897acd0a109f4ba4cca9c123a94e8",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/incountry/sdk-java/blob/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/c268f33f19863c73bbbecfa1ae39a0b8ba7f662c/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/Filter.java?ref=c268f33f19863c73bbbecfa1ae39a0b8ba7f662c",
    "patch": "@@ -0,0 +1,11 @@\n+package com.incountry.residence.sdk.dto.search.internal;\n+\n+public abstract class Filter {\n+    public static final String OPERATOR_NOT = \"$not\";\n+    public static final String OPERATOR_GREATER = \"$gt\";\n+    public static final String OPERATOR_GREATER_OR_EQUALS = \"$gte\";\n+    public static final String OPERATOR_LESS = \"$lt\";\n+    public static final String OPERATOR_LESS_OR_EQUALS = \"$lte\";\n+\n+    public abstract Object toTransferObject();\n+}"
  },
  {
    "sha": "3486d5484094eebab08e457f269a58cf3499ef3e",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNullParam.java",
    "status": "removed",
    "additions": 0,
    "deletions": 14,
    "changes": 14,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNullParam.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNullParam.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNullParam.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,14 +0,0 @@\n-package com.incountry.residence.sdk.dto.search.internal;\n-\n-public class FilterNullParam {\n-\n-    private final boolean nullable;\n-\n-    public FilterNullParam(boolean isNull) {\n-        nullable = isNull;\n-    }\n-\n-    public boolean isNullable() {\n-        return nullable;\n-    }\n-}"
  },
  {
    "sha": "138e8bbefe061dc932cb166712a6775fdc0434ab",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNumberParam.java",
    "status": "removed",
    "additions": 0,
    "deletions": 119,
    "changes": 119,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNumberParam.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNumberParam.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/FilterNumberParam.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,119 +0,0 @@\n-package com.incountry.residence.sdk.dto.search.internal;\n-\n-import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import org.apache.logging.log4j.Logger;\n-import org.apache.logging.log4j.LogManager;\n-\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-\n-import static com.incountry.residence.sdk.dto.search.FindFilterBuilder.OPER_GT;\n-import static com.incountry.residence.sdk.dto.search.FindFilterBuilder.OPER_GTE;\n-import static com.incountry.residence.sdk.dto.search.FindFilterBuilder.OPER_LT;\n-import static com.incountry.residence.sdk.dto.search.FindFilterBuilder.OPER_LTE;\n-import static com.incountry.residence.sdk.dto.search.FindFilterBuilder.OPER_NOT;\n-\n-public class FilterNumberParam {\n-\n-    private static final Logger LOG = LogManager.getLogger(FilterNumberParam.class);\n-\n-    private static final String ERR_NULL_VALUE = \"FilterNumberParam values can't be null\";\n-    private static final String ERR_OPER1_RESTR = String.format(\"Operator1 in range filter can by only %s or %s\", OPER_GT, OPER_GTE);\n-    private static final String ERR_OPER2_RESTR = String.format(\"Operator2 in range filter can by only %s or %s\", OPER_LT, OPER_LTE);\n-    private static final String ERR_RANGE_RESTR = \"Value1 in range filter can by only less or equals value2\";\n-    private static final String ERR_CONDITION_RESTR = String.format(\"Operator in number filter can by only in [%s,%s,%s,%s,%s]\",\n-            OPER_LT, OPER_LTE, OPER_GT, OPER_GTE, OPER_NOT);\n-\n-    private final Long[] values;\n-    private final String operator1;\n-    private final String operator2;\n-\n-    public FilterNumberParam(Long[] values) throws StorageClientException {\n-        if (values == null || values.length == 0 || (Stream.of(values).anyMatch(Objects::isNull))) {\n-            LOG.error(ERR_NULL_VALUE);\n-            throw new StorageClientException(ERR_NULL_VALUE);\n-        }\n-        this.values = Arrays.copyOf(values, values.length);\n-        this.operator1 = null;\n-        this.operator2 = null;\n-    }\n-\n-    public FilterNumberParam(String operator, Long value) throws StorageClientException {\n-        if (operator == null || notIn(operator, OPER_GT, OPER_GTE, OPER_NOT, OPER_LT, OPER_LTE)) {\n-            LOG.error(ERR_CONDITION_RESTR);\n-            throw new StorageClientException(ERR_CONDITION_RESTR);\n-        }\n-        if (value == null) {\n-            LOG.error(ERR_NULL_VALUE);\n-            throw new StorageClientException(ERR_NULL_VALUE);\n-        }\n-        this.values = new Long[]{value};\n-        this.operator1 = operator;\n-        this.operator2 = null;\n-    }\n-\n-    public FilterNumberParam(String operator1, Long value1, String operator2, Long value2) throws StorageClientException {\n-        if (operator1 == null || notIn(operator1, OPER_GT, OPER_GTE)) {\n-            LOG.error(ERR_OPER1_RESTR);\n-            throw new StorageClientException(ERR_OPER1_RESTR);\n-        }\n-        if (operator2 == null || (!OPER_LT.equals(operator2)) && !OPER_LTE.equals(operator2)) {\n-            LOG.error(ERR_OPER2_RESTR);\n-            throw new StorageClientException(ERR_OPER2_RESTR);\n-        }\n-        if (value1 == null || value2 == null) {\n-            LOG.error(ERR_NULL_VALUE);\n-            throw new StorageClientException(ERR_NULL_VALUE);\n-        }\n-        if (value1 > value2) {\n-            LOG.error(ERR_RANGE_RESTR);\n-            throw new StorageClientException(ERR_RANGE_RESTR);\n-        }\n-        this.values = new Long[]{value1, value2};\n-        this.operator1 = operator1;\n-        this.operator2 = operator2;\n-    }\n-\n-\n-    private boolean notIn(String operator, String... permitted) {\n-        for (String value : permitted) {\n-            if (value.equals(operator)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public boolean isConditional() {\n-        return operator1 != null;\n-    }\n-\n-    public boolean isRange() {\n-        return operator2 != null && operator1 != null;\n-    }\n-\n-    public Long[] getValues() {\n-        if (values != null && values.length > 0) {\n-            return Arrays.copyOf(values, values.length);\n-        }\n-        return new Long[]{};\n-    }\n-\n-    public String getOperator1() {\n-        return operator1;\n-    }\n-\n-    public String getOperator2() {\n-        return operator2;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"FilterRangeParam{\" +\n-                \"values=\" + Arrays.toString(values) +\n-                \", operator1='\" + operator1 + '\\'' +\n-                \", operator2='\" + operator2 + '\\'' +\n-                '}';\n-    }\n-}"
  },
  {
    "sha": "13f32aa6187106e84c7319c771c0d8981f84c7a3",
    "filename": "src/main/java/com/incountry/residence/sdk/dto/search/internal/FindFilter.java",
    "status": "removed",
    "additions": 0,
    "deletions": 95,
    "changes": 95,
    "blob_url": "https://github.com/incountry/sdk-java/blob/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FindFilter.java",
    "raw_url": "https://github.com/incountry/sdk-java/raw/1a21b73113a9bb6129cf594c8d4c554944e48eb7/src/main/java/com/incountry/residence/sdk/dto/search/internal/FindFilter.java",
    "contents_url": "https://api.github.com/repos/incountry/sdk-java/contents/src/main/java/com/incountry/residence/sdk/dto/search/internal/FindFilter.java?ref=1a21b73113a9bb6129cf594c8d4c554944e48eb7",
    "patch": "@@ -1,95 +0,0 @@\n-package com.incountry.residence.sdk.dto.search.internal;\n-\n-import com.incountry.residence.sdk.dto.search.RecordField;\n-import com.incountry.residence.sdk.tools.exceptions.StorageClientException;\n-import org.apache.logging.log4j.Logger;\n-import org.apache.logging.log4j.LogManager;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * Container for filters to searching of stored data by param values\n- */\n-public class FindFilter {\n-    private static final Logger LOG = LogManager.getLogger(FindFilter.class);\n-\n-    public static final int MAX_LIMIT = 100;\n-    public static final int DEFAULT_OFFSET = 0;\n-    private static final String MSG_MAX_LIMIT = \"Max limit is %d. Use offset to populate more\";\n-    private static final String MSG_NEG_LIMIT = \"Limit must be more than 1\";\n-    private static final String MSG_NEG_OFFSET = \"Offset must be more than 0\";\n-\n-    private final Map<RecordField, Object> filterMap = new HashMap<>();\n-    private final List<SortingParam> sortingList = new ArrayList<>();\n-\n-    private int limit = MAX_LIMIT;\n-    private int offset = DEFAULT_OFFSET;\n-\n-    public void setLimit(int limit) throws StorageClientException {\n-        if (limit > MAX_LIMIT) {\n-            String message = String.format(MSG_MAX_LIMIT, MAX_LIMIT);\n-            LOG.error(message);\n-            throw new StorageClientException(message);\n-        }\n-        if (limit < 1) {\n-            LOG.error(MSG_NEG_LIMIT);\n-            throw new StorageClientException(MSG_NEG_LIMIT);\n-        }\n-        this.limit = limit;\n-    }\n-\n-    public void setOffset(int offset) throws StorageClientException {\n-        if (offset < 0) {\n-            LOG.error(MSG_NEG_OFFSET);\n-            throw new StorageClientException(MSG_NEG_OFFSET);\n-        }\n-        this.offset = offset;\n-    }\n-\n-    public int getLimit() {\n-        return limit;\n-    }\n-\n-    public int getOffset() {\n-        return offset;\n-    }\n-\n-    public <T extends Enum<T> & RecordField> void setFilter(T field, Object param) {\n-        filterMap.put(field, param);\n-    }\n-\n-    public void addSorting(SortingParam param) {\n-        sortingList.add(param);\n-    }\n-\n-    public Map<RecordField, Object> getFilterMap() {\n-        return filterMap;\n-    }\n-\n-    public List<SortingParam> getSortingList() {\n-        return sortingList;\n-    }\n-\n-    public FindFilter copy() throws StorageClientException {\n-        FindFilter clone = new FindFilter();\n-        clone.filterMap.putAll(this.filterMap);\n-        clone.setOffset(this.getOffset());\n-        clone.setLimit(this.getLimit());\n-        clone.sortingList.addAll(this.sortingList);\n-        return clone;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"FindFilter{\" +\n-                \"filterMap=\" + filterMap +\n-                \", limit=\" + limit +\n-                \", offset=\" + offset +\n-                \", sorting=\" + sortingList +\n-                '}';\n-    }\n-}\n-"
  }
]
