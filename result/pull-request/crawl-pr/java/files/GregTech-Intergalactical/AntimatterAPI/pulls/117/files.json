[
  {
    "sha": "50144f9e847650316604ad94daa269d9f917689d",
    "filename": "src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineEnergyHandler.java",
    "status": "added",
    "additions": 123,
    "deletions": 0,
    "changes": 123,
    "blob_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/blob/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineEnergyHandler.java",
    "raw_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/raw/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineEnergyHandler.java",
    "contents_url": "https://api.github.com/repos/GregTech-Intergalactical/AntimatterAPI/contents/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineEnergyHandler.java?ref=a723721e5aba98350aaaf368a53e48085feffab0",
    "patch": "@@ -0,0 +1,123 @@\n+package muramasa.antimatter.capability.machine;\n+\n+import muramasa.antimatter.capability.IEnergyHandler;\n+import muramasa.antimatter.machine.Tier;\n+import muramasa.antimatter.tile.TileEntityMachine;\n+import muramasa.antimatter.tile.multi.TileEntityBasicMultiMachine;\n+import muramasa.antimatter.tile.multi.TileEntityMultiMachine;\n+import tesseract.api.gt.IGTNode;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class BasicMultiMachineEnergyHandler extends MachineEnergyHandler<TileEntityBasicMultiMachine> {\n+\n+    protected IEnergyHandler[] inputs;//= new IEnergyHandler[0];\n+    protected IEnergyHandler[] outputs; //= new IEnergyHandler[0];\n+\n+    protected long cachedCapacity;\n+\n+    public BasicMultiMachineEnergyHandler(TileEntityMachine tile, int amps, boolean generator) {\n+        super((TileEntityBasicMultiMachine)tile, amps, generator);\n+    }\n+\n+    public void onStructureBuild() {\n+        cacheInputs();\n+        cacheOutputs();\n+\n+        //Amps in, amps out etc for this handler does not matter.\n+        //all handlers should be of same voltage.\n+        IEnergyHandler handler = anyHandler();\n+        if (handler != null) {\n+            this.voltageIn = handler.getInputVoltage();\n+            this.voltageOut = handler.getOutputVoltage();\n+        }\n+        this.cachedCapacity = super.getCapacity() + Arrays.stream(inputs).mapToLong(IGTNode::getCapacity).sum() + Arrays.stream(outputs).mapToLong(IGTNode::getCapacity).sum();\n+    }\n+\n+    private void cacheInputs() {\n+        List<IEnergyHandler> list = tile.getComponents(\"hatch_energy\").stream().filter(t -> t.getEnergyHandler().isPresent()).map(t -> t.getEnergyHandler().get()).collect(Collectors.toList());\n+        list.add(this);\n+        this.inputs = list.toArray(new IEnergyHandler[0]);\n+    }\n+\n+    private void cacheOutputs() {\n+        List<IEnergyHandler> list = tile.getComponents(\"hatch_dynamo\").stream().filter(t -> t.getEnergyHandler().isPresent()).map(t -> t.getEnergyHandler().get()).collect(Collectors.toList());\n+        list.add(this);\n+        this.outputs = list.toArray(new IEnergyHandler[0]);\n+    }\n+\n+    private IEnergyHandler anyHandler() {\n+        if (inputs != null && inputs.length > 0) {\n+            return inputs[0];\n+        }\n+        if (outputs != null && outputs.length > 0) {\n+            return outputs[0];\n+        }\n+        return null;\n+    }\n+\n+    public void invalidate() {\n+        this.cachedCapacity = super.getCapacity();\n+        this.inputs = null;\n+        this.outputs = null;\n+    }\n+\n+    @Override\n+    public long insert(long maxReceive, boolean simulate) {\n+        if (outputs == null) cacheOutputs();\n+        long inserted = super.insert(maxReceive, simulate);\n+        if (inserted == 0 && outputs != null) {\n+            for (IEnergyHandler handler : outputs) {\n+                inserted += handler.insert(maxReceive-inserted, simulate);\n+                //Output voltage as a dynamo outputs energy.\n+                if (!simulate && inserted > handler.getOutputVoltage()) {\n+                    System.out.println(\"BOOM\");\n+                }\n+                if (inserted >= maxReceive)\n+                    return inserted;\n+            }\n+        }\n+        return inserted;\n+    }\n+\n+    @Override\n+    public long getEnergy() {\n+        return super.getEnergy() +(inputs == null ? 0 : Arrays.stream(inputs).mapToLong(IGTNode::getEnergy).sum() + (outputs == null ? 0 : Arrays.stream(outputs).mapToLong(IGTNode::getEnergy).sum()));\n+    }\n+\n+    @Override\n+    public long getCapacity() {\n+        return cachedCapacity;\n+    }\n+\n+    @Override\n+    public boolean canOutput() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean canInput() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long extract(long maxReceive, boolean simulate) {\n+        if (inputs == null) cacheInputs();\n+        long extracted = super.extract(maxReceive, simulate);\n+        if (extracted == 0 && inputs != null) {\n+            for (IEnergyHandler handler : inputs) {\n+                extracted += handler.extract(maxReceive-extracted, simulate);\n+                if (extracted >= maxReceive)\n+                    return extracted;\n+            }\n+        }\n+        return extracted;\n+    }\n+\n+    public Tier getAccumulatedPower() {\n+        if (inputs == null) return Tier.ULV;\n+        return Tier.getTier((int)(Arrays.stream(inputs).mapToLong(t -> (long) t.getInputVoltage() *t.getInputAmperage()).sum()));\n+    }\n+}"
  },
  {
    "sha": "069c237874ecd7937a45499ef869a97ef2eaaaf0",
    "filename": "src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineFluidHandler.java",
    "status": "added",
    "additions": 133,
    "deletions": 0,
    "changes": 133,
    "blob_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/blob/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineFluidHandler.java",
    "raw_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/raw/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineFluidHandler.java",
    "contents_url": "https://api.github.com/repos/GregTech-Intergalactical/AntimatterAPI/contents/src/main/java/muramasa/antimatter/capability/machine/BasicMultiMachineFluidHandler.java?ref=a723721e5aba98350aaaf368a53e48085feffab0",
    "patch": "@@ -0,0 +1,133 @@\n+package muramasa.antimatter.capability.machine;\n+\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import muramasa.antimatter.capability.IComponentHandler;\n+import muramasa.antimatter.capability.fluid.FluidTanks;\n+import muramasa.antimatter.tile.multi.TileEntityBasicMultiMachine;\n+import muramasa.antimatter.tile.multi.TileEntityMultiMachine;\n+import muramasa.antimatter.util.LazyHolder;\n+import net.minecraftforge.fluids.FluidStack;\n+import net.minecraftforge.fluids.capability.templates.FluidTank;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class BasicMultiMachineFluidHandler extends MachineFluidHandler<TileEntityBasicMultiMachine> {\n+\n+    MachineFluidHandler<?>[] inputs = new MachineFluidHandler[0];\n+    MachineFluidHandler<?>[] outputs = new MachineFluidHandler[0];\n+\n+    protected Int2ObjectMap<MachineFluidHandler<?>> INPUT_TO_HANDLER = new Int2ObjectOpenHashMap<>();\n+    protected Object2IntMap<MachineFluidHandler<?>> INPUT_START = new Object2IntOpenHashMap<>();\n+    protected int INPUT_END;\n+    protected Int2ObjectMap<MachineFluidHandler<?>> OUTPUT_TO_HANDLER = new Int2ObjectOpenHashMap<>();\n+    protected Object2IntMap<MachineFluidHandler<?>> OUTPUT_START = new Object2IntOpenHashMap<>();\n+    protected MachineFluidHandler<?> DUMMY_INPUT;\n+    protected MachineFluidHandler<?> DUMMY_OUTPUT;\n+\n+    public BasicMultiMachineFluidHandler(TileEntityBasicMultiMachine tile) {\n+        super(tile);\n+        DUMMY_INPUT = new DummyInputHandler(tile);\n+        DUMMY_OUTPUT = new DummyOutputHandler(tile);\n+    }\n+\n+    protected void cacheInputs() {\n+        List<MachineFluidHandler<?>> list = tile.getComponents(\"hatch_fluid_input\").stream().map(IComponentHandler::getFluidHandler).filter(LazyHolder::isPresent).map(LazyHolder::get).collect(Collectors.toList());\n+        list.add(DUMMY_INPUT);\n+        inputs = list.toArray(new MachineFluidHandler<?>[0]);//this::allocateExtraSize);\n+        // handlers[handlers.length-1] = this.inputWrapper;\n+        INPUT_TO_HANDLER.clear();\n+        INPUT_START.clear();\n+        int i = 0;\n+        for (MachineFluidHandler<?> input : inputs) {\n+            for (int j = 0; j < input.getTanks(); j++) {\n+                INPUT_TO_HANDLER.put(j+i, input);\n+                if (j == 0) INPUT_START.put(input,i);\n+            }\n+            i += input.getTanks();\n+        }\n+        INPUT_END = i;\n+    }\n+\n+    protected void cacheOutputs() {\n+        List<MachineFluidHandler<?>> list = tile.getComponents(\"hatch_fluid_output\").stream().map(IComponentHandler::getFluidHandler).filter(LazyHolder::isPresent).map(LazyHolder::get).collect(Collectors.toList());\n+        list.add(DUMMY_OUTPUT);\n+        outputs = list.toArray(new MachineFluidHandler<?>[0]);//this::allocateExtraSize);\n+        // handlers[handlers.length-1] = this.inputWrapper;\n+        OUTPUT_TO_HANDLER.clear();\n+        OUTPUT_START.clear();\n+        int i = 0;\n+        for (MachineFluidHandler<?> output : outputs) {\n+            for (int j = 0; j < output.getTanks(); j++) {\n+                OUTPUT_TO_HANDLER.put(j+i, output);\n+                if (j == 0) OUTPUT_START.put(output,i);\n+            }\n+            i += output.getTanks();\n+        }\n+    }\n+\n+    //TODO: Remove gettanks() != null as this is called twice.\n+    @Nullable\n+    @Override\n+    public FluidTanks getInputTanks() {\n+        //Input tanks output into the machine.\n+        return new FluidTanks(Arrays.stream(inputs).filter(t -> t.getInputTanks() != null).flatMap(t -> Arrays.stream(t.getInputTanks().getBackingTanks())).collect(Collectors.toList()));\n+    }\n+    //TODO: Remove gettanks() != null as this is called twice.\n+    @Nullable\n+    @Override\n+    public FluidTanks getOutputTanks() {\n+        return new FluidTanks(Arrays.stream(outputs).filter(t -> t.getOutputTanks() != null).flatMap(t -> Arrays.stream(t.getOutputTanks().getBackingTanks())).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public int getTanks() {\n+        return Arrays.stream(inputs).mapToInt(MachineFluidHandler::getTanks).sum() + Arrays.stream(outputs).mapToInt(MachineFluidHandler::getTanks).sum();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public FluidStack getFluidInTank(int tank) {\n+        if (tank < INPUT_END) return INPUT_TO_HANDLER.get(tank).getFluidInTank(tank - INPUT_START.get(INPUT_TO_HANDLER.get(tank)));\n+        return OUTPUT_TO_HANDLER.get(tank).getFluidInTank(tank - OUTPUT_START.get(OUTPUT_TO_HANDLER.get(tank)));\n+    }\n+\n+    public void invalidate() {\n+        inputs = new MachineFluidHandler[0];\n+        outputs = new MachineFluidHandler[0];\n+    }\n+\n+    public void onStructureBuild() {\n+        cacheInputs();\n+        cacheOutputs();\n+    }\n+\n+    public static class DummyInputHandler  extends MachineFluidHandler<TileEntityBasicMultiMachine> {\n+        public DummyInputHandler(TileEntityBasicMultiMachine tile) {\n+            super(tile);\n+        }\n+\n+        @Override\n+        public int getTanks() {\n+            return tanks.get(FluidDirection.INPUT).getTanks();\n+        }\n+    }\n+\n+    public static class DummyOutputHandler  extends MachineFluidHandler<TileEntityBasicMultiMachine> {\n+        public DummyOutputHandler(TileEntityBasicMultiMachine tile) {\n+            super(tile);\n+        }\n+\n+        @Override\n+        public int getTanks() {\n+            return tanks.get(FluidDirection.OUTPUT).getTanks();\n+        }\n+    }\n+}"
  },
  {
    "sha": "2ea24be4cf2ebbbdf07890f5b625ea36fecfbedb",
    "filename": "src/main/java/muramasa/antimatter/capability/machine/MultiMachineItemHandler.java",
    "status": "modified",
    "additions": 24,
    "deletions": 4,
    "changes": 28,
    "blob_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/blob/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/MultiMachineItemHandler.java",
    "raw_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/raw/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/capability/machine/MultiMachineItemHandler.java",
    "contents_url": "https://api.github.com/repos/GregTech-Intergalactical/AntimatterAPI/contents/src/main/java/muramasa/antimatter/capability/machine/MultiMachineItemHandler.java?ref=a723721e5aba98350aaaf368a53e48085feffab0",
    "patch": "@@ -1,12 +1,16 @@\n package muramasa.antimatter.capability.machine;\n \n+import muramasa.antimatter.machine.MachineFlag;\n import muramasa.antimatter.tile.TileEntityMachine;\n+import muramasa.antimatter.tile.multi.TileEntityBasicMultiMachine;\n import muramasa.antimatter.tile.multi.TileEntityMultiMachine;\n import muramasa.antimatter.util.LazyHolder;\n import net.minecraftforge.items.IItemHandlerModifiable;\n import net.minecraftforge.items.wrapper.CombinedInvWrapper;\n \n+import java.util.List;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n \n \n public class MultiMachineItemHandler extends MachineItemHandler<TileEntityMultiMachine> {\n@@ -21,7 +25,11 @@ public MultiMachineItemHandler(TileEntityMachine tile) {\n     @Override\n     public IItemHandlerModifiable getInputHandler() {\n         if (inputs.isPresent()) return inputs.get();\n-        IItemHandlerModifiable[] handlers = tile.getComponents(\"hatch_item_input\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getInputHandler)).map(LazyHolder::get).toArray(IItemHandlerModifiable[]::new);//this::allocateExtraSize);\n+        List<IItemHandlerModifiable> list = tile.getComponents(\"hatch_item_input\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getInputHandler)).map(LazyHolder::get).collect(Collectors.toList());\n+        if (tile instanceof TileEntityBasicMultiMachine){\n+            list.add(this.inventories.get(MachineFlag.ITEM_INPUT));\n+        }\n+        IItemHandlerModifiable[] handlers = list.toArray(new IItemHandlerModifiable[0]);//this::allocateExtraSize);\n        // handlers[handlers.length-1] = this.inputWrapper;\n         inputs = Optional.of(new CombinedInvWrapper(handlers));\n         return inputs.get();\n@@ -37,11 +45,19 @@ public void invalidate() {\n     }\n \n     public void onStructureBuild() {\n-        IItemHandlerModifiable[] handlers = tile.getComponents(\"hatch_item_input\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getInputHandler)).map(LazyHolder::get).toArray(IItemHandlerModifiable[]::new);//this::allocateExtraSize);\n+        List<IItemHandlerModifiable> list = tile.getComponents(\"hatch_item_input\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getInputHandler)).map(LazyHolder::get).collect(Collectors.toList());\n+        if (tile instanceof TileEntityBasicMultiMachine){\n+            list.add(this.inventories.get(MachineFlag.ITEM_INPUT));\n+        }\n+        IItemHandlerModifiable[] handlers = list.toArray(new IItemHandlerModifiable[0]);//this::allocateExtraSize);\n        // handlers[handlers.length-1] = this.inputWrapper;\n         inputs = Optional.of(new CombinedInvWrapper(handlers));\n \n-        IItemHandlerModifiable[] h = tile.getComponents(\"hatch_item_output\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getOutputHandler)).map(LazyHolder::get).toArray(IItemHandlerModifiable[]::new);//this::allocateExtraSize);\n+        List<IItemHandlerModifiable> l = tile.getComponents(\"output\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getOutputHandler)).map(LazyHolder::get).collect(Collectors.toList());\n+        if (tile instanceof TileEntityBasicMultiMachine){\n+            l.add(this.inventories.get(MachineFlag.ITEM_OUTPUT));\n+        }\n+        IItemHandlerModifiable[] h = l.toArray(new IItemHandlerModifiable[0]);//this::allocateExtraSize);\n         //h[handlers.length-1] = this.outputWrapper;\n         outputs = Optional.of(new CombinedInvWrapper(h));\n     }\n@@ -50,7 +66,11 @@ public void onStructureBuild() {\n     @Override\n     public IItemHandlerModifiable getOutputHandler() {\n         if (outputs.isPresent()) return outputs.get();\n-        IItemHandlerModifiable[] handlers = tile.getComponents(\"output\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getOutputHandler)).map(LazyHolder::get).toArray(IItemHandlerModifiable[]::new);//this::allocateExtraSize);\n+        List<IItemHandlerModifiable> list = tile.getComponents(\"output\").stream().filter(t -> t.getItemHandler().isPresent()).map(t -> t.getItemHandler().map(MachineItemHandler::getOutputHandler)).map(LazyHolder::get).collect(Collectors.toList());\n+        if (tile instanceof TileEntityBasicMultiMachine){\n+            list.add(this.inventories.get(MachineFlag.ITEM_OUTPUT));\n+        }\n+        IItemHandlerModifiable[] handlers = list.toArray(new IItemHandlerModifiable[0]);//this::allocateExtraSize);\n         //handlers[handlers.length-1] = this.outputWrapper;\n         outputs = Optional.of(new CombinedInvWrapper(handlers));\n         return outputs.get();"
  },
  {
    "sha": "943f7441ffe284cfca36aff66ce24758dc3eb80b",
    "filename": "src/main/java/muramasa/antimatter/tile/multi/TileEntityBasicMultiMachine.java",
    "status": "modified",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/blob/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/tile/multi/TileEntityBasicMultiMachine.java",
    "raw_url": "https://github.com/GregTech-Intergalactical/AntimatterAPI/raw/a723721e5aba98350aaaf368a53e48085feffab0/src/main/java/muramasa/antimatter/tile/multi/TileEntityBasicMultiMachine.java",
    "contents_url": "https://api.github.com/repos/GregTech-Intergalactical/AntimatterAPI/contents/src/main/java/muramasa/antimatter/tile/multi/TileEntityBasicMultiMachine.java?ref=a723721e5aba98350aaaf368a53e48085feffab0",
    "patch": "@@ -1,12 +1,23 @@\n package muramasa.antimatter.tile.multi;\n \n+import muramasa.antimatter.capability.machine.BasicMultiMachineEnergyHandler;\n+import muramasa.antimatter.capability.machine.BasicMultiMachineFluidHandler;\n+import muramasa.antimatter.capability.machine.MultiMachineEnergyHandler;\n+import muramasa.antimatter.capability.machine.MultiMachineFluidHandler;\n import muramasa.antimatter.machine.types.Machine;\n+import muramasa.antimatter.util.LazyHolder;\n+\n+import static muramasa.antimatter.machine.MachineFlag.ENERGY;\n+import static muramasa.antimatter.machine.MachineFlag.FLUID;\n+import static muramasa.antimatter.machine.MachineFlag.GENERATOR;\n \n /** Allows a MultiMachine to handle GUI recipes, instead of using Hatches **/\n public class TileEntityBasicMultiMachine extends TileEntityMultiMachine {\n \n     public TileEntityBasicMultiMachine(Machine<?> type) {\n         super(type);\n+        this.fluidHandler = type.has(FLUID) ? LazyHolder.of(() -> new BasicMultiMachineFluidHandler(this)) : LazyHolder.empty();\n+        this.energyHandler = type.has(ENERGY) ? LazyHolder.of(() -> new BasicMultiMachineEnergyHandler(this, type.amps(),type.has(GENERATOR))) : LazyHolder.empty();\n         // TODO\n         /*\n         recipeHandler.setup((tile, tag) -> new MultiMachineRecipeHandler<TileEntityMultiMachine>(tile, tag) {"
  }
]
