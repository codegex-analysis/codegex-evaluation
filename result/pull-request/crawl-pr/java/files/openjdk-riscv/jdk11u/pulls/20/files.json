[
  {
    "sha": "9e5d20fa81cac3367c8825562b162334f09539e1",
    "filename": "src/hotspot/os_cpu/linux_riscv32/atomic_linux_riscv32.hpp",
    "status": "added",
    "additions": 112,
    "deletions": 0,
    "changes": 112,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/atomic_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/atomic_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/atomic_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_ATOMIC_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_ATOMIC_LINUX_RISCV32_HPP\n+\n+#include \"vm_version_riscv32.hpp\"\n+\n+// Implementation of class atomic\n+\n+#define FULL_MEM_BARRIER  __sync_synchronize()\n+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformAdd\n+  : public Atomic::AddAndFetch<Atomic::PlatformAdd<byte_size> >\n+{\n+  template<typename I, typename D>\n+  D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const {\n+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+    FULL_MEM_BARRIER;\n+    return res;\n+  }\n+};\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformXchg<byte_size>::operator()(T exchange_value,\n+                                                     T volatile* dest,\n+                                                     atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+// No direct support for cmpxchg of bytes; emulate using int.\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T exchange_value,\n+                                                        T volatile* dest,\n+                                                        T compare_value,\n+                                                        atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  T value = compare_value;\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  __atomic_compare_exchange(dest, &value, &exchange_value, /* weak */ false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<4>::operator()(T exchange_value,\n+                                                T volatile* dest,\n+                                                T compare_value,\n+                                                atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  T rv;\n+  int tmp;\n+  __asm volatile(\n+    \"1:\\n\\t\"\n+    \" addiw     %[tmp], %[cv], 0\\n\\t\" // make sure compare_value signed_extend\n+    \" lr.w.aq   %[rv], (%[dest])\\n\\t\"\n+    \" bne       %[rv], %[tmp], 2f\\n\\t\"\n+    \" sc.w.rl   %[tmp], %[ev], (%[dest])\\n\\t\"\n+    \" bnez      %[tmp], 1b\\n\\t\"\n+    \"2:\\n\\t\"\n+    : [rv] \"=&r\" (rv), [tmp] \"=&r\" (tmp)\n+    : [ev] \"r\" (exchange_value), [dest] \"r\" (dest), [cv] \"r\" (compare_value)\n+    : \"memory\");\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return rv;\n+}\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_ATOMIC_LINUX_RISCV32_HPP"
  },
  {
    "sha": "e8440ffa2d9ff02e4d39965d914110f36558660f",
    "filename": "src/hotspot/os_cpu/linux_riscv32/bytes_linux_riscv32.inline.hpp",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/bytes_linux_riscv32.inline.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/bytes_linux_riscv32.inline.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/bytes_linux_riscv32.inline.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_BYTES_LINUX_RISCV32_INLINE_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_BYTES_LINUX_RISCV32_INLINE_HPP\n+\n+#include <byteswap.h>\n+\n+// Efficient swapping of data bytes from Java byte\n+// ordering to native byte ordering and vice versa.\n+inline u2 Bytes::swap_u2(u2 x) {\n+  return bswap_16(x);\n+}\n+\n+inline u4 Bytes::swap_u4(u4 x) {\n+  return bswap_32(x);\n+}\n+\n+inline u8 Bytes::swap_u8(u8 x) {\n+  return bswap_64(x);\n+}\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_BYTES_LINUX_RISCV32_INLINE_HPP"
  },
  {
    "sha": "ca8a9c3dc31d4809485e2b7f1635102f384cb9ef",
    "filename": "src/hotspot/os_cpu/linux_riscv32/copy_linux_riscv32.inline.hpp",
    "status": "added",
    "additions": 117,
    "deletions": 0,
    "changes": 117,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/copy_linux_riscv32.inline.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/copy_linux_riscv32.inline.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/copy_linux_riscv32.inline.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_COPY_LINUX_RISCV32_INLINE_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_COPY_LINUX_RISCV32_INLINE_HPP\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  (void)memmove(to, from, count * HeapWordSize);\n+}\n+\n+static inline void pd_disjoint_words_helper(const HeapWord* from, HeapWord* to, size_t count, bool is_atomic) {\n+  switch (count) {\n+    case 8:  to[7] = from[7];   // fall through\n+    case 7:  to[6] = from[6];   // fall through\n+    case 6:  to[5] = from[5];   // fall through\n+    case 5:  to[4] = from[4];   // fall through\n+    case 4:  to[3] = from[3];   // fall through\n+    case 3:  to[2] = from[2];   // fall through\n+    case 2:  to[1] = from[1];   // fall through\n+    case 1:  to[0] = from[0];   // fall through\n+    case 0:  break;\n+    default:\n+      if(is_atomic) {\n+        while (count-- > 0) { *to++ = *from++; }\n+      } else {\n+        memcpy(to, from, count * HeapWordSize);\n+      }\n+  }\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words_helper(from, to, count, false);\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words_helper(from, to, count, true);\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  _Copy_conjoint_jshorts_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  _Copy_conjoint_jints_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  _Copy_conjoint_jlongs_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size.\");\n+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jshorts(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jints(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+  assert(!UseCompressedOops, \"foo!\");\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_COPY_LINUX_RISCV32_INLINE_HPP"
  },
  {
    "sha": "258c7aa61cc77d6da61f03eb792b55655a70ddfc",
    "filename": "src/hotspot/os_cpu/linux_riscv32/globals_linux_riscv32.hpp",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/globals_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/globals_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/globals_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_GLOBALS_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_GLOBALS_LINUX_RISCV32_HPP\n+\n+// Sets the default values for platform dependent flags used by the runtime system.\n+// (see globals.hpp)\n+\n+define_pd_global(bool,  DontYieldALot,            false);\n+define_pd_global(intx,  ThreadStackSize,          2048); // 0 => use system default\n+define_pd_global(intx,  VMThreadStackSize,        2048);\n+\n+define_pd_global(intx,  CompilerThreadStackSize,  2048);\n+\n+define_pd_global(uintx, JVMInvokeMethodSlack,     8192);\n+\n+// Used on 64 bit platforms for UseCompressedOops base address\n+define_pd_global(uintx, HeapBaseMinAddress,       2 * G);\n+\n+extern __thread Thread *riscv32_currentThread;\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_GLOBALS_LINUX_RISCV32_HPP"
  },
  {
    "sha": "dc8e5c82fb9a330c17408beb9a13fec2fda5e0d4",
    "filename": "src/hotspot/os_cpu/linux_riscv32/orderAccess_linux_riscv32.hpp",
    "status": "added",
    "additions": 73,
    "deletions": 0,
    "changes": 73,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/orderAccess_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/orderAccess_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/orderAccess_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_ORDERACCESS_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_ORDERACCESS_LINUX_RISCV32_HPP\n+\n+// Included in orderAccess.hpp header file.\n+\n+#include \"vm_version_riscv32.hpp\"\n+\n+// Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+template<size_t byte_size>\n+struct OrderAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T data; __atomic_load(p, &data, __ATOMIC_ACQUIRE); return data; }\n+};\n+\n+template<size_t byte_size>\n+struct OrderAccess::PlatformOrderedStore<byte_size, RELEASE_X>\n+{\n+  template <typename T>\n+  void operator()(T v, volatile T* p) const { __atomic_store(p, &v, __ATOMIC_RELEASE); }\n+};\n+\n+template<size_t byte_size>\n+struct OrderAccess::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(T v, volatile T* p) const { release_store(p, v); fence(); }\n+};\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_ORDERACCESS_LINUX_RISCV32_HPP"
  },
  {
    "sha": "27e173876efba2598aa7a8e61bb25540fd6d2207",
    "filename": "src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.cpp",
    "status": "added",
    "additions": 700,
    "deletions": 0,
    "changes": 700,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.cpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.cpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.cpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+// no precompiled headers\n+#include \"asm/macroAssembler.hpp\"\n+#include \"classfile/classLoader.hpp\"\n+#include \"classfile/systemDictionary.hpp\"\n+#include \"classfile/vmSymbols.hpp\"\n+#include \"code/codeCache.hpp\"\n+#include \"code/icBuffer.hpp\"\n+#include \"code/nativeInst.hpp\"\n+#include \"code/vtableStubs.hpp\"\n+#include \"interpreter/interpreter.hpp\"\n+#include \"jvm.h\"\n+#include \"memory/allocation.inline.hpp\"\n+#include \"os_share_linux.hpp\"\n+#include \"prims/jniFastGetField.hpp\"\n+#include \"prims/jvm_misc.hpp\"\n+#include \"runtime/arguments.hpp\"\n+#include \"runtime/extendedPC.hpp\"\n+#include \"runtime/frame.inline.hpp\"\n+#include \"runtime/interfaceSupport.inline.hpp\"\n+#include \"runtime/java.hpp\"\n+#include \"runtime/javaCalls.hpp\"\n+#include \"runtime/mutexLocker.hpp\"\n+#include \"runtime/osThread.hpp\"\n+#include \"runtime/sharedRuntime.hpp\"\n+#include \"runtime/stubRoutines.hpp\"\n+#include \"runtime/thread.inline.hpp\"\n+#include \"runtime/timer.hpp\"\n+#include \"utilities/debug.hpp\"\n+#include \"utilities/events.hpp\"\n+#include \"utilities/vmError.hpp\"\n+\n+// put OS-includes here\n+# include <dlfcn.h>\n+# include <fpu_control.h>\n+# include <errno.h>\n+# include <pthread.h>\n+# include <signal.h>\n+# include <stdio.h>\n+# include <stdlib.h>\n+# include <sys/mman.h>\n+# include <sys/resource.h>\n+# include <sys/socket.h>\n+# include <sys/stat.h>\n+# include <sys/time.h>\n+# include <sys/types.h>\n+# include <sys/utsname.h>\n+# include <sys/wait.h>\n+# include <poll.h>\n+# include <pwd.h>\n+# include <ucontext.h>\n+# include <unistd.h>\n+\n+#define REG_LR       1\n+#define REG_FP       8\n+\n+NOINLINE address os::current_stack_pointer() {\n+  return (address)__builtin_frame_address(0);\n+}\n+\n+char* os::non_memory_address_word() {\n+  // Must never look like an address returned by reserve_memory,\n+  return (char*) -1;\n+}\n+\n+address os::Linux::ucontext_get_pc(const ucontext_t * uc) {\n+  return (address)uc->uc_mcontext.__gregs[REG_PC];\n+}\n+\n+void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {\n+  uc->uc_mcontext.__gregs[REG_PC] = (intptr_t)pc;\n+}\n+\n+intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->uc_mcontext.__gregs[REG_SP];\n+}\n+\n+intptr_t* os::Linux::ucontext_get_fp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->uc_mcontext.__gregs[REG_FP];\n+}\n+\n+// For Forte Analyzer AsyncGetCallTrace profiling support - thread\n+// is currently interrupted by SIGPROF.\n+// os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal\n+// frames. Currently we don't do that on Linux, so it's the same as\n+// os::fetch_frame_from_context().\n+ExtendedPC os::Linux::fetch_frame_from_ucontext(Thread* thread,\n+  const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  assert(thread != NULL, \"just checking\");\n+  assert(ret_sp != NULL, \"just checking\");\n+  assert(ret_fp != NULL, \"just checking\");\n+\n+  return os::fetch_frame_from_context(uc, ret_sp, ret_fp);\n+}\n+\n+ExtendedPC os::fetch_frame_from_context(const void* ucVoid,\n+                                        intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  ExtendedPC  epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = ExtendedPC(os::Linux::ucontext_get_pc(uc));\n+    if (ret_sp != NULL) {\n+      *ret_sp = os::Linux::ucontext_get_sp(uc);\n+    }\n+    if (ret_fp != NULL) {\n+      *ret_fp = os::Linux::ucontext_get_fp(uc);\n+    }\n+  } else {\n+    // construct empty ExtendedPC for return value checking\n+    epc = ExtendedPC(NULL);\n+    if (ret_sp != NULL) {\n+      *ret_sp = (intptr_t *)NULL;\n+    }\n+    if (ret_fp != NULL) {\n+      *ret_fp = (intptr_t *)NULL;\n+    }\n+  }\n+\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* frame_sp = NULL;\n+  intptr_t* frame_fp = NULL;\n+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &frame_sp, &frame_fp);\n+  return frame(frame_sp, frame_fp, epc.pc());\n+}\n+\n+bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n+  address pc = (address) os::Linux::ucontext_get_pc(uc);\n+  if (Interpreter::contains(pc)) {\n+    // interpreter performs stack banging after the fixed frame header has\n+    // been generated while the compilers perform it before. To maintain\n+    // semantic consistency between interpreted and compiled frames, the\n+    // method returns the Java sender of the current frame.\n+    *fr = os::fetch_frame_from_context(uc);\n+    if (!fr->is_first_java_frame()) {\n+      assert(fr->safe_for_sender(thread), \"Safety check\");\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    // more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      // Not sure where the pc points to, fallback to default\n+      // stack overflow handling\n+      return false;\n+    } else {\n+      // In compiled code, the stack banging is performed before LR\n+      // has been saved in the frame.  LR is live, and SP and FP\n+      // belong to the caller.\n+      intptr_t* frame_fp = os::Linux::ucontext_get_fp(uc);\n+      intptr_t* frame_sp = os::Linux::ucontext_get_sp(uc);\n+      address frame_pc = (address)(uintptr_t)(uc->uc_mcontext.__gregs[REG_LR] -\n+                         NativeInstruction::instruction_size);\n+      *fr = frame(frame_sp, frame_fp, frame_pc);\n+      if (!fr->is_java_frame()) {\n+        assert(fr->safe_for_sender(thread), \"Safety check\");\n+        assert(!fr->is_first_frame(), \"Safety check\");\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n+\n+// By default, gcc always saves frame pointer rfp on this stack. This\n+// may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->c_frame_sender_sp(), fr->c_frame_link(), fr->c_frame_sender_pc());\n+}\n+\n+NOINLINE frame os::current_frame() {\n+  intptr_t **sender_sp = (intptr_t **)__builtin_frame_address(0);\n+  if(sender_sp != NULL) {\n+    frame myframe((intptr_t*)os::current_stack_pointer(),\n+                  sender_sp[frame::c_frame_link_offset],\n+                  CAST_FROM_FN_PTR(address, os::current_frame));\n+    if (os::is_first_C_frame(&myframe)) {\n+      // stack is not walkable\n+      return frame();\n+    } else {\n+      return os::get_sender_for_C_frame(&myframe);\n+    }\n+  } else {\n+    ShouldNotReachHere();\n+    return frame();\n+  }\n+}\n+\n+bool os::is_first_C_frame(frame* fr) {\n+  // Load up sp, fp, sender sp and sender fp, check for reasonable values.\n+  // Check usp first, because if that's bad the other accessors may fault\n+  // on some architectures.  Ditto ufp second, etc.\n+  uintptr_t fp_align_mask = (uintptr_t)(sizeof(address) - 1);\n+  // sp on amd can be 32 bit aligned.\n+  uintptr_t sp_align_mask = (uintptr_t)(sizeof(int) - 1);\n+\n+  uintptr_t usp    = (uintptr_t)fr->sp();\n+  if ((usp & sp_align_mask) != 0) {\n+    return true;\n+  }\n+\n+  uintptr_t ufp    = (uintptr_t)fr->fp();\n+  if ((ufp & fp_align_mask) != 0) {\n+    return true;\n+  }\n+\n+  uintptr_t old_sp = (uintptr_t)fr->c_frame_sender_sp();\n+  if ((old_sp & sp_align_mask) != 0) {\n+    return true;\n+  }\n+  if (old_sp == 0 || old_sp == (uintptr_t)-1) {\n+    return true;\n+  }\n+\n+  uintptr_t old_fp = (uintptr_t)fr->c_frame_link();\n+  if ((old_fp & fp_align_mask) != 0) {\n+    return true;\n+  }\n+  if (old_fp == 0 || old_fp == (uintptr_t)-1 || old_fp == ufp) {\n+    return true;\n+  }\n+\n+  // stack grows downwards; if old_fp is below current fp or if the stack\n+  // frame is too large, either the stack is corrupted or fp is not saved\n+  // on stack (i.e. on x86, ebp may be used as general register). The stack\n+  // is not walkable beyond current frame.\n+  if (old_fp < ufp) {\n+    return true;\n+  }\n+  if (old_fp - ufp > 64 * K) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+int os::get_native_stack(address* stack, int frames, int toSkip) {\n+  int frame_idx = 0;\n+  int num_of_frames = 0;  // number of frames captured\n+  frame fr = os::current_frame();\n+  while (fr.pc() && frame_idx < frames) {\n+    if (toSkip > 0) {\n+      toSkip --;\n+    } else {\n+      stack[frame_idx ++] = fr.pc();\n+    }\n+    if (fr.fp() == NULL || fr.cb() != NULL ||\n+        fr.c_frame_sender_pc() == NULL || os::is_first_C_frame(&fr)) {\n+      break;\n+    }\n+\n+    if (fr.c_frame_sender_pc() && !os::is_first_C_frame(&fr)) {\n+      fr = os::get_sender_for_C_frame(&fr);\n+    } else {\n+      break;\n+    }\n+  }\n+  num_of_frames = frame_idx;\n+  for (; frame_idx < frames; frame_idx ++) {\n+    stack[frame_idx] = NULL;\n+  }\n+\n+  return num_of_frames;\n+}\n+\n+// Utility functions\n+extern \"C\" JNIEXPORT int\n+JVM_handle_linux_signal(int sig,\n+                        siginfo_t* info,\n+                        void* ucVoid,\n+                        int abort_if_unrecognized) {\n+  ucontext_t* uc = (ucontext_t*) ucVoid;\n+\n+  Thread* t = Thread::current_or_null_safe();\n+\n+  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away\n+  // (no destructors can be run)\n+  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+\n+  SignalHandlerMark shm(t);\n+\n+  // Note: it's not uncommon that JNI code uses signal/sigset to install\n+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n+  // or have a SIGILL handler when detecting CPU type). When that happens,\n+  // JVM_handle_linux_signal() might be invoked with junk info/ucVoid. To\n+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals\n+  // that do not require siginfo/ucontext first.\n+\n+  if (sig == SIGPIPE || sig == SIGXFSZ) {\n+    // allow chained handler to go first\n+    if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+      return true;\n+    } else {\n+      // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219\n+      return true;\n+    }\n+  }\n+\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n+    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n+      return 1;\n+    }\n+  }\n+#endif\n+\n+  JavaThread* thread = NULL;\n+  VMThread* vmthread = NULL;\n+  if (os::Linux::signal_handlers_are_installed) {\n+    if (t != NULL ) {\n+      if(t->is_Java_thread()) {\n+        thread = (JavaThread*)t;\n+      } else if(t->is_VM_thread()) {\n+        vmthread = (VMThread *)t;\n+      }\n+    }\n+  }\n+\n+  // decide if this trap can be handled by a stub\n+  address stub = NULL;\n+\n+  address pc = NULL;\n+\n+  //%note os_trap_1\n+  if (info != NULL && uc != NULL && thread != NULL) {\n+    pc = (address) os::Linux::ucontext_get_pc(uc);\n+\n+    if (StubRoutines::is_safefetch_fault(pc)) {\n+      os::Linux::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      return 1;\n+    }\n+\n+    // Handle ALL stack overflow variations here\n+    if (sig == SIGSEGV) {\n+      address addr = (address) info->si_addr;\n+\n+      // check if fault address is within thread stack\n+      if (thread->on_local_stack(addr)) {\n+        // stack overflow\n+        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+          if (thread->thread_state() == _thread_in_Java) {\n+            if (thread->in_stack_reserved_zone(addr)) {\n+              frame fr;\n+              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n+                assert(fr.is_java_frame(), \"Must be a Java frame\");\n+                frame activation =\n+                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n+                if (activation.sp() != NULL) {\n+                  thread->disable_stack_reserved_zone();\n+                  if (activation.is_interpreted_frame()) {\n+                    thread->set_reserved_stack_activation((address)(\n+                      activation.fp() + frame::interpreter_frame_initial_sp_offset));\n+                  } else {\n+                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                  }\n+                  return 1;\n+                }\n+              }\n+            }\n+            // Throw a stack overflow exception.  Guard pages will be reenabled\n+            // while unwinding the stack.\n+            thread->disable_stack_yellow_reserved_zone();\n+            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n+          } else {\n+            // Thread was in the vm or native code.  Return and try to finish.\n+            thread->disable_stack_yellow_reserved_zone();\n+            return 1;\n+          }\n+        } else if (thread->in_stack_red_zone(addr)) {\n+          // Fatal red zone violation.  Disable the guard pages and fall through\n+          // to handle_unexpected_exception way down below.\n+          thread->disable_stack_red_zone();\n+          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n+\n+          // This is a likely cause, but hard to verify. Let's just print\n+          // it as a hint.\n+          tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n+                            \"enabled executable stack (see man page execstack(8))\");\n+        } else {\n+          // Accessing stack address below sp may cause SEGV if current\n+          // thread has MAP_GROWSDOWN stack. This should only happen when\n+          // current thread was created by user code with MAP_GROWSDOWN flag\n+          // and then attached to VM. See notes in os_linux.cpp.\n+          if (thread->osthread()->expanding_stack() == 0) {\n+             thread->osthread()->set_expanding_stack();\n+             if (os::Linux::manually_expand_stack(thread, addr)) {\n+               thread->osthread()->clear_expanding_stack();\n+               return 1;\n+             }\n+             thread->osthread()->clear_expanding_stack();\n+          } else {\n+             fatal(\"recursive segv. expanding stack.\");\n+          }\n+        }\n+      }\n+    }\n+\n+    if (thread->thread_state() == _thread_in_Java) {\n+      // Java thread running in Java code => find exception handler if any\n+      // a fault inside compiled code, the interpreter, or a stub\n+\n+      // Handle signal from NativeJump::patch_verified_entry().\n+      if ((sig == SIGILL || sig == SIGTRAP)\n+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant (%s)\", (sig == SIGTRAP) ? \"SIGTRAP\" : \"SIGILL\");\n+        }\n+        stub = SharedRuntime::get_handle_wrong_method_stub();\n+      } else if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {\n+        stub = SharedRuntime::get_poll_stub(pc);\n+      } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {\n+        // BugId 4454115: A read from a MappedByteBuffer can fault\n+        // here if the underlying file has been truncated.\n+        // Do not crash the VM in such a case.\n+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+        if (nm != NULL && nm->has_unsafe_access()) {\n+          address next_pc = pc + NativeCall::instruction_size;\n+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+        }\n+      } else if (sig == SIGFPE  &&\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+        stub =\n+          SharedRuntime::\n+          continuation_for_implicit_exception(thread,\n+                                              pc,\n+                                              SharedRuntime::\n+                                              IMPLICIT_DIVIDE_BY_ZERO);\n+      } else if (sig == SIGSEGV &&\n+                 !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {\n+          // Determination of interpreter/vtable stub/compiled code null exception\n+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n+      }\n+    } else if (thread->thread_state() == _thread_in_vm &&\n+               sig == SIGBUS && /* info->si_code == BUS_OBJERR && */\n+               thread->doing_unsafe_access()) {\n+      address next_pc = pc + NativeCall::instruction_size;\n+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+    }\n+\n+    // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n+    // and the heap gets shrunk before the field access.\n+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n+      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n+      if (addr != (address)-1) {\n+        stub = addr;\n+      }\n+    }\n+\n+    // Check to see if we caught the safepoint code in the\n+    // process of write protecting the memory serialization page.\n+    // It write enables the page immediately after protecting it\n+    // so we can just return to retry the write.\n+    if ((sig == SIGSEGV) &&\n+        os::is_memory_serialize_page(thread, (address) info->si_addr)) {\n+      // Block current thread until the memory serialize page permission restored.\n+      os::block_on_serialize_page_trap();\n+      return true;\n+    }\n+  }\n+\n+  if (stub != NULL) {\n+    // save all thread context in case we need to restore it\n+    if (thread != NULL) {\n+      thread->set_saved_exception_pc(pc);\n+    }\n+\n+    os::Linux::ucontext_set_pc(uc, stub);\n+    return true;\n+  }\n+\n+  // signal-chaining\n+  if (os::Linux::chained_handler(sig, info, ucVoid)) {\n+     return true;\n+  }\n+\n+  if (!abort_if_unrecognized) {\n+    // caller wants another chance, so give it to him\n+    return false;\n+  }\n+\n+  if (pc == NULL && uc != NULL) {\n+    pc = os::Linux::ucontext_get_pc(uc);\n+  }\n+\n+  // unmask current signal\n+  sigset_t newset;\n+  sigemptyset(&newset);\n+  sigaddset(&newset, sig);\n+  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n+\n+  VMError::report_and_die(t, sig, pc, info, ucVoid);\n+\n+  ShouldNotReachHere();\n+  return true; // Mute compiler\n+}\n+\n+void os::Linux::init_thread_fpu_state(void) {\n+}\n+\n+int os::Linux::get_fpu_control_word(void) {\n+  return 0;\n+}\n+\n+void os::Linux::set_fpu_control_word(int fpu_control) {\n+}\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// thread stack\n+\n+// Minimum usable stack sizes required to get to user code. Space for\n+// HotSpot guard pages is added later.\n+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;\n+\n+// return default stack size for thr_type\n+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {\n+  // default stack size (compiler thread needs larger stack)\n+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);\n+  return s;\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// helper functions for fatal error handler\n+\n+static const char* reg_abi_names[] = {\n+  \"pc\",\n+  \"x1(ra)\", \"x2(sp)\", \"x3(gp)\", \"x4(tp)\",\n+  \"x5(t0)\", \"x6(t1)\", \"x7(t2)\",\n+  \"x8(s0)\", \"x9(s1)\",\n+  \"x10(a0)\", \"x11(a1)\", \"x12(a2)\", \"x13(a3)\", \"x14(a4)\", \"x15(a5)\", \"x16(a6)\", \"x17(a7)\",\n+  \"x18(s2)\", \"x19(s3)\", \"x20(s4)\", \"x21(s5)\", \"x22(s6)\", \"x23(s7)\", \"x24(s8)\", \"x25(s9)\", \"x26(s10)\", \"x27(s11)\",\n+  \"x28(t3)\", \"x29(t4)\",\"x30(t5)\", \"x31(t6)\"\n+};\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) {\n+    return;\n+  }\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  st->print_cr(\"Registers:\");\n+  for (int r = 0; r < 32; r++) {\n+    st->print(\"%-*.*s=\", 8, 8, reg_abi_names[r]);\n+    print_location(st, uc->uc_mcontext.__gregs[r]);\n+  }\n+  st->cr();\n+\n+  intptr_t *frame_sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);\n+  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", p2i(frame_sp));\n+  print_hex_dump(st, (address)frame_sp, (address)(frame_sp + 8 * sizeof(intptr_t)), sizeof(intptr_t));\n+  st->cr();\n+\n+  // Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  // point to garbage if entry point in an nmethod is corrupted. Leave\n+  // this at the end, and hope for the best.\n+  address pc = os::Linux::ucontext_get_pc(uc);\n+  print_instructions(st, pc, sizeof(char));\n+  st->cr();\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+  if (context == NULL) {\n+    return;\n+  }\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+\n+  // this is horrendously verbose but the layout of the registers in the\n+  // context does not match how we defined our abstract Register set, so\n+  // we can't just iterate through the gregs area\n+\n+  // this is only for the \"general purpose\" registers\n+\n+  for (int r = 0; r < 32; r++)\n+    st->print_cr(\"%-*.*s=\" INTPTR_FORMAT, 8, 8, reg_abi_names[r], (uintptr_t)uc->uc_mcontext.__gregs[r]);\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  return 0;\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+\n+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+    if (from > to) {\n+      const jshort *end = from + count;\n+      while (from < end) {\n+        *(to++) = *(from++);\n+      }\n+    } else if (from < to) {\n+      const jshort *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end) {\n+        *(to--) = *(from--);\n+      }\n+    }\n+  }\n+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+    if (from > to) {\n+      const jint *end = from + count;\n+      while (from < end) {\n+        *(to++) = *(from++);\n+      }\n+    } else if (from < to) {\n+      const jint *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end) {\n+        *(to--) = *(from--);\n+      }\n+    }\n+  }\n+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+    if (from > to) {\n+      const jlong *end = from + count;\n+      while (from < end) {\n+        os::atomic_copy64(from++, to++);\n+      }\n+    } else if (from < to) {\n+      const jlong *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end) {\n+        os::atomic_copy64(from--, to--);\n+      }\n+    }\n+  }\n+\n+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count);\n+  }\n+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,\n+                                      HeapWord* to,\n+                                      size_t    count) {\n+    memmove(to, from, count * 2);\n+  }\n+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count * 4);\n+  }\n+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,\n+                                     HeapWord* to,\n+                                     size_t    count) {\n+    memmove(to, from, count * 8);\n+  }\n+};"
  },
  {
    "sha": "e4f52dc2abe1da56851c13dfce658485bc6fabb0",
    "filename": "src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.hpp",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/os_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_OS_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_OS_LINUX_RISCV32_HPP\n+\n+  static void setup_fpu();\n+\n+  // Used to register dynamic code cache area with the OS\n+  // Note: Currently only used in 64 bit Windows implementations\n+  static bool register_code_area(char *low, char *high) { return true; }\n+\n+  // Atomically copy 64 bits of data\n+  static void atomic_copy64(const volatile void *src, volatile void *dst) {\n+    *(jlong *) dst = *(const jlong *) src;\n+  }\n+\n+  // SYSCALL_RISCV_FLUSH_ICACHE is used to flush instruction cache. The \"fence.i\" instruction\n+  // only work on the current hart, so kernel provides the icache flush syscall to flush icache\n+  // on each hart. You can pass a flag to determine a global or local icache flush.\n+  static void icache_flush(long int start, long int end)\n+  {\n+    const int SYSCALL_RISCV_FLUSH_ICACHE = 259;\n+    register long int __a7 asm (\"a7\") = SYSCALL_RISCV_FLUSH_ICACHE;\n+    register long int __a0 asm (\"a0\") = start;\n+    register long int __a1 asm (\"a1\") = end;\n+    // the flush can be applied to either all threads or only the current.\n+    // 0 means a global icache flush, and the icache flush will be applied\n+    // to other harts concurrently executing.\n+    register long int __a2 asm (\"a2\") = 0;\n+    __asm__ volatile (\"ecall\\n\\t\"\n+                      : \"+r\" (__a0)\n+                      : \"r\" (__a0), \"r\" (__a1), \"r\" (__a2), \"r\" (__a7)\n+                      : \"memory\");\n+  }\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_OS_LINUX_RISCV32_HPP"
  },
  {
    "sha": "73fc0059f1882cc32c32192aebf39df5fb535e72",
    "filename": "src/hotspot/os_cpu/linux_riscv32/prefetch_linux_riscv32.inline.hpp",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/prefetch_linux_riscv32.inline.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/prefetch_linux_riscv32.inline.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/prefetch_linux_riscv32.inline.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_PREFETCH_LINUX_RISCV32_INLINE_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_PREFETCH_LINUX_RISCV32_INLINE_HPP\n+\n+#include \"runtime/prefetch.hpp\"\n+\n+\n+inline void Prefetch::read (void *loc, intx interval) {\n+}\n+\n+inline void Prefetch::write(void *loc, intx interval) {\n+}\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_PREFETCH_LINUX_RISCV32_INLINE_HPP"
  },
  {
    "sha": "a22aff2921f88afed7678a9c216edf0c6434f35e",
    "filename": "src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.cpp",
    "status": "added",
    "additions": 104,
    "deletions": 0,
    "changes": 104,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.cpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.cpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.cpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#include \"precompiled.hpp\"\n+#include \"memory/metaspaceShared.hpp\"\n+#include \"runtime/frame.inline.hpp\"\n+#include \"runtime/thread.inline.hpp\"\n+\n+frame JavaThread::pd_last_frame() {\n+  assert(has_last_Java_frame(), \"must have last_Java_sp() when suspended\");\n+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+}\n+\n+// For Forte Analyzer AsyncGetCallTrace profiling support - thread is\n+// currently interrupted by SIGPROF\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+  void* ucontext, bool isInJava) {\n+\n+  assert(Thread::current() == this, \"caller must be current thread\");\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {\n+  assert(this->is_Java_thread(), \"must be JavaThread\");\n+  JavaThread* jt = (JavaThread *)this;\n+\n+  // If we have a last_Java_frame, then we should use it even if\n+  // isInJava == true.  It should be more reliable than ucontext info.\n+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {\n+    *fr_addr = jt->pd_last_frame();\n+    return true;\n+  }\n+\n+  // At this point, we don't have a last_Java_frame, so\n+  // we try to glean some information out of the ucontext\n+  // if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+\n+    intptr_t* ret_fp = NULL;\n+    intptr_t* ret_sp = NULL;\n+    ExtendedPC addr = os::Linux::fetch_frame_from_ucontext(this, uc,\n+      &ret_sp, &ret_fp);\n+    if (addr.pc() == NULL || ret_sp == NULL ) {\n+      // ucontext wasn't useful\n+      return false;\n+    }\n+\n+    if (MetaspaceShared::is_in_trampoline_frame(addr.pc())) {\n+      // In the middle of a trampoline call. Bail out for safety.\n+      // This happens rarely so shouldn't affect profiling.\n+      return false;\n+    }\n+\n+    frame ret_frame(ret_sp, ret_fp, addr.pc());\n+    if (!ret_frame.safe_for_sender(jt)) {\n+#ifdef COMPILER2\n+      frame ret_frame2(ret_sp, NULL, addr.pc());\n+      if (!ret_frame2.safe_for_sender(jt)) {\n+        // nothing else to try if the frame isn't good\n+        return false;\n+      }\n+      ret_frame = ret_frame2;\n+#else\n+      // nothing else to try if the frame isn't good\n+      return false;\n+#endif /* COMPILER2 */\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+\n+  // nothing else to try\n+  return false;\n+}\n+\n+void JavaThread::cache_global_variables() { }"
  },
  {
    "sha": "2d19adb65a765247bca2d3c8dc6b3ef92700e7af",
    "filename": "src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.hpp",
    "status": "added",
    "additions": 71,
    "deletions": 0,
    "changes": 71,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/thread_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_THREAD_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_THREAD_LINUX_RISCV32_HPP\n+\n+ private:\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  // Mutators are highly dangerous....\n+  intptr_t* last_Java_fp()                       { return _anchor.last_Java_fp(); }\n+  void  set_last_Java_fp(intptr_t* java_fp)      { _anchor.set_last_Java_fp(java_fp);   }\n+\n+  void set_base_of_stack_pointer(intptr_t* base_sp) {\n+  }\n+\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  intptr_t* base_of_stack_pointer() {\n+    return NULL;\n+  }\n+  void record_base_of_stack_pointer() {\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *riscv64_get_thread_helper();\n+\n+  // These routines are only used on cpu architectures that\n+  // have separate register stacks (Itanium).\n+  static bool register_stack_overflow() { return false; }\n+  static void enable_register_stack_guard() {}\n+  static void disable_register_stack_guard() {}\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_THREAD_LINUX_RISCV32_HPP"
  },
  {
    "sha": "7a066209402824e2bf2fe7c9a63779d5958b4dc4",
    "filename": "src/hotspot/os_cpu/linux_riscv32/vmStructs_linux_riscv32.hpp",
    "status": "added",
    "additions": 56,
    "deletions": 0,
    "changes": 56,
    "blob_url": "https://github.com/openjdk-riscv/jdk11u/blob/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/vmStructs_linux_riscv32.hpp",
    "raw_url": "https://github.com/openjdk-riscv/jdk11u/raw/f856c2da34cc0b5da36b728d7574c918191f6859/src/hotspot/os_cpu/linux_riscv32/vmStructs_linux_riscv32.hpp",
    "contents_url": "https://api.github.com/repos/openjdk-riscv/jdk11u/contents/src/hotspot/os_cpu/linux_riscv32/vmStructs_linux_riscv32.hpp?ref=f856c2da34cc0b5da36b728d7574c918191f6859",
    "patch": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021,  Institute of Software, Chinese Academy of Sciences. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ */\n+\n+#ifndef OS_CPU_LINUX_RISCV32_VM_VMSTRUCTS_LINUX_RISCV32_HPP\n+#define OS_CPU_LINUX_RISCV32_VM_VMSTRUCTS_LINUX_RISCV32_HPP\n+\n+// These are the OS and CPU-specific fields, types and integer\n+// constants required by the Serviceability Agent. This file is\n+// referenced by vmStructs.cpp.\n+\n+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+                                                                                                                                     \\\n+  /******************************/                                                                                                   \\\n+  /* Threads (NOTE: incomplete) */                                                                                                   \\\n+  /******************************/                                                                                                   \\\n+  nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \\\n+  nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)\n+\n+\n+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+                                                                          \\\n+  /**********************/                                                \\\n+  /* Posix Thread IDs   */                                                \\\n+  /**********************/                                                \\\n+                                                                          \\\n+  declare_integer_type(OSThread::thread_id_t)                             \\\n+  declare_unsigned_integer_type(pthread_t)\n+\n+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#endif // OS_CPU_LINUX_RISCV32_VM_VMSTRUCTS_LINUX_RISCV32_HPP"
  }
]
