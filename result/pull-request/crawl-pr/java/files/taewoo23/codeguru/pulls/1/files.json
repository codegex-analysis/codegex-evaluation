[
  {
    "sha": "8d983e58ccc5dffc3a670942a0cd3248de3d5441",
    "filename": "src/main/java/com/shipmentEvents/demo/EventHandler.java",
    "status": "added",
    "additions": 174,
    "deletions": 0,
    "changes": 174,
    "blob_url": "https://github.com/taewoo23/codeguru/blob/454260fdfb24e39f2c9fd708a19d08b2e2278d21/src/main/java/com/shipmentEvents/demo/EventHandler.java",
    "raw_url": "https://github.com/taewoo23/codeguru/raw/454260fdfb24e39f2c9fd708a19d08b2e2278d21/src/main/java/com/shipmentEvents/demo/EventHandler.java",
    "contents_url": "https://api.github.com/repos/taewoo23/codeguru/contents/src/main/java/com/shipmentEvents/demo/EventHandler.java?ref=454260fdfb24e39f2c9fd708a19d08b2e2278d21",
    "patch": "@@ -0,0 +1,174 @@\n+package com.shipmentEvents.handlers;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import com.amazonaws.regions.Regions;\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.amazonaws.services.lambda.runtime.LambdaLogger;\n+import com.amazonaws.services.lambda.runtime.events.ScheduledEvent;\n+import com.amazonaws.services.s3.AmazonS3;\n+import com.amazonaws.services.s3.AmazonS3ClientBuilder;\n+import com.amazonaws.services.s3.model.DeleteObjectsRequest;\n+import com.amazonaws.services.s3.model.DeleteObjectsRequest.KeyVersion;\n+import com.amazonaws.services.s3.model.ObjectListing;\n+import com.amazonaws.services.s3.model.S3ObjectSummary;\n+import com.shipmentEvents.util.Constants;\n+\n+import org.apache.commons.lang3.tuple.MutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+\n+public class EventHandler implements RequestHandler<ScheduledEvent, String> {\n+\n+    /**\n+     * Shipment events for a carrier are uploaded to separate S3 buckets based on the source of events. E.g., events originating from\n+     * the hand-held scanner are stored in a separate bucket than the ones from mobile App. The Lambda processes events from multiple\n+     * sources and updates the latest status of the package in a summary S3 bucket every 15 minutes.\n+     * \n+     * The events are stored in following format:\n+     * - Each status update is a file, where the name of the file is tracking number + random id.\n+     * - Each file has status and time-stamp as the first 2 lines respectively.\n+     * - The time at which the file is stored in S3 is not an indication of the time-stamp of the event.\n+     * - Once the status is marked as DELIVERED, we can stop tracking the package.\n+     * \n+     * A Sample files looks as below:\n+     *  FILE-NAME-> '8787323232232332--55322798-dd29-4a04-97f4-93e18feed554'\n+     *   >status:IN TRANSIT\n+     *   >timestamp: 1573410202\n+     *   >Other fields like...tracking history and address\n+     */\n+    public String handleRequest(ScheduledEvent scheduledEvent, Context context) {\n+\n+        final LambdaLogger logger = context.getLogger();\n+        try {\n+            processShipmentUpdates(logger);\n+            return \"SUCCESS\";\n+        } catch (final Exception ex) {\n+            logger.log(String.format(\"Failed to process shipment Updates in %s due to %s\", scheduledEvent.getAccount(), ex.getMessage()));\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+\n+    private void processShipmentUpdates(final LambdaLogger logger) throws InterruptedException {\n+\n+        final List<String> bucketsToProcess = Constants.BUCKETS_TO_PROCESS;\n+        final Map<String, Pair<Long, String>> latestStatusForTrackingNumber = new HashMap<String, Pair<Long, String>>();\n+        final Map<String, List<KeyVersion>> filesToDelete = new HashMap<String, List<DeleteObjectsRequest.KeyVersion>>(); \n+        for (final String bucketName : bucketsToProcess) {\n+            final List<KeyVersion> filesProcessed = processEventsInBucket(bucketName, logger, latestStatusForTrackingNumber);\n+            filesToDelete.put(bucketName, filesProcessed);\n+        }\n+        final AmazonS3 s3Client = EventHandler.getS3Client();\n+\n+        //Create a new file in the Constants.SUMMARY_BUCKET\n+        logger.log(\"Map of statuses -> \" + latestStatusForTrackingNumber);\n+        String summaryUpdateName = Long.toString(System.currentTimeMillis());\n+        \n+        EventHandler.getS3Client().putObject(Constants.SUMMARY_BUCKET, summaryUpdateName, latestStatusForTrackingNumber.toString());\n+        \n+        long expirationTime = System.currentTimeMillis() + Duration.ofMinutes(1).toMillis();\n+        while(System.currentTimeMillis() < expirationTime) {\n+            if (s3Client.doesObjectExist(Constants.SUMMARY_BUCKET, summaryUpdateName)) {\n+                break;\n+            }\n+            logger.log(\"waiting for file to be created \" + summaryUpdateName);\n+            Thread.sleep(1000);\n+        }\n+        \n+        // Before we delete the shipment updates make sure the summary update file exists\n+        if (EventHandler.getS3Client().doesObjectExist(Constants.SUMMARY_BUCKET, summaryUpdateName)) {\n+            deleteProcessedFiles(filesToDelete);\n+            logger.log(\"All updates successfully processed\");\n+        } else {\n+            throw new RuntimeException(\"Failed to write summary status, will be retried in 15 minutes\");\n+        }\n+        \n+    }\n+\n+    private List<KeyVersion> processEventsInBucket(String bucketName, LambdaLogger logger, Map<String, Pair<Long, String>> latestStatusForTrackingNumber) {\n+        final AmazonS3 s3Client = EventHandler.getS3Client();\n+        logger.log(\"Processing Bucket: \" + bucketName);\n+\n+        ObjectListing files = s3Client.listObjects(bucketName);\n+        List<KeyVersion> filesProcessed = new ArrayList<DeleteObjectsRequest.KeyVersion>();\n+\n+        for (Iterator<?> iterator = files.getObjectSummaries().iterator(); iterator.hasNext(); ) {\n+            S3ObjectSummary summary = (S3ObjectSummary) iterator.next();\n+            logger.log(\"Reading Object: \" + summary.getKey());\n+\n+            String trackingNumber = summary.getKey().split(\"--\")[0];\n+            Pair<Long, String> lastKnownStatus = latestStatusForTrackingNumber.get(trackingNumber);\n+\n+            // Check if this shipment has already been delivered, skip this file\n+            if (lastKnownStatus != null && \"DELIVERED\".equals(lastKnownStatus.getRight())) {\n+                continue;\n+            }\n+\n+            String fileContents = s3Client.getObjectAsString(bucketName, summary.getKey());\n+\n+            if (!isValidFile(fileContents)) {\n+                logger.log(String.format(\"Skipping invalid file %s\", summary.getKey()));\n+                continue;\n+            }\n+            \n+            if (!fileContents.contains(\"\\n\")) {\n+                \n+            }\n+            String[] lines = fileContents.split(\"\\n\");\n+            String line1 = lines[0];\n+            String line2 = lines[1];\n+\n+            String status = line1.split(\":\")[1];\n+            Long timeStamp = Long.parseLong(line2.split(\":\")[1]);\n+\n+\n+            if (null == lastKnownStatus || lastKnownStatus.getLeft() < timeStamp) {\n+                lastKnownStatus = new MutablePair<Long, String>(timeStamp, status);\n+                latestStatusForTrackingNumber.put(trackingNumber, lastKnownStatus);\n+            }\n+\n+            //Add to list of processed files\n+            filesProcessed.add(new KeyVersion(summary.getKey()));\n+            logger.log(\"logging Contents of the file\" + fileContents);\n+        }\n+        return filesProcessed;\n+    }\n+    \n+\n+    private void deleteProcessedFiles(Map<String, List<KeyVersion>> filesToDelete) {\n+      final AmazonS3 s3Client = EventHandler.getS3Client();\n+      for (Entry<String, List<KeyVersion>> entry : filesToDelete.entrySet()) {\n+          final DeleteObjectsRequest deleteRequest = new DeleteObjectsRequest(entry.getKey()).withKeys(entry.getValue()).withQuiet(false);\n+          s3Client.deleteObjects(deleteRequest);\n+      }\n+    }\n+    \n+    private boolean isValidFile(String fileContents) {\n+        if (!fileContents.contains(\"\\n\")) {\n+            return false;\n+        }\n+        String[] lines = fileContents.split(\"\\n\");\n+        for (String l: lines) {\n+            if (!l.contains(\":\")) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    public static AmazonS3 getS3Client() {\n+        return AmazonS3ClientBuilder.standard().withRegion(Regions.DEFAULT_REGION).build();\n+    }\n+    \n+    \n+}\n+\n+"
  }
]
