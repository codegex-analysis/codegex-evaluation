[
  {
    "sha": "bca12574709f7155179c6dbb475d45d89b160033",
    "filename": ".travis.yml",
    "status": "modified",
    "additions": 10,
    "deletions": 1,
    "changes": 11,
    "blob_url": "https://github.com/shishkovilja/ignite/blob/ba619e0659cf590966d3259e5bb1a778e9edefb4/.travis.yml",
    "raw_url": "https://github.com/shishkovilja/ignite/raw/ba619e0659cf590966d3259e5bb1a778e9edefb4/.travis.yml",
    "contents_url": "https://api.github.com/repos/shishkovilja/ignite/contents/.travis.yml?ref=ba619e0659cf590966d3259e5bb1a778e9edefb4",
    "patch": "@@ -51,4 +51,13 @@ matrix:\n       dotnet: 3.1.101\n       script:\n         - dotnet build modules/platforms/dotnet/Apache.Ignite.DotNetCore.sln\n-        - \n\\ No newline at end of file\n+\n+    - language: java\n+      name: \"Check test suites\"\n+      os: linux\n+      dist: trusty\n+      install: skip\n+      jdk: openjdk8\n+      script: mvn test -Pcheck-test-suites,all-java,all-scala,scala -B -V\n+      before_cache: rm -rfv $HOME/.m2/repository/org/apache/ignite\n+      cache: { directories: [ $HOME/.m2/repository ] }"
  },
  {
    "sha": "f178c021aaaf33ad81f9353e20646febd1ca445b",
    "filename": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/persistence/InlineIndexCompatibilityTest.java",
    "status": "added",
    "additions": 359,
    "deletions": 0,
    "changes": 359,
    "blob_url": "https://github.com/shishkovilja/ignite/blob/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/compatibility/src/test/java/org/apache/ignite/compatibility/persistence/InlineIndexCompatibilityTest.java",
    "raw_url": "https://github.com/shishkovilja/ignite/raw/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/compatibility/src/test/java/org/apache/ignite/compatibility/persistence/InlineIndexCompatibilityTest.java",
    "contents_url": "https://api.github.com/repos/shishkovilja/ignite/contents/modules/compatibility/src/test/java/org/apache/ignite/compatibility/persistence/InlineIndexCompatibilityTest.java?ref=ba619e0659cf590966d3259e5bb1a778e9edefb4",
    "patch": "@@ -0,0 +1,359 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.compatibility.persistence;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cache.query.annotations.QuerySqlField;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.compatibility.testframework.junits.Dependency;\n+import org.apache.ignite.configuration.BinaryConfiguration;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+\n+/**\n+ * Tests that upgrade version on persisted inline index is successfull.\n+ */\n+@RunWith(Parameterized.class)\n+public class InlineIndexCompatibilityTest extends IgnitePersistenceCompatibilityAbstractTest {\n+    /** */\n+    private static final String TEST_CACHE_NAME = InlineIndexCompatibilityTest.class.getSimpleName();\n+\n+    /** */\n+    private static final int ROWS_CNT = 100;\n+\n+    /** Index to test. */\n+    private static final String INDEX_NAME = \"intval1_val_intval2\";\n+\n+    /** Index to test with configured inline size. */\n+    private static final String INDEX_SIZED_NAME = \"intval1_val_intval2_sized\";\n+\n+    /** Parametrized run param: Ignite version. */\n+    @Parameterized.Parameter(0)\n+    public String igniteVer;\n+\n+    /** Parametrized run param: Inline size is configured by user. */\n+    @Parameterized.Parameter(1)\n+    public boolean cfgInlineSize;\n+\n+    /** Test run configurations: Ignite version, Inline size configuration. */\n+    @Parameterized.Parameters(name = \"ver={0}, cfgInlineSize={1}\")\n+    public static Collection<Object[]> runConfig() {\n+        return Arrays.asList(new Object[][] {\n+            /** 2.6.0 is a last version where POJO inlining isn't enabled. */\n+            {\"2.6.0\", false},\n+            {\"2.6.0\", true},\n+\n+            {\"2.7.0\", false},\n+            {\"2.7.0\", true},\n+\n+            {\"2.7.6\", false},\n+            {\"2.7.6\", true},\n+\n+            {\"2.8.0\", false},\n+            {\"2.8.0\", true},\n+\n+            {\"2.8.1\", false},\n+            {\"2.8.1\", true},\n+\n+            {\"2.9.0\", false},\n+            {\"2.9.0\", true},\n+\n+            {\"2.9.1\", false},\n+            {\"2.9.1\", true}\n+        });\n+    }\n+\n+    /** */\n+    @Test\n+    public void testQueryOldInlinedIndex() throws Exception {\n+        PostStartupClosure closure = cfgInlineSize ? new PostStartupClosureSized() : new PostStartupClosure();\n+        String idxName = cfgInlineSize ? INDEX_SIZED_NAME : INDEX_NAME;\n+\n+        doTestStartupWithOldVersion(igniteVer, closure, idxName);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override @NotNull protected Collection<Dependency> getDependencies(String igniteVer) {\n+        Collection<Dependency> dependencies = super.getDependencies(igniteVer);\n+\n+        if (\"2.6.0\".equals(igniteVer))\n+            dependencies.add(new Dependency(\"h2\", \"com.h2database\", \"h2\", \"1.4.195\", false));\n+\n+        dependencies.add(new Dependency(\"indexing\", \"ignite-indexing\", false));\n+\n+        return dependencies;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected Set<String> getExcluded(String ver, Collection<Dependency> dependencies) {\n+        Set<String> excluded = super.getExcluded(ver, dependencies);\n+\n+        if (\"2.6.0\".equals(ver))\n+            excluded.add(\"h2\");\n+\n+        return excluded;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        cfg.setPeerClassLoadingEnabled(false);\n+\n+        cfg.setDataStorageConfiguration(\n+            new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(\n+                    new DataRegionConfiguration()\n+                        .setPersistenceEnabled(true)\n+                        .setMaxSize(DataStorageConfiguration.DFLT_DATA_REGION_INITIAL_SIZE)\n+                )\n+                // Disable WAL to skip filling index with reading WAL. Instead just start on previous persisted files.\n+                .setWalMode(WALMode.NONE));\n+\n+        cfg.setBinaryConfiguration(\n+            new BinaryConfiguration()\n+                .setCompactFooter(true)\n+        );\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Tests opportunity to read data from previous Ignite DB version.\n+     *\n+     * @param igniteVer 3-digits version of ignite\n+     * @throws Exception If failed.\n+     */\n+    protected void doTestStartupWithOldVersion(String igniteVer, PostStartupClosure closure, String idxName) throws Exception {\n+        try {\n+            startGrid(1, igniteVer,\n+                new PersistenceBasicCompatibilityTest.ConfigurationClosure(true),\n+                closure);\n+\n+            stopAllGrids();\n+\n+            IgniteEx ignite = startGrid(0);\n+\n+            assertEquals(1, ignite.context().discovery().topologyVersion());\n+\n+            ignite.cluster().state(ClusterState.ACTIVE);\n+\n+            validateResultingCacheData(ignite.cache(TEST_CACHE_NAME), idxName);\n+        }\n+        finally {\n+            stopAllGrids();\n+        }\n+    }\n+\n+    /**\n+     * Asserts cache contained all expected values as it was saved before.\n+     *\n+     * @param cache Cache to check.\n+     * @param idxName Name of index to check.\n+     */\n+    private void validateResultingCacheData(IgniteCache<Object, Object> cache, String idxName) {\n+        validateRandomRow(cache, idxName);\n+        validateRandomRange(cache, idxName);\n+    }\n+\n+    /** */\n+    private void validateRandomRow(IgniteCache<Object, Object> cache, String idxName) {\n+        int val = new Random().nextInt(ROWS_CNT);\n+\n+        // Select by quering complex index.\n+        SqlFieldsQuery qry = new SqlFieldsQuery(\n+            \"SELECT * FROM \\\"\" + TEST_CACHE_NAME + \"\\\".EntityValueValue v \" +\n+                \"WHERE v.intVal1 = ? and v.val = ? and v.intVal2 = ?;\")\n+            .setArgs(val, new EntityValue(val + 2), val + 1);\n+\n+        checkIndexUsed(cache, qry, idxName);\n+\n+        List<List<?>> result = cache.query(qry).getAll();\n+\n+        assertTrue(result.size() == 1);\n+\n+        List<?> row = result.get(0);\n+\n+        assertTrue(row.get(0).equals(new EntityValue(val + 2)));\n+        assertTrue(row.get(1).equals(val));\n+        assertTrue(row.get(2).equals(val + 1));\n+    }\n+\n+    /** */\n+    private void validateRandomRange(IgniteCache<Object, Object> cache, String idxName) {\n+        int pivot = new Random().nextInt(ROWS_CNT);\n+\n+        // Select by quering complex index.\n+        SqlFieldsQuery qry = new SqlFieldsQuery(\n+            \"SELECT * FROM \\\"\" + TEST_CACHE_NAME + \"\\\".EntityValueValue v \" +\n+                \"WHERE v.intVal1 > ? and v.val > ? and v.intVal2 > ? \" +\n+                \"ORDER BY v.val, v.intVal1, v.intVal2;\")\n+            .setArgs(pivot, new EntityValue(pivot), pivot);\n+\n+        checkIndexUsed(cache, qry, idxName);\n+\n+        List<List<?>> result = cache.query(qry).getAll();\n+\n+        // For strict comparison. There was an issues with >= comparison for some versions.\n+        pivot += 1;\n+\n+        assertTrue(result.size() == ROWS_CNT - pivot);\n+\n+        for (int i = 0; i < ROWS_CNT - pivot; i++) {\n+            List<?> row = result.get(i);\n+\n+            assertTrue(row.get(0).equals(new EntityValue(pivot + i + 2)));\n+            assertTrue(row.get(1).equals(pivot + i));\n+            assertTrue(row.get(2).equals(pivot + i + 1));\n+        }\n+    }\n+\n+    /** */\n+    private void checkIndexUsed(IgniteCache<?, ?> cache, SqlFieldsQuery qry, String idxName) {\n+        assertTrue(\"Query does not use index.\", queryPlan(cache, qry).toLowerCase().contains(idxName.toLowerCase()));\n+    }\n+\n+    /** */\n+    public static class PostStartupClosure implements IgniteInClosure<Ignite> {\n+        /** {@inheritDoc} */\n+        @Override public void apply(Ignite ignite) {\n+            ignite.active(true);\n+\n+            CacheConfiguration<Object, Object> cacheCfg = new CacheConfiguration<>();\n+            cacheCfg.setName(TEST_CACHE_NAME);\n+            cacheCfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL);\n+            cacheCfg.setBackups(1);\n+\n+            cacheCfg.setIndexedTypes(Integer.class, EntityValueValue.class);\n+\n+            IgniteCache<Object, Object> cache = ignite.createCache(cacheCfg);\n+\n+            saveCacheData(cache);\n+\n+            ignite.active(false);\n+\n+            try {\n+                Thread.sleep(1_000);\n+            }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        /**\n+         * Create a complex index (int, pojo, int). Check that middle POJO object is correctly available from inline.\n+         *\n+         * @param cache to be filled with data. Results may be validated in {@link #validateResultingCacheData(IgniteCache, String)}.\n+         */\n+        protected void saveCacheData(IgniteCache<Object, Object> cache) {\n+            for (int i = 0; i < ROWS_CNT; i++)\n+                cache.put(i, new EntityValueValue(new EntityValue(i + 2), i, i + 1));\n+\n+            // Create index (int, pojo, int).\n+            cache.query(new SqlFieldsQuery(\n+                    \"CREATE INDEX \" + INDEX_NAME + \" ON \\\"\" + TEST_CACHE_NAME + \"\\\".EntityValueValue \" +\n+                    \"(intVal1, val, intVal2)\")).getAll();\n+        }\n+    }\n+\n+    /** */\n+    public static class PostStartupClosureSized extends PostStartupClosure {\n+        /** {@inheritDoc} */\n+        @Override protected void saveCacheData(IgniteCache<Object, Object> cache) {\n+            for (int i = 0; i < ROWS_CNT; i++)\n+                cache.put(i, new EntityValueValue(new EntityValue(i + 2), i, i + 1));\n+\n+            // Create index (int, pojo, int) with configured inline size.\n+            cache.query(new SqlFieldsQuery(\n+                \"CREATE INDEX \" + INDEX_SIZED_NAME + \" ON \\\"\" + TEST_CACHE_NAME + \"\\\".EntityValueValue \" +\n+                    \"(intVal1, val, intVal2) \" +\n+                    \"INLINE_SIZE 100\")).getAll();\n+        }\n+    }\n+\n+    /** POJO object aimed to be inlined. */\n+    public static class EntityValue {\n+        /** */\n+        private final int val;\n+\n+        /** */\n+        public EntityValue(int val) {\n+            this.val = val;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public String toString() {\n+            return \"EV[value=\" + val + \"]\";\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public int hashCode() {\n+            return val;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public boolean equals(Object other) {\n+            return val == ((EntityValue) other).val;\n+        }\n+    }\n+\n+    /** Represents a cache value with 3 fields (POJO, int, int). */\n+    public static class EntityValueValue {\n+        /** */\n+        @QuerySqlField\n+        private final EntityValue val;\n+\n+        /** */\n+        @QuerySqlField\n+        private final int intVal1;\n+\n+        /** */\n+        @QuerySqlField\n+        private final int intVal2;\n+\n+        /** */\n+        public EntityValueValue(EntityValue val, int val1, int val2) {\n+            this.val = val;\n+            intVal1 = val1;\n+            intVal2 = val2;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override public String toString() {\n+            return \"EVV[value=\" + val + \"]\";\n+        }\n+    }\n+}"
  },
  {
    "sha": "652a0e241746f6683c15fdf34b4a5d65524982dc",
    "filename": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/testsuites/IgniteCompatibilityBasicTestSuite.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/shishkovilja/ignite/blob/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/compatibility/src/test/java/org/apache/ignite/compatibility/testsuites/IgniteCompatibilityBasicTestSuite.java",
    "raw_url": "https://github.com/shishkovilja/ignite/raw/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/compatibility/src/test/java/org/apache/ignite/compatibility/testsuites/IgniteCompatibilityBasicTestSuite.java",
    "contents_url": "https://api.github.com/repos/shishkovilja/ignite/contents/modules/compatibility/src/test/java/org/apache/ignite/compatibility/testsuites/IgniteCompatibilityBasicTestSuite.java?ref=ba619e0659cf590966d3259e5bb1a778e9edefb4",
    "patch": "@@ -20,6 +20,7 @@\n import org.apache.ignite.compatibility.cache.LocalCacheTest;\n import org.apache.ignite.compatibility.jdbc.JdbcThinCompatibilityTest;\n import org.apache.ignite.compatibility.persistence.FoldersReuseCompatibilityTest;\n+import org.apache.ignite.compatibility.persistence.InlineIndexCompatibilityTest;\n import org.apache.ignite.compatibility.persistence.MetaStorageCompatibilityTest;\n import org.apache.ignite.compatibility.persistence.MigratingToWalV2SerializerWithCompactionTest;\n import org.apache.ignite.compatibility.persistence.MoveBinaryMetadataCompatibility;\n@@ -33,6 +34,7 @@\n @RunWith(Suite.class)\n @Suite.SuiteClasses({\n     PersistenceBasicCompatibilityTest.class,\n+    InlineIndexCompatibilityTest.class,\n     FoldersReuseCompatibilityTest.class,\n     MigratingToWalV2SerializerWithCompactionTest.class,\n     MetaStorageCompatibilityTest.class,"
  },
  {
    "sha": "2b2f81badb7abf9d3f5539c8143d3b75aef8ceb3",
    "filename": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/H2Tree.java",
    "status": "modified",
    "additions": 47,
    "deletions": 10,
    "changes": 57,
    "blob_url": "https://github.com/shishkovilja/ignite/blob/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/H2Tree.java",
    "raw_url": "https://github.com/shishkovilja/ignite/raw/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/H2Tree.java",
    "contents_url": "https://api.github.com/repos/shishkovilja/ignite/contents/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/H2Tree.java?ref=ba619e0659cf590966d3259e5bb1a778e9edefb4",
    "patch": "@@ -24,6 +24,7 @@\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.stream.Collectors;\n import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n import org.apache.ignite.failure.FailureType;\n@@ -239,14 +240,26 @@ public H2Tree(\n \n             inlineSize = metaInfo.inlineSize();\n \n+            setIos(\n+                H2ExtrasInnerIO.getVersions(inlineSize, mvccEnabled),\n+                H2ExtrasLeafIO.getVersions(inlineSize, mvccEnabled)\n+            );\n+\n             List<InlineIndexColumn> inlineIdxs0 = getAvailableInlineColumns(affinityKey, cacheName, idxName, log, pk,\n                 table, cols, factory, metaInfo.inlineObjectHash());\n \n-            boolean inlineObjSupported = inlineSize > 0 && metaInfo.inlineObjectSupported();\n+            boolean inlineObjSupported = inlineSize > 0 && inlineObjectSupported(metaInfo, inlineIdxs0);\n+\n+            if (inlineObjSupported)\n+                inlineIdxs = inlineIdxs0;\n+            else {\n+                // If an index contains JO type and doesn't support inlining of it then use only prior columns.\n+                int objIdx = 0;\n+\n+                for (; objIdx < inlineIdxs0.size() && inlineIdxs0.get(objIdx).type() != Value.JAVA_OBJECT; ++objIdx);\n \n-            inlineIdxs = inlineObjSupported ? inlineIdxs0 : inlineIdxs0.stream()\n-                .filter(ih -> ih.type() != Value.JAVA_OBJECT)\n-                .collect(Collectors.toList());\n+                inlineIdxs = inlineIdxs0.subList(0, objIdx);\n+            }\n \n             inlineCols = new IndexColumn[inlineIdxs.size()];\n \n@@ -257,11 +270,6 @@ public H2Tree(\n \n             if (!metaInfo.flagsSupported())\n                 upgradeMetaPage(inlineObjSupported);\n-\n-            setIos(\n-                H2ExtrasInnerIO.getVersions(inlineSize, mvccEnabled),\n-                H2ExtrasLeafIO.getVersions(inlineSize, mvccEnabled)\n-            );\n         }\n         else {\n             unwrappedPk = true;\n@@ -284,6 +292,35 @@ public H2Tree(\n         created = initNew;\n     }\n \n+    /**\n+     * Find whether tree supports inlining objects or not.\n+     *\n+     * @param metaInfo Metapage info.\n+     * @param inlineIdxs Base collection of index helpers.\n+     * @return {@code true} if inline object is supported by exists tree.\n+     */\n+    private boolean inlineObjectSupported(MetaPageInfo metaInfo, List<InlineIndexColumn> inlineIdxs) {\n+        if (metaInfo.flagsSupported())\n+            return metaInfo.inlineObjectSupported();\n+        else {\n+            try {\n+                if (InlineObjectBytesDetector.objectMayBeInlined(inlineSize, inlineIdxs)) {\n+                    InlineObjectBytesDetector inlineObjDetector = new InlineObjectBytesDetector(\n+                        inlineSize, inlineIdxs, tblName, idxName, log);\n+\n+                    findFirst(inlineObjDetector);\n+\n+                    return inlineObjDetector.inlineObjectSupported();\n+                }\n+                else\n+                    return false;\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Unexpected exception on detect inline object\", e);\n+            }\n+        }\n+    }\n+\n     /**\n      * Return columns of the index.\n      *\n@@ -475,7 +512,7 @@ private void upgradeMetaPage(boolean inlineObjSupported) throws IgniteCheckedExc\n \n                 for (int i = 0; i < inlineIdxs.size(); i++) {\n                     InlineIndexColumn inlineIdx = inlineIdxs.get(i);\n-                    \n+\n                     Value v2 = row.getValue(inlineIdx.columnIndex());\n \n                     if (v2 == null)"
  },
  {
    "sha": "fc77acb3d4b7a8eb8c7b021ea86be41ea0460316",
    "filename": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/InlineObjectBytesDetector.java",
    "status": "added",
    "additions": 197,
    "deletions": 0,
    "changes": 197,
    "blob_url": "https://github.com/shishkovilja/ignite/blob/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/InlineObjectBytesDetector.java",
    "raw_url": "https://github.com/shishkovilja/ignite/raw/ba619e0659cf590966d3259e5bb1a778e9edefb4/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/InlineObjectBytesDetector.java",
    "contents_url": "https://api.github.com/repos/shishkovilja/ignite/contents/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/database/InlineObjectBytesDetector.java?ref=ba619e0659cf590966d3259e5bb1a778e9edefb4",
    "patch": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.h2.database;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.pagemem.PageUtils;\n+import org.apache.ignite.internal.processors.cache.persistence.tree.BPlusTree;\n+import org.apache.ignite.internal.processors.cache.persistence.tree.io.BPlusIO;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.h2.value.Value;\n+import org.h2.value.ValueNull;\n+\n+/**\n+ * This class helps to detect whether tree contains inlined JO type.\n+ *\n+ * When starting on old Ignite versions it's impossible to discover whether JO type was inlined or not.\n+ * Then try to find that with 2 steps:\n+ * 1. analyze of inline size;\n+ * 2. traverse tree and check stored values.\n+ */\n+public class InlineObjectBytesDetector implements BPlusTree.TreeRowClosure<H2Row, H2Row> {\n+    /** Inline size. */\n+    private final int inlineSize;\n+\n+    /** Inline helpers. */\n+    private final List<InlineIndexColumn> inlineCols;\n+\n+    /** Inline object supported flag. */\n+    private boolean inlineObjSupported = true;\n+\n+    /** */\n+    private final String tblName;\n+\n+    /** */\n+    private final String idxName;\n+\n+    /** */\n+    private final IgniteLogger log;\n+\n+    /**\n+     * @param inlineSize Inline size.\n+     * @param inlineCols Inline columns.\n+     * @param idxName Index name.\n+     * @param log Ignite logger.\n+     */\n+    InlineObjectBytesDetector(int inlineSize, List<InlineIndexColumn> inlineCols, String tblName, String idxName,\n+        IgniteLogger log) {\n+        this.inlineSize = inlineSize;\n+        this.inlineCols = inlineCols;\n+        this.tblName = tblName;\n+        this.idxName = idxName;\n+        this.log = log;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public boolean apply(BPlusTree<H2Row, H2Row> tree, BPlusIO<H2Row> io,\n+        long pageAddr,\n+        int idx) throws IgniteCheckedException {\n+        H2Row r = tree.getRow(io, pageAddr, idx);\n+\n+        int off = io.offset(idx);\n+\n+        int fieldOff = 0;\n+\n+        boolean varLenPresents = false;\n+\n+        for (InlineIndexColumn ih : inlineCols) {\n+            if (fieldOff >= inlineSize)\n+                return false;\n+\n+            if (ih.type() != Value.JAVA_OBJECT) {\n+                if (ih.size() < 0)\n+                    varLenPresents = true;\n+\n+                fieldOff += ih.fullSize(pageAddr, off + fieldOff);\n+\n+                continue;\n+            }\n+\n+            Value val = r.getValue(ih.columnIndex());\n+\n+            if (val == ValueNull.INSTANCE)\n+                return false;\n+\n+            int type = PageUtils.getByte(pageAddr, off + fieldOff);\n+\n+            // We can have garbage in memory and need to compare data.\n+            if (type == Value.JAVA_OBJECT) {\n+                int len = PageUtils.getShort(pageAddr, off + fieldOff + 1);\n+\n+                len &= 0x7FFF;\n+\n+                byte[] originalObjBytes = val.getBytesNoCopy();\n+\n+                // Read size more then available space or more then origin length.\n+                if (len > inlineSize - fieldOff - 3 || len > originalObjBytes.length) {\n+                    inlineObjectSupportedDecision(false, \"length is big \" + len);\n+\n+                    return true;\n+                }\n+\n+                // Try compare byte by byte for fully or partial inlined object.\n+                byte[] inlineBytes = PageUtils.getBytes(pageAddr, off + fieldOff + 3, len);\n+\n+                if (!Arrays.equals(inlineBytes, originalObjBytes)) {\n+                    inlineObjectSupportedDecision(false, \"byte compare\");\n+\n+                    return true;\n+                }\n+\n+                inlineObjectSupportedDecision(true, len + \" bytes compared\");\n+\n+                return true;\n+            }\n+\n+            if (type == Value.UNKNOWN && varLenPresents) {\n+                // We can't guarantee in case unknown type and should check next row:\n+                // 1: long string, UNKNOWN for java object.\n+                // 2: short string, inlined java object\n+                return false;\n+            }\n+\n+            inlineObjectSupportedDecision(false, \"inline type \" + type);\n+\n+            return true;\n+        }\n+\n+        inlineObjectSupportedDecision(true, \"no java objects for inlining\");\n+\n+        return true;\n+    }\n+\n+    /**\n+     * @return {@code true} if inline object is supported on current tree.\n+     */\n+    public boolean inlineObjectSupported() {\n+        return inlineObjSupported;\n+    }\n+\n+    /**\n+     * Static analyze inline_size and inline columns set.\n+     * e.g.: indexed: (long, obj) and inline_size < 12.\n+     * In this case there is no space for inline object.\n+     *\n+     * @param inlineCols Inline columns.\n+     * @param inlineSize Inline size.\n+     *\n+     * @return {@code true} If the object may be inlined.\n+     */\n+    public static boolean objectMayBeInlined(int inlineSize, List<InlineIndexColumn> inlineCols) {\n+        int remainSize = inlineSize;\n+\n+        for (InlineIndexColumn ih : inlineCols) {\n+            if (ih.type() == Value.JAVA_OBJECT)\n+                break;\n+\n+            // Set size to 1 for variable length columns as that value can be set by user.\n+            remainSize -= ih.size() > 0 ? 1 + ih.size() : 1;\n+        }\n+\n+        // For old versions JO type was inlined as byte array.\n+        return remainSize >= 4;\n+    }\n+\n+    /**\n+     * @param inlineObjSupported {@code true} if inline object is supported on current tree.\n+     * @param reason Reason why has been made decision.\n+     */\n+    private void inlineObjectSupportedDecision(boolean inlineObjSupported, String reason) {\n+        this.inlineObjSupported = inlineObjSupported;\n+\n+        if (inlineObjSupported)\n+            log.warning(\"Index supports JAVA_OBJECT type inlining [tblName=\" + tblName + \", idxName=\" +\n+                idxName + \", reason='\" + reason + \"']\");\n+        else\n+            log.warning(\"Index doesn't support JAVA_OBJECT type inlining [tblName=\" + tblName + \", idxName=\" +\n+                idxName + \", reason='\" + reason + \"']\");\n+    }\n+}"
  }
]
