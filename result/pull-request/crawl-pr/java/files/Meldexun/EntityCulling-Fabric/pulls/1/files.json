[
  {
    "sha": "e03d274328f426b0ce11ea7611eb4b1f4cfa9512",
    "filename": "gradle.properties",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/gradle.properties",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/gradle.properties",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/gradle.properties?ref=2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71",
    "patch": "@@ -8,7 +8,7 @@ org.gradle.jvmargs=-Xmx1G\n \tloader_version=0.11.0\n \n # Mod Properties\n-\tmod_version = 1.0.2\n+\tmod_version = 1.0.3\n \tmaven_group = dev.tr7zw\n \tarchives_base_name = EntityCulling-Fabric\n "
  },
  {
    "sha": "e27250e79a42adc6aa9920bd91d300493e522de6",
    "filename": "src/main/java/dev/tr7zw/entityculling/EntityCullingMod.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/EntityCullingMod.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/EntityCullingMod.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/EntityCullingMod.java?ref=2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71",
    "patch": "@@ -15,6 +15,7 @@\n \tpublic Set<BlockEntityType<?>> unCullable = new HashSet<>();\n \tpublic boolean nametags = true;\n \tpublic boolean debug = false;\n+\tpublic boolean debugHitboxes = false;\n \tprivate CullTask cullTask = new CullTask(culling, unCullable);\n \n \t@Override"
  },
  {
    "sha": "cb1d9580ce78f7ea123db6b869c0c1f6c700f96b",
    "filename": "src/main/java/dev/tr7zw/entityculling/mixin/EntityMixin.java",
    "status": "removed",
    "additions": 0,
    "deletions": 47,
    "changes": 47,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/EntityMixin.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/EntityMixin.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/mixin/EntityMixin.java?ref=f0ed8d5b93819f11b5d493bb50dc11984b14fe74",
    "patch": "@@ -1,47 +0,0 @@\n-package dev.tr7zw.entityculling.mixin;\n-\n-import org.spongepowered.asm.mixin.Mixin;\n-import org.spongepowered.asm.mixin.Shadow;\n-import org.spongepowered.asm.mixin.injection.At;\n-import org.spongepowered.asm.mixin.injection.Inject;\n-import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n-\n-import net.minecraft.entity.Entity;\n-import net.minecraft.scoreboard.AbstractTeam;\n-import net.minecraft.scoreboard.Team;\n-import net.minecraft.text.HoverEvent;\n-import net.minecraft.text.Text;\n-\n-@Mixin(value = {Entity.class})\n-public abstract class EntityMixin {\n-\n-\tprivate Text cachedDisplayName = null;\n-\tprivate Text cachedName = null;\n-\tprivate AbstractTeam cachedTeam = null;\n-\t\n-\t@Inject(method = \"getDisplayName\", at = @At(\"HEAD\"), cancellable = true)\n-\tpublic Text getDisplayName(CallbackInfoReturnable<Text> info) {\n-\t\tif(cachedDisplayName == null || !cachedName.equals(getName()) || cachedTeam != getScoreboardTeam()) {\n-\t\t\tcachedName = getName();\n-\t\t\tcachedTeam = getScoreboardTeam();\n-\t\t\tcachedDisplayName = Team.modifyText(cachedTeam, cachedName)\n-\t\t\t\t\t.styled(style -> style.withHoverEvent(this.getHoverEvent()).withInsertion(this.getUuidAsString()));\n-\t\t}\n-\t\tinfo.setReturnValue(cachedDisplayName);\n-\t\tinfo.cancel();\n-\t\treturn cachedDisplayName;\n-\t}\n-\t\n-\t@Shadow\n-\tprotected abstract Text getName();\n-\t\n-\t@Shadow\n-\tprotected abstract AbstractTeam getScoreboardTeam();\n-\t\n-\t@Shadow\n-\tprotected abstract HoverEvent getHoverEvent();\n-\t\n-\t@Shadow\n-\tprotected abstract String getUuidAsString();\n-\t\n-}"
  },
  {
    "sha": "705f71180ac3f58be91d7b017584943843c9ee09",
    "filename": "src/main/java/dev/tr7zw/entityculling/mixin/PlayerEntityMixin.java",
    "status": "removed",
    "additions": 0,
    "deletions": 39,
    "changes": 39,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/PlayerEntityMixin.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/PlayerEntityMixin.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/mixin/PlayerEntityMixin.java?ref=f0ed8d5b93819f11b5d493bb50dc11984b14fe74",
    "patch": "@@ -1,39 +0,0 @@\n-package dev.tr7zw.entityculling.mixin;\n-\n-import org.spongepowered.asm.mixin.Mixin;\n-import org.spongepowered.asm.mixin.injection.At;\n-import org.spongepowered.asm.mixin.injection.Inject;\n-import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n-\n-import net.minecraft.entity.Entity;\n-import net.minecraft.entity.EntityType;\n-import net.minecraft.entity.player.PlayerEntity;\n-import net.minecraft.scoreboard.AbstractTeam;\n-import net.minecraft.scoreboard.Team;\n-import net.minecraft.text.Text;\n-import net.minecraft.world.World;\n-\n-@Mixin(PlayerEntity.class)\n-public abstract class PlayerEntityMixin extends Entity {\n-\n-\tpublic PlayerEntityMixin(EntityType<?> type, World world) {\n-\t\tsuper(type, world);\n-\t}\n-\n-\tprivate Text cachedDisplayName = null;\n-\tprivate Text cachedName = null;\n-\tprivate AbstractTeam cachedTeam = null;\n-\t\n-\t@Inject(method = \"getDisplayName\", at = @At(\"HEAD\"), cancellable = true)\n-\tpublic Text getDisplayName(CallbackInfoReturnable<Text> info) {\n-\t\tif(cachedDisplayName == null || !cachedName.equals(getName()) || cachedTeam != getScoreboardTeam()) {\n-\t\t\tcachedName = getName();\n-\t\t\tcachedTeam = getScoreboardTeam();\n-\t\t\tcachedDisplayName = Team.modifyText(cachedTeam, cachedName);\n-\t\t}\n-\t\tinfo.setReturnValue(cachedDisplayName);\n-\t\tinfo.cancel();\n-\t\treturn cachedDisplayName;\n-\t}\n-\t\n-}"
  },
  {
    "sha": "d57ed4739214251900814763eb38357d7ea0bebb",
    "filename": "src/main/java/dev/tr7zw/entityculling/mixin/TextMixin.java",
    "status": "removed",
    "additions": 0,
    "deletions": 25,
    "changes": 25,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/TextMixin.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/TextMixin.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/mixin/TextMixin.java?ref=f0ed8d5b93819f11b5d493bb50dc11984b14fe74",
    "patch": "@@ -1,25 +0,0 @@\n-package dev.tr7zw.entityculling.mixin;\n-\n-import org.spongepowered.asm.mixin.Mixin;\n-\n-import dev.tr7zw.entityculling.Drawer;\n-import dev.tr7zw.entityculling.access.CachedText;\n-import net.minecraft.text.LiteralText;\n-import net.minecraft.text.TranslatableText;\n-\n-@Mixin(value = { TranslatableText.class, LiteralText.class })\n-public class TextMixin implements CachedText {\n-\n-\tprivate Drawer drawer = null;\n-\t\n-\t@Override\n-\tpublic Drawer getDrawer() {\n-\t\treturn drawer;\n-\t}\n-\n-\t@Override\n-\tpublic void setDrawer(Drawer drawer) {\n-\t\tthis.drawer = drawer;\n-\t}\n-\n-}"
  },
  {
    "sha": "dc6de15a845d345791bdce8ed2e983c48b162962",
    "filename": "src/main/java/dev/tr7zw/entityculling/mixin/TextRendererMixin.java",
    "status": "removed",
    "additions": 0,
    "deletions": 83,
    "changes": 83,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/TextRendererMixin.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/f0ed8d5b93819f11b5d493bb50dc11984b14fe74/src/main/java/dev/tr7zw/entityculling/mixin/TextRendererMixin.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/mixin/TextRendererMixin.java?ref=f0ed8d5b93819f11b5d493bb50dc11984b14fe74",
    "patch": "@@ -1,83 +0,0 @@\n-package dev.tr7zw.entityculling.mixin;\n-\n-import java.util.function.Function;\n-\n-import org.spongepowered.asm.mixin.Mixin;\n-import org.spongepowered.asm.mixin.Shadow;\n-import org.spongepowered.asm.mixin.injection.At;\n-import org.spongepowered.asm.mixin.injection.Inject;\n-import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n-\n-import dev.tr7zw.entityculling.Drawer;\n-import dev.tr7zw.entityculling.access.CachedText;\n-import net.minecraft.client.font.FontStorage;\n-import net.minecraft.client.font.TextRenderer;\n-import net.minecraft.client.render.VertexConsumerProvider;\n-import net.minecraft.client.util.math.Vector3f;\n-import net.minecraft.text.OrderedText;\n-import net.minecraft.text.Text;\n-import net.minecraft.util.Identifier;\n-import net.minecraft.util.math.Matrix4f;\n-\n-@Mixin(TextRenderer.class)\n-public abstract class TextRendererMixin {\n-\n-\t@Shadow\n-\tprivate Function<Identifier, FontStorage> fontStorageAccessor;\n-\tprivate static final Vector3f FORWARD_SHIFT = new Vector3f(0.0f, 0.0f, 0.03f);\n-\n-\t@Inject(method = \"Lnet/minecraft/client/font/TextRenderer;draw(Lnet/minecraft/text/Text;FFIZLnet/minecraft/util/math/Matrix4f;Lnet/minecraft/client/render/VertexConsumerProvider;ZII)I\", at = @At(\"HEAD\"), cancellable = true)\n-\tpublic int draw(Text text, float x, float y, int color, boolean shadow, Matrix4f matrix,\n-\t\t\tVertexConsumerProvider vertexConsumers, boolean seeThrough, int backgroundColor, int light,\n-\t\t\tCallbackInfoReturnable<Integer> info) {\n-\t\tinfo.setReturnValue(this.drawInternal(text, x, y, color, shadow, matrix, vertexConsumers, seeThrough,\n-\t\t\t\tbackgroundColor, light));\n-\t\tinfo.cancel();\n-\t\treturn 0;\n-\t}\n-\n-\tprivate int drawInternal(Text text, float x, float y, int color, boolean shadow, Matrix4f matrix,\n-\t\t\tVertexConsumerProvider vertexConsumerProvider, boolean seeThrough, int backgroundColor, int light) {\n-\t\tcolor = tweakTransparency(color);\n-\t\tMatrix4f matrix4f = matrix.copy();\n-\t\tif (shadow) {\n-\t\t\tthis.drawLayer(text, x, y, color, true, matrix, vertexConsumerProvider, seeThrough, backgroundColor, light);\n-\t\t\tmatrix4f.addToLastColumn(FORWARD_SHIFT);\n-\t\t}\n-\t\tx = this.drawLayer(text, x, y, color, false, matrix4f, vertexConsumerProvider, seeThrough, backgroundColor,\n-\t\t\t\tlight);\n-\t\treturn (int) x + (shadow ? 1 : 0);\n-\t}\n-\n-\tprivate float drawLayer(Text text, float x, float y, int color, boolean shadow, Matrix4f matrix,\n-\t\t\tVertexConsumerProvider vertexConsumerProvider, boolean seeThrough, int underlineColor, int light) {\n-\t\tif (text instanceof CachedText) {\n-\t\t\tCachedText cached = (CachedText) text;\n-\t\t\tif (cached.getDrawer() != null) {\n-\t\t\t\tcached.getDrawer().drawAll(vertexConsumerProvider, matrix);\n-\t\t\t\treturn x;\n-\t\t\t}\n-\t\t\tDrawer drawer = new Drawer(fontStorageAccessor, x, y, underlineColor, shadow, seeThrough, light);\n-\t\t\ttext.asOrderedText().accept(drawer);\n-\t\t\tdrawer.drawLayer(underlineColor, x);\n-\t\t\t//System.out.println(\"uncached rendering \" + text.hashCode());\n-\t\t\tcached.setDrawer(drawer);\n-\t\t\tcached.getDrawer().drawAll(vertexConsumerProvider, matrix);\n-\t\t\treturn x;\n-\t\t}\n-\t\treturn drawLayer(text.asOrderedText(), x, y, color, shadow, matrix, vertexConsumerProvider, seeThrough,\n-\t\t\t\tunderlineColor, light);\n-\t}\n-\n-\t@Shadow\n-\tprotected abstract float drawLayer(OrderedText text, float x, float y, int color, boolean shadow, Matrix4f matrix,\n-\t\t\tVertexConsumerProvider vertexConsumerProvider, boolean seeThrough, int underlineColor, int light);\n-\n-\tprivate static int tweakTransparency(int argb) {\n-\t\tif ((argb & -67108864) == 0) {\n-\t\t\treturn argb | -16777216;\n-\t\t}\n-\t\treturn argb;\n-\t}\n-\n-}"
  },
  {
    "sha": "6c80c593fddf607ca1b9553b4106235b6ad3aef6",
    "filename": "src/main/java/dev/tr7zw/entityculling/mixin/WorldRendererMixin.java",
    "status": "modified",
    "additions": 0,
    "deletions": 24,
    "changes": 24,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/mixin/WorldRendererMixin.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/mixin/WorldRendererMixin.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/mixin/WorldRendererMixin.java?ref=2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71",
    "patch": "@@ -9,19 +9,15 @@\n import dev.tr7zw.entityculling.EntityCullingMod;\n import dev.tr7zw.entityculling.access.Cullable;\n import dev.tr7zw.entityculling.access.EntityRendererInter;\n-import dev.tr7zw.entityculling.occlusionculling.OcclusionCullingInstance;\n import net.minecraft.client.render.Camera;\n import net.minecraft.client.render.GameRenderer;\n import net.minecraft.client.render.LightmapTextureManager;\n-import net.minecraft.client.render.RenderLayer;\n-import net.minecraft.client.render.VertexConsumer;\n import net.minecraft.client.render.VertexConsumerProvider;\n import net.minecraft.client.render.WorldRenderer;\n import net.minecraft.client.render.entity.EntityRenderDispatcher;\n import net.minecraft.client.render.entity.EntityRenderer;\n import net.minecraft.client.util.math.MatrixStack;\n import net.minecraft.entity.Entity;\n-import net.minecraft.util.math.Box;\n import net.minecraft.util.math.MathHelper;\n import net.minecraft.util.math.Matrix4f;\n import net.minecraft.util.math.Vec3d;\n@@ -46,9 +42,6 @@ private void renderEntity(Entity entity, double cameraX, double cameraY, double\n \t\t\treturn;\n \t\t}\n \t\tif(cullable.isCulled()) {\n-\t\t\tif(EntityCullingMod.instance.debug) {\n-\t\t\t\trenderDebugPoints(matrices, vertexConsumers);\n-\t\t\t}\n \t\t\t@SuppressWarnings(\"unchecked\")\n \t\t\tEntityRenderer<Entity> entityRenderer = (EntityRenderer<Entity>) entityRenderDispatcher.getRenderer(entity);\n \t\t\t@SuppressWarnings(\"unchecked\")\n@@ -69,23 +62,6 @@ private void renderEntity(Entity entity, double cameraX, double cameraY, double\n \t\t\tinfo.cancel();\n \t\t\treturn;\n \t\t}\n-\t\trenderDebugPoints(matrices, vertexConsumers);\n-\t}\n-\t\n-\tprivate void renderDebugPoints(MatrixStack matrices, VertexConsumerProvider vertexConsumers) {\n-\t\tif(true)return;\n-\t\tif(EntityCullingMod.instance.debug) {\n-\t\t\tfor(Vec3d pos : OcclusionCullingInstance.targets) {\n-\t\t\t\tdrawBox(matrices, vertexConsumers.getBuffer(RenderLayer.getLines()), new Box(pos.x, pos.y, pos.z, pos.x+0.1, pos.y+0.1, pos.z+0.1), 1, 1, 1);\n-\t\t\t}\n-\t\t}\n-\t}\n-\t\n-\tprivate void drawBox(MatrixStack matrix, VertexConsumer vertices, Box box, float red, float green,\n-\t\t\tfloat blue) {\n-\t\tWorldRenderer.drawBox((MatrixStack) matrix, (VertexConsumer) vertices, (Box) box, (float) red, (float) green,\n-\t\t\t\t(float) blue, (float) 1.0f);\n \t}\n \t\n-\t\n }"
  },
  {
    "sha": "d261fb47918e9929bcd7f7b0c27a8277cdc1885c",
    "filename": "src/main/java/dev/tr7zw/entityculling/occlusionculling/MathUtil.java",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/occlusionculling/MathUtil.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/occlusionculling/MathUtil.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/occlusionculling/MathUtil.java?ref=2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71",
    "patch": "@@ -0,0 +1,23 @@\n+package dev.tr7zw.entityculling.occlusionculling;\n+\n+/**\n+ * Contains MathHelper methods\n+ *\n+ */\n+public class MathUtil {\n+\n+\tpublic static int floor(double d) {\n+\t\tint i = (int) d;\n+\t\treturn d < (double) i ? i - 1 : i;\n+\t}\n+\t\n+\tpublic static int fastFloor(double d) {\n+\t\treturn (int) (d + 1024.0) - 1024;\n+\t}\n+\t\n+\tpublic static int ceil(double d) {\n+\t\tint i = (int) d;\n+\t\treturn d > (double) i ? i + 1 : i;\n+\t}\n+\t\n+}"
  },
  {
    "sha": "8dfc1baac34ce444140351f3d6e45a6dfd3ad643",
    "filename": "src/main/java/dev/tr7zw/entityculling/occlusionculling/OcclusionCullingInstance.java",
    "status": "modified",
    "additions": 248,
    "deletions": 103,
    "changes": 351,
    "blob_url": "https://github.com/Meldexun/EntityCulling-Fabric/blob/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/occlusionculling/OcclusionCullingInstance.java",
    "raw_url": "https://github.com/Meldexun/EntityCulling-Fabric/raw/2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71/src/main/java/dev/tr7zw/entityculling/occlusionculling/OcclusionCullingInstance.java",
    "contents_url": "https://api.github.com/repos/Meldexun/EntityCulling-Fabric/contents/src/main/java/dev/tr7zw/entityculling/occlusionculling/OcclusionCullingInstance.java?ref=2e46fa7ba2b3a7fa0f4d616a6c5988f8ec21bf71",
    "patch": "@@ -2,78 +2,184 @@\n \n import java.util.Arrays;\n \n+import dev.tr7zw.entityculling.EntityCullingMod;\n import net.minecraft.block.BlockState;\n import net.minecraft.client.MinecraftClient;\n import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.particle.ParticleTypes;\n import net.minecraft.util.math.BlockPos;\n import net.minecraft.util.math.Vec3d;\n import net.minecraft.world.chunk.WorldChunk;\n \n public class OcclusionCullingInstance {\n \n-\tpublic static Vec3d[] targets = new Vec3d[5];\n-\t\n+\tprivate Vec3d[] targets = new Vec3d[8];\n+\tprivate MinecraftClient client = MinecraftClient.getInstance();\n+\n \tpublic boolean isAABBVisible(Vec3d aabbBlock, AxisAlignedBB aabb, Vec3d playerLoc, boolean entity) {\n \t\ttry {\n-\t\t\tdouble width = aabb.getWidth();\n-\t\t\tdouble height = aabb.getHeight();\n-\t\t\tdouble depth = aabb.getDepth();\n-\t\t\tVec3d center = entity ? aabbBlock.add(0, height/2, 0) : aabb.getAABBMiddle(aabbBlock);\n-\t\t\tVec3d centerXZMin = center.add(-width / 2, 0, depth / 2);\n-\t\t\tVec3d centerXMZMax = center.add(width / 2, 0, -depth / 2);\n-\t\t\tVec3d centerYMin = center.add(0, -height / 2, 0);\n-\t\t\tVec3d centerYMax = center.add(0, height / 2, 0);\n-\t\t\tVec3d centerZMXMin = center.add(-width / 2, 0, -depth / 2);\n-\t\t\tVec3d centerZXMax = center.add(width / 2, 0, depth / 2);\n-\t\t\t\n-\t\t\ttargets[0] = center.subtract(playerLoc);\n-\t\t\ttargets[1] = centerYMin.subtract(playerLoc);\n-\t\t\ttargets[2] = centerYMax.subtract(playerLoc);\n-\t\t\t\n-\t\t\tif(centerXZMin.squaredDistanceTo(playerLoc) > centerXMZMax.squaredDistanceTo(playerLoc)) {\n-\t\t\t\ttargets[3] = centerXZMin.subtract(playerLoc);\n-\t\t\t}else {\n-\t\t\t\ttargets[3] = centerXMZMax.subtract(playerLoc);\n+\t\t\tint blockPlayerX = MathUtil.floor(playerLoc.x);\n+\t\t\tint blockPlayerY = MathUtil.floor(playerLoc.y);\n+\t\t\tint blockPlayerZ = MathUtil.floor(playerLoc.z);\n+\t\t\tint maxX;\n+\t\t\tint maxY;\n+\t\t\tint maxZ;\n+\t\t\tint minX;\n+\t\t\tint minY;\n+\t\t\tint minZ;\n+\t\t\tif (entity) {\n+\t\t\t\tmaxX = MathUtil.ceil(aabb.maxx + 0.25) - blockPlayerX;\n+\t\t\t\tminX = MathUtil.floor(aabb.minx - 0.25) - blockPlayerX;\n+\t\t\t\tmaxY = MathUtil.ceil(aabb.maxy + 0.25) - blockPlayerY;\n+\t\t\t\tminY = MathUtil.floor(aabb.miny - 0.25) - blockPlayerY;\n+\t\t\t\tmaxZ = MathUtil.ceil(aabb.maxz + 0.25) - blockPlayerZ;\n+\t\t\t\tminZ = MathUtil.floor(aabb.minz - 0.25) - blockPlayerZ;\n+\t\t\t} else {\n+\t\t\t\tmaxX = MathUtil.ceil(aabbBlock.x + aabb.maxx + 0.25) - blockPlayerX;\n+\t\t\t\tminX = MathUtil.floor(aabbBlock.x + aabb.minx - 0.25) - blockPlayerX;\n+\t\t\t\tmaxY = MathUtil.ceil(aabbBlock.y + aabb.maxy + 0.25) - blockPlayerY;\n+\t\t\t\tminY = MathUtil.floor(aabbBlock.y + aabb.miny - 0.25) - blockPlayerY;\n+\t\t\t\tmaxZ = MathUtil.ceil(aabbBlock.z + aabb.maxz + 0.25) - blockPlayerZ;\n+\t\t\t\tminZ = MathUtil.floor(aabbBlock.z + aabb.minz - 0.25) - blockPlayerZ;\n \t\t\t}\n-\t\t\tif(centerZMXMin.squaredDistanceTo(playerLoc) > centerZXMax.squaredDistanceTo(playerLoc)) {\n-\t\t\t\ttargets[4] = centerZMXMin.subtract(playerLoc);\n-\t\t\t}else {\n-\t\t\t\ttargets[4] = centerZXMax.subtract(playerLoc);\n+\n+\t\t\tRelative relX = Relative.from(minX, maxX);\n+\t\t\tRelative relY = Relative.from(minY, maxY);\n+\t\t\tRelative relZ = Relative.from(minZ + 1, maxZ + 1);\n+\t\t\tif (minX <= 0 && maxX > 0 && minY <= 0 && maxY >= 0 && minZ < 0 && maxZ >= 0) {\n+\t\t\t\treturn true; // We are inside of the AABB, don't cull\n \t\t\t}\n-\t\t\tif(isVisible(playerLoc, targets))return true;\n \n+\t\t\tVec3d[] blocks = new Vec3d[(maxX - minX + 1) * (maxY - minY + 1) * (maxZ - minZ + 1)];\n+\t\t\tboolean[][] faceEdgeData = new boolean[(maxX - minX + 1) * (maxY - minY + 1) * (maxZ - minZ + 1)][];\n+\t\t\tint slot = 0;\n+\n+\t\t\tboolean[] onFaceEdge = new boolean[6];\n+\t\t\tfor (int x = minX; x < maxX; x++) {\n+\t\t\t\tonFaceEdge[0] = x == minX;\n+\t\t\t\tonFaceEdge[1] = x == maxX - 1;\n+\t\t\t\tfor (int y = minY; y < maxY; y++) {\n+\t\t\t\t\tonFaceEdge[2] = y == minY;\n+\t\t\t\t\tonFaceEdge[3] = y == maxY - 1;\n+\t\t\t\t\tfor (int z = minZ; z < maxZ; z++) {\n+\t\t\t\t\t\tint cVal = getCacheValue(x, y, z);\n+\t\t\t\t\t\tif (cVal == 1) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (cVal == 0) {\n+\t\t\t\t\t\t\tonFaceEdge[4] = z == minZ;\n+\t\t\t\t\t\t\tonFaceEdge[5] = z == maxZ - 1;\n+\t\t\t\t\t\t\tif ((onFaceEdge[0] && relX == Relative.POSITIVE)\n+\t\t\t\t\t\t\t\t\t|| (onFaceEdge[1] && relX == Relative.NEGATIVE)\n+\t\t\t\t\t\t\t\t\t|| (onFaceEdge[2] && relY == Relative.POSITIVE)\n+\t\t\t\t\t\t\t\t\t|| (onFaceEdge[3] && relY == Relative.NEGATIVE)\n+\t\t\t\t\t\t\t\t\t|| (onFaceEdge[4] && relZ == Relative.POSITIVE)\n+\t\t\t\t\t\t\t\t\t|| (onFaceEdge[5] && relZ == Relative.NEGATIVE)) {\n+\t\t\t\t\t\t\t\tblocks[slot] = new Vec3d(x, y, z);\n+\t\t\t\t\t\t\t\tfaceEdgeData[slot] = Arrays.copyOf(onFaceEdge, 6);\n+\t\t\t\t\t\t\t\tslot++;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < slot; i++) {\n+\t\t\t\tif (isVoxelVisible(playerLoc, blocks[i], faceEdgeData[i],\n+\t\t\t\t\t\tEntityCullingMod.instance.debugHitboxes && !entity)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\treturn false;\n \n \t\t} catch (Exception exception) {\n \t\t\texception.printStackTrace();\n \t\t}\n \t\treturn true;\n \t}\n-\t\n+\n+\t// -1 = invalid location, 0 = not checked yet, 1 = visible, 2 = blocked\n+\tprivate int getCacheValue(int x, int y, int z) {\n+\t\tint maxX = (int) Math.abs(x);\n+\t\tint maxY = (int) Math.abs(y);\n+\t\tint maxZ = (int) Math.abs(z);\n+\n+\t\tif (maxX > reach - 2 || maxY > reach - 2 || maxZ > reach - 2)\n+\t\t\treturn -1;\n+\n+\t\t{// check if target is already known\n+\t\t\tint cx = (int) MathUtil.fastFloor(x + reach);\n+\t\t\tint cy = (int) MathUtil.fastFloor(y + reach);\n+\t\t\tint cz = (int) MathUtil.fastFloor(z + reach);\n+\t\t\tint keyPos = cx + cy * (reach * 2) + cz * (reach * 2) * (reach * 2);\n+\t\t\tint entry = keyPos / 4;\n+\t\t\tint offset = (keyPos % 4) * 2;\n+\t\t\tint cVal = cache[entry] >> offset & 3;\n+\t\t\treturn cVal;\n+\t\t}\n+\t}\n+\n+\tprivate boolean isVoxelVisible(Vec3d playerLoc, Vec3d position, boolean[] faceEdgeData, boolean showDebug) {\n+\t\tint targetSize = 0;\n+\t\t// boolean onMinX = faceEdgeData[0];\n+\t\t// boolean onMaxX = faceEdgeData[1];\n+\t\t// boolean onMinY = faceEdgeData[2];\n+\t\t// boolean onMaxY = faceEdgeData[3];\n+\t\t// boolean onMinZ = faceEdgeData[4];\n+\t\t// boolean onMaxZ = faceEdgeData[5];\n+\t\t// main points for all faces\n+\t\tif (faceEdgeData[0] || faceEdgeData[4] || faceEdgeData[2]) {\n+\t\t\ttargets[targetSize++] = position;\n+\t\t}\n+\t\tif (faceEdgeData[1]) {\n+\t\t\ttargets[targetSize++] = position.add(0.95, 0, 0);\n+\t\t}\n+\t\tif (faceEdgeData[3]) {\n+\t\t\ttargets[targetSize++] = position.add(0, 0.95, 0);\n+\t\t}\n+\t\tif (faceEdgeData[5]) {\n+\t\t\ttargets[targetSize++] = position.add(0, 0, 0.95);\n+\t\t}\n+\t\t// Extra corner points\n+\t\tif ((faceEdgeData[4] && faceEdgeData[1] && faceEdgeData[3]) && (faceEdgeData[1] && faceEdgeData[3])) {\n+\t\t\ttargets[targetSize++] = position.add(0.95, 0.95, 0);\n+\t\t}\n+\t\tif ((faceEdgeData[0] && faceEdgeData[5] && faceEdgeData[3]) || (faceEdgeData[5] && faceEdgeData[3])) {\n+\t\t\ttargets[targetSize++] = position.add(0, 0.95, 0.95);\n+\t\t}\n+\t\tif (faceEdgeData[5] && faceEdgeData[1]) {\n+\t\t\ttargets[targetSize++] = position.add(0.95, 0, 0.95);\n+\t\t}\n+\t\tif (faceEdgeData[1] && faceEdgeData[3] && faceEdgeData[5]) {\n+\t\t\ttargets[targetSize++] = position.add(0.95, 0.95, 0.95);\n+\t\t}\n+\n+\t\tif (showDebug) {\n+\t\t\tfor (int i = 0; i < targetSize; i++) {\n+\t\t\t\tVec3d target = targets[i];\n+\t\t\t\tclient.world.addImportantParticle(ParticleTypes.HAPPY_VILLAGER, true, ((int) playerLoc.x) + target.x,\n+\t\t\t\t\t\t((int) playerLoc.y) + target.y, ((int) playerLoc.z) + target.z, 0, 0, 0);\n+\t\t\t}\n+\t\t}\n+\t\treturn isVisible(playerLoc, targets, targetSize);\n+\t}\n+\n \tprivate final int reach = 64;\n-\tprivate final byte[] cache = new byte[((reach*2)*(reach*2)*(reach*2))/4];\n-\t\n+\tprivate final byte[] cache = new byte[((reach * 2) * (reach * 2) * (reach * 2)) / 4];\n+\n \tpublic void resetCache() {\n-\t\tArrays.fill(cache, (byte)0);\n+\t\tArrays.fill(cache, (byte) 0);\n \t}\n-\t\n+\n \t/**\n \t * returns the grid cells that intersect with this Vec3d<br>\n \t * <a href=\n \t * \"http://playtechs.blogspot.de/2007/03/raytracing-on-grid.html\">http://playtechs.blogspot.de/2007/03/raytracing-on-grid.html</a>\n+\t * \n+\t * Caching assumes that all Vec3d's are inside the same block\n \t */\n-\tprivate boolean isVisible(Vec3d start, Vec3d[] targets) {\n-\t\tint maxX = 0;\n-\t\tint maxY = 0;\n-\t\tint maxZ = 0;\n-\t\tfor(int i = 0; i < targets.length; i++) {\n-\t\t\tmaxX = Math.max(maxX, (int)Math.abs(targets[i].x));\n-\t\t\tmaxY = Math.max(maxY, (int)Math.abs(targets[i].y));\n-\t\t\tmaxZ = Math.max(maxZ, (int)Math.abs(targets[i].z));\n-\t\t}\n-\t\tif(maxX > reach - 2 || maxY > reach - 2 || maxZ > reach - 2)return false;\n-\t\t\n-\t\tfor(int v = 0; v < targets.length; v++) {\n+\tprivate boolean isVisible(Vec3d start, Vec3d[] targets, int size) {\n+\n+\t\tfor (int v = 0; v < size; v++) {\n \t\t\tVec3d target = targets[v];\n \t\t\t// coordinates of start and target point\n \t\t\tdouble x0 = start.getX();\n@@ -82,132 +188,157 @@ private boolean isVisible(Vec3d start, Vec3d[] targets) {\n \t\t\tdouble x1 = x0 + target.getX();\n \t\t\tdouble y1 = y0 + target.getY();\n \t\t\tdouble z1 = z0 + target.getZ();\n-\t\n+\n \t\t\t// horizontal and vertical cell amount spanned\n \t\t\tdouble dx = Math.abs(x1 - x0);\n \t\t\tdouble dy = Math.abs(y1 - y0);\n \t\t\tdouble dz = Math.abs(z1 - z0);\n-\t\n+\n \t\t\t// start cell coordinate\n-\t\t\tint x = (int) Math.floor(x0);\n-\t\t\tint y = (int) Math.floor(y0);\n-\t\t\tint z = (int) Math.floor(z0);\n-\t\n+\t\t\tint x = (int) MathUtil.floor(x0);\n+\t\t\tint y = (int) MathUtil.floor(y0);\n+\t\t\tint z = (int) MathUtil.floor(z0);\n+\n \t\t\t// distance between horizontal intersection points with cell border as a\n \t\t\t// fraction of the total Vec3d length\n \t\t\tdouble dt_dx = 1f / dx;\n \t\t\t// distance between vertical intersection points with cell border as a fraction\n \t\t\t// of the total Vec3d length\n \t\t\tdouble dt_dy = 1f / dy;\n \t\t\tdouble dt_dz = 1f / dz;\n-\t\n+\n \t\t\t// total amount of intersected cells\n \t\t\tint n = 1;\n-\t\n+\n \t\t\t// 1, 0 or -1\n \t\t\t// determines the direction of the next cell (horizontally / vertically)\n \t\t\tint x_inc, y_inc, z_inc;\n \t\t\t// the distance to the next horizontal / vertical intersection point with a cell\n \t\t\t// border as a fraction of the total Vec3d length\n \t\t\tdouble t_next_y, t_next_x, t_next_z;\n-\t\n+\n \t\t\tif (dx == 0f) {\n \t\t\t\tx_inc = 0;\n \t\t\t\tt_next_x = dt_dx; // don't increment horizontally because the Vec3d is perfectly vertical\n \t\t\t} else if (x1 > x0) {\n \t\t\t\tx_inc = 1; // target point is horizontally greater than starting point so increment every\n \t\t\t\t\t\t\t// step by 1\n-\t\t\t\tn += (int) Math.floor(x1) - x; // increment total amount of intersecting cells\n-\t\t\t\tt_next_x = (float) ((Math.floor(x0) + 1 - x0) * dt_dx); // calculate the next horizontal intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += (int) MathUtil.floor(x1) - x; // increment total amount of intersecting cells\n+\t\t\t\tt_next_x = (float) ((MathUtil.floor(x0) + 1 - x0) * dt_dx); // calculate the next horizontal\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// intersection\n+\t\t\t\t// point based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t} else {\n \t\t\t\tx_inc = -1; // target point is horizontally smaller than starting point so reduce every step\n \t\t\t\t\t\t\t// by 1\n-\t\t\t\tn += x - (int) Math.floor(x1); // increment total amount of intersecting cells\n-\t\t\t\tt_next_x = (float) ((x0 - Math.floor(x0)) * dt_dx); // calculate the next horizontal intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += x - (int) MathUtil.floor(x1); // increment total amount of intersecting cells\n+\t\t\t\tt_next_x = (float) ((x0 - MathUtil.floor(x0)) * dt_dx); // calculate the next horizontal\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// intersection point\n+\t\t\t\t// based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t}\n-\t\n+\n \t\t\tif (dy == 0f) {\n \t\t\t\ty_inc = 0;\n \t\t\t\tt_next_y = dt_dy; // don't increment vertically because the Vec3d is perfectly horizontal\n \t\t\t} else if (y1 > y0) {\n \t\t\t\ty_inc = 1; // target point is vertically greater than starting point so increment every\n \t\t\t\t\t\t\t// step by 1\n-\t\t\t\tn += (int) Math.floor(y1) - y; // increment total amount of intersecting cells\n-\t\t\t\tt_next_y = (float) ((Math.floor(y0) + 1 - y0) * dt_dy); // calculate the next vertical intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += (int) MathUtil.floor(y1) - y; // increment total amount of intersecting cells\n+\t\t\t\tt_next_y = (float) ((MathUtil.floor(y0) + 1 - y0) * dt_dy); // calculate the next vertical\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// intersection\n+\t\t\t\t// point based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t} else {\n \t\t\t\ty_inc = -1; // target point is vertically smaller than starting point so reduce every step\n \t\t\t\t\t\t\t// by 1\n-\t\t\t\tn += y - (int) Math.floor(y1); // increment total amount of intersecting cells\n-\t\t\t\tt_next_y = (float) ((y0 - Math.floor(y0)) * dt_dy); // calculate the next vertical intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += y - (int) MathUtil.floor(y1); // increment total amount of intersecting cells\n+\t\t\t\tt_next_y = (float) ((y0 - MathUtil.floor(y0)) * dt_dy); // calculate the next vertical intersection\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n+\t\t\t\t// based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t}\n-\t\n+\n \t\t\tif (dz == 0f) {\n \t\t\t\tz_inc = 0;\n \t\t\t\tt_next_z = dt_dz; // don't increment vertically because the Vec3d is perfectly horizontal\n \t\t\t} else if (z1 > z0) {\n \t\t\t\tz_inc = 1; // target point is vertically greater than starting point so increment every\n \t\t\t\t\t\t\t// step by 1\n-\t\t\t\tn += (int) Math.floor(z1) - z; // increment total amount of intersecting cells\n-\t\t\t\tt_next_z = (float) ((Math.floor(z0) + 1 - z0) * dt_dz); // calculate the next vertical intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += (int) MathUtil.floor(z1) - z; // increment total amount of intersecting cells\n+\t\t\t\tt_next_z = (float) ((MathUtil.floor(z0) + 1 - z0) * dt_dz); // calculate the next vertical\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// intersection\n+\t\t\t\t// point based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t} else {\n \t\t\t\tz_inc = -1; // target point is vertically smaller than starting point so reduce every step\n \t\t\t\t\t\t\t// by 1\n-\t\t\t\tn += z - (int) Math.floor(z1); // increment total amount of intersecting cells\n-\t\t\t\tt_next_z = (float) ((z0 - Math.floor(z0)) * dt_dz); // calculate the next vertical intersection point based on the position inside\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the first cell\n+\t\t\t\tn += z - (int) MathUtil.floor(z1); // increment total amount of intersecting cells\n+\t\t\t\tt_next_z = (float) ((z0 - MathUtil.floor(z0)) * dt_dz); // calculate the next vertical intersection\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// point\n+\t\t\t\t// based on the position inside\n+\t\t\t\t// the first cell\n \t\t\t}\n-\t\n-\t\t\tboolean finished =stepRay(start, x0, y0, z0, x, y, z, dt_dx, dt_dy, dt_dz, n, x_inc, y_inc, z_inc, t_next_y, t_next_x,\n-\t\t\t\t\tt_next_z);\n-\t\t\tif(finished) {\n+\n+\t\t\tboolean finished = stepRay(start, x, y, z, x, y, z, dt_dx, dt_dy, dt_dz, n, x_inc, y_inc, z_inc,\n+\t\t\t\t\tt_next_y, t_next_x, t_next_z);\n+\t\t\tif (finished) {\n+\t\t\t\tcacheResult(targets[0], true);\n \t\t\t\treturn true;\n \t\t\t}\n \t\t}\n+\t\tcacheResult(targets[0], false);\n \t\treturn false;\n \t}\n-\t\n-\tprivate boolean stepRay(Vec3d start, double x0, double y0, double z0, int x, int y,\n-\t\t\tint z, double dt_dx, double dt_dy, double dt_dz, int n, int x_inc, int y_inc, int z_inc, double t_next_y,\n-\t\t\tdouble t_next_x, double t_next_z) {\n+\n+\tprivate void cacheResult(Vec3d vector, boolean result) {\n+\t\tint cx = (int) MathUtil.fastFloor(vector.x + reach);\n+\t\tint cy = (int) MathUtil.fastFloor(vector.y + reach);\n+\t\tint cz = (int) MathUtil.fastFloor(vector.z + reach);\n+\t\tint keyPos = cx + cy * (reach * 2) + cz * (reach * 2) * (reach * 2);\n+\t\tint entry = keyPos / 4;\n+\t\tint offset = (keyPos % 4) * 2;\n+\t\tif (result) {\n+\t\t\tcache[entry] |= 1 << offset;\n+\t\t} else {\n+\t\t\tcache[entry] |= 1 << offset + 1;\n+\t\t}\n+\t}\n+\n+\tprivate boolean stepRay(Vec3d start, int x0, int y0, int z0, int x, int y, int z, double dt_dx,\n+\t\t\tdouble dt_dy, double dt_dz, int n, int x_inc, int y_inc, int z_inc, double t_next_y, double t_next_x,\n+\t\t\tdouble t_next_z) {\n \t\tint chunkX = 0;\n \t\tint chunkZ = 0;\n \t\tWorldChunk snapshot = null;\n-\t\t@SuppressWarnings(\"resource\")\n-\t\tClientWorld world =  MinecraftClient.getInstance().world;\n-\t\t\n+\t\tClientWorld world = client.world;\n+\n \t\t// iterate through all intersecting cells (n times)\n-\t\tfor (; n > 0; n--) {\n-\t\t\tint cx = (int) Math.floor((x0 - x) + reach);\n-\t\t\tint cy = (int) Math.floor((y0 - y) + reach);\n-\t\t\tint cz = (int) Math.floor((z0 - z) + reach);\n-\n-\t\t\tint keyPos = cx + cy*(reach*2) + cz*(reach*2)*(reach*2);\n-\t\t\tint entry = keyPos/4;\n-\t\t\tint offset = (keyPos%4)*2;\n+\t\tfor (; n > 1; n--) { // n-1 times because we don't want to check the last block\n+\t\t\tint cx = (int) x - x0 + reach;\n+\t\t\tint cy = (int) y - y0 + reach;\n+\t\t\tint cz = (int) z - z0 + reach;\n+\n+\t\t\tint keyPos = cx + cy * (reach * 2) + cz * (reach * 2) * (reach * 2);\n+\t\t\tint entry = keyPos / 4;\n+\t\t\tint offset = (keyPos % 4) * 2;\n \t\t\tint cVal = cache[entry] >> offset & 3;\n-\t\t\tif(cVal == 2) {\n+\t\t\tif (cVal == 2) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tif(cVal == 0) {\n+\t\t\tif (cVal == 0) {\n \t\t\t\t// save current cell\n-\t\t\t\t//Vec3d cp = new Vec3d(x, y, z);\n-\t\t\t\tint tchunkX = (int) Math.floor(x / 16d);\n-\t\t\t\tint tchunkZ = (int) Math.floor(z / 16d);\n-\t\t\t\tif(snapshot == null || chunkX != tchunkX || chunkZ != tchunkZ) {\n+\t\t\t\tint tchunkX = (int) MathUtil.fastFloor(x / 16d);\n+\t\t\t\tint tchunkZ = (int) MathUtil.fastFloor(z / 16d);\n+\t\t\t\tif (snapshot == null || chunkX != tchunkX || chunkZ != tchunkZ) {\n \t\t\t\t\tchunkX = tchunkX;\n \t\t\t\t\tchunkZ = tchunkZ;\n-\t\t\t\t\tsnapshot = world.getChunk(chunkX, chunkZ);//CullingPlugin.instance.blockChangeListener.cachedChunkSnapshots.get(cc);\n-\t\t\t\t\tif(snapshot == null) {\n-\t\t\t\t\t\t//cache[cx][cy][cz] = 2;\n+\t\t\t\t\tsnapshot = world.getChunk(chunkX, chunkZ);\n+\t\t\t\t\tif (snapshot == null) {\n \t\t\t\t\t\treturn false;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t\tint relativeX = x % 16;\n \t\t\t\tif (relativeX < 0) {\n \t\t\t\t\trelativeX = 16 + relativeX;\n@@ -230,14 +361,15 @@ private boolean stepRay(Vec3d start, double x0, double y0, double z0, int x, int\n \t\t\t\t}\n \t\t\t\tBlockPos pos = new BlockPos(x, y, z);\n \t\t\t\tBlockState state = snapshot.getBlockState(pos);\n-\t\t\t\tif(state.isOpaqueFullCube(world, pos)) {\n+\t\t\t\tif (state.isOpaqueFullCube(world, pos)) {\n \t\t\t\t\tcache[entry] |= 1 << offset + 1;\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t\tcache[entry] |= 1 << offset;\n \t\t\t}\n \n-\t\t\tif (t_next_y < t_next_x && t_next_y < t_next_z) { // next cell is upwards/downwards because the distance to the next vertical\n+\t\t\tif (t_next_y < t_next_x && t_next_y < t_next_z) { // next cell is upwards/downwards because the distance to\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the next vertical\n \t\t\t\t// intersection point is smaller than to the next horizontal intersection point\n \t\t\t\ty += y_inc; // move up/down\n \t\t\t\tt_next_y += dt_dy; // update next vertical intersection point\n@@ -253,4 +385,17 @@ private boolean stepRay(Vec3d start, double x0, double y0, double z0, int x, int\n \t\treturn true;\n \t}\n \n+\tprivate enum Relative {\n+\t\tINSIDE, POSITIVE, NEGATIVE;\n+\n+\t\tpublic static Relative from(int min, int max) {\n+\t\t\tif (max > 0 && min > 0) {\n+\t\t\t\treturn POSITIVE;\n+\t\t\t} else if (min < 0 && max <= 0) {\n+\t\t\t\treturn NEGATIVE;\n+\t\t\t}\n+\t\t\treturn INSIDE;\n+\t\t}\n+\t}\n+\n }"
  }
]
