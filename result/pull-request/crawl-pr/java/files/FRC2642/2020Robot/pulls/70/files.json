[
  {
    "sha": "2f14611e3c290ec78f42b808be20eb50cc19d7c2",
    "filename": "src/main/java/frc/robot/Constants.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/FRC2642/2020Robot/blob/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/Constants.java",
    "raw_url": "https://github.com/FRC2642/2020Robot/raw/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/Constants.java",
    "contents_url": "https://api.github.com/repos/FRC2642/2020Robot/contents/src/main/java/frc/robot/Constants.java?ref=042a6e4aed24434271b647df10e9663a9a4231f9",
    "patch": "@@ -120,6 +120,13 @@\n \n     public static final double kArmAngleConversionFactor = 10.0;\n \n+\n+   /**encoder constants as of 2/26\n+    * inch = .6883-\n+    * foot = 8.26 \n+    */\n+\n+\n     /**\n      * ROBOT CONSTANTS\n      */"
  },
  {
    "sha": "ef9c606247019a23f5d61feb2bb0b5f7d5f25610",
    "filename": "src/main/java/frc/robot/Robot.java",
    "status": "modified",
    "additions": 39,
    "deletions": 26,
    "changes": 65,
    "blob_url": "https://github.com/FRC2642/2020Robot/blob/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/Robot.java",
    "raw_url": "https://github.com/FRC2642/2020Robot/raw/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/Robot.java",
    "contents_url": "https://api.github.com/repos/FRC2642/2020Robot/contents/src/main/java/frc/robot/Robot.java?ref=042a6e4aed24434271b647df10e9663a9a4231f9",
    "patch": "@@ -67,6 +67,8 @@ For ekatni (intake backwards)\n \n import static frc.robot.util.GeneralUtil.generateAuto;\n \n+import com.kauailabs.navx.frc.AHRS;\n+\n import org.opencv.core.Point;\n import org.opencv.core.Rect;\n import org.opencv.imgproc.Imgproc;\n@@ -88,7 +90,7 @@ For ekatni (intake backwards)\n import edu.wpi.first.wpilibj2.command.CommandScheduler;\n import frc.robot.util.JevoisDriver;\n import frc.robot.RobotContainer;\n-import frc.robot.commands.autoCommands.AutoCommandGroup;\n+import frc.robot.subsystems.SwerveDriveSubsystem;\n \n /**\n  * The VM is configured to automatically run this class, and to call the\n@@ -99,8 +101,10 @@ For ekatni (intake backwards)\n  */\n public class Robot extends TimedRobot {\n \n-  public Command m_autonomousCommand;\n-  public RobotContainer robotContainer;\n+  private Command m_autonomousCommand;\n+  private RobotContainer robotContainer;\n+  AHRS ahrs;\n+  public static final SwerveDriveSubsystem drive = new SwerveDriveSubsystem();\n \n /*   public VideoSource camera;\n   public VisionPipeline cameraPipeline;\n@@ -114,26 +118,27 @@ For ekatni (intake backwards)\n   NetworkTable table;\n \n   // Jevois driver\n-  JevoisDriver jevoisCam;\n+ // JevoisDriver jevoisCam;\n  \n   public PowerDistributionPanel pdp;\n   \n   public static Command autoCommand;\n \n-  UsbCamera intakeCam;\n-  UsbCamera shooterCam;\n+ // UsbCamera intakeCam;\n+ // UsbCamera shooterCam;\n \n   VideoSink camServer;\n   \n   @Override\n   public void robotInit() {\n   \n     robotContainer = new RobotContainer();\n-    jevoisCam = new JevoisDriver();\n+    //jevoisCam = new JevoisDriver();\n     pdp = new PowerDistributionPanel();\n \n-    autoCommand = generateAuto();\n-\n+    m_autonomousCommand = generateAuto();\n+    \n+/*\n     intakeCam = CameraServer.getInstance().startAutomaticCapture(0);\n     shooterCam = CameraServer.getInstance().startAutomaticCapture(1);\n \n@@ -149,7 +154,7 @@ public void robotInit() {\n     camServer = CameraServer.getInstance().getServer();\n \n     //table = NetworkTableInstance.getDefault().getTable(\"GRIP/mycontoursReport\");\n-\n+*/\n   }\n  \n  /*  public void setUpCamera() {\n@@ -204,43 +209,51 @@ public void robotPeriodic() {\n \n     //SmartDashboard.putNumber(\"mag vel\", RobotContainer.magazine.getVelocity());\n     \n-   /*  SmartDashboard.putNumber(\"fl\", RobotContainer.drive.frontLeftModule.getModulePosition());\n-    SmartDashboard.putNumber(\"fr\", RobotContainer.drive.frontRightModule.getModulePosition());\n-    SmartDashboard.putNumber(\"bl\", RobotContainer.drive.backLeftModule.getModulePosition());\n-    SmartDashboard.putNumber(\"br\", RobotContainer.drive.backRightModule.getModulePosition());  */\n-\n+   \n     //SmartDashboard.putBoolean(\"isShoot\", RobotContainer.shooter.isAtTargetVelocity());\n     //SmartDashboard.putBoolean(\"isArm\", RobotContainer.arm.isArmAtGoal());\n     SmartDashboard.putBoolean(\"isMagReady\", RobotContainer.magazine.isMagReadyToShoot());\n-    SmartDashboard.putNumber(\"driveEncoder\", RobotContainer.drive.getDrivePosition());\n-\n-\n+    //SmartDashboard.putNumber(\"bl\", RobotContainer.drive.backLeftModule.getModulePosition());\n+    SmartDashboard.putNumber(\"blangle\", RobotContainer.drive.backLeftModule.getAbsoluteAngleEncoder());\n+    SmartDashboard.putNumber(\"brangle\", RobotContainer.drive.backRightModule.getAbsoluteAngleEncoder());\n+    SmartDashboard.putNumber(\"flangle\", RobotContainer.drive.frontLeftModule.getAbsoluteAngleEncoder());\n+    SmartDashboard.putNumber(\"frangle\", RobotContainer.drive.frontRightModule.getAbsoluteAngleEncoder());\n+\n+    SmartDashboard.putNumber(\"relblangle\", RobotContainer.drive.backLeftModule.getRelativeAngleEncoder());\n+    SmartDashboard.putNumber(\"relbrangle\", RobotContainer.drive.backRightModule.getRelativeAngleEncoder());\n+    SmartDashboard.putNumber(\"relflangle\", RobotContainer.drive.frontLeftModule.getRelativeAngleEncoder());\n+    SmartDashboard.putNumber(\"relfrangle\", RobotContainer.drive.frontRightModule.getRelativeAngleEncoder());\n+\n+    SmartDashboard.putNumber(\"xDisplacement\", ahrs.getDisplacementX());\n+    SmartDashboard.putNumber(\"yDisplacement\", ahrs.getDisplacementY());\n+    \n+    \n     //SmartDashboard.putString(\"targetColor\", value)\n   }\n \n   @Override\n   public void disabledInit() {\n+    ahrs.resetDisplacement();\n   }\n \n+\n   @Override\n   public void disabledPeriodic() {\n   }\n \n   @Override\n   public void autonomousInit() {\n     \n-    //m_autonomousCommand = robotContainer.getAutonomousCommand();\n-\n-    m_autonomousCommand = new AutoCommandGroup();\n+    m_autonomousCommand = robotContainer.getAutonomousCommand();\n \n     if (m_autonomousCommand != null) {\n       m_autonomousCommand.schedule();\n-    } \n-    \n-  }\n+       } \n+    }\n \n   @Override\n   public void autonomousPeriodic() {\n+  \n   }\n \n   @Override\n@@ -254,13 +267,13 @@ public void teleopInit() {\n \n   @Override\n   public void teleopPeriodic() {\n-\n+/*\n     if(RobotContainer.driveController.getTriggerAxis(Hand.kLeft) > .5){\n       camServer.setSource(intakeCam);\n     } else {\n       camServer.setSource(shooterCam);\n     }\n-\n+*/\n     \n \n     /* double[] defaultValue = new double[0];"
  },
  {
    "sha": "ac3339da8ec7b9494b3b77fc522547ef4f8c72eb",
    "filename": "src/main/java/frc/robot/commands/autoCommands/InchesDrive.java",
    "status": "modified",
    "additions": 6,
    "deletions": 2,
    "changes": 8,
    "blob_url": "https://github.com/FRC2642/2020Robot/blob/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/commands/autoCommands/InchesDrive.java",
    "raw_url": "https://github.com/FRC2642/2020Robot/raw/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/commands/autoCommands/InchesDrive.java",
    "contents_url": "https://api.github.com/repos/FRC2642/2020Robot/contents/src/main/java/frc/robot/commands/autoCommands/InchesDrive.java?ref=042a6e4aed24434271b647df10e9663a9a4231f9",
    "patch": "@@ -31,11 +31,15 @@ public InchesDrive(double ticks) {\n     addRequirements(drive);\n     //drive.drive(ticks, 0.0, 0.0);\n     //sets timeout\n+\n+    //homie, hear me out, full send, no speed regulation\n+    //idk how the ticks are gonna work tbh\n+\n     if (drive.getDrivePosition() < ticks) {\n-      drive.drive(ticks, 0,0);\n+      drive.setWheelsStraight();\n     }\n     else if (drive.getDrivePosition() >= ticks) {\n-      drive.drive(0,0,0);\n+      drive.lockWheels();\n     }\n     \n "
  },
  {
    "sha": "8a6f0a599ca4bdff9cd9ca1d6bb51f210b2ded5c",
    "filename": "src/main/java/frc/robot/commands/autoCommands/TurnDrive.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/FRC2642/2020Robot/blob/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/commands/autoCommands/TurnDrive.java",
    "raw_url": "https://github.com/FRC2642/2020Robot/raw/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/commands/autoCommands/TurnDrive.java",
    "contents_url": "https://api.github.com/repos/FRC2642/2020Robot/contents/src/main/java/frc/robot/commands/autoCommands/TurnDrive.java?ref=042a6e4aed24434271b647df10e9663a9a4231f9",
    "patch": "@@ -10,7 +10,7 @@\n \n \n import frc.robot.subsystems.SwerveDriveSubsystem;\n-import frc.robot.util.SwerveModule;\n+import frc.robot.util.SwerveModule; \n import edu.wpi.first.wpilibj.kinematics.ChassisSpeeds;\n import edu.wpi.first.wpilibj.kinematics.SwerveModuleState;\n "
  },
  {
    "sha": "28f2ab9b3a6a1c97e8ca17179f65e0ca8f699e62",
    "filename": "src/main/java/frc/robot/subsystems/SwerveDriveSubsystem.java",
    "status": "modified",
    "additions": 68,
    "deletions": 28,
    "changes": 96,
    "blob_url": "https://github.com/FRC2642/2020Robot/blob/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/subsystems/SwerveDriveSubsystem.java",
    "raw_url": "https://github.com/FRC2642/2020Robot/raw/042a6e4aed24434271b647df10e9663a9a4231f9/src/main/java/frc/robot/subsystems/SwerveDriveSubsystem.java",
    "contents_url": "https://api.github.com/repos/FRC2642/2020Robot/contents/src/main/java/frc/robot/subsystems/SwerveDriveSubsystem.java?ref=042a6e4aed24434271b647df10e9663a9a4231f9",
    "patch": "@@ -15,6 +15,7 @@\n import java.util.List;\n \n import com.kauailabs.navx.frc.AHRS;\n+import com.revrobotics.CANEncoder;\n import com.revrobotics.CANSparkMax;\n import com.revrobotics.CANSparkMaxLowLevel.MotorType;\n \n@@ -37,8 +38,6 @@\n import frc.robot.Constants;\n import frc.robot.Robot;\n import frc.robot.util.SwerveModule;\n-import com.revrobotics.CANEncoder;\n-\n \n public class SwerveDriveSubsystem extends SubsystemBase {\n   CANSparkMax frontLeftDriveMotor, frontLeftAngleMotor;\n@@ -64,22 +63,20 @@\n   public Trajectory rightTrajectory1;\n   public Trajectory rightTrajectory2;\n   public Trajectory exampleTrajectory;\n-\n-  public CANSparkMax driveMotor;\n-  public CANEncoder driveEncoder;\n-\n  \n   public boolean isDriveFieldCentric;\n   public boolean isAimingMode;\n   public boolean areAllWheelsAligned;\n \n-  public double position;\n+  public CANSparkMax driveMotor;\n+  public CANEncoder driveEncoder;\n+\n \n   public boolean isSlowDrive = false;\n+  public double position;\n \n   /**\n    * Creates a new SwerveDriveSubsystem.\n- * @return \n    */\n   public SwerveDriveSubsystem() {\n     //instantiates all 8 module motors\n@@ -103,7 +100,7 @@ public SwerveDriveSubsystem() {\n     backRightAngleMotor.restoreFactoryDefaults(); \n \n     //sets default inversion settings for motors\n-    frontLeftDriveMotor.setInverted(false);\n+    frontLeftDriveMotor.setInverted(true);\n     frontLeftAngleMotor.setInverted(true);\n     frontRightDriveMotor.setInverted(true);\n     frontRightAngleMotor.setInverted(true);\n@@ -122,17 +119,17 @@ public SwerveDriveSubsystem() {\n     backRightDriveMotor.setSmartCurrentLimit(kCurrentLimit);\n     backRightAngleMotor.setSmartCurrentLimit(kCurrentLimit);\n \n-    //assign drive encoder\n-    this.driveMotor = driveMotor;\n-    driveEncoder = frontLeftDriveMotor.getEncoder();\n-\n-\n     //assigns drive and angle motors to their respective swerve modules with offsets\n     frontLeftModule = new SwerveModule(frontLeftDriveMotor, frontLeftAngleMotor, kFrontLeftAngleModuleOffset);\n     frontRightModule = new SwerveModule(frontRightDriveMotor, frontRightAngleMotor, kFrontRightAngleModuleOffset);\n     backLeftModule = new SwerveModule(backLeftDriveMotor, backLeftAngleMotor, kBackLeftAngleModuleOffset);\n     backRightModule = new SwerveModule(backRightDriveMotor, backRightAngleMotor, kBackRightAngleModuleOffset);\n \n+     //assign drive encoder\n+     this.driveMotor = driveMotor;\n+     driveEncoder = frontLeftDriveMotor.getEncoder();\n+ \n+\n     //assigns swerve modules to an array \n     //this simplifies updating module states\n     modules = new ArrayList<SwerveModule>();\n@@ -144,7 +141,7 @@ public SwerveDriveSubsystem() {\n     //sets module distances from center of rotation\n     //forward = postive x, right = positive y\n     Translation2d frontLeft = new Translation2d(-kXDistanceFromCenter, kYDistanceFromCenter);\n-    Translation2d frontRight = new Translation2d(-kXDistanceFromCenter, -kYDistanceFromCenter);\n+    Translation2d frontRight = new Translation2d(kXDistanceFromCenter, -kYDistanceFromCenter);\n     Translation2d backLeft = new Translation2d(kXDistanceFromCenter, kYDistanceFromCenter);\n     Translation2d backRight = new Translation2d(kXDistanceFromCenter, -kYDistanceFromCenter);\n \n@@ -200,6 +197,8 @@ public SwerveDriveSubsystem() {\n                   config); */\n \n         \n+\n+    \n     \n     //instantiates navx\n     try{\n@@ -222,10 +221,12 @@ public SwerveDriveSubsystem() {\n   /**\n    * drive methods\n    */\n+\n   public double getDrivePosition(){\n     position = driveEncoder.getPosition();\n     return position;\n   }\n+\n   /**\n    * Drives with either robot-centric or field-centric\n    * \n@@ -286,12 +287,13 @@ public void driveByAimbot(double rawXInput, double rawYInput, double rawRotate){\n     yInput *= Math.abs(yInput);\n     //rotate *= Math.abs(rotate);\n \n+    \n     //if there is no stick input\n-    if(xInput == 0 && yInput == 0 && rotate == 0){\n+     if(xInput == 0 && yInput == 0 && rotate == 0){\n         lockWheels();\n     } else {\n         aimingModeDrive(xInput, yInput, rotate);\n-    }\n+    } \n   }\n \n   /**\n@@ -382,7 +384,9 @@ public void stop(){\n   /**\n    * Sets wheels into locked position (most resistant to being pushed)\n    */\n-  public void lockWheels(){\n+  \n+   \n+   public void lockWheels(){\n     double frontLeftVelocity = 0.0;\n     double frontRightVelocity = 0.0;\n     double backLeftVelocity = 0.0;\n@@ -403,13 +407,13 @@ public void lockWheels(){\n     frontRightModule.zeroOutI();\n     backLeftModule.zeroOutI();\n     backRightModule.zeroOutI();\n-\n+    \n     //sets wheels in the locked orientation\n-    frontLeftModule.setModuleAngle(frontLeftAngle);   \n+    /*frontLeftModule.setModuleAngle(frontLeftAngle);   \n     frontRightModule.setModuleAngle(frontRightAngle);\n     backLeftModule.setModuleAngle(backLeftAngle);\n-    backRightModule.setModuleAngle(backRightAngle);\n-\n+    backRightModule.setModuleAngle(backRightAngle);*/\n+    \n     //updates swerve module states for pose \n     SwerveModuleState frontLeft = new SwerveModuleState(frontLeftVelocity, frontLeftAngle);\n     SwerveModuleState frontRight = new SwerveModuleState(frontRightVelocity, frontRightAngle);\n@@ -419,13 +423,13 @@ public void lockWheels(){\n     ChassisSpeeds chassisSpeeds = kinematics.toChassisSpeeds(frontLeft, frontRight, backLeft, backRight);\n \n     moduleStates = kinematics.toSwerveModuleStates(chassisSpeeds);\n-  }\n-\n-  public void alignWheels(){\n+  } \n+    \n+     public void alignWheels(){\n     for(SwerveModule module: modules){\n-        module.zeroModules();\n+       module.zeroModules();\n     }\n-  }\n+  } \n \n   /** \n    * TOGGLEABLES AND GETTERS FOR DRIVING STATES\n@@ -517,6 +521,7 @@ public double getPoseXInFeet(){\n     double xPose = poseTrans2d.getX();\n     return Units.metersToFeet(xPose);\n   }\n+  \n \n   public void resetPose(){\n     odometry.resetPosition(new Pose2d(), getRobotYawInRotation2d());\n@@ -525,6 +530,38 @@ public void resetPose(){\n   public void doNothing(){\n   }\n \n+  public double[] getDisplacement() {\n+    double dispacementValues[] = new double[3];\n+    dispacementValues[0] = navx.getDisplacementX();\n+    dispacementValues[1] = navx.getDisplacementY();\n+    dispacementValues[2] = navx.getDisplacementZ();\n+    return dispacementValues;\n+}\n+\n+  public void setWheelsStraight(){\n+    //set wheels to straight for auto\n+    //pray this works\n+    //what is velocititty based on?\n+    //is it \n+\n+    double frontLeftVelocity = 2.0;\n+    double frontRightVelocity = 2.0;\n+    double backLeftVelocity = 2.0;\n+    double backRightVelocity = 2.0;\n+\n+    Rotation2d frontLeftAngle = toRotation2d(0.0);\n+    Rotation2d frontRightAngle = toRotation2d(0.0);\n+    Rotation2d backLeftAngle = toRotation2d(0.0);\n+    Rotation2d backRightAngle = toRotation2d(0.0);\n+\n+   \n+    frontLeftModule.setModuleVelocity(frontLeftVelocity);\n+    frontRightModule.setModuleVelocity(frontRightVelocity);\n+    backLeftModule.setModuleVelocity(backLeftVelocity);\n+    backRightModule.setModuleVelocity(backRightVelocity);\n+\n+  }\n+\n   /**\n    * TARGET ACQUISITON FOR AIMING\n    */\n@@ -535,7 +572,7 @@ public void doNothing(){\n     return target;\n   } */\n \n-//AUTONOMOUS\n+\n \n   /**\n    * DIAGNOSTIC \n@@ -569,4 +606,7 @@ public void periodic() {\n \n   //SmartDashboard.putNumber(\"fl vel\", frontLeftModule.getDriveVelocity());\n   }\n+\n+  \n+\n }\n\\ No newline at end of file"
  }
]
