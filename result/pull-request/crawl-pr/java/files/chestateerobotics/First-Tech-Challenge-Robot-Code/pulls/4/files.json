[
  {
    "sha": "e0bcf259e468622716b62d425aefe51bf693ecc9",
    "filename": ".github/BasicMechanumAutonomous.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/BasicMechanumAutonomous.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/BasicMechanumAutonomous.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/.github/BasicMechanumAutonomous.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,72 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.ColorSensor;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+\n+\n+@TeleOp(name = \"Basic Mechanum auto\")\n+public class BasicMechanumAutonomous extends OpMode {\n+\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+\n+    // Define hardware\n+    private DcMotor m1, m2, m3, m4;\n+    private ColorSensor colorSensor;\n+\n+    // Game variables\n+    private boolean isFinished = false;\n+\n+    public void init() {\n+        m1 = hardwareMap.dcMotor.get(\"backLeft\");\n+        m2 = hardwareMap.dcMotor.get(\"frontLeft\");\n+        m3 = hardwareMap.dcMotor.get(\"frontRight\");\n+        m4 = hardwareMap.dcMotor.get(\"backRight\");\n+        m1.setDirection(DcMotor.Direction.REVERSE);\n+        m2.setDirection(DcMotor.Direction.REVERSE);\n+        mecanumDrive.init(hardwareMap);\n+\n+        colorSensor = hardwareMap.colorSensor.get(\"colorSensor\");\n+        telemetry.addData(\"Press Start When Ready\", \"\");\n+        telemetry.update();\n+\n+    }\n+\n+    @Override\n+    public void loop() {\n+        if (!isFinished) {\n+            while (!isOverWhite()) {\n+                telemetry.addData(\"R: \", colorSensor.red());\n+                telemetry.addData(\"G: \", colorSensor.green());\n+                telemetry.addData(\"B: \", colorSensor.blue());\n+                telemetry.update();\n+                //driveForward(.5);\n+            }\n+            fullStop();\n+            isFinished = true;\n+            telemetry.addData(\"finished\", \"\");\n+            telemetry.update();\n+        }\n+        else {\n+            stop();\n+        }\n+    }\n+\n+    private void driveForward(double speed) {\n+        mecanumDrive.driveMecanum(speed,0,0);\n+    }\n+\n+    private void fullStop() {\n+        m1.setPower(0);\n+        m2.setPower(0);\n+        m3.setPower(0);\n+        m4.setPower(0);\n+    }\n+\n+    private boolean isOverWhite() {\n+        return colorSensor.blue() > 150 &&\n+                colorSensor.green() > 150 &&\n+                colorSensor.red() > 150;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "338d495c2956241605b8b609c9cd928654226452",
    "filename": ".github/Eagles_of_the_north_drive",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/Eagles_of_the_north_drive",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/Eagles_of_the_north_drive",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/.github/Eagles_of_the_north_drive?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,63 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.*;\n+\n+\n+@TeleOp(name = \"Hunter_Testing\", group = \"XBot\")\n+public class hunterTesting extends LinearOpMode {\n+    public void runOpMode() {\n+        double maxSpeed = 1;\n+        DcMotor front = hardwareMap.dcMotor.get(\"front_right_motor\");\n+        DcMotor left = hardwareMap.dcMotor.get(\"front_left_motor\");\n+        DcMotor right = hardwareMap.dcMotor.get(\"back_right_motor\");\n+        DcMotor back = hardwareMap.dcMotor.get(\"back_left_motor\");\n+        front.setDirection(DcMotor.Direction.REVERSE);\n+        left.setDirection(DcMotor.Direction.REVERSE);\n+        front.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        right.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        left.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        back.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        front.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        right.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        left.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        back.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+\n+        waitForStart();\n+\n+        while (opModeIsActive()) {\n+            double lsY = gamepad1.left_stick_y;\n+            if (Math.abs(lsY) <= 0.1) lsY = 0;\n+            double lsX = gamepad1.left_stick_x;\n+            if (Math.abs(lsX) <= 0.1) lsX = 0;\n+            double rsX = gamepad1.right_stick_x;\n+            if (Math.abs(rsX) <=0.1) rsX = 0;\n+            if (gamepad1.left_bumper) maxSpeed = 0.5;\n+            if (gamepad1.right_bumper) maxSpeed = 1;\n+\n+            front.setPower(lsX*maxSpeed);\n+            back.setPower(lsX*maxSpeed);\n+            left.setPower(-lsY+rsX*maxSpeed);\n+            right.setPower(-lsY-rsX*maxSpeed);\n+\n+            telemetry.addData(\"Max speed\", \"%.1f\", maxSpeed);\n+            telemetry.addData(\"Left motor\", \"%.1f\", left.getPower());\n+            telemetry.addData(\"Right motor\", \"%.1f\", right.getPower());\n+            telemetry.addData(\"Up motor\", \"%.1f\", front.getPower());\n+            telemetry.addData(\"Down motor\", \"%.1f\", back.getPower());\n+            telemetry.addData(\"Left Stick X\", \"%.1f\", gamepad1.left_stick_x);\n+            telemetry.addData(\"Left Stick Y\", \"%.1f\", -gamepad1.left_stick_y);\n+            telemetry.addData(\"Right Stick X\", \"%.1f\", gamepad1.right_stick_x);\n+            telemetry.addData(\"Encoders\",\" %d %d %d %d\", front.getCurrentPosition(), right.getCurrentPosition(),\n+                    left.getCurrentPosition(), back.getCurrentPosition());\n+            telemetry.update();\n+        }\n+        front.setPower(0);\n+        back.setPower(0);\n+        left.setPower(0);\n+        right.setPower(0);\n+    }\n+}\n+\n+"
  },
  {
    "sha": "2f72f4a727e144857b5542818cf22394fd007433",
    "filename": ".github/MoveForward.java",
    "status": "added",
    "additions": 37,
    "deletions": 0,
    "changes": 37,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/MoveForward.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/.github/MoveForward.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/.github/MoveForward.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,37 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.Gyroscope;\n+import com.qualcomm.robotcore.hardware.Blinker;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.ColorSensor;\n+\n+@Autonomous\n+\n+public class MoveForward extends LinearOpMode{\n+    private Blinker expansion_Hub_1;\n+    private Blinker expansion_Hub_2;\n+    private DcMotor backLeft;\n+    private DcMotor backRight;\n+    private ColorSensor colorSensor;\n+    private DcMotor frontLeft;\n+    private DcMotor frontRight;\n+    private Gyroscope imu;\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+    // todo: write your code here\n+    \n+    public void runOpMode() {\n+        waitForStart();\n+        mecanumDrive.init(hardwareMap);\n+        mecanumDrive.setMaxSpeed(0.4);\n+        \n+        while (opModeIsActive()) {\n+            mecanumDrive.driveMecanum(1, 0, 0);\n+            sleep(1000);\n+            mecanumDrive.driveMecanum(0,0,0);\n+            break;\n+        }  \n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "85be0d30af89fe8979dfe7c6277c08ce0cbc0f06",
    "filename": "TeamCode/BasicMecanumAutonomous.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/BasicMecanumAutonomous.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/BasicMecanumAutonomous.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/BasicMecanumAutonomous.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,72 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.ColorSensor;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+\n+\n+@TeleOp(name = \"Basic Mechanum auto\")\n+public class BasicMecanumAutonomous extends OpMode {\n+\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+\n+    // Define hardware\n+    private DcMotor m1, m2, m3, m4;\n+    private ColorSensor colorSensor;\n+\n+    // Game variables\n+    private boolean isFinished = false;\n+\n+    public void init() {\n+        m1 = hardwareMap.dcMotor.get(\"backLeft\");\n+        m2 = hardwareMap.dcMotor.get(\"frontLeft\");\n+        m3 = hardwareMap.dcMotor.get(\"frontRight\");\n+        m4 = hardwareMap.dcMotor.get(\"backRight\");\n+        m1.setDirection(DcMotor.Direction.REVERSE);\n+        m2.setDirection(DcMotor.Direction.REVERSE);\n+        mecanumDrive.init(hardwareMap);\n+\n+        colorSensor = hardwareMap.colorSensor.get(\"colorSensor\");\n+        telemetry.addData(\"Press Start When Ready\", \"\");\n+        telemetry.update();\n+\n+    }\n+\n+    @Override\n+    public void loop() {\n+        if (!isFinished) {\n+            while (!isOverWhite()) {\n+                telemetry.addData(\"R: \", colorSensor.red());\n+                telemetry.addData(\"G: \", colorSensor.green());\n+                telemetry.addData(\"B: \", colorSensor.blue());\n+                telemetry.update();\n+                //driveForward(.5);\n+            }\n+            fullStop();\n+            isFinished = true;\n+            telemetry.addData(\"finished\", \"\");\n+            telemetry.update();\n+        }\n+        else {\n+            stop();\n+        }\n+    }\n+\n+    private void driveForward(double speed) {\n+        mecanumDrive.driveMecanum(speed,0,0);\n+    }\n+\n+    private void fullStop() {\n+        m1.setPower(0);\n+        m2.setPower(0);\n+        m3.setPower(0);\n+        m4.setPower(0);\n+    }\n+\n+    private boolean isOverWhite() {\n+        return colorSensor.blue() > 150 &&\n+                colorSensor.green() > 150 &&\n+                colorSensor.red() > 150;\n+    }\n+}"
  },
  {
    "sha": "d0ed770ec508f2dba25ddc49a6097e9030fd225b",
    "filename": "TeamCode/ConceptTensorFlowObjectDetection.java",
    "status": "added",
    "additions": 147,
    "deletions": 0,
    "changes": 147,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/ConceptTensorFlowObjectDetection.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/ConceptTensorFlowObjectDetection.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/ConceptTensorFlowObjectDetection.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,147 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.List;\n+\n+/**\n+ * This 2020-2021 OpMode illustrates the basics of using the TensorFlow Object Detection API to\n+ * determine the position of the Ultimate Goal game elements.\n+ *\n+ * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\n+ * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.\n+ *\n+ * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as\n+ * is explained below.\n+ */\n+@TeleOp(name = \"Concept: TensorFlow Object Detection\")\n+public class ConceptTensorFlowObjectDetection extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+\n+    /*\n+     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which\n+     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.\n+     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer\n+     * web site at https://developer.vuforia.com/license-manager.\n+     *\n+     * Vuforia license keys are always 380 characters long, and look as if they contain mostly\n+     * random data. As an example, here is a example of a fragment of a valid key:\n+     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...\n+     * Once you've obtained a license key, copy the string from the Vuforia web site\n+     * and paste it in to your code on the next line, between the double quotes.\n+     */\n+    private static final String VUFORIA_KEY =\n+            \"AXovKxf/////AAABmZ1xSbRDdkXAj9XCHF9C0zpA2yWkekS0x4rJqlFl2RhwdnlZcEvEHJKomiMMZHTvwElLT9SawX7aWdpQZS6L7rfBNI090mCrnoub3lIgwiDTc/DbBuYsz1ICvWHrhz1R0k62/4ZtZXVHclv+ZyqBbbHwI3GfQCgyGSM8aEGdNOEck2Qw8b5WPo8FrtgsqFm4plJ3iIqHvS0Wi3EYosU0eJ46tnvj7xKm3wz0Vf5zUMz4h9fqHZ9WwzXaohSSsad99K42ByO9FAlO1f+vvp2KCr6d5QweT0QGlaSnzz4C03H4X1yARyPIUD9JCeAc8mhhYwqekr7FBdIJLrfp4pKH1nVWdH/J7g0Sa0mJkgDkWwY7\";\n+\n+    /**\n+     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia\n+     * localization engine.\n+     */\n+    private VuforiaLocalizer vuforia;\n+\n+    /**\n+     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object\n+     * Detection engine.\n+     */\n+    private TFObjectDetector tfod;\n+\n+    @Override\n+    public void runOpMode() {\n+        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\n+        // first.\n+        initVuforia();\n+        initTfod();\n+\n+        /**\n+         * Activate TensorFlow Object Detection before we wait for the start command.\n+         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n+         **/\n+        if (tfod != null) {\n+            tfod.activate();\n+\n+            // The TensorFlow software will scale the input images from the camera to a lower resolution.\n+            // This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n+            // If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n+            // to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\n+            // should be set to the value of the images used to create the TensorFlow Object Detection model\n+            // (typically 1.78 or 16/9).\n+\n+            // Uncomment the following line if you want to adjust the magnification and/or the aspect ratio of the input images.\n+            //tfod.setZoom(2.5, 1.78);\n+        }\n+\n+        /** Wait for the game to begin */\n+        telemetry.addData(\">\", \"Press Play to start op mode\");\n+        telemetry.update();\n+        waitForStart();\n+\n+        if (opModeIsActive()) {\n+            while (opModeIsActive()) {\n+                if (tfod != null) {\n+                    // getUpdatedRecognitions() will return null if no new information is available since\n+                    // the last time that call was made.\n+                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                    if (updatedRecognitions != null) {\n+                      telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+\n+                      // step through the list of recognitions and display boundary info.\n+                      int i = 0;\n+                      for (Recognition recognition : updatedRecognitions) {\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                          recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                      }\n+                      telemetry.update();\n+                    }\n+                }\n+\n+\n+            }\n+        }\n+\n+        if (tfod != null) {\n+            tfod.shutdown();\n+        }\n+    }\n+\n+    /**\n+     * Initialize the Vuforia localization engine.\n+     */\n+    private void initVuforia() {\n+        /*\n+         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\n+         */\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        parameters.cameraDirection = CameraDirection.BACK;\n+\n+        //  Instantiate the Vuforia engine\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+\n+        // Loading trackables is not necessary for the TensorFlow Object Detection engine.\n+    }\n+\n+    /**\n+     * Initialize the TensorFlow Object Detection engine.\n+     */\n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+            \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n+}"
  },
  {
    "sha": "d9b9527f519846d3b9fdf25af4ca7bf9eb81ab9b",
    "filename": "TeamCode/DistanceSensorAutonomous.java",
    "status": "added",
    "additions": 211,
    "deletions": 0,
    "changes": 211,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/DistanceSensorAutonomous.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/DistanceSensorAutonomous.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/DistanceSensorAutonomous.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,211 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.ColorSensor;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DistanceSensor;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n+\n+/*\n+Stuff to test before running on the actual robot:\n+    1: Color Sensor Values for the white line\n+    2: Distance sensor values for each of the squares\n+    3: Change all movement to slower\n+    (I recomend 0.25 for regular and 0.05 for testing for white line)\n+    4:\n+*/\n+\n+\n+@TeleOp(name = \"Distance Sensor Autonomous\")\n+public class DistanceSensorAutonomous extends LinearOpMode{\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+    // Define harware\n+    private DcMotor arm;\n+    private Servo handServo;\n+    private DistanceSensor frontDistance, rightDistance;\n+    private ColorSensor colorSensor;\n+\n+    // Game variables\n+    private String alliance = \"Red\";\n+    private int target;\n+    private int targetXMin, targetXMax, targetYMin, targetYMax;\n+\n+    public void runOpMode(){\n+        Initiate();\n+        telemetry.addData(\"Press Start When Ready\", \"\");\n+        telemetry.update();\n+\n+        //target = 3;\n+        target = (int) Math.ceil(Math.random() * 3);\n+        telemetry.addData(\"target\", target);\n+        telemetry.update();\n+\n+        if (target == 1) {\n+            targetXMin = 0;\n+            targetYMax = 0;\n+            targetXMax = 15;\n+            targetYMax = 15;\n+        } else if (target == 2) {\n+            targetXMin = 60;\n+            targetYMin = 60;\n+            targetXMax = 75;\n+            targetYMax = 75;\n+        } else {\n+            targetXMin = 0;\n+            targetYMin = 135;\n+            targetXMax = 15;\n+            targetYMax = 150;\n+        }\n+\n+        //mecanumDrive.setEndPowerBehaviorBrake();\n+        waitForStart();\n+        while(opModeIsActive()){\n+                //Sets Robot on the line after it looks at the rings\n+                while(rightDistance.getDistance(DistanceUnit.CM)  <= 95.5){\n+                    driveLeft(0.4);\n+                }\n+                while(rightDistance.getDistance(DistanceUnit.CM) >= 95.5){\n+                    driveRight(0.2);\n+                }\n+\n+                //Robot moves to Area and posts \"Dropped the thing\"\n+                if (target == 3) {\n+                    while (colorSensor.blue() < 200 &&\n+                            colorSensor.green() < 200 &&\n+                            colorSensor.red() < 200){\n+                        driveForward(0.3);\n+                    }\n+                }\n+                else{\n+                    while (frontDistance.getDistance(DistanceUnit.CM) > targetYMax) {\n+                        driveForward(1);\n+                    }\n+                    while (frontDistance.getDistance(DistanceUnit.CM) < targetYMin) {\n+                        driveBackwards(1);\n+                    }\n+                }\n+                while (rightDistance.getDistance(DistanceUnit.CM) > targetXMax) {\n+                    driveRight(1);\n+                }\n+                while (rightDistance.getDistance(DistanceUnit.CM) < targetXMin) {\n+                    driveLeft(1);\n+                }\n+                fullStop();\n+                telemetry.addData(\"Dropped the thing\", \"\");\n+                telemetry.update();\n+                sleep(200);\n+\n+                if (target == 3){\n+                    break;\n+                }\n+\n+                //Arm Moves\n+                armSetOut(0.5);\n+                //Position 0 is Retract\n+                handServo.setPosition(0);\n+                sleep(100);\n+                driveLeft(1);\n+                sleep(100);\n+                returnArm();\n+\n+                //Find actual color sensor values\n+                while (colorSensor.blue() < 300 &&\n+                        colorSensor.green() < 300 &&\n+                        colorSensor.red() < 300) {\n+                    driveBackwards(.1);\n+                }\n+\n+                fullStop();\n+                telemetry.addData(\"finished\", \"\");\n+                telemetry.update();\n+                break;\n+            }\n+        }\n+\n+    private void Initiate(){\n+        mecanumDrive.init(hardwareMap);\n+\n+        arm = hardwareMap.get(DcMotor.class, \"arm_motor\");\n+        arm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        handServo = hardwareMap.servo.get(\"hand_servo\");\n+\n+        frontDistance = hardwareMap.get(DistanceSensor.class, \"front_distance\");\n+        rightDistance = hardwareMap.get(DistanceSensor.class, \"right_distance\");;\n+\n+        colorSensor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\n+    }\n+\n+    private void driveForward(double speed) {\n+        telemetry.addData(\"driving forward\", \"\");\n+        telemetry.update();\n+        mecanumDrive.driveMecanum(speed,0,0);\n+    }\n+\n+    private void driveBackwards(double speed) {\n+        telemetry.addData(\"driving backwards\", \"\");\n+        telemetry.update();\n+        mecanumDrive.driveMecanum(-speed,0,0);\n+    }\n+\n+    private void driveLeft(double speed) {\n+        mecanumDrive.driveMecanum(0, -speed, 0);\n+    }\n+\n+    private void driveRight(double speed) {\n+        mecanumDrive.driveMecanum(0, speed, 0);\n+    }\n+\n+    private void rotateClockwise(double speed) {\n+        mecanumDrive.driveMecanum(0, 0, speed);\n+    }\n+\n+    private void rotateCounterClockwise(double speed) {\n+        mecanumDrive.driveMecanum(0, 0, -speed);\n+    }\n+\n+    private void fullStop() {\n+        mecanumDrive.driveMecanum(0,0,0);\n+    }\n+\n+    private void armSetOut(double power){\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        arm.setTargetPosition(-260);\n+        arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        //Power = 0.2 without WobbleGoal\n+        arm.setPower(power);\n+        while (arm.isBusy()){\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+        arm.setPower(0);\n+\n+        //Possibly comment out the up motion since it doesn't matter for autonomous much\n+        sleep(50);\n+        arm.setPower(-0.15);\n+        while (arm.isBusy()){\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+        arm.setPower(0);\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+    }\n+\n+    private void returnArm(){\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        arm.setTargetPosition(-50);\n+        arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        arm.setPower(-0.2);\n+        while (arm.isBusy()){\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+        arm.setPower(0);\n+    }\n+}"
  },
  {
    "sha": "06c64bf41fa6db1531bb7a8288c3ce2212210be0",
    "filename": "TeamCode/Eagles_of_the_north_drive",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/Eagles_of_the_north_drive",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/Eagles_of_the_north_drive",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/Eagles_of_the_north_drive?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,63 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.*;\n+\n+\n+@TeleOp(name = \"Hunter_Testing\", group = \"XBot\")\n+public class hunterTesting extends LinearOpMode {\n+    public void runOpMode() {\n+        double maxSpeed = 1;\n+        DcMotor front = hardwareMap.dcMotor.get(\"front_right_motor\");\n+        DcMotor left = hardwareMap.dcMotor.get(\"front_left_motor\");\n+        DcMotor right = hardwareMap.dcMotor.get(\"back_right_motor\");\n+        DcMotor back = hardwareMap.dcMotor.get(\"back_left_motor\");\n+        front.setDirection(DcMotor.Direction.REVERSE);\n+        left.setDirection(DcMotor.Direction.REVERSE);\n+        front.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        right.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        left.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        back.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        front.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        right.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        left.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        back.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+\n+        waitForStart();\n+\n+        while (opModeIsActive()) {\n+            double lsY = gamepad1.left_stick_y;\n+            if (Math.abs(lsY) <= 0.1) lsY = 0;\n+            double lsX = gamepad1.left_stick_x;\n+            if (Math.abs(lsX) <= 0.1) lsX = 0;\n+            double rsX = gamepad1.right_stick_x;\n+            if (Math.abs(rsX) <=0.1) rsX = 0;\n+            if (gamepad1.left_bumper) maxSpeed = 0.5;\n+            if (gamepad1.right_bumper) maxSpeed = 1;\n+\n+            front.setPower(lsX*maxSpeed);\n+            back.setPower(lsX*maxSpeed);\n+            left.setPower(-lsY+rsX*maxSpeed);\n+            right.setPower(-lsY-rsX*maxSpeed);\n+\n+            telemetry.addData(\"Max speed\", \"%.1f\", maxSpeed);\n+            telemetry.addData(\"Left motor\", \"%.1f\", left.getPower());\n+            telemetry.addData(\"Right motor\", \"%.1f\", right.getPower());\n+            telemetry.addData(\"Up motor\", \"%.1f\", front.getPower());\n+            telemetry.addData(\"Down motor\", \"%.1f\", back.getPower());\n+            telemetry.addData(\"Left Stick X\", \"%.1f\", gamepad1.left_stick_x);\n+            telemetry.addData(\"Left Stick Y\", \"%.1f\", -gamepad1.left_stick_y);\n+            telemetry.addData(\"Right Stick X\", \"%.1f\", gamepad1.right_stick_x);\n+            telemetry.addData(\"Encoders\",\" %d %d %d %d\", front.getCurrentPosition(), right.getCurrentPosition(),\n+                left.getCurrentPosition(), back.getCurrentPosition());\n+            telemetry.update();\n+        }\n+        front.setPower(0);\n+        back.setPower(0);\n+        left.setPower(0);\n+        right.setPower(0);\n+    }\n+}\n+\n+"
  },
  {
    "sha": "8e53d0d9bfd9ece862369e2554e1942b4411cb0a",
    "filename": "TeamCode/IntakeDrive.java",
    "status": "added",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/IntakeDrive.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/IntakeDrive.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/IntakeDrive.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,122 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.Servo;\n+\n+@TeleOp(name = \"Intake Drive\")\n+\n+public class IntakeDrive extends LinearOpMode{\n+    private Servo arm_servo;\n+    private CRServo intake_servo;\n+    private DcMotor leftLauncher, rightLauncher;\n+    private DcMotor arm, intake;\n+    private Servo handServo;\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+\n+    public void runOpMode() {\n+        mecanumDrive.init(hardwareMap);\n+        mecanumDrive.setMaxSpeed(0.4);\n+        arm = hardwareMap.get(DcMotor.class, \"arm_motor\");\n+        arm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        handServo = hardwareMap.get(Servo.class, \"arm_servo\");\n+\n+        leftLauncher = hardwareMap.get(DcMotor.class, \"leftLauncher\");\n+        rightLauncher = hardwareMap.get(DcMotor.class, \"rightLauncher\");\n+        leftLauncher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+        rightLauncher.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+        intake = hardwareMap.get(DcMotor.class, \"intake\");\n+        intake_servo = hardwareMap.get(Servo.class, \"intake_servo\";\n+        \n+        waitForStart();\n+        while (opModeIsActive()){\n+            double forward = gamepad1.left_stick_y * -1; //The y direction on the gamepad is reversed idk why\n+            double strafe = gamepad1.left_stick_x;\n+            double rotate = gamepad1.right_stick_x;\n+            \n+            mecanumDrive.driveMecanum(forward, strafe, rotate);\n+            \n+            if (gamepad1.x){\n+                mecanumDrive.setMaxSpeed(0.4);\n+            }\n+            else if (gamepad1.y){\n+                mecanumDrive.setMaxSpeed(0.1);\n+            }\n+            if (gamepad1.left_bumper){\n+                mecanumDrive.moveArm(-1);\n+            }\n+            else if (gamepad1.right_bumper){\n+                mecanumDrive.moveArm(1);\n+            }\n+            else{\n+                mecanumDrive.moveArm(0);\n+            }\n+            \n+            if (gamepad1.dpad_right){\n+                moveArm();\n+            }\n+            \n+            if (gamepad1.a){\n+                mecanumDrive.moveServo(1);\n+            }\n+            else if (gamepad1.b){\n+                mecanumDrive.moveServo(0);\n+            }\n+\n+            if (gamepad1.dpad_up){\n+                intake.setPower(-0.5);\n+            }\n+            else if(gamepad1.dpad_down){\n+                intake.setPower(0.5);\n+            }\n+            else if(gamepad1.dpad_left){\n+                intake_servo.setPower(1);\n+            }\n+            else{\n+                intake.setPower(0);\n+                intake_servo.setPower(0);\n+            }\n+\n+            if (gamepad1.left_trigger > 0){\n+                leftLauncher.setPower(-1);\n+                rightLauncher.setPower(1);\n+            }\n+            else{\n+                leftLauncher.setPower(0);\n+                rightLauncher.setPower(0);\n+            }\n+\n+\n+\n+    \n+            telemetry.addData(\"Gamepad Left Stick\", gamepad1.left_stick_x);\n+            telemetry.addData(\"Max Speed\", mecanumDrive.getMaxSpeed());\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+    }\n+\n+    private void moveArm(){\n+        arm.setTargetPosition(-260);\n+        arm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        arm.setPower(0.2);\n+        while (arm.isBusy()){\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+        arm.setPower(0);\n+        sleep(50);\n+        arm.setPower(-0.15);\n+        while (arm.isBusy()){\n+            telemetry.addData(\"Encoder Arm\", arm.getCurrentPosition());\n+            telemetry.addData(\"Arm Power\", arm.getPower());\n+            telemetry.update();\n+        }\n+        arm.setPower(0);\n+        arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "35cf5a479687bb2b936b2de777d9bfb3f973362c",
    "filename": "TeamCode/MecanumArmDrive.java",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/MecanumArmDrive.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/MecanumArmDrive.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/MecanumArmDrive.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,52 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.eventloop.opmode.OpMode;\n+\n+@TeleOp(name = \"Main Drive\")\n+public class MecanumArmDrive extends OpMode {\n+    private MecanumDrive mecanumDrive = new MecanumDrive();\n+    private double[] distances;\n+\n+    // Code to run ONCE when the driver hits INIT\n+    @Override\n+    public void init() {\n+        mecanumDrive.init(hardwareMap);\n+        mecanumDrive.setMaxSpeed(0.4);\n+    }\n+\n+    // Code to run REPEATEDLY after the driver hits PLAY but before they hit STOP\n+    @Override\n+    public void loop() {\n+        double forward = gamepad1.left_stick_y * -1; //The y direction on the gamepad is reversed idk why\n+        double strafe = gamepad1.left_stick_x;\n+        double rotate = gamepad1.right_stick_x;\n+\n+        mecanumDrive.driveMecanum(forward, strafe, rotate);\n+\n+        if (gamepad1.x){\n+            mecanumDrive.setMaxSpeed(0.4);\n+        }\n+        else if (gamepad1.y){\n+            mecanumDrive.setMaxSpeed(0.1);\n+        }\n+        if (gamepad1.left_bumper){\n+            mecanumDrive.moveArm(-1);\n+        }\n+        else if (gamepad1.right_bumper){\n+            mecanumDrive.moveArm(1);\n+        }\n+        else{\n+            mecanumDrive.moveArm(0);\n+        }\n+        if (gamepad1.a){\n+            mecanumDrive.moveServo(1);\n+        }\n+        else if (gamepad1.b){\n+            mecanumDrive.moveServo(0);\n+        }\n+        telemetry.addData(\"Gamepad Left Stick\", gamepad1.left_stick_x);\n+        telemetry.addData(\"Max Speed\", mecanumDrive.getMaxSpeed());\n+        telemetry.update();\n+    }\n+}"
  },
  {
    "sha": "02ab30d2814e63c959f1c30d64e9d2c626ad0425",
    "filename": "TeamCode/MecanumDrive.java",
    "status": "added",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/blob/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/MecanumDrive.java",
    "raw_url": "https://github.com/chestateerobotics/First-Tech-Challenge-Robot-Code/raw/b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e/TeamCode/MecanumDrive.java",
    "contents_url": "https://api.github.com/repos/chestateerobotics/First-Tech-Challenge-Robot-Code/contents/TeamCode/MecanumDrive.java?ref=b85fea8c3cfb40f2d1c8c895c83b1149386c2e7e",
    "patch": "@@ -0,0 +1,122 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.hardware.HardwareMap;\n+import org.firstinspires.ftc.robotcore.external.matrices.GeneralMatrixF;\n+import org.firstinspires.ftc.robotcore.external.matrices.MatrixF;\n+\n+class MecanumDrive {\n+    private DcMotor frontLeft;\n+    private DcMotor frontRight;\n+    private DcMotor backRight;\n+    private DcMotor backLeft;\n+    private DcMotor arm;\n+    private Servo armServo;\n+\n+    public static double GEAR_RATIO = 1.0; // for simulator - ours should be 0.5f;\n+    public static double WHEEL_RADIUS = 5.0;  // 5 cm\n+    public static double TICKS_PER_ROTATION = 1120.0;  // From NeveRest (for simulator)  GoBilda should be 383.6f\n+\n+    public static double CM_PER_TICK = (2 * Math.PI * GEAR_RATIO * WHEEL_RADIUS) / TICKS_PER_ROTATION;\n+\n+    private double maxSpeed = 0.5;\n+\n+    private MatrixF conversion;\n+    private GeneralMatrixF encoderMatrix = new GeneralMatrixF(3, 1);\n+\n+    private int frontLeftOffset;\n+    private int frontRightOffset;\n+    private int backRightOffset;\n+    private int backLeftOffset;\n+\n+\n+    MecanumDrive() {\n+        float[] data = {1.0f, 1.0f, 1.0f,\n+                1.0f, -1.0f, -1.0f,\n+                1.0f, -1.0f, 1.0f};\n+        conversion = new GeneralMatrixF(3, 3, data);\n+        conversion = conversion.inverted();\n+    }\n+\n+    void init(HardwareMap hwMap) {\n+        frontLeft = hwMap.get(DcMotor.class, \"frontLeft\");\n+        frontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        frontRight = hwMap.get(DcMotor.class, \"frontRight\");\n+        frontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        backLeft = hwMap.get(DcMotor.class, \"backLeft\");\n+        backLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        backRight = hwMap.get(DcMotor.class, \"backRight\");\n+        backRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+\n+        arm = hwMap.get(DcMotor.class, \"arm_motor\");\n+        armServo = hwMap.get(Servo.class, \"arm_servo\");\n+\n+        arm.setDirection(DcMotor.Direction.REVERSE);\n+        backLeft.setDirection(DcMotor.Direction.REVERSE);\n+        frontLeft.setDirection(DcMotor.Direction.REVERSE);\n+\n+        arm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+\n+    }\n+\n+    private void setSpeeds(double flSpeed, double frSpeed, double blSpeed, double brSpeed) {\n+        double largest = maxSpeed;\n+        /*\n+        largest = Math.max(largest, Math.abs(flSpeed));\n+        largest = Math.max(largest, Math.abs(frSpeed));\n+        largest = Math.max(largest, Math.abs(blSpeed));\n+        largest = Math.max(largest, Math.abs(brSpeed));\n+        */\n+\n+        frontLeft.setPower(flSpeed * largest);\n+        frontRight.setPower(frSpeed * largest);\n+        backLeft.setPower(blSpeed * largest);\n+        backRight.setPower(brSpeed * largest);\n+    }\n+\n+    void driveMecanum(double forward, double strafe, double rotate) {\n+        double frontLeftSpeed = forward + strafe + rotate;\n+        double frontRightSpeed = forward - strafe - rotate;\n+        double backLeftSpeed = forward - strafe + rotate;\n+        double backRightSpeed = forward + strafe - rotate;\n+\n+        setSpeeds(frontLeftSpeed, frontRightSpeed, backLeftSpeed, backRightSpeed);\n+    }\n+\n+    void moveArm(double speed){\n+        arm.setPower(speed * 0.6);\n+    }\n+    void moveServo(double position){\n+        armServo.setPosition(position);\n+    }\n+    // Returns forward, strafe\n+    double[] getDistanceCm() {\n+        double[] distances = {0.0, 0.0};\n+\n+        encoderMatrix.put(0, 0, (float) ((frontLeft.getCurrentPosition() - frontLeftOffset) * CM_PER_TICK));\n+        encoderMatrix.put(1, 0, (float) ((frontRight.getCurrentPosition() - frontRightOffset) * CM_PER_TICK));\n+        encoderMatrix.put(2, 0, (float) ((backLeft.getCurrentPosition() - backLeftOffset) * CM_PER_TICK));\n+\n+        MatrixF distanceMatrix = conversion.multiplied(encoderMatrix);\n+        distances[0] = distanceMatrix.get(0, 0);\n+        distances[1] = distanceMatrix.get(1, 0);\n+\n+        return distances;\n+    }\n+\n+    void setMaxSpeed(double speed) {\n+        maxSpeed = Math.min(speed, 1.0);\n+    }\n+\n+    public double getMaxSpeed() {\n+        return maxSpeed;\n+    }\n+\n+    public void setEncoderOffsets() {\n+        frontRightOffset = frontRight.getCurrentPosition();\n+        frontLeftOffset = frontLeft.getCurrentPosition();\n+        backLeftOffset = backLeft.getCurrentPosition();\n+        backRightOffset = backRight.getCurrentPosition();\n+    }\n+}"
  }
]
