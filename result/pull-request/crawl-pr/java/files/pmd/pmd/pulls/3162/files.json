[
  {
    "sha": "f0eff998e29ea2f2c77235ab1c506dc091acc16b",
    "filename": ".ci/files/all-java.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/.ci/files/all-java.xml",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/.ci/files/all-java.xml",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/.ci/files/all-java.xml?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -132,8 +132,8 @@\n     <!-- <rule ref=\"category/java/design.xml/ClassWithOnlyPrivateConstructorsShouldBeFinal\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/CollapsibleIfStatements\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/CouplingBetweenObjects\"/> -->\n-    <!-- <rule ref=\"category/java/design.xml/CyclomaticComplexity\"/> -->\n-    <!-- <rule ref=\"category/java/design.xml/DataClass\"/> -->\n+    <rule ref=\"category/java/design.xml/CyclomaticComplexity\"/>\n+    <rule ref=\"category/java/design.xml/DataClass\"/>\n     <!-- <rule ref=\"category/java/design.xml/DoNotExtendJavaLangError\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/ExceptionAsFlowControl\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/ExcessiveClassLength\"/> -->\n@@ -142,13 +142,13 @@\n     <!-- <rule ref=\"category/java/design.xml/ExcessiveParameterList\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/ExcessivePublicCount\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/FinalFieldCouldBeStatic\"/> -->\n-    <!-- <rule ref=\"category/java/design.xml/GodClass\"/> -->\n+    <rule ref=\"category/java/design.xml/GodClass\"/>\n     <!-- <rule ref=\"category/java/design.xml/ImmutableField\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/LawOfDemeter\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/LogicInversion\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/LoosePackageCoupling\"/> -->\n-    <!-- <rule ref=\"category/java/design.xml/NPathComplexity\"/> -->\n-    <!-- <rule ref=\"category/java/design.xml/NcssCount\"/> -->\n+    <rule ref=\"category/java/design.xml/NPathComplexity\"/>\n+    <rule ref=\"category/java/design.xml/NcssCount\"/>\n     <!-- <rule ref=\"category/java/design.xml/SignatureDeclareThrowsException\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/SimplifiedTernary\"/> -->\n     <!-- <rule ref=\"category/java/design.xml/SimplifyBooleanAssertion\"/> -->"
  },
  {
    "sha": "f85e4603047ceedde52fa9e0660fbfdb3e8138f9",
    "filename": "docs/_data/sidebars/pmd_sidebar.yml",
    "status": "modified",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/docs/_data/sidebars/pmd_sidebar.yml",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/docs/_data/sidebars/pmd_sidebar.yml",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/_data/sidebars/pmd_sidebar.yml?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -94,9 +94,6 @@ entries:\n         - title: Defining rule properties\n           url: /pmd_userdocs_extending_defining_properties.html\n           output: web, pdf\n-        - title: Using and defining code metrics\n-          url: /pmd_userdocs_extending_metrics_howto.html\n-          output: web, pdf\n         - title: Rule guidelines\n           url: /pmd_userdocs_extending_rule_guidelines.html\n           output: web, pdf\n@@ -358,12 +355,6 @@ entries:\n     - title: JSP Support\n       url: /pmd_languages_jsp.html\n       output: web, pdf\n-    - title: Java code metrics\n-      url: /pmd_java_metrics_index.html\n-      output: web, pdf\n-    - title: Apex code metrics\n-      url: /pmd_apex_metrics_index.html\n-      output: web, pdf\n   - title: Developer Documentation\n     output: web, pdf\n     folderitems:\n@@ -403,9 +394,6 @@ entries:\n         - title: Adding a new CPD language\n           url: /pmd_devdocs_major_adding_new_cpd_language.html\n           output: web, pdf\n-        - title: Adding metrics support to a language\n-          url: /pmd_devdocs_major_adding_new_metrics_framework.html\n-          output: web, pdf\n       - title: Experimental features\n         output: web, pdf\n         subfolderitems:"
  },
  {
    "sha": "b2a7beb5f53d931eae29f140ce46fb5d5962f3fc",
    "filename": "docs/_data/xpath_funs.yml",
    "status": "modified",
    "additions": 13,
    "deletions": 3,
    "changes": 16,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/docs/_data/xpath_funs.yml",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/docs/_data/xpath_funs.yml",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/_data/xpath_funs.yml?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -65,12 +65,22 @@ langs:\n       - name: metric\n         returnType: \"xs:decimal?\"\n         shortDescription: \"Computes and returns the value of a metric\"\n-        description: \"Returns the value of the metric as evaluated on the context node\"\n-        notes: \"The context node must be a {% jdoc jast::ASTAnyTypeDeclaration %} or a {% jdoc jast::MethodLikeNode %}\"\n+        description:\n+          Returns the value of the metric as evaluated on the context node.\n+          If the metric cannot be computed on that node, returns an empty sequence\n+          (which is falsy).\n+\n         parameters:\n           - name: \"metricKey\"\n             type: \"xs:string\"\n-            description: \"The name of an enum constant in {% jdoc jmx::api.JavaOperationMetricKey %} or {% jdoc jmx::api.JavaClassMetricKey %}\"\n+            description: \"The name of a metric in {% jdoc jmx::JavaMetrics %} (or an alias thereof).\"\n+        examples:\n+          - code: \"//ClassOrInterfaceDeclaration[metric('NCSS') > 200]\"\n+            outcome: \"\"\n+          - code: \"//MethodDeclaration[metric('CYCLO') > 10 and metric('NCSS') > 20]\"\n+            outcome: \"\"\n+          - code: \"//TypeParameter[metric('idontexist') > 50]\"\n+            outcome: \"Error: no such metric\"\n \n       - name: hasAnnotation\n         returnType: \"xs:boolean\""
  },
  {
    "sha": "3fe7ee272e04f22163a6b48e6c19f7f78a98ef99",
    "filename": "docs/pages/7_0_0_release_notes.md",
    "status": "modified",
    "additions": 17,
    "deletions": 2,
    "changes": 19,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/docs/pages/7_0_0_release_notes.md",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/docs/pages/7_0_0_release_notes.md",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/pages/7_0_0_release_notes.md?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -176,8 +176,23 @@ The following previously deprecated rules have been finally removed:\n \n #### Metrics framework\n \n-* {% jdoc_old !!core::lang.metrics.MetricKeyUtil#of(java.lang.String, core::lang.metrics.Metric) %} is replaced with {% jdoc_old !!core::lang.metrics.MetricKey#of(java.lang.String, core::lang.metrics.Metric) %}\n-* {% jdoc_old !!core::lang.metrics.MetricsUtil#computeAggregate(core::lang.metrics.MetricKey, java.lang.Iterable, core::lang.metrics.ResultOption) %} and its overload are replaced with {% jdoc_old !!core::lang.metrics.MetricsUtil#computeStatistics(core::lang.metrics.MetricKey, java.lang.Iterable) %}, {% jdoc_old core::lang.metrics.ResultOption %} is removed\n+The metrics framework has been made simpler and more general.\n+\n+* The metric interface takes an additional type parameter, representing the result type of the metric. This is usually `Integer` or `Double`. It avoids widening the result to a `double` just to narrow it down.\n+\n+  This makes it so, that `Double.NaN` is not an appropriate sentinel value to represent \"not supported\" anymore. Instead, `computeFor` may return `null` in that case (or a garbage value). The value `null` may have caused problems with the narrowing casts, which through unboxing, might have thrown an NPE. But when we deprecated the language-specific metrics façades to replace them with the generic `MetricsUtil`, we took care of making the new methods throw an exception if the metric cannot be computed on the parameter. This forces you to guard calls to `MetricsUtil::computeMetric` with something like `if (metric.supports(node))`. If you're following this pattern, then you won't observe the undefined behavior.\n+\n+* The `MetricKey` interface is not so useful and has been merged into the `Metric` interface and removed. So the `Metric` interface has the new method `String name()`.\n+\n+* The framework is not tied to at most 2 node types per language anymore. Previously those were nodes for classes and for methods/constructors. Instead, many metrics support more node types. For example, NCSS can be computed on any code block.\n+\n+  For that reason, keeping around a hard distinction between \"class metrics\" and \"operation metrics\" is not useful. So in the Java framework for example, we removed the interfaces `JavaClassMetric`, `JavaOperationMetric`,  abstract classes for those, `JavaClassMetricKey`, and `JavaOperationMetricKey`. Metric constants are now all inside the `JavaMetrics` utility class. The same was done in the Apex framework.\n+\n+  We don't really need abstract classes for metrics now. So `AbstractMetric` is also removed from pmd-core. There is a factory method on the `Metric` interface to create a metric easily.\n+\n+* This makes it so, that {% jdoc core::lang.metrics.LanguageMetricsProvider %} does not need type parameters. It can just return a `Set<Metric<?, ?>>` to list available metrics.\n+\n+* {% jdoc_old core::lang.metrics.Signature %}s, their implementations, and the interface `SignedNode` have been removed. Node streams allow replacing their usages very easily.\n \n ### External Contributions\n "
  },
  {
    "sha": "384efa8ea267f1f06885c214ec1755f1ec27313d",
    "filename": "docs/pages/pmd/devdocs/major_contributions/adding_new_metrics_framework.md",
    "status": "removed",
    "additions": 0,
    "deletions": 46,
    "changes": 46,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/devdocs/major_contributions/adding_new_metrics_framework.md",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/devdocs/major_contributions/adding_new_metrics_framework.md",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/pages/pmd/devdocs/major_contributions/adding_new_metrics_framework.md?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,46 +0,0 @@\n----\n-title: Adding support for metrics to a language\n-short_title: Implement a metrics framework\n-tags: [devdocs, extending, metrics]\n-summary: \"PMD's Java module has an extensive framework for the calculation of metrics, which allows rule developers\n-to implement and use new code metrics very simply. Most of the functionality of this framework is abstracted in such\n-a way that any PMD supported language can implement such a framework without too much trouble. Here's how.\"\n-last_updated: February 2020\n-permalink: pmd_devdocs_major_adding_new_metrics_framework.html\n-author: Clément Fournier <clement.fournier76@gmail.com>\n----\n-\n-## Internal architecture of the metrics framework\n-\n-The framework is pretty simple. On a high level, a `Metric<N>` describes some numeric computation on a node of type `N`.\n-You should wrap it into a `MetricKey<N>`, so that it can be cached on nodes (implemented by {%jdoc core::lang.metrics.MetricsUtil %}).\n-\n-At the very least, a metrics framework has those two components and is just a convenient way to compute and memoize\n-metrics on a single file. The expressive power of metrics can be improved by implementing *signature matching* capabilities,\n-which allows a metric to count signatures matching a specific pattern (a mask) over a whole class. This was originally\n-designed to work across files, given a working usage resolution. However, making that work with incremental analysis is\n-harder than it looks, and has been rescheduled to another project.\n-\n-## Implementation of a new framework\n-\n-* Implement metrics (typically in an internal package)\n-* Create some public enums/ utility classes to expose metric keys\n-* Implement a {%jdoc core::lang.metrics.LanguageMetricsProvider %}, to expose your metrics to the designer\n-* Use your metric keys in rules with {%jdoc core::lang.metrics.MetricsUtil %}\n-\n-### Optional: Signature matching\n-\n-You can match the signature of anything: method, field, class, package... It depends on what's useful for you.\n-Suppose you want to be able to match signatures for nodes of type `N`. What you have to do then is the following:\n-\n-* Create a class implementing the interface `Signature<N>`. Signatures describe basic information about the node,\n-which typically includes most of the modifiers they declare (eg visibility, abstract or virtual, etc.).\n-It's up to you to define the right level of detail, depending on the accuracy of the pattern matching required.\n-* Make type `N` implement `SignedNode<N>`. This makes the node capable of giving its signature. Factory methods to\n-build a `Signature<N>` from a `N` are a good idea.\n-* Create signature masks. A mask is an object that matches some signatures based on their features. For example, with\n- the Java framework, you can build a `JavaOperationSigMask` that matches all method signatures with visibility\n- `public`. A sigmask implements `SigMask<S>`, where `S` is the type of signature your mask handles.\n-* Create utility methods in your abstract class metric class to count signatures matching a specific mask.\n-[Example](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/AbstractJavaClassMetric.java#L52)\n-"
  },
  {
    "sha": "6b0b62bf7b494ba47897c3ccad0b3b0233febcc7",
    "filename": "docs/pages/pmd/languages/apex_metrics_index.md",
    "status": "removed",
    "additions": 0,
    "deletions": 71,
    "changes": 71,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/languages/apex_metrics_index.md",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/languages/apex_metrics_index.md",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/pages/pmd/languages/apex_metrics_index.md?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,71 +0,0 @@\n----\n-title:  Index of Apex code metrics\n-tags: [extending, metrics]\n-summary: \"Index of the code metrics available out of the box to Apex rule developers.\"\n-last_updated: July 20, 2017\n-permalink: pmd_apex_metrics_index.html\n-toc:\n-  minimumHeaders: 8\n----\n-# Index of code metrics\n-\n-## Cyclomatic Complexity (CYCLO) \n-\n-*Operation metric.* Can be calculated on any non-abstract operation.\n-\n-### Description\n-\n-Number of independent paths through a block of code \\[[Lanza05](#Lanza05)\\]. \n-Formally, given that the control flow graph of the block has `n` vertices, `e` \n-edges and `p` connected components, the cyclomatic complexity of the block is \n-given by `CYCLO = e - n + 2p` \\[[McCabe76](#McCabe76)\\]. In practice it can be \n-calculated by counting control flow statements following the standard rules given \n-below.\n-\n-The standard version of the metric complies with McCabe's original definition:\n-\n-* Methods have a base complexity of 1.\n-* +1 for every control flow statement (`if`, `catch`, `throw`, `do`,\n-  `while`, `for`, `break`, `continue`) and conditional expression (`?:`).\n-* `else`, `finally` and `default` don't count;\n-* +1 for every boolean operator (`&&`, `||`) in the guard condition of a control \n-  flow statement.\n-\n-### Code examples\n-\n-```java\n-class Foo {\n-  void baseCyclo() {                // Cyclo = 1\n-    highCyclo();\n-  }\n-  \n-  void highCyclo() {                // Cyclo = 10\n-    int x = 0, y = 2;\n-    boolean a = false, b = true;\n-    \n-    if (a && (y == 1 ? b : true)) { // +3\n-      if (y == x) {                 // +1\n-        while (true) {              // +1\n-          if (x++ < 20) {           // +1\n-            break;                  // +1\n-          }\n-        }\n-      } else if (y == t && !d) {    // +2\n-        x = a ? y : x;              // +1\n-      } else {\n-        x = 2;\n-      }\n-    }  \n-  }     \n-}\n-```\n-\n-## Weighted Method Count (WMC)\n-\n-*Class metric.* Can be computed on classes and enums.\n-\n-# References\n-\n-<a name=\"Lanza05\">Lanza05:</a> Lanza, Marinescu; Object-Oriented Metrics in Practice, 2005.\n-\n-<a name=\"McCabe76\">McCabe76:</a> McCabe, A Complexity Measure, in Proceedings of the 2nd ICSE (1976)."
  },
  {
    "sha": "f2dad16f17d18539a336562b40a451b6cd6d5ce7",
    "filename": "docs/pages/pmd/languages/java_metrics_index.md",
    "status": "removed",
    "additions": 0,
    "deletions": 346,
    "changes": 346,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/languages/java_metrics_index.md",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/languages/java_metrics_index.md",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/pages/pmd/languages/java_metrics_index.md?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,346 +0,0 @@\n----\n-title:  Index of Java code metrics\n-tags: [extending, metrics]\n-summary: \"Index of the code metrics available out of the box to Java rule developers.\"\n-last_updated: July 20, 2017\n-permalink: pmd_java_metrics_index.html\n-toc:\n-  minimumHeaders: 8\n----\n-# Index of code metrics\n-\n-## Access to Foreign Data (ATFD)\n-\n-*Operation metric, class metric.* Can be computed on classes, enums and \n-concrete operations.\n-\n-### Description\n-\n-Number of usages of foreign attributes, both directly and through accessors. \n-High values of ATFD (> 3 for an operation) may suggest that the class or operation\n-breaks encapsulation by relying on the internal representation of the classes\n-it uses instead of the services they provide.\n- \n-ATFD can be used to detect God Classes and Feature Envy. \\[[Lanza05](#Lanza05)\\]\n-\n-## Class Fan Out Complexity (CLASS_FAN_OUT)\n-\n-*Operation metric, class metric.* Can be computed on classes, enums and \n-concrete operations.\n-\n-### Description\n-This counts the number of other classes a given class or operation relies on.\n-Classes from the package `java.lang` are ignored by default (can be changed via options).\n-Also primitives are not included into the count.\n-\n-### Code example\n-\n-```java\n-import java.util.*;\n-import java.io.IOException;\n-\n-public class Foo { // total 8\n-    public Set set = new HashSet(); // +2\n-    public Map map = new HashMap(); // +2\n-    public String string = \"\"; // from java.lang -> does not count by default\n-    public Double number = 0.0; // from java.lang -> does not count by default\n-    public int[] intArray = new int[3]; // primitive -> does not count\n-\n-    @Deprecated // from java.lang -> does not count by default\n-    @Override // from java.lang -> does not count by default\n-    public void foo(List list) throws Exception { // +1 (Exception is from java.lang)\n-        throw new IOException(); // +1\n-    }\n-\n-    public int getMapSize() {\n-        return map.size(); // +1 because it uses the Class from the 'map' field\n-    }   \n-}\n-```\n-\n-### Options\n-\n-* Option `includeJavaLang`: Also include classes from the package `java.lang`\n-\n-## Cyclomatic Complexity (CYCLO) \n-\n-*Operation metric.* Can be calculated on any non-abstract operation.\n-\n-### Description\n-\n-Number of independent paths through a block of code \\[[Lanza05](#Lanza05)\\]. \n-Formally, given that the control flow graph of the block has `n` vertices, `e` \n-edges and `p` connected components, the cyclomatic complexity of the block is \n-given by `CYCLO = e - n + 2p` \\[[McCabe76](#McCabe76)\\]. In practice it can be \n-calculated by counting control flow statements following the standard rules given \n-below.\n-\n-The standard version of the metric complies with McCabe's original definition:\n-\n-* Methods have a base complexity of 1.\n-* +1 for every control flow statement (`if`, `case`, `catch`, `throw`, `do`, \n-  `while`, `for`, `break`, `continue`) and conditional expression (`?:`) \n-  \\[[Sonarqube](#Sonarqube)\\]. Notice switch cases count as one, but not the \n-  switch itself: the point is that a switch should have the same complexity \n-  value as the equivalent series of `if` statements. \n-* `else`, `finally` and `default` don't count;\n-* +1 for every boolean operator (`&&`, `||`) in the guard condition of a control \n-  flow statement. That's because Java has short-circuit evaluation semantics for \n-  boolean operators, which makes every boolean operator kind of a control flow \n-  statement in itself.\n-\n-### Code examples\n-\n-```java\n-class Foo {\n-  void baseCyclo() {                // Cyclo = 1\n-    highCyclo();\n-  }\n-  \n-  void highCyclo() {                // Cyclo = 10\n-    int x = 0, y = 2;\n-    boolean a = false, b = true;\n-    \n-    if (a && (y == 1 ? b : true)) { // +3\n-      if (y == x) {                 // +1\n-        while (true) {              // +1\n-          if (x++ < 20) {           // +1\n-            break;                  // +1\n-          }\n-        }\n-      } else if (y == t && !d) {    // +2\n-        x = a ? y : x;              // +1\n-      } else {\n-        x = 2;\n-      }\n-    }  \n-  }     \n-}\n-```\n-### Options\n-\n-* Option `CycloVersion#IGNORE_BOOLEAN_PATHS`: Boolean operators are not counted,\n-  nor are empty fall-through cases in `switch` statements. You can use this \n-  option to get results similar to those of the old `StdCyclomaticComplexityRule`, \n-  which is to be replaced.\n-* Option `CycloVersion#CONSIDER_ASSERTS`: Assert statements are counted as if \n-  they were `if (..) throw new AssertionError(..)`. Compatible with \n-  `IGNORE_BOOLEAN_PATHS`.\n- \n-## Lines of Code (LoC)\n-\n-*Operation metric, class metric.* Can be calculated on any of those nodes.\n-\n-### Description\n-\n-Simply counts the number of lines of code the operation or class takes up in \n-the source. This metric doesn't discount comments or blank lines. See also \n-[NCSS](#non-commenting-source-statements-ncss).\n-\n-\n-## Non-commenting source statements (NCSS)\n-\n-*Operation metric, class metric.* Can be calculated on any of those nodes.\n-\n-### Description\n-\n-Number of statements in a class or operation. That's roughly equivalent to \n-counting the number of semicolons and opening braces in the program. Comments \n-and blank lines are ignored, and statements spread on multiple lines count as \n-only one (e.g. `int\\n a;` counts a single statement). \n-\n-The standard version of the metric is based off JavaNCSS's version  \n-\\[[JavaNcss](#JavaNcss)\\]:\n-\n-* +1 for any of the following statements: `if`, `else`, `while`, `do`, `for`, \n-  `switch`, `break`, `continue`, `return`, `throw`, `synchronized`, `catch`, \n-  `finally`.\n-* +1 for each assignment, variable declaration (except `for` loop initializers) \n-  or statement expression. We count variables  declared on the same line (e.g. \n-  `int a, b, c;`) as a single statement. \n-* Contrary to Sonarqube, but as JavaNCSS, we count type declarations (class, \n-  interface, enum, annotation), and method and field declarations \n-  \\[[Sonarqube](#Sonarqube)\\].\n-* Contrary to JavaNCSS, but as Sonarqube, we do not count package declaration \n-  and import declarations as statements. This makes it easier to compare nested \n-  classes to outer classes. Besides, it makes for class metric results that \n-  actually represent the size of the class and not of the file. If you don't \n-  like that behaviour, use the `COUNT_IMPORTS` option.\n-\n-### Code example\n-```java\n-import java.util.Collections;       // +0\n-import java.io.IOException;         // +0\n-\n-class Foo {                         // +1, total Ncss = 12\n-  \n-  public void bigMethod()           // +1\n-      throws IOException {     \n-    int x = 0, y = 2;               // +1\n-    boolean a = false, b = true;    // +1\n-    \n-    if (a || b) {                   // +1\n-      try {                         // +1\n-        do {                        // +1\n-          x += 2;                   // +1\n-        } while (x < 12);\n-          \n-        System.exit(0);             // +1\n-      } catch (IOException ioe) {   // +1\n-        throw new PatheticFailException(ioe); // +1\n-      }\n-    } else {\n-      assert false;                 // +1\n-    }\n-  }     \n-}\n-```\n-\n-\n-### Options\n-\n-* Option `NcssVersion#COUNT_IMPORTS`: Import and package statements are counted \n-  as well. This version fully complies with JavaNCSS.\n-\n-## NPath complexity (NPath)\n-\n-*Operation metric.* Can be computed on any non-abstract operation.\n-\n-### Description\n-\n-Number of acyclic execution paths through a piece of code. This is related to \n-cyclomatic complexity, but the two metrics don't count the same thing: NPath \n-counts the number of distinct *full* paths from the beginning to the end of the \n-method, while Cyclo only counts the number of decision points. NPath is not \n-computed as simply as Cyclo. With NPath, two decision points appearing sequentially \n-have their complexity multiplied. \n-\n-The fact that NPath multiplies the complexity of statements makes it grow \n-exponentially: 10 `if` - `else` statements in a row would give an NPath of 1024, \n-while Cyclo would evaluate to 20. Methods with an NPath complexity over 200 are \n-generally considered too complex.\n-\n-We compute NPath recursively, with the following set of rules:\n-* An empty block has a complexity of 1.\n-* The complexity of a block is the product of the NPath complexity of its \n-  statements, calculated as follows:\n-  * The complexity of `for`, `do` and `while` statements is 1, plus the \n-    complexity of the block, plus the complexity of the guard condition.\n-  * The complexity of a cascading `if` statement (`if .. else if ..`) is the \n-    number of `if` statements in the chain, plus the complexity of their guard \n-    condition, plus the complexity of the unguarded `else` block (or 1 if there \n-    is none).\n-  * The complexity of a `switch` statement is the number of cases, plus the \n-    complexity of each `case` block. It's equivalent to the complexity of the \n-    equivalent cascade of `if` statements.\n-  * The complexity of a ternary expression (`?:`) is the complexity of the guard\n-    condition, plus the complexity of both expressions. It's equivalent to the \n-    complexity of the equivalent `if .. else` construct.\n-  * The complexity of a `try .. catch` statement is the complexity of the `try` \n-    block, plus the complexity of each catch block.\n-  * The complexity of a `return` statement is the complexity of the expression \n-    (or 1 if there is none).\n-  * All other statements have a complexity of 1 and are discarded from the product.\n-   \n-### Code example\n-\n-```java\n-void fun(boolean a, boolean b, boolean c) { // NPath = 6\n-    \n-  // block #0\n-  \n-  if (a) {\n-    // block #1\n-  } else {\n-    // block #2\n-  }\n-  \n-  // block #3\n-  \n-  if (b) {\n-    // block #4\n-  } else if (c) {\n-    // block #5  \n-  }\n-  \n-  // block #6\n-}\n-```\n-After block 0, the control flow can either execute block 1 or 2 before jumping \n-to block 3. From block three, the control flow will again have the choice \n-between blocks 4 and 5 before jumping to block 6. The first `if` offers 2 \n-choices, the second offers 3, so the cyclomatic complexity of this method is \n-2 + 3 = 5. NPath, however, sees 2 * 3 = 6 full paths from the beginning to the end.\n- \n-\n-## Number Of Public Attributes (NOPA)\n-*Class metric.* Can be computed on classes.\n-\n-## Number Of Accessor Methods (NOAM)\n-*Class metric.* Can be computed on classes.\n-\n-## Tight Class Cohesion (TCC)\n-\n-*Class metric.* Can be computed on classes and enums.\n-\n-### Description\n-\n-The relative number of method pairs of a class that access in common at\n-least one attribute of the measured class. TCC only counts\n-direct attribute accesses, that is, only those attributes that are accessed in\n-the body of the method \\[[BK95](#BK95)\\].\n-\n-TCC is taken to be a reliable cohesion metric for a class. High values (>70%)\n-indicate a class with one basic function, which is hard to break into subcomponents.\n-On the other hand, low values (<50%) may indicate that the class tries to do too much and\n-defines several unrelated services, which is undesirable.\n-\n-TCC can be used to detect God Classes and Brain Classes \\[[Lanza05](#Lanza05)\\].\n- \n-## Weighted Method Count (WMC)\n-\n-*Class metric.* Can be computed on classes and enums.\n-\n-### Description\n-\n-Sum of the statistical complexity of the operations in the class. We use \n-[CYCLO](#cyclomatic-complexity-cyclo) to quantify the complexity of an operation \n-\\[[Lanza05](#Lanza05)\\].\n-\n-### Options\n-\n-WMC uses the same options as CYCLO, which are provided to CYCLO when \n-computing it.\n-\n-## Weight Of Class (WOC)\n-\n-*Class metric.* Can be computed on classes.\n-\n-### Description\n-\n-Number of \"functional\" public methods divided by the total number of\n-public methods. Our definition of \"functional method\" excludes\n-constructors, getters, and setters.\n-\n-This metric tries to quantify whether the measured class' interface reveals\n-more data than behaviour. Low values (less than 30%) indicate that the class\n-reveals much more data than behaviour, which is a sign of poor encapsulation.\n-\n-This metric is used to detect Data Classes, in conjunction with [WMC](#weighted-method-count-wmc),\n-[NOPA](#number-of-public-attributes-nopa) and [NOAM](#number-of-accessor-methods-noam).\n-\n-\n-\n-# References\n-\n-\n-<a name=\"BK95\">BK95:</a> Bieman, Kang; Cohesion and reuse in an object-oriented system. \n-In Proceedings ACM Symposium on Software Reusability, 1995.\n-\n-<a name=\"Lanza05\">Lanza05:</a> Lanza, Marinescu; Object-Oriented Metrics in Practice, 2005.\n-\n-<a name=\"McCabe76\">McCabe76:</a> McCabe, A Complexity Measure, in Proceedings of the 2nd ICSE (1976).\n-\n-<a name=\"Sonarqube\">Sonarqube:</a> [Sonarqube online documentation.](https://docs.sonarqube.org/display/SONAR/Metric+Definitions)\n-\n-<a name=\"JavaNcss\">JavaNcss:</a> [JavaNCSS online documentation.](http://www.kclee.de/clemens/java/javancss/)"
  },
  {
    "sha": "80ae0cf5169358f670a57a6bc4347453e145e0e6",
    "filename": "docs/pages/pmd/userdocs/extending/metrics_howto.md",
    "status": "removed",
    "additions": 0,
    "deletions": 301,
    "changes": 301,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/userdocs/extending/metrics_howto.md",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/docs/pages/pmd/userdocs/extending/metrics_howto.md",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/docs/pages/pmd/userdocs/extending/metrics_howto.md?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,301 +0,0 @@\n----\n-title:  Using and defining code metrics for custom rules\n-tags: [extending, userdocs, metrics]\n-summary: \"Since version 6.0.0, PMD is enhanced with the ability to compute code metrics on Java and Apex source (the so-called\n-Metrics Framework). This framework provides developers with a straightforward interface to use code metrics in their\n-rules, and to extend the framework with their own custom metrics.\"\n-last_updated: December 18, 2017\n-permalink: pmd_userdocs_extending_metrics_howto.html\n-author: Clément Fournier <clement.fournier76@gmail.com>\n----\n-\n-{% jdoc_nspace :coremx core::lang.metrics %}\n-{% jdoc_nspace :coreast core::lang.ast %}\n-{% jdoc_nspace :jmx java::lang.java.metrics %}\n-{% jdoc_nspace :jast java::lang.java.ast %}\n-\n-\n-## Using the metrics framework\n-\n-{%include note.html content=\"The following explains how to use the Java metrics framework. The Apex framework \n-differs only by the name of its classes.\" %}\n-\n-In PMD's Metrics framework, a metric is an operation that can be carried out on nodes of a certain type and produces\n-a numeric result. In the Java framework, metrics can be computed on operation declaration nodes (constructor and\n-method declaration), and type declaration nodes (class, interface, enum, and annotation declarations). A metric\n-object in the framework can only handle either types or operations, but not both.\n-\n-PMD ships with a library of already implemented metrics. These metrics are referenced by {% jdoc coremx::MetricKey %} objects,\n-which are listed in two public enums: {% jdoc jmx::api.JavaClassMetricKey %} and {% jdoc jmx::api.JavaOperationMetricKey %}.\n-Metric keys wrap a metric, and know which type of node their metric can be computed on. That way, you cannot compute an operation metric on a class\n-declaration node. Metrics that can be computed on both operation and type declarations (e.g. NCSS) have one metric key in\n-each enum.\n-\n-## For XPath rules\n-\n-XPath rules can compute metrics using the `metric` function. This function takes a single **string argument**,\n-which is the name of the metric key as defined in  `JavaClassMetricKey` or `JavaOperationMetricKey`. The metric\n- will be **computed on the context node**.\n-\n-The function will throw an exception in the following cases:\n-* The context node is neither an instance of {% jdoc jast::ASTAnyTypeDeclaration %} or {% jdoc jast::MethodLikeNode %}, that is,\n-it's not one of {% jdoc jast::ASTClassOrInterfaceDeclaration %}, {% jdoc jast::ASTEnumDeclaration},\n-{% jdoc jast::ASTAnnotationDeclaration %}, {% jdoc jast::ASTMethodDeclaration %},\n-{% jdoc jast::ASTConstructorDeclaration %}, or {% jdoc jast::ASTLambdaExpression %}.\n-* The metric key does not exist (the name is case insensitive) or is not defined for the type of the context node.\n-\n-{%include note.html\n-  content=\"More advanced features of the API are not accessible yet, but may be supported in the future.\n-           The API is thus subject to change.\" %}\n-\n-### Examples\n-\n-* `//ClassOrInterfaceDeclaration[metric('NCSS') > 200]`\n-* `//MethodDeclaration[metric('CYCLO') > 10 and metric('NCSS') > 20]`\n-* `//ClassOrInterfaceDeclaration[metric('CYCLO') > 50]`: IllegalArgumentException!\n-  CYCLO's only defined for methods and constructors.\n-\n-## For Java Rules\n-\n-The static façade class {% jdoc jmx::JavaMetrics %} is the single entry point to compute metrics in the Java framework.\n-\n-This class provides the method `get` and its overloads. The following sections describes the interface of this class.\n-\n-### Basic usage\n-\n-The simplest overloads of `JavaMetrics.get` take two parameters: **a `MetricKey` and a node of the corresponding type.**\n-Say you want to write a rule to report methods that have a high cyclomatic complexity. In your rule's visitor, you\n-can get the value of Cyclo for a method node like so:\n-```java\n-public Object visit(ASTMethodDeclaration method, Object data) {\n-  int cyclo = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, method);\n-  if (cyclo > 10) {\n-    // add violation\n-  }\n-  return data;\n-}\n-```\n-\n-The same goes for class metrics: you select one among `JavaClassMetricKey`'s constants and pass it along with the node\n-to `JavaMetrics.get`.\n-\n-{%include tip.html\n-           content=\"A specific base rule class (`AbstractJavaMetricsRule`) exists\n-           to e.g. check constructors and method nodes completely alike. This comes\n-           in handy for metrics, as they usually don't make the distinction\" %}\n-\n-### Capability checking\n-\n-Metrics are not necessarily computable on any node of the type they handle. For example, Cyclo cannot be computed on\n-abstract methods. Metric keys provides a {% jdoc !a!coremx::MetricKey#supports(coreast::Node) %} boolean method\n-to find out if the metric can be computed on\n-the specified node. **If the metric cannot be computed on the given node, `JavaMetrics.get` will return `Double.NaN` .**\n-If you're concerned about that, you can condition your call on whether the node is supported or not:\n-```java\n-public Object visit(ASTMethodDeclaration method, Object data) {\n-  if (JavaOperationMetricKey.CYCLO.supports(node)) {\n-    int cyclo = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, method);\n-    if (cyclo > 10) {\n-      // add violation\n-    }\n-    return data;\n-  }\n-}\n-```\n-\n-### Metric options\n-\n-Some metrics define options that can be used to slightly modify the computation. You'll typically see these options\n-gathered inside an enum in the implementation class of the metric, for example `CycloMetric.CycloOption`. They're\n-also documented on the [index of metrics](pmd_java_metrics_index.html).\n-\n-To use options with a metric, you must first bundle them into a {% jdoc coremx::MetricOptions %} object. `MetricOptions` provides the\n-utility method `ofOptions` to get a `MetricOptions` bundle from a collection or with varargs parameters. You can then\n-pass this bundle as a parameter to `JavaMetrics.get`:\n-```java\n-public Object visit(ASTMethodDeclaration method, Object data) {\n-  int cyclo = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, method,\n-                                    MetricOptions.ofOptions(CycloOptions.IGNORE_BOOLEAN_PATHS));\n-  if (cyclo > 10) {\n-      // add violation\n-  }\n-    return data;\n-}\n-```\n-\n-The version of `MetricOptions.ofOptions` using a collection is useful when you're building a `MetricOptions` from eg\n-the value of an `EnumeratedMultiProperty`, which gives users control of the options they use. See\n-[CyclomaticComplexityRule](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CyclomaticComplexityRule.java#L35)\n-for an example usage.\n-\n-### Result options\n-\n-The Metrics API also gives you the possibility to aggregate the result of an operation metric on all operations of a\n-class very simply. You can for example get the highest value of the metric over a class that way:\n-```java\n-public Object visit(ASTClassOrInterfaceDeclaration clazz, Object data) {\n-  int highest = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, clazz,\n-                                      ResultOption.HIGHEST);\n-  if (highest > 10) {\n-      // add violation\n-  }\n-    return data;\n-}\n-```\n-\n-Notice that **we use an operation metric and a class node**. The `ResultOption` parameter controls what result will be\n-computed: you can choose among `HIGHEST`, `SUM` and `AVERAGE`. You can use metric options together with a result\n-option too.\n-\n-### Complete use case\n-\n-The following is a sample code for a rule reporting methods with a cyclomatic\n-complexity over 10 and classes with a total cyclo over 50. A metric option can be\n-user-configured with a rule property. More complete examples can be found in\n-[CyclomaticComplexityRule](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/CyclomaticComplexityRule.java#L35),\n-[NcssCountRule](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/NcssCountRule.java#L30),\n-or [GodClassRule](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/GodClassRule.java#L24).\n-\n-\n-```java\n-public class CycloRule extends AbstractJavaMetricsRule {\n-\n-  public static final BooleanProperty COUNT_BOOLEAN_PATHS\n-      = BooleanProperty.named(\"countBooleanPaths\")\n-                       .desc(\"Count boolean paths\")\n-                       .defaultValue(true).build();\n-\n-  private static final MetricOptions options;\n-\n-  public CycloRule() {\n-    definePropertyDescriptor(COUNT_BOOLEAN_PATHS);\n-  }\n-\n-  @Override\n-  public Object visit(ASTCompilationUnit node, Object data) {\n-    options = getProperty(COUNT_BOOLEAN_PATHS)\n-              ? MetricOptions.ofOptions(CycloOptions.IGNORE_BOOLEAN_PATHS)\n-              : MetricOptions.emptyOptions();\n-  }\n-\n-  @Override\n-  public Object visit(ASTAnyTypeDeclaration clazz, Object data) {\n-    int total = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, clazz,\n-                                      options, ResultOption.SUM);\n-\n-    if (total > 50) {\n-     // add violation\n-    }\n-\n-    return data;\n-  }\n-\n-  @Override\n-  public Object visit(ASTMethodDeclaration method, Object data) {\n-    int cyclo = (int) JavaMetrics.get(JavaOperationMetricKey.CYCLO, method,\n-                                      options);\n-    if (cyclo > 10) { // this is safe if the node is not supported, as (Double.NaN > 10) == false\n-      // add violation\n-    }\n-    return data;\n-  }\n-}\n-```\n-\n-## Available metrics\n-\n-There are already many metrics ready to use. We maintain the following documentation\n-pages to describe them all, including their usage and options:\n-* [Java metrics](pmd_java_metrics_index.html)\n-* [Apex metrics](pmd_apex_metrics_index.html)\n-\n-\n-## Writing custom metrics\n-\n-You can use the framework to customize the existing metrics at will, or define\n-new ones quite easily. Here's some info to get you started. Again, the examples are for\n-the Java framework but it's symmetrical in the Apex framework.\n-\n-### The really short guide\n-\n-1. Determine whether your metric is an operation metric or a class metric and\n-   **extend the correct base class** ({% jdoc jmx::AbstractJavaClassMetric %} or\n-   {% jdoc jmx::AbstractJavaOperationMetric %})\n-1. You're immediately prompted by your IDE to **implement the `computeFor` method**.\n-   This method takes a node of the type you want to handle, a bundle of options,\n-   and returns the result of the metric.\n-1. Optionally specify a predicate to check if a node can be handled by **overriding\n-   the `supports` method**.\n-1. Optionally define options (implementing [`MetricOption`](https://github.com/pmd/pmd/blob/master/pmd-core/src/main/java/net/sourceforge/pmd/lang/metrics/MetricOption.java))\n-   and handle them as you see fit in your `computeFor` method\n-1. **Create a metric key** using `MetricKeyUtil`'s `of` method, specifying a name\n-   for your metric and an instance of your metric. You're done and can use your\n-   metric key as if it were a standard one.\n-\n-### Best practices\n-\n-* **Metrics should be stateless**. In any case, instances of the same metric class\n-  are considered `equals`. The same instance of your metric will be used to\n-  compute the metric on the AST of different nodes so it should really be\n-  \"functionally pure\". That rule also makes you keep it simple and understandable\n-  which is nice.\n-* **Implementation patterns:** You can implement your `computeFor` method as you\n-  like it. But most metrics in our library are implemented following a few\n-  patterns you may want to look at:\n-  * *Visitor metrics:* Those metrics use one or more AST visitor to compute their\n-    value. That's especially good to implement metrics that count some kind of node,\n-    e.g. [NPath complexity](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NpathMetric.java)\n-    or [NCSS](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NcssMetric.java).\n-    Additionally, it makes your metric more easily generalisable to other node types.\n-\n-  * *Signature matching metrics:* That's even more straightforward when you want\n-    to count the number of methods or fields that match a specific signature, e.g.\n-    public static final fields. Basically a signature is an object that describes\n-    a field or method, with info about its modifers and other node-specific info.\n-     `AbstractJavaClassMetric` has a few methods that allow you to count signatures\n-      directly, see e.g. the metrics [NOPA](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/NopaMetric.java)\n-      and [WOC](https://github.com/pmd/pmd/blob/master/pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/internal/WocMetric.java).\n-\n-\n-### Capability checking\n-\n-You may have noticed that when you extend e.g. `AbstractJavaClassMetric`, the\n-`computeFor` method you're prompted to implement takes a node of type\n-`ASTAnyTypeDeclaration` as a parameter. That's not a concrete node type, but\n-an interface, implemented by several concrete node types. Basically that's done\n-so that class metrics are given the ability to be computed on any type\n-declaration, and operation metrics on constructors and methods. Here are the\n-concrete node types you can target with class and operation metrics, by language:\n-\n-\n-Language   | Java | Apex |\n------------|------|------|\n-Operation declaration|`ASTMethodOrConstructorDeclaration`<br/>>: `ASTMethodDeclaration`, `ASTConstructorDeclaration`| `ASTMethod`*\n-Type declaration|`ASTAnyTypeDeclaration` >: `ASTEnumDeclaration`, <br> `ASTAnnotationDeclaration`, `ASTClassOrInterfaceDeclaration`| `ASTUserClassOrInterface` >: `ASTUserClass`, `ASTUserInterface`\n-\n-*Apex method metrics are also applied to triggers by default (see [#771](https://github.com/pmd/pmd/pull/771)). Finer capability checking is not available out of the box for now.\n-\n-What if you don't want such a generalisation? The `supports` method lets you\n-define a predicate to check that the node is supported by your metric. For example,\n-if your metric can only be computed on classes, you may override the default behaviour\n-like so:\n-```java\n-@Override\n-public boolean supports(ASTAnyTypeDeclaration node) {\n-  return node.getTypeKind() == TypeKind.CLASS;\n-}\n-```\n-\n-{%include tip.html\n-  content=\"You can be sure that if your `supports` method returns `false` on a node, then\n-           that node will never be passed as a parameter to `computeFor`. That allows you\n-           to write your `computeFor` method without worrying about unsupported nodes.\" %}\n-\n-The `supports` method already has a default implementation in the abstract base\n-classes. Here's the default behaviour by language and type of metric:\n-\n-Language   | Java | Apex |\n------------|------|------|\n-Operation metrics| supports constructors and non abstract methods| supports any non abstract method (including triggers), except `<init>`, `<clinit>`, and `clone`\n-Type declaration|supports classes and enums|supports classes\n-"
  },
  {
    "sha": "ac4b2901600c2c742f175d317e665e816ebf6fbf",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexHandler.java",
    "status": "modified",
    "additions": 14,
    "deletions": 22,
    "changes": 36,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexHandler.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexHandler.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ApexHandler.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -4,20 +4,18 @@\n \n package net.sourceforge.pmd.lang.apex;\n \n-import java.util.Arrays;\n-import java.util.List;\n+import static net.sourceforge.pmd.util.CollectionUtil.setOf;\n+\n+import java.util.Set;\n \n import net.sourceforge.pmd.annotation.InternalApi;\n import net.sourceforge.pmd.lang.AbstractPmdLanguageVersionHandler;\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n import net.sourceforge.pmd.lang.apex.ast.ApexParser;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexClassMetricKey;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetricKey;\n+import net.sourceforge.pmd.lang.apex.metrics.ApexMetrics;\n import net.sourceforge.pmd.lang.apex.rule.internal.ApexRuleViolationFactory;\n import net.sourceforge.pmd.lang.ast.Parser;\n import net.sourceforge.pmd.lang.metrics.LanguageMetricsProvider;\n-import net.sourceforge.pmd.lang.metrics.internal.AbstractLanguageMetricsProvider;\n+import net.sourceforge.pmd.lang.metrics.Metric;\n import net.sourceforge.pmd.lang.rule.RuleViolationFactory;\n \n @InternalApi\n@@ -38,27 +36,21 @@ public Parser getParser() {\n \n \n     @Override\n-    public LanguageMetricsProvider<ASTUserClassOrInterface<?>, ASTMethod> getLanguageMetricsProvider() {\n+    public LanguageMetricsProvider getLanguageMetricsProvider() {\n         return myMetricsProvider;\n     }\n \n-    private static class ApexMetricsProvider extends AbstractLanguageMetricsProvider<ASTUserClassOrInterface<?>, ASTMethod> {\n-\n-        @SuppressWarnings(\"unchecked\")\n-        ApexMetricsProvider() {\n-            // a wild double cast\n-            super((Class<ASTUserClassOrInterface<?>>) (Object) ASTUserClassOrInterface.class, ASTMethod.class);\n-        }\n-\n-        @Override\n-        public List<ApexClassMetricKey> getAvailableTypeMetrics() {\n-            return Arrays.asList(ApexClassMetricKey.values());\n-        }\n+    private static class ApexMetricsProvider implements LanguageMetricsProvider {\n \n+        private final Set<Metric<?, ?>> metrics = setOf(\n+            ApexMetrics.COGNITIVE_COMPLEXITY,\n+            ApexMetrics.CYCLO,\n+            ApexMetrics.WEIGHED_METHOD_COUNT\n+        );\n \n         @Override\n-        public List<ApexOperationMetricKey> getAvailableOperationMetrics() {\n-            return Arrays.asList(ApexOperationMetricKey.values());\n+        public Set<Metric<?, ?>> getMetrics() {\n+            return metrics;\n         }\n     }\n }"
  },
  {
    "sha": "57ebfe6a56a0cbf1b8bfa635d15016e9df32eb9d",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethod.java",
    "status": "modified",
    "additions": 1,
    "deletions": 11,
    "changes": 12,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethod.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethod.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTMethod.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -4,14 +4,9 @@\n \n package net.sourceforge.pmd.lang.apex.ast;\n \n-import net.sourceforge.pmd.lang.apex.metrics.signature.ApexOperationSignature;\n-import net.sourceforge.pmd.lang.ast.Node;\n-import net.sourceforge.pmd.lang.ast.SignedNode;\n-\n import apex.jorje.semantic.ast.member.Method;\n \n-public final class ASTMethod extends AbstractApexNode<Method> implements ApexQualifiableNode,\n-                                                                         SignedNode<ASTMethod>, Node {\n+public final class ASTMethod extends AbstractApexNode<Method> implements ApexQualifiableNode {\n \n     ASTMethod(Method method) {\n         super(method);\n@@ -58,11 +53,6 @@ public ApexQualifiedName getQualifiedName() {\n     }\n \n \n-    @Override\n-    public ApexOperationSignature getSignature() {\n-        return ApexOperationSignature.of(this);\n-    }\n-\n     /**\n      * Returns true if this is a synthetic class initializer, inserted\n      * by the parser."
  },
  {
    "sha": "0b8c5c959416e378cc1fd81253360f148b20d637",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/AbstractApexMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 18,
    "changes": 18,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/AbstractApexMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/AbstractApexMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/AbstractApexMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,18 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics;\n-\n-import net.sourceforge.pmd.lang.ast.Node;\n-import net.sourceforge.pmd.lang.metrics.AbstractMetric;\n-\n-/**\n- * Base class for all Apex metrics.\n- *\n- * @author Clément Fournier\n- */\n-public abstract class AbstractApexMetric<N extends Node> extends AbstractMetric<N> {\n-\n-\n-}"
  },
  {
    "sha": "c97979efff6123928e780f899e5d51f897ca7eff",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetrics.java",
    "status": "added",
    "additions": 137,
    "deletions": 0,
    "changes": 137,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetrics.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetrics.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetrics.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -0,0 +1,137 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.apex.metrics;\n+\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import org.apache.commons.lang3.mutable.MutableInt;\n+\n+import net.sourceforge.pmd.internal.util.PredicateUtil;\n+import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n+import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\n+import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n+import net.sourceforge.pmd.lang.apex.ast.ApexNode;\n+import net.sourceforge.pmd.lang.apex.metrics.internal.CognitiveComplexityVisitor;\n+import net.sourceforge.pmd.lang.apex.metrics.internal.CognitiveComplexityVisitor.State;\n+import net.sourceforge.pmd.lang.apex.metrics.internal.StandardCycloVisitor;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.metrics.Metric;\n+import net.sourceforge.pmd.lang.metrics.MetricOptions;\n+import net.sourceforge.pmd.lang.metrics.MetricsUtil;\n+\n+/**\n+ * Built-in Apex metrics. See {@link Metric} and {@link MetricsUtil}\n+ * for usage doc.\n+ */\n+public final class ApexMetrics {\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private static final Class<ApexNode<?>> GENERIC_APEX_NODE_CLASS =\n+        (Class) ApexNode.class; // this is a Class<ApexNode>, the raw type\n+\n+\n+    /**\n+     * Number of independent paths through a block of code.\n+     * Formally, given that the control flow graph of the block has n\n+     * vertices, e edges and p connected components, the cyclomatic complexity\n+     * of the block is given by {@code CYCLO = e - n + 2p}. In practice\n+     * it can be calculated by counting control flow statements following\n+     * the standard rules given below.\n+     *\n+     *\n+     * <p>The standard version of the metric complies with McCabe’s original definition:\n+     * <ul>\n+     *  <li>Methods have a base complexity of 1.\n+     *  <li>+1 for every control flow statement (if, catch, throw, do, while, for, break, continue) and conditional expression (?:).\n+     *  <li>else, finally and default do not count;\n+     *  <li>+1 for every boolean operator ({@code &&}, {@code ||}) in\n+     *  the guard condition of a control flow statement. That’s because\n+     *  Apex has short-circuit evaluation semantics for boolean operators,\n+     *  which makes every boolean operator kind of a control flow statement in itself.\n+     * </ul>\n+     *\n+     * <p>Code example:\n+     * <pre>{@code\n+     * class Foo {\n+     *   void baseCyclo() {                // Cyclo = 1\n+     *     highCyclo();\n+     *   }\n+     *\n+     *   void highCyclo() {                // Cyclo = 10\n+     *     int x = 0, y = 2;\n+     *     boolean a = false, b = true;\n+     *\n+     *     if (a && (y == 1 ? b : true)) { // +3\n+     *       if (y == x) {                 // +1\n+     *         while (true) {              // +1\n+     *           if (x++ < 20) {           // +1\n+     *             break;                  // +1\n+     *           }\n+     *         }\n+     *       } else if (y == t && !d) {    // +2\n+     *         x = a ? y : x;              // +1\n+     *       } else {\n+     *         x = 2;\n+     *       }\n+     *     }\n+     *   }\n+     * }\n+     * }</pre>\n+     */\n+    public static final Metric<ApexNode<?>, Integer> CYCLO =\n+        Metric.of(ApexMetrics::computeCyclo, isRegularApexNode(),\n+                  \"Cyclomatic Complexity\", \"Cyclo\");\n+\n+    public static final Metric<ApexNode<?>, Integer> COGNITIVE_COMPLEXITY =\n+        Metric.of(ApexMetrics::computeCognitiveComp, isRegularApexNode(),\n+                  \"Cognitive Complexity\");\n+\n+\n+    /**\n+     * Sum of the statistical complexity of the operations in the class.\n+     * We use CYCLO to quantify the complexity of an operation.\n+     *\n+     */\n+    public static final Metric<ASTUserClassOrInterface<?>, Integer> WEIGHED_METHOD_COUNT =\n+        Metric.of(ApexMetrics::computeWmc, filterMapNode(ASTUserClass.class, PredicateUtil.always()),\n+                  \"Weighed Method Count\", \"WMC\");\n+\n+    private ApexMetrics() {\n+        // utility class\n+    }\n+\n+\n+\n+    private static Function<Node, ApexNode<?>> isRegularApexNode() {\n+        return filterMapNode(GENERIC_APEX_NODE_CLASS, n -> !(n instanceof ASTMethod && ((ASTMethod) n).isSynthetic()));\n+    }\n+\n+\n+    private static <T extends Node> Function<Node, T> filterMapNode(Class<? extends T> klass, Predicate<? super T> pred) {\n+        return n -> n.asStream().filterIs(klass).filter(pred).first();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private static int computeCyclo(ApexNode<?> node, MetricOptions ignored) {\n+        MutableInt result = new MutableInt(1);\n+        node.acceptVisitor(new StandardCycloVisitor(), result);\n+        return result.getValue();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private static int computeCognitiveComp(ApexNode<?> node, MetricOptions ignored) {\n+        State state = new State();\n+        node.acceptVisitor(CognitiveComplexityVisitor.INSTANCE, state);\n+        return state.getComplexity();\n+    }\n+\n+\n+\n+    private static int computeWmc(ASTUserClassOrInterface<?> node, MetricOptions options) {\n+        return (int) MetricsUtil.computeStatistics(CYCLO, node.getMethods(), options).getSum();\n+    }\n+\n+\n+}"
  },
  {
    "sha": "aa45ea9c297327ffaa6b39f2680c2d29294478ac",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexSignatureMatcher.java",
    "status": "removed",
    "additions": 0,
    "deletions": 24,
    "changes": 24,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexSignatureMatcher.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexSignatureMatcher.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexSignatureMatcher.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,24 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ApexQualifiedName;\n-import net.sourceforge.pmd.lang.apex.metrics.signature.ApexOperationSigMask;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public interface ApexSignatureMatcher {\n-\n-    /**\n-     * Returns true if the signature of the operation designated by the qualified name is covered by the mask.\n-     *\n-     * @param qname   The operation to test\n-     * @param sigMask The signature mask to use\n-     *\n-     * @return True if the signature of the operation designated by the qualified name is covered by the mask\n-     */\n-    boolean hasMatchingSig(ApexQualifiedName qname, ApexOperationSigMask sigMask);\n-}"
  },
  {
    "sha": "83bb1428651954bb3879b42c4eebc677def2f275",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 14,
    "changes": 14,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,14 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.api;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n-import net.sourceforge.pmd.lang.metrics.Metric;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public interface ApexClassMetric extends Metric<ASTUserClassOrInterface<?>> {\n-}"
  },
  {
    "sha": "73a08d5f2cdc077eb615910ce94bb16e2ae96613",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetricKey.java",
    "status": "removed",
    "additions": 0,
    "deletions": 39,
    "changes": 39,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetricKey.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetricKey.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexClassMetricKey.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,39 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.api;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.ClassCognitiveComplexityMetric;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.WmcMetric;\n-import net.sourceforge.pmd.lang.metrics.MetricKey;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public enum ApexClassMetricKey implements MetricKey<ASTUserClassOrInterface<?>> {\n-    COGNITIVE(new ClassCognitiveComplexityMetric()),\n-    WMC(new WmcMetric());\n-\n-\n-    private final ApexClassMetric calculator;\n-\n-\n-    ApexClassMetricKey(ApexClassMetric m) {\n-        calculator = m;\n-    }\n-\n-\n-    @Override\n-    public ApexClassMetric getCalculator() {\n-        return calculator;\n-    }\n-\n-\n-    @Override\n-    public boolean supports(ASTUserClassOrInterface<?> node) {\n-        return calculator.supports(node);\n-    }\n-\n-}"
  },
  {
    "sha": "79ed8323c453143828c0810e31d81c0cd73c0bae",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 14,
    "changes": 14,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,14 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.api;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.metrics.Metric;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public interface ApexOperationMetric extends Metric<ASTMethod> {\n-}"
  },
  {
    "sha": "e5816c5e6c2fd440e09dcb4729c4427b90d41fcf",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetricKey.java",
    "status": "removed",
    "additions": 0,
    "deletions": 38,
    "changes": 38,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetricKey.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetricKey.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/api/ApexOperationMetricKey.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,38 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.api;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.CognitiveComplexityMetric;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.CycloMetric;\n-import net.sourceforge.pmd.lang.metrics.MetricKey;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public enum ApexOperationMetricKey implements MetricKey<ASTMethod> {\n-    CYCLO(new CycloMetric()),\n-    COGNITIVE(new CognitiveComplexityMetric());\n-\n-\n-    private final ApexOperationMetric calculator;\n-\n-\n-    ApexOperationMetricKey(ApexOperationMetric m) {\n-        calculator = m;\n-    }\n-\n-\n-    @Override\n-    public ApexOperationMetric getCalculator() {\n-        return calculator;\n-    }\n-\n-\n-    @Override\n-    public boolean supports(ASTMethod node) {\n-        return calculator.supports(node);\n-    }\n-}"
  },
  {
    "sha": "ca0dbc59807f6be66dbf2e19a024fe572b3fe304",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexClassMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 24,
    "changes": 24,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexClassMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexClassMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexClassMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,24 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface.TypeKind;\n-import net.sourceforge.pmd.lang.apex.metrics.AbstractApexMetric;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexClassMetric;\n-\n-/**\n- * Base class for Apex metrics.\n- *\n- * @author Clément Fournier\n- */\n-public abstract class AbstractApexClassMetric extends AbstractApexMetric<ASTUserClassOrInterface<?>>\n-    implements ApexClassMetric {\n-\n-    @Override\n-    public boolean supports(ASTUserClassOrInterface<?> node) {\n-        return node.getTypeKind() == TypeKind.CLASS;\n-    }\n-}"
  },
  {
    "sha": "54a7ad66a1b2153b6df8f7a83ffca40fbc9f2667",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexOperationMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 32,
    "changes": 32,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexOperationMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexOperationMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/AbstractApexOperationMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,32 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\n-import net.sourceforge.pmd.lang.apex.metrics.AbstractApexMetric;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetric;\n-\n-/**\n- * Base class for Apex operation metrics.\n- *\n- * @author Clément Fournier\n- */\n-public abstract class AbstractApexOperationMetric extends AbstractApexMetric<ASTMethod> implements ApexOperationMetric {\n-\n-    /**\n-     * Checks if the metric can be computed on the node. For now, we filter out {@literal <clinit>, <init> and clone},\n-     * which are present in all apex class nodes even if they're not implemented, which may yield unexpected results.\n-     *\n-     * @param node The node to check\n-     *\n-     * @return True if the metric can be computed\n-     */\n-    @Override\n-    public boolean supports(ASTMethod node) {\n-        return !node.isSynthetic()\n-            && !node.getFirstChildOfType(ASTModifierNode.class).isAbstract();\n-    }\n-}"
  },
  {
    "sha": "3193727c30f1370b9a7c9715f2dd00d45fdc4f73",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/ClassCognitiveComplexityMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 22,
    "changes": 22,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/ClassCognitiveComplexityMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/ClassCognitiveComplexityMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/ClassCognitiveComplexityMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,22 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetricKey;\n-import net.sourceforge.pmd.lang.metrics.MetricOptions;\n-import net.sourceforge.pmd.lang.metrics.MetricsUtil;\n-\n-/**\n- * The sum of the cognitive complexities of all the methods within a class.\n- *\n- * @author Gwilym Kuiper\n- */\n-public class ClassCognitiveComplexityMetric extends AbstractApexClassMetric {\n-    @Override\n-    public double computeFor(ASTUserClassOrInterface<?> node, MetricOptions options) {\n-        return MetricsUtil.computeStatistics(ApexOperationMetricKey.COGNITIVE, node.getMethods()).getSum();\n-    }\n-}"
  },
  {
    "sha": "ce508231a5289ee7617c9e50a0d08ac59554b907",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CognitiveComplexityMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 26,
    "changes": 26,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CognitiveComplexityMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CognitiveComplexityMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CognitiveComplexityMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,26 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.visitors.CognitiveComplexityVisitor;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.visitors.CognitiveComplexityVisitor.State;\n-import net.sourceforge.pmd.lang.metrics.MetricOptions;\n-\n-/**\n- * Measures the cognitive complexity of a Class / Method in Apex.\n- *\n- * See https://www.sonarsource.com/docs/CognitiveComplexity.pdf for information about the metric\n- *\n- * @author Gwilym Kuiper\n- */\n-public class CognitiveComplexityMetric extends AbstractApexOperationMetric {\n-    @Override\n-    public double computeFor(ASTMethod node, MetricOptions options) {\n-        State state = new State();\n-        node.acceptVisitor(CognitiveComplexityVisitor.INSTANCE, state);\n-        return state.getComplexity();\n-    }\n-}"
  },
  {
    "sha": "dc13dc9d239fb7c0210f18e55114a6d4384ef9f4",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/WmcMetric.java",
    "status": "removed",
    "additions": 0,
    "deletions": 23,
    "changes": 23,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/WmcMetric.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/WmcMetric.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/WmcMetric.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,23 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetricKey;\n-import net.sourceforge.pmd.lang.metrics.MetricOptions;\n-import net.sourceforge.pmd.lang.metrics.MetricsUtil;\n-\n-/**\n- * See the doc for the Java metric.\n- *\n- * @author Clément Fournier\n- */\n-public class WmcMetric extends AbstractApexClassMetric {\n-\n-    @Override\n-    public double computeFor(ASTUserClassOrInterface<?> node, MetricOptions options) {\n-        return MetricsUtil.computeStatistics(ApexOperationMetricKey.CYCLO, node.getMethods()).getSum();\n-    }\n-}"
  },
  {
    "sha": "5a93ea72603ee71f05a3364ad60badd53028d33e",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/ApexMetricsHelper.java",
    "status": "renamed",
    "additions": 6,
    "deletions": 18,
    "changes": 24,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/ApexMetricsHelper.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/ApexMetricsHelper.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/ApexMetricsHelper.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -1,38 +1,26 @@\n-/**\n+/*\n  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n  */\n \n-package net.sourceforge.pmd.lang.apex.metrics.impl;\n+package net.sourceforge.pmd.lang.apex.metrics.internal;\n \n import java.util.HashSet;\n import java.util.Set;\n \n-import org.apache.commons.lang3.mutable.MutableInt;\n-\n import net.sourceforge.pmd.lang.apex.ast.ASTBooleanExpression;\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n import net.sourceforge.pmd.lang.apex.ast.ASTStandardCondition;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.visitors.StandardCycloVisitor;\n-import net.sourceforge.pmd.lang.metrics.MetricOptions;\n \n import apex.jorje.data.ast.BooleanOp;\n \n /**\n- * See the doc for the Java metric.\n  *\n- * @author Clément Fournier\n  */\n-public class CycloMetric extends AbstractApexOperationMetric {\n+public final class ApexMetricsHelper {\n \n-\n-    @Override\n-    public double computeFor(ASTMethod node, MetricOptions options) {\n-        MutableInt result = new MutableInt(1);\n-        node.acceptVisitor(new StandardCycloVisitor(), result);\n-        return result.doubleValue();\n+    private ApexMetricsHelper() {\n+        // utility class\n     }\n \n-\n     /**\n      * Computes the number of control flow paths through that expression, which is the number of {@code ||} and {@code\n      * &&} operators. Used both by Npath and Cyclo.\n@@ -41,7 +29,7 @@ public double computeFor(ASTMethod node, MetricOptions options) {\n      *\n      * @return The complexity of the expression\n      */\n-    public static int booleanExpressionComplexity(ASTStandardCondition expression) {\n+    static int booleanExpressionComplexity(ASTStandardCondition expression) {\n         Set<ASTBooleanExpression> subs = new HashSet<>(expression.findDescendantsOfType(ASTBooleanExpression.class));\n         int complexity = 0;\n ",
    "previous_filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/CycloMetric.java"
  },
  {
    "sha": "f6953c0660ba76db2e09b501fbb96c1e17b0f50f",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/CognitiveComplexityVisitor.java",
    "status": "renamed",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/CognitiveComplexityVisitor.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/CognitiveComplexityVisitor.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/CognitiveComplexityVisitor.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -1,8 +1,8 @@\n-/**\n+/*\n  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n  */\n \n-package net.sourceforge.pmd.lang.apex.metrics.impl.visitors;\n+package net.sourceforge.pmd.lang.apex.metrics.internal;\n \n import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;\n import net.sourceforge.pmd.lang.apex.ast.ASTBooleanExpression;\n@@ -21,7 +21,7 @@\n import net.sourceforge.pmd.lang.apex.ast.ASTWhileLoopStatement;\n import net.sourceforge.pmd.lang.apex.ast.ApexNode;\n import net.sourceforge.pmd.lang.apex.ast.ApexVisitorBase;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.visitors.CognitiveComplexityVisitor.State;\n+import net.sourceforge.pmd.lang.apex.metrics.internal.CognitiveComplexityVisitor.State;\n \n import apex.jorje.data.ast.BooleanOp;\n import apex.jorje.data.ast.PrefixOp;\n@@ -41,7 +41,7 @@\n         private BooleanOp currentBooleanOperation = null;\n         private String methodName = null;\n \n-        public double getComplexity() {\n+        public int getComplexity() {\n             return complexity;\n         }\n ",
    "previous_filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/visitors/CognitiveComplexityVisitor.java"
  },
  {
    "sha": "8cfdc83f683ac5ec6d1732cc8886bf1000064b32",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/StandardCycloVisitor.java",
    "status": "renamed",
    "additions": 7,
    "deletions": 8,
    "changes": 15,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/StandardCycloVisitor.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/StandardCycloVisitor.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/internal/StandardCycloVisitor.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -1,8 +1,8 @@\n-/**\n+/*\n  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n  */\n \n-package net.sourceforge.pmd.lang.apex.metrics.impl.visitors;\n+package net.sourceforge.pmd.lang.apex.metrics.internal;\n \n import org.apache.commons.lang3.mutable.MutableInt;\n \n@@ -17,7 +17,6 @@\n import net.sourceforge.pmd.lang.apex.ast.ASTThrowStatement;\n import net.sourceforge.pmd.lang.apex.ast.ASTWhileLoopStatement;\n import net.sourceforge.pmd.lang.apex.ast.ApexVisitorBase;\n-import net.sourceforge.pmd.lang.apex.metrics.impl.CycloMetric;\n \n /**\n  * @author Clément Fournier\n@@ -32,7 +31,7 @@ public Void visit(ASTMethod node, MutableInt data) {\n \n     @Override\n     public Void visit(ASTIfBlockStatement node, MutableInt data) {\n-        data.add(1 + CycloMetric.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n+        data.add(1 + ApexMetricsHelper.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n         return super.visit(node, data);\n     }\n \n@@ -47,7 +46,7 @@ public Void visit(ASTCatchBlockStatement node, MutableInt data) {\n     @Override\n     public Void visit(ASTForLoopStatement node, MutableInt data) {\n         data.add(\n-                1 + CycloMetric.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n+                1 + ApexMetricsHelper.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n         return super.visit(node, data);\n     }\n \n@@ -68,23 +67,23 @@ public Void visit(ASTThrowStatement node, MutableInt data) {\n     @Override\n     public Void visit(ASTWhileLoopStatement node, MutableInt data) {\n         data.add(\n-                1 + CycloMetric.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n+                1 + ApexMetricsHelper.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n         return super.visit(node, data);\n     }\n \n \n     @Override\n     public Void visit(ASTDoLoopStatement node, MutableInt data) {\n         data.add(\n-                1 + CycloMetric.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n+                1 + ApexMetricsHelper.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n         return super.visit(node, data);\n     }\n \n \n     @Override\n     public Void visit(ASTTernaryExpression node, MutableInt data) {\n         data.add(\n-                1 + CycloMetric.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n+                1 + ApexMetricsHelper.booleanExpressionComplexity(node.getFirstDescendantOfType(ASTStandardCondition.class)));\n         return super.visit(node, data);\n     }\n ",
    "previous_filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/impl/visitors/StandardCycloVisitor.java"
  },
  {
    "sha": "feb8e6f5bcadc6376d7dd38745b233a62fabade5",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSigMask.java",
    "status": "removed",
    "additions": 0,
    "deletions": 62,
    "changes": 62,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSigMask.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSigMask.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSigMask.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,62 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.signature;\n-\n-import java.util.Arrays;\n-import java.util.EnumSet;\n-import java.util.Set;\n-\n-import net.sourceforge.pmd.lang.apex.metrics.signature.ApexSignature.Visibility;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public class ApexOperationSigMask {\n-\n-    private Set<Visibility> visMask = EnumSet.allOf(Visibility.class);\n-\n-\n-    /**\n-     * Sets the mask to cover all visibilities.\n-     */\n-    public void coverAllVisibilities() {\n-        visMask.addAll(Arrays.asList(Visibility.values()));\n-    }\n-\n-\n-    /**\n-     * Restricts the visibilities covered by the mask to the parameters.\n-     *\n-     * @param visibilities The visibilities to cover\n-     */\n-    public void restrictVisibilitiesTo(Visibility... visibilities) {\n-        visMask.clear();\n-        visMask.addAll(Arrays.asList(visibilities));\n-    }\n-\n-\n-    /**\n-     * Forbid all mentioned visibilities.\n-     *\n-     * @param visibilities The visibilities to forbid\n-     */\n-    public void forbid(Visibility... visibilities) {\n-        visMask.removeAll(Arrays.asList(visibilities));\n-    }\n-\n-\n-    /**\n-     * Returns true if the parameter is covered by this mask.\n-     *\n-     * @param sig The signature to test.\n-     *\n-     * @return True if the parameter is covered by this mask\n-     */\n-    public boolean covers(ApexOperationSignature sig) {\n-        return visMask.contains(sig.visibility);\n-    }\n-\n-\n-}"
  },
  {
    "sha": "3d2206f8ae796c59e43b1b207674a46f2e118248",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSignature.java",
    "status": "removed",
    "additions": 0,
    "deletions": 65,
    "changes": 65,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSignature.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSignature.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexOperationSignature.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,65 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.signature;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.metrics.Signature;\n-\n-/**\n- * @author Clément Fournier\n- */\n-public final class ApexOperationSignature extends ApexSignature implements Signature<ASTMethod> {\n-\n-    private static final Map<Integer, ApexOperationSignature> POOL = new HashMap<>();\n-\n-\n-    /**\n-     * Create a signature using its visibility.\n-     *\n-     * @param visibility The visibility\n-     */\n-    private ApexOperationSignature(Visibility visibility) {\n-        super(visibility);\n-    }\n-\n-\n-    @Override\n-    public int hashCode() {\n-        return code(visibility);\n-    }\n-\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return obj == this;\n-    }\n-\n-\n-    private static int code(Visibility visibility) {\n-        return visibility.hashCode();\n-    }\n-\n-\n-    /**\n-     * Builds the signature of this node.\n-     *\n-     * @param node The method node\n-     *\n-     * @return The signature of the node\n-     */\n-    public static ApexOperationSignature of(ASTMethod node) {\n-        Visibility visibility = Visibility.get(node);\n-        int code = code(visibility);\n-        if (!POOL.containsKey(code)) {\n-            POOL.put(code, new ApexOperationSignature(visibility));\n-        }\n-        return POOL.get(code);\n-    }\n-\n-\n-}"
  },
  {
    "sha": "d780e5d75adb0ae105329550f74d302e5cbe030f",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexSignature.java",
    "status": "removed",
    "additions": 0,
    "deletions": 53,
    "changes": 53,
    "blob_url": "https://github.com/pmd/pmd/blob/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexSignature.java",
    "raw_url": "https://github.com/pmd/pmd/raw/12cec068e7341b6acd5229d8267e9f011993440c/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexSignature.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/signature/ApexSignature.java?ref=12cec068e7341b6acd5229d8267e9f011993440c",
    "patch": "@@ -1,53 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd.lang.apex.metrics.signature;\n-\n-import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n-import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\n-\n-/**\n- * Base class for apex field or method signatures.\n- *\n- * @author Clément Fournier\n- */\n-public abstract class ApexSignature {\n-\n-    /** Visibility of the field or method. */\n-    public final Visibility visibility;\n-\n-\n-    /** Create a signature using its visibility. */\n-    protected ApexSignature(Visibility visibility) {\n-        this.visibility = visibility;\n-    }\n-\n-\n-    /** Visibility of a field or method. */\n-    public enum Visibility {\n-        PRIVATE, PUBLIC, PROTECTED, GLOBAL;\n-\n-\n-        /**\n-         * Finds out the visibility of a method node.\n-         *\n-         * @param method The method node\n-         *\n-         * @return The visibility of the method\n-         */\n-        public static Visibility get(ASTMethod method) {\n-            ASTModifierNode modifierNode = method.getFirstChildOfType(ASTModifierNode.class);\n-            if (modifierNode.isPublic()) {\n-                return PUBLIC;\n-            } else if (modifierNode.isPrivate()) {\n-                return PRIVATE;\n-            } else if (modifierNode.isProtected()) {\n-                return PROTECTED;\n-            } else {\n-                return GLOBAL;\n-            }\n-        }\n-    }\n-\n-}"
  },
  {
    "sha": "0be66af8ad79dd0d5c099d1e653ffd078d8a8940",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CognitiveComplexityRule.java",
    "status": "modified",
    "additions": 6,
    "deletions": 7,
    "changes": 13,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CognitiveComplexityRule.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CognitiveComplexityRule.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CognitiveComplexityRule.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -11,8 +11,7 @@\n import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexClassMetricKey;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetricKey;\n+import net.sourceforge.pmd.lang.apex.metrics.ApexMetrics;\n import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n import net.sourceforge.pmd.lang.metrics.MetricsUtil;\n import net.sourceforge.pmd.properties.PropertyDescriptor;\n@@ -60,11 +59,11 @@ public Object visit(ASTUserClass node, Object data) {\n         super.visit(node, data);\n         classNames.pop();\n \n-        if (ApexClassMetricKey.COGNITIVE.supports(node)) {\n-            int classCognitive = (int) MetricsUtil.computeMetric(ApexClassMetricKey.COGNITIVE, node);\n+        if (ApexMetrics.COGNITIVE_COMPLEXITY.supports(node)) {\n+            int classCognitive = MetricsUtil.computeMetric(ApexMetrics.COGNITIVE_COMPLEXITY, node);\n \n             if (classCognitive >= getProperty(CLASS_LEVEL_DESCRIPTOR)) {\n-                int classHighest = (int) MetricsUtil.computeStatistics(ApexOperationMetricKey.COGNITIVE, node.getMethods()).getMax();\n+                int classHighest = (int) MetricsUtil.computeStatistics(ApexMetrics.COGNITIVE_COMPLEXITY, node.getMethods()).getMax();\n \n                 String[] messageParams = {\n                     \"class\",\n@@ -83,8 +82,8 @@ public Object visit(ASTUserClass node, Object data) {\n     @Override\n     public final Object visit(ASTMethod node, Object data) {\n \n-        if (ApexOperationMetricKey.COGNITIVE.supports(node)) {\n-            int cognitive = (int) MetricsUtil.computeMetric(ApexOperationMetricKey.COGNITIVE, node);\n+        if (ApexMetrics.COGNITIVE_COMPLEXITY.supports(node)) {\n+            int cognitive = MetricsUtil.computeMetric(ApexMetrics.COGNITIVE_COMPLEXITY, node);\n             if (cognitive >= getProperty(METHOD_LEVEL_DESCRIPTOR)) {\n                 String opType = inTrigger ? \"trigger\"\n                         : node.getImage().equals(classNames.peek()) ? \"constructor\""
  },
  {
    "sha": "52eda89bb7228ae34d82885a1f336c466e04bedc",
    "filename": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CyclomaticComplexityRule.java",
    "status": "modified",
    "additions": 6,
    "deletions": 7,
    "changes": 13,
    "blob_url": "https://github.com/pmd/pmd/blob/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CyclomaticComplexityRule.java",
    "raw_url": "https://github.com/pmd/pmd/raw/2bd9445098bae414263178880e81d1010e00ea7d/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CyclomaticComplexityRule.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/CyclomaticComplexityRule.java?ref=2bd9445098bae414263178880e81d1010e00ea7d",
    "patch": "@@ -12,8 +12,7 @@\n import net.sourceforge.pmd.lang.apex.ast.ASTMethod;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexClassMetricKey;\n-import net.sourceforge.pmd.lang.apex.metrics.api.ApexOperationMetricKey;\n+import net.sourceforge.pmd.lang.apex.metrics.ApexMetrics;\n import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n import net.sourceforge.pmd.lang.metrics.MetricsUtil;\n import net.sourceforge.pmd.properties.PropertyDescriptor;\n@@ -67,11 +66,11 @@ public Object visit(ASTUserClass node, Object data) {\n         super.visit(node, data);\n         classNames.pop();\n \n-        if (ApexClassMetricKey.WMC.supports(node)) {\n-            int classWmc = (int) MetricsUtil.computeMetric(ApexClassMetricKey.WMC, node);\n+        if (ApexMetrics.WEIGHED_METHOD_COUNT.supports(node)) {\n+            int classWmc = MetricsUtil.computeMetric(ApexMetrics.WEIGHED_METHOD_COUNT, node);\n \n             if (classWmc >= getProperty(CLASS_LEVEL_DESCRIPTOR)) {\n-                int classHighest = (int) MetricsUtil.computeStatistics(ApexOperationMetricKey.CYCLO, node.getMethods()).getMax();\n+                int classHighest = (int) MetricsUtil.computeStatistics(ApexMetrics.CYCLO, node.getMethods()).getMax();\n \n                 String[] messageParams = {\"class\",\n                                           node.getImage(),\n@@ -88,8 +87,8 @@ public Object visit(ASTUserClass node, Object data) {\n     @Override\n     public final Object visit(ASTMethod node, Object data) {\n \n-        if (ApexOperationMetricKey.CYCLO.supports(node)) {\n-            int cyclo = (int) MetricsUtil.computeMetric(ApexOperationMetricKey.CYCLO, node);\n+        if (ApexMetrics.CYCLO.supports(node)) {\n+            int cyclo = MetricsUtil.computeMetric(ApexMetrics.CYCLO, node);\n             if (cyclo >= getProperty(METHOD_LEVEL_DESCRIPTOR)) {\n                 String opType = inTrigger ? \"trigger\"\n                                           : node.getImage().equals(classNames.peek()) ? \"constructor\""
  }
]
