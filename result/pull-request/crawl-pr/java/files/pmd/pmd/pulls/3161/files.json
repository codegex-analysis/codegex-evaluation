[
  {
    "sha": "341420046592757e3d37518f5fc511db015d620a",
    "filename": "pmd-dist/src/test/resources/sample-source/plsql/SampleCode.pls",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-dist/src/test/resources/sample-source/plsql/SampleCode.pls",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-dist/src/test/resources/sample-source/plsql/SampleCode.pls",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-dist/src/test/resources/sample-source/plsql/SampleCode.pls?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -1,14 +1,14 @@\n --\n -- Example 2-25 Assigning Value to Variable with SELECT INTO Statement\n -- From: https://docs.oracle.com/en/database/oracle/oracle-database/18/lnpls/plsql-language-fundamentals.html#GUID-664BFFEA-063A-48B6-A65B-95225EDDED59\n---\n+-- Note that the original code example from Oracle is invalid:\n+-- The call to dbms_output.put_line MUST be inside begin ... end.\n DECLARE\n   bonus   NUMBER(8,2);\n BEGIN\n   SELECT salary * 0.10 INTO bonus\n   FROM employees\n   WHERE employee_id = 100;\n+  DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));\n END;\n-\n-DBMS_OUTPUT.PUT_LINE('bonus = ' || TO_CHAR(bonus));\n /\n\\ No newline at end of file"
  },
  {
    "sha": "37cf0704f61d6a145f8b859ecf02a8a907ae5193",
    "filename": "pmd-plsql/etc/grammar/PldocAST.jjt",
    "status": "modified",
    "additions": 218,
    "deletions": 48,
    "changes": 266,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/etc/grammar/PldocAST.jjt",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/etc/grammar/PldocAST.jjt",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/etc/grammar/PldocAST.jjt?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -135,6 +135,7 @@ options {\n   NODE_CLASS = \"net.sourceforge.pmd.lang.plsql.ast.AbstractPLSQLNode\";\n }\n \n+\n PARSER_BEGIN(PLSQLParser)\n \n /* Copyright (C) 2002 Albert Tumanov\n@@ -158,6 +159,8 @@ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n package net.sourceforge.pmd.lang.plsql.ast;\n \n import java.io.*;\n+import java.util.List;\n+import java.util.ArrayList;\n import net.sourceforge.pmd.lang.ast.Node;\n import net.sourceforge.pmd.lang.ast.SimpleCharStream;\n import net.sourceforge.pmd.lang.ast.TokenMgrError;\n@@ -241,6 +244,35 @@ public class PLSQLParser {\n }\n \n PARSER_END(PLSQLParser)\n+\n+\n+\n+TOKEN_MGR_DECLS : {\n+\n+  public static final class Exclusion {\n+\n+    public int beginLine;\n+    public int endLine;\n+    public String source = null;\n+    public String reason = null;\n+\n+    public Exclusion(int b, int e, String s) {\n+      this.beginLine = b;\n+      this.endLine = e;\n+      this.source = s;\n+      int i1 = s.toUpperCase().indexOf(\"PMD-EXCLUDE-BEGIN\");\n+      int i2 = s.toUpperCase().indexOf(\"\\n\");\n+      this.reason = s.substring(i1 + 17, i2).trim();\n+      if (this.reason.startsWith(\":\")) {\n+        this.reason = this.reason.substring(2).trim(); \n+      }\n+    }\n+  }\n+\n+  public List<Exclusion> exclusions = new ArrayList<Exclusion>();\n+}\n+\n+\n /**\n  * 2006-05-22 - Matthias Hendler - Added parsing of triggers and global functions/procedures\n  *                                 Refactored printing of custom tags into the XML/DOM.\n@@ -251,7 +283,10 @@ PARSER_END(PLSQLParser)\n /**\n  * 2006-05-22 - Matthias Hendler - added globalBody()\n  */\n-ASTInput Input(String sourcecode) : {}\n+ASTInput Input(String sourcecode) :\n+{\n+  token_source.exclusions.clear();\n+}\n {\n \t// SRT 2011-04-17 This syntax breaks the parser when fields of record.attach* are referenced (attachLibrary())*\n \t(\n@@ -277,7 +312,23 @@ ASTInput Input(String sourcecode) : {}\n \t (\"/\")*\n \t)*\n \t<EOF>\n-      { jjtThis.setSourcecode(sourcecode); return jjtThis ; }\n+      { jjtThis.setSourcecode(sourcecode); \n+        List<PLSQLParserTokenManager.Exclusion> exclusions = token_source.exclusions;\n+        if (exclusions != null) {\n+          // System.err.println(\"Exclusions:\");\n+          for (int i=0; i<exclusions.size(); i++) {\n+            PLSQLParserTokenManager.Exclusion ex = exclusions.get(i);\n+            // System.err.print(\"  Lines \" + ex.beginLine + \" - \" + ex.endLine);\n+            // if (ex.reason != null) {\n+            //   System.err.println(\": \" + ex.reason);\n+            // } else {\n+            //   System.err.println(\"\");\n+            // }\n+            jjtThis.addExcludedLineRange(ex.beginLine, ex.endLine);\n+          }\n+        }\n+        return jjtThis ;\n+      }\n }\n \n ASTDDLCommand DDLCommand() :\n@@ -301,58 +352,73 @@ ASTDDLCommand DDLCommand() :\n \n ASTSqlPlusCommand SqlPlusCommand() :\n {\n- StringBuilder sb = new StringBuilder() ;\n+  StringBuilder sb = new StringBuilder();\n }\n {\n   (\n   // e.g. SHOW ERRORS, GRANT EXECUTE ON ... TO ...\n   // SQLPLUS commands\n-  ( \"@\"\n-  | <ACCEPT>\n+  ( \"@@\" ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n+  | \"@\" ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n+  | <ACCEPT> | \"ACC\"\n+  | \"ARCHIVE LOG LIST\"\n+  | <ATTRIBUTE>\n+  | \"BREAK\"\n+  | \"BTITLE\"\n+  | LOOKAHEAD({isKeyword(\"CLEAR\")}) KEYWORD(\"CLEAR\")\n   | <COLUMN>\n-  | <CONNECT>\n+  | LOOKAHEAD({isKeyword(\"COL\")}) KEYWORD(\"COL\")\n+  | LOOKAHEAD({isKeyword(\"COMPUTE\")}) KEYWORD(\"COMPUTE\")\n+  | LOOKAHEAD({isKeyword(\"COMP\")}) KEYWORD(\"COMP\")\n+  | <CONNECT> | \"CONN\"\n   | <COPY>\n-  | <DEFINE>\n-  | <DISCONNECT>\n-  | <EXECUTE>\n+  | <DEFINE> | \"DEF\"\n+  | \"DESCRIBE\" | \"DESCR\" | LOOKAHEAD({isKeyword(\"DESC\")}) KEYWORD(\"DESC\")\n+  | <DISCONNECT> | \"DISC\"\n+  | <EXECUTE> | \"EXEC\"\n   | <EXIT>\n-  | <HOST>\n+  | <HOST> ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n+  | \"$\"    ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) * // only works with a blank after the dollar\n+  | \"!\"    ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) * // only works with a blank afer the exlamation mark\n+  // These characters are platform-specific, anyway...\n+  | \"INPUT\"\n+  | LOOKAHEAD({isKeyword(\"PASSWORD\")}) KEYWORD(\"PASSWORD\")\n+  | LOOKAHEAD({isKeyword(\"PASSW\")}) KEYWORD(\"PASSW\")\n+  | \"PAUSE\"\n   | <PRINT>\n-  | <PROMPT>\n+  | <PROMPT> ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n   | <QUIT>\n-  | <REMARK>\n+  | LOOKAHEAD({isKeyword(\"RECOVER\")}) KEYWORD(\"RECOVER\")\n+  | <REMARK> ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n+  | \"REM\" ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n   | <SET>\n-  | <SHOW>\n+  | <SHOW> | \"SHO\"\n+  | <SHUTDOWN>\n   | <SPOOL>\n-  | <START>\n+  | <START> ( <_CHARACTER> | <SPECIAL_CHARACTERS> | <DELIMITER> ) *\n+  | <STARTUP>\n+  | LOOKAHEAD({isKeyword(\"STORE\")}) KEYWORD(\"STORE\")\n+  | \"TIMING\"\n+  | \"TTITLE\"\n   | <UNDEFINE>\n-  | <VARIABLE>\n+  | <VARIABLE> | \"VAR\"\n   | <WHENEVER>\n+  // XQUERY is not yet supported, because it is not a single-line command\n+  // It should be handled as unknown, skipping to the next stand-alone \"/\".\n   // DDL that might be encountered\n   | LOOKAHEAD({isKeyword(\"COMMENT\")}) KEYWORD(\"COMMENT\")\n   | <GRANT>\n   | <REVOKE>\n   | <DROP>\n-  | <IDENTIFIER>\n   // Attach Library\n   | \".\" <ATTACH>\n   )\n-  { sb.append(token.getImage()) ; sb.append(\" ...\") ; }\n-  Skip2NextTokenOccurrence(EOL) //Tracker Issue 1433480 skip until next EOL Special Token\n-  //[\";\" | \"-\"]\n+  { sb.append(token.getImage()) ; sb.append(\" \") ; sb.append(Read2NextTokenOccurrence(EOL).getImage()) ;\n+  }\n   )\n-  { jjtThis.setImage(sb.toString()) ;  return jjtThis ; }\n+  { jjtThis.setImage(sb.toString()) ; return jjtThis ; }\n }\n \n-/*\n-SRT 2011-04-17 This syntax breaks the parser when fields of record.attach* are referenced  in PL/SQL\n-void attachLibrary() :\n-{}\n-{\n-\t<\".attach\"> <IDENTIFIER> <IDENTIFIER> <END> <IDENTIFIER>\n-}\n-*/\n-\n /**\n  * All global definitions of triggers, functions and procedures are evaluated here.\n  * Every occurrence goes under a new PACKAGE-Node in the XML document.\n@@ -1140,6 +1206,28 @@ ASTRead2NextOccurrence Read2NextOccurrence(String target) :\n \t{ jjtThis.setImage(sb.toString()) ;  jjtThis.value = sb.toString(); return jjtThis ;}\n }\n \n+/*\n+ Read Tokens up to but not including the target token.\n+*/\n+ASTRead2NextTokenOccurrence Read2NextTokenOccurrence(int target) :\n+{\n+  StringBuilder sb = new StringBuilder();\n+  Token nextToken = getToken(1);\n+  while (nextToken.kind!=target\n+        && (null == nextToken.specialToken || nextToken.specialToken.kind!=target ) //In case the target is a Special Token\n+        && nextToken.kind!=EOF\n+        )\n+  {\n+    nextToken = getNextToken();\n+    sb.append(nextToken.getImage());\n+    sb.append(' ');\n+    nextToken = getToken(1);\n+  }\n+}\n+{\n+\t{ jjtThis.setImage(sb.toString()) ;  jjtThis.value = sb.toString(); return jjtThis ;}\n+}\n+\n /*\n  Read Tokens up to and including the target String.\n */\n@@ -3379,7 +3467,7 @@ ASTPrimaryPrefix PrimaryPrefix() :\n | LOOKAHEAD(Literal()) ( simpleNode = Literal() ) { sb.append(simpleNode.getImage()) ; }\n | LOOKAHEAD(SimpleExpression()) ( simpleNode = SimpleExpression() ) { sb.append(simpleNode.getImage()); }\n | ( simpleNode =Name() ) { sb.append(simpleNode.getImage()) ; }\n-| SelectStatement()\n+// | SelectStatement()\n | LOOKAHEAD(\"(\" <SELECT>) \"(\" SelectStatement() \")\"\n | LOOKAHEAD(<WITH>) (<WITH>) {sb.append(\"WITH ...\"); }  Skip2NextTerminator(null,\";\")\n | LOOKAHEAD((\"(\")+ <WITH>) (\"(\") {sb.append(\"(WITH ...\"); }  Skip2NextTerminator(\"(\",\")\") \")\"\n@@ -4556,13 +4644,75 @@ SKIP :\n \t\" \" | \"\\t\" | \"\\f\"\n }\n \n+/* \n+This Grammar (or JavaCC) has several bugs.\n+\n+Currently (2021-02-26) it fails for things like\n+- dbms_lob.trim(...),\n+- scalar subqueries in the WHERE-clause,\n+- TREAT(object AS type),\n+just to name a few.\n+\n+Running PMD over a code base of approx. 1100 DDL scripts\n+from a commercial product, the parser failed for 182 files.\n+About 10% of these parsing errors actually showed flaws in the code,\n+e.g. \"\\u2013\" instead of \"-\", or utf-8 encoding instead of windows-1252\n+(which is the standard for the product's scripts).\n+Still, ~ 15% of perfectly valid DDL scripts could not be parsed by PMD.\n+\n+Nevertheless it should be best practice to call PMD for _every_ DDL script.\n+\n+Thus, we introduce the following workaround to cope with the situation.\n+We introduce two special comments PMD-EXCLUDE-BEGIN and PMD-EXCLUDE-END\n+which cause PMD to treat the source inbetween these comments more or less\n+like a multi-line comment, or in other words, just not try to parse them.\n+\n+It is good practice to include a reason for excluding inside the\n+-- PMD-EXCUDE-BEGIN comment.\n+\n+The PMD-EXCLUDE-BEGIN and PMD-EXLUDE-END comment lines must not contain\n+other statements, e.g. do_xy(); -- PMD-EXCLUDE-BEGIN is invalid.\n+\n+Example:\n+\n+begin\n+  do_something();\n+  -- PMD-EXCLUDE-BEGIN: PMD does not like dbms_lob.trim (clash with TrimExpression)\n+  dbms_lob.trim(the_blob, 1000);\n+  -- PMD-EXCLUDE-END\n+  do_something_else();\n+end;\n+\n+The existence of exclusions can be detected with the attributes\n+excludedRangesCount and excludedLinesCount of the top-lvel ASTInput node.\n+If nothing is excluded, both values are 0 (zero).\n+Otherwise, excludedRangesCount contains the number of excluded line-ranges\n+and excludedRangesCount is the total number of excluded lines.\n+A future version of PMD might pass the line ecluded line ranges,\n+source fragments and the corresponding reason comments\n+as child nodes of the top-level ASTInput node.\n+See the commented code in Input().\n+*/\n+\n /* COMMENTS */\n \n MORE :\n {\n \t<\"/**\" ~[\"/\"]> : IN_FORMAL_COMMENT\n |\n \t\"/*\" : IN_MULTI_LINE_COMMENT\n+| \n+  <\"--\" (\" \")* \"PMD-EXCLUDE-BEGIN\" (\" \")* (\":\")? (\" \")* (~[\"\\n\", \"\\r\"])*> : IN_PARSING_EXCLUSION\n+}\n+\n+<IN_PARSING_EXCLUSION>\n+SPECIAL_TOKEN :\n+{\n+  \t<PARSING_EXCLUSION: \"--\" (\" \")* \"PMD-EXCLUDE-END\" (~[\"\\n\", \"\\r\"])* >\n+    {\n+      String excluded_source = matchedToken.getImage();\n+      exclusions.add(new Exclusion(matchedToken.getBeginLine(), matchedToken.getEndLine(), excluded_source));\n+    } : DEFAULT\n }\n \n SPECIAL_TOKEN :\n@@ -4598,7 +4748,7 @@ SKIP :\n */\n \n <IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT,\n- IN_SQL_STATEMENT_ENDED_SEMICOLON>\n+ IN_SQL_STATEMENT_ENDED_SEMICOLON, IN_PARSING_EXCLUSION>\n MORE :\n {\n \t< ~[] >\n@@ -5067,22 +5217,13 @@ TOKEN [IGNORE_CASE]:\n  */\n TOKEN :\n {\n-< #GERMAN_SPECIAL_CHARACTERS: \"Ä\" | \"Ö\" | \"Ü\" | \"ä\" | \"ü\" | \"ö\" | \"ß\" >\n-|\n-< #LETTER: [\"A\"-\"Z\"] | [\"a\"-\"z\"] | <GERMAN_SPECIAL_CHARACTERS> >\n-|\n-< #DIGIT: [\"0\"-\"9\"]>\n-|\n-< #_CHARACTER: <_CHARACTER_WO_ASTERISK> | \"'\" >\n-|\n-< #_CHARACTER_WO_ASTERISK: <LETTER> | <DIGIT> | \"(\" | \")\" | \"+\" | \"-\" | \"*\" | \"/\" | \"<\" | \">\"\n- | \"=\" | \"!\" | \"~\" | \"^\" | \";\" | \":\" | \".\" | \"@\" | \"%\" | \",\" | \"\\\"\" | \"#\"\n- | \"$\" | \"&\" | \"_\" | \"|\" | \"{\" | \"}\" | \"?\" | \"[\" | \"]\"\n- | \" \" | \"\\t\" >\n-|\n-< #SPECIAL_CHARACTERS: \"á\" | \"Ž\" | \"™\" | \"š\" | \"„\" | \"”\" | \"ý\" | \"²\" | \"€\" | \"³\" | \"µ\">\n+<ESCAPED_AMPERSAND:\n+  \"\\\\&\"\n+>\n |\n-< #DELIMITER: \"+\" | \"%\" | \"'\" | \"\\\"\" | \".\" | \"/\" | \"(\" | \")\" | \":\" | \",\" | \"*\" | \"=\" | \"<\" | \">\" | \"@\" | \";\" | \"-\">\n+<BACKSLASH:\n+  \"\\\\\"\n+>\n |\n < IDENTIFIER:\n \t( (\"$\" | \":\" | <LETTER>) ( <LETTER> | <DIGIT> | \"$\" | \"_\" | \"#\" )* ) // 2006-05-17 - Matthias Hendler - Bind variablen werden nun als Identifier akzeptiert.\n@@ -5091,13 +5232,26 @@ TOKEN :\n \t//( <LETTER> ( \"$\" ) )\n \t//( <LETTER> ( \"_\" ) )\n \t//( <LETTER> ( \"#\" ) )\n+  |\n+  (\n+    <LEXICAL_PARAMETER> ( <LETTER> | <DIGIT> | \"$\" | \"_\" | \"#\" )*\n+  )\n \t|\n \t( (<LETTER> | \"$\" ) ( <LETTER> | <DIGIT> | \"$\" | \"_\" | \"#\" )* )\n \t|\n-//SRT\t( \"\\\"\" (<_CHARACTER_WO_ASTERISK>)* \"\\\"\" )\n \t( \"\\\"\"  <LETTER> ( <LETTER> | <DIGIT> | \"$\" | \"_\" | \"#\" )* \"\\\"\" )\n >\n |\n+< LEXICAL_PARAMETER:\n+  (\n+    (\"&&\" | \"&\")\n+    (\n+      ( <LETTER> | <DIGIT> | \"$\" | \"_\" | \"#\" )+\n+      (\".\")?  \n+    )?\n+  )\n+>\n+|\n < UNSIGNED_NUMERIC_LITERAL: <FLOAT_LITERAL> ( [\"e\",\"E\"] ([\"-\",\"+\"])? <FLOAT_LITERAL> )? ([\"f\",\"F\",\"d\",\"D\"])? >\n |\n < #FLOAT_LITERAL: <INTEGER_LITERAL> ( \".\" <INTEGER_LITERAL> )? | \".\" <INTEGER_LITERAL> >\n@@ -5121,6 +5275,23 @@ TOKEN :\n < JAVA_INTERFACE_CLASS: ( \"SQLData\" | \"CustomDatum\" | \"OraData\" ) >\n //|\n //< #BOOLEAN_LITERAL: \"TRUE\" | \"FALSE\" >\n+|\n+< #GERMAN_SPECIAL_CHARACTERS: \"Ä\" | \"Ö\" | \"Ü\" | \"ä\" | \"ü\" | \"ö\" | \"ß\" >\n+|\n+< #LETTER: [\"A\"-\"Z\"] | [\"a\"-\"z\"] | <GERMAN_SPECIAL_CHARACTERS> >\n+|\n+< #DIGIT: [\"0\"-\"9\"]>\n+|\n+< _CHARACTER: <_CHARACTER_WO_ASTERISK> | \"'\" >\n+|\n+< #_CHARACTER_WO_ASTERISK: <LETTER> | <DIGIT> | \"(\" | \")\" | \"+\" | \"-\" | \"*\" | \"/\" | \"<\" | \">\"\n+ | \"=\" | \"!\" | \"~\" | \"^\" | \";\" | \":\" | \".\" | \"@\" | \"%\" | \",\" | \"\\\"\" | \"#\"\n+ | \"$\" | \"_\" | \"|\" | \"{\" | \"}\" | \"?\" | \"[\" | \"]\"\n+ | \" \" | \"\\t\" >\n+|\n+< SPECIAL_CHARACTERS: \"á\" | \"Ž\" | \"™\" | \"š\" | \"„\" | \"”\" | \"ý\" | \"²\" | \"€\" | \"³\" | \"µ\">\n+|\n+< DELIMITER: \"+\" | \"%\" | \"'\" | \"\\\"\" | \".\" | \"/\" | \"(\" | \")\" | \":\" | \",\" | \"*\" | \"=\" | \"<\" | \">\" | \"@\" | \";\" | \"-\">\n }\n \n /**\n@@ -6831,4 +7002,3 @@ ASTJavaInterfaceClass JavaInterfaceClass(): {}\n         )\n \t{ jjtThis.setImage(token.getImage()) ; jjtThis.value = token ; return jjtThis ; }\n }\n-"
  },
  {
    "sha": "373bd37465c3b30112df4a3cf84a3d3fc4d00a69",
    "filename": "pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/ASTInput.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/ASTInput.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/ASTInput.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/ASTInput.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -34,4 +34,25 @@ void setSourcecode(String sourcecode) {\n     public String getSourcecode() {\n         return sourcecode;\n     }\n+\n+    private int excludedRangesCount = 0;\n+    private int excludedLinesCount = 0;\n+\n+    /**\n+    Let the user know that a range of lines were excluded from parsing.\n+    @param first First line of the exlucded line range (1-based).\n+    @param last Last line  of the exlucded line range (1-based).\n+    */\n+    void addExcludedLineRange(int first, int last) {\n+        excludedLinesCount += last - first + 1;\n+        excludedRangesCount += 1;\n+    }\n+\n+    public int getExcludedLinesCount() {\n+        return excludedLinesCount;\n+    }\n+\n+    public int getExcludedRangesCount() {\n+        return excludedRangesCount;\n+    }\n }"
  },
  {
    "sha": "865a91e4f315d2b4d26eabb2e24b80da2f89c971",
    "filename": "pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/PLSQLParserVisitorAdapter.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/PLSQLParserVisitorAdapter.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/PLSQLParserVisitorAdapter.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/ast/PLSQLParserVisitorAdapter.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -165,6 +165,11 @@ public Object visit(ASTSkipPastNextTokenOccurrence node, Object data) {\n     public Object visit(ASTRead2NextOccurrence node, Object data) {\n         return visit((PLSQLNode) node, data);\n     }\n+    \n+    @Override\n+    public Object visit(ASTRead2NextTokenOccurrence node, Object data) {\n+        return visit((PLSQLNode) node, data);\n+    }\n \n     @Override\n     public Object visit(ASTReadPastNextOccurrence node, Object data) {"
  },
  {
    "sha": "587c9bc0aad48041d0821eb55e074b4e897f5e0b",
    "filename": "pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/rule/AbstractPLSQLRule.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/rule/AbstractPLSQLRule.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/rule/AbstractPLSQLRule.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/main/java/net/sourceforge/pmd/lang/plsql/rule/AbstractPLSQLRule.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -161,6 +161,7 @@\n import net.sourceforge.pmd.lang.plsql.ast.ASTQueryPartitionClause;\n import net.sourceforge.pmd.lang.plsql.ast.ASTRaiseStatement;\n import net.sourceforge.pmd.lang.plsql.ast.ASTRead2NextOccurrence;\n+import net.sourceforge.pmd.lang.plsql.ast.ASTRead2NextTokenOccurrence;\n import net.sourceforge.pmd.lang.plsql.ast.ASTReadPastNextOccurrence;\n import net.sourceforge.pmd.lang.plsql.ast.ASTReferencesClause;\n import net.sourceforge.pmd.lang.plsql.ast.ASTRegexpLikeCondition;\n@@ -482,6 +483,11 @@ public Object visit(ASTRead2NextOccurrence node, Object data) {\n         return visit((PLSQLNode) node, data);\n     }\n \n+    @Override\n+    public Object visit(ASTRead2NextTokenOccurrence node, Object data) {\n+        return visit((PLSQLNode) node, data);\n+    }\n+    \n     @Override\n     public Object visit(ASTReadPastNextOccurrence node, Object data) {\n         return visit((PLSQLNode) node, data);"
  },
  {
    "sha": "b694b685ea0d78af9f712303315673d070f09a13",
    "filename": "pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/LexicalParametersTest.java",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/LexicalParametersTest.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/LexicalParametersTest.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/LexicalParametersTest.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -0,0 +1,17 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.plsql.ast;\n+\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;\n+\n+public class LexicalParametersTest extends AbstractPLSQLParserTst {\n+\n+    @Test\n+    public void parseLexicalParameters() {\n+        plsql.parseResource(\"LexicalParameters.sql\");\n+    }\n+}"
  },
  {
    "sha": "7a7fb2c6686ded8019fc49e168ddb907fd591c37",
    "filename": "pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/ParserExclusionTest.java",
    "status": "added",
    "additions": 17,
    "deletions": 0,
    "changes": 17,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/ParserExclusionTest.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/ParserExclusionTest.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/ParserExclusionTest.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -0,0 +1,17 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.plsql.ast;\n+\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;\n+\n+public class ParserExclusionTest extends AbstractPLSQLParserTst {\n+\n+    @Test\n+    public void parseParserExclusion() {\n+        plsql.parseResource(\"ParserExclusion.sql\");\n+    }\n+}"
  },
  {
    "sha": "145f6f495b4f20d936af0c077cb37fb0dffffa9e",
    "filename": "pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/SelectIntoStatementTest.java",
    "status": "modified",
    "additions": 8,
    "deletions": 1,
    "changes": 9,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/SelectIntoStatementTest.java",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/SelectIntoStatementTest.java",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/java/net/sourceforge/pmd/lang/plsql/ast/SelectIntoStatementTest.java?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -6,8 +6,10 @@\n \n import org.junit.Test;\n \n+import net.sourceforge.pmd.lang.ast.ParseException;\n import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;\n \n+\n public class SelectIntoStatementTest extends AbstractPLSQLParserTst {\n \n     @Test\n@@ -17,7 +19,12 @@ public void testParsingComplex() {\n \n     @Test\n     public void testParsingExample1() {\n-        plsql.parseResource(\"SelectIntoStatementExample1.pls\");\n+        try {\n+            plsql.parseResource(\"SelectIntoStatementExample1.pls\");\n+            throw new AssertionError(\"The last line of this example must cause a ParseException.\");\n+        } catch (ParseException e) {\n+            // This is expected, because the last line of the example is valid only inside BEGIN END.\n+        }\n     }\n \n     @Test"
  },
  {
    "sha": "616188a165d6e57cb5e2903717b6f5e4fa05c13d",
    "filename": "pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/IsOfType.pls",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/IsOfType.pls",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/IsOfType.pls",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/IsOfType.pls?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -17,7 +17,7 @@ IF ioFPOobj IS NOT OF TYPE (ONLY FPOGE_OBJ) THEN\n loFPOGE_OBJ:=treat(ioFPOobj AS FPOGE_OBJ);\n end if;\n \n-loFPOGE_OBJ:=SELECT A FROM persons p WHERE VALUE(p) IS OF TYPE (employee_t);\n-loFPOGE_OBJ:=SELECT A FROM persons p WHERE VALUE(p) IS NOT OF TYPE (ONLY employee_t, other_t);\n+SELECT A into lo_FPOGE_OBJ FROM persons p WHERE VALUE(p) IS OF TYPE (employee_t);\n+SELECT A into lo_FPOGE_OBJ FROM persons p WHERE VALUE(p) IS NOT OF TYPE (ONLY employee_t, other_t);\n \n end;\n\\ No newline at end of file"
  },
  {
    "sha": "57cfbb57be79a3bb7454fe99ce3c54998048c689",
    "filename": "pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/LexicalParameters.sql",
    "status": "added",
    "additions": 52,
    "deletions": 0,
    "changes": 52,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/LexicalParameters.sql",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/LexicalParameters.sql",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/LexicalParameters.sql?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -0,0 +1,52 @@\n+set define on\n+set escape off\n+define schema_name=SYS\n+define object_name=DBMS_OUTPUT\n+define directory_name=not_existing\n+define file_name=not_existing.sql\n+\n+rem Ampersand in a comment: Copyright Foo,Bar&Baz 2567\n+rem Backslash in a comment: See c:\\doc\\bla\n+/*\n+rem Ampersand in a comment: Copyright Foo,Bar& Baz 2567\n+rem Backslash in a comment: See c:\\doc\\bla\n+*/\n+-- Ampersand in a comment: Copyright Foo,Bar&Baz 2567\n+-- Backslash in a comment: See c:\\doc\\bla\n+\n+prompt Backslash in a start command\n+start c:\\not_existing\\file\\sql\n+@@c:\\not_existing\\file\\sql\n+@c:\\not_existing\\file\\sql\n+\n+prompt Lexical variable in a start command\n+start &file_name\n+@&file_name\n+@&file_name\n+\n+set escape \\\n+prompt An ampersand directly followed by the text \"schema_name\": \\&schema_name\n+prompt A windows directory name: C:\\\\temp - the backslash has to be doubled\n+\n+prompt Double dot results in SYS.DBMS_OUTPUT\n+describe &schema_name..&object_name\n+-- Unfortunately, DESC does not work.\n+-- Anyway, this is usually only used in interactive sessions, not for linting.\n+-- desc &schema_name..&object_name\n+\n+host dir c:\\\\temp\\\\*.pdf\n+\n+rem Unfortunately, the $ and ! SQLPlus*Commands (shortcuts for HOST) do not work:\n+-- $dir c:\\\\temp\\\\*.pdf\n+\n+prompt Double ampersand or single ampersand to reference a variable in SQL.\n+select *\n+from all_errors where owner = '&&schema_name' and name = '&object_name';\n+\n+set serveroutput on\n+prompt Double ampersand or single ampersand to reference a variable in PL/SQL.\n+begin\n+  &&schema_name..&object_name..put_line('Hello from Foo,Bar\\&Baz');\n+end;\n+/\n+set escape off"
  },
  {
    "sha": "0f1f8cfb16153c9d71a156588fac1937418bb3ce",
    "filename": "pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/ParserExclusion.sql",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/pmd/pmd/blob/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/ParserExclusion.sql",
    "raw_url": "https://github.com/pmd/pmd/raw/9d667824576bf151f0c06ab2cc360a8ae7eeb1ea/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/ParserExclusion.sql",
    "contents_url": "https://api.github.com/repos/pmd/pmd/contents/pmd-plsql/src/test/resources/net/sourceforge/pmd/lang/plsql/ast/ParserExclusion.sql?ref=9d667824576bf151f0c06ab2cc360a8ae7eeb1ea",
    "patch": "@@ -0,0 +1,15 @@\n+begin\n+  do_something();\n+  -- pmd-exclude-begin: PMD does not like dbms_lob.trim (clash with TrimExpression)\n+  dbms_lob.trim(the_blob, 1000);\n+  -- pmd-exclude-end\n+  do_something_else(x);\n+end;\n+/\n+\n+select dummy from dual a\n+where 1=1\n+  -- pmd-exclude-begin: PMD does not like scalar subqueries in WHERE conditions\n+  and 'J' = (select max('J') from dual b)\n+  -- pmd-exclude-end\n+;"
  }
]
