[
  {
    "sha": "8ff84050c02975a6b89ab4871582111c9a9aad6c",
    "filename": ".github/workflows/gradle.yml",
    "status": "modified",
    "additions": 10,
    "deletions": 2,
    "changes": 12,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/.github/workflows/gradle.yml",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/.github/workflows/gradle.yml",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/.github/workflows/gradle.yml?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -48,11 +48,19 @@ jobs:\n       run: ./gradlew\n       \n     - name: Upload builds\n-      if: matrix.os != 'macos-latest'\n+      if: matrix.os == 'windows-latest'\n       uses: actions/upload-artifact@v2\n       with:\n         name: MZmine_package_${{matrix.os}}\n-        path: build/jpackage/MZmine\n+        path: build/jpackage/\n+        retention-days: 7  # store for 7 days\n+\n+    - name: Upload builds ubuntu\n+      if: matrix.os == 'ubuntu-latest'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: MZmine_package_${{matrix.os}}\n+        path: build/jpackage/*.deb\n         retention-days: 7  # store for 7 days\n         \n     - name: Upload builds macos"
  },
  {
    "sha": "6e514f9df8538910dbe65c454397a3754cad7197",
    "filename": ".github/workflows/gradle_release_dev_version.yml",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/.github/workflows/gradle_release_dev_version.yml",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/.github/workflows/gradle_release_dev_version.yml",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/.github/workflows/gradle_release_dev_version.yml?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -0,0 +1,93 @@\n+# This workflow will build a Java project with Gradle\n+# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-gradle\n+\n+name: Release Dev Version MZmine on OS\n+\n+on:\n+  push:\n+    branches: [ master ]\n+\n+# run on OS listed below\n+jobs:\n+  build:\n+    runs-on: ${{ matrix.os }}\n+    strategy:\n+      matrix:\n+        include:\n+        - os: macos-latest\n+        - os: ubuntu-latest\n+        - os: windows-latest\n+        \n+# Checkout OS and java version\n+    steps:\n+    - uses: actions/checkout@v2\n+    - name: Set up JDK 14 for x64\n+      uses: actions/setup-java@v1\n+      with:\n+        java-version: 14\n+        java-package: jdk # jdk+fx ?\n+        architecture: x64\n+\n+# Cache packages\n+    - name: Cache Gradle packages\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+          ~/.gradle/caches\n+          ~/.gradle/wrapper\n+        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}\n+        restore-keys: |\n+          ${{ runner.os }}-gradle-\n+# build with gradlew\n+    - name: Build with Gradle\n+      run: chmod +x gradlew\n+    - name: Build with Gradle\n+      run: ./gradlew\n+      \n+    - name: Upload builds\n+      if: matrix.os == 'windows-latest'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: MZmine_package_${{matrix.os}}\n+        path: build/jpackage/\n+        retention-days: 7  # store for 7 days\n+\n+    - name: Upload builds ubuntu\n+      if: matrix.os == 'ubuntu-latest'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: MZmine_package_${{matrix.os}}\n+        path: build/jpackage/*.deb\n+        retention-days: 7  # store for 7 days\n+        \n+    - name: Upload builds macos\n+      if: matrix.os == 'macos-latest'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: MZmine_package_${{matrix.os}}\n+        path: build/jpackage/MZmine.app\n+        retention-days: 7  # store for 7 days\n+       \n+       \n+    - name: Update Automatic Release\n+      if: matrix.os == 'ubuntu-latest'\n+      uses: marvinpinto/action-automatic-releases@latest\n+      with:\n+        repo_token: \"${{ secrets.GITHUB_TOKEN}}\"\n+        automatic_release_tag: \"Ubuntu-latest\"\n+        prerelease: true\n+        title: \"Ubuntu Development Build\"\n+        files: build/jpackage/*.deb\n+\n+# clean cache important but DOES NOT WORK on windows - -f not allowed \n+\n+# Remove some files from the Gradle cache, so they aren't cached by GitHub Actions.\n+# Restoring these files from a GitHub Actions cache might cause problems for future builds.\n+    - name: Cleanup Gradle Cache\n+      uses: JesseTG/rm@v1.0.2 # should work on all OS but only one file at a time\n+      with:\n+        path: ~/.gradle/caches/modules-2/modules-2.lock\n+    - name: Cleanup Gradle Cache second file\n+      uses: JesseTG/rm@v1.0.2\n+      with:\n+        path: ~/.gradle/caches/modules-2/gc.properties"
  },
  {
    "sha": "e67e5daa3b154e99723c5a0b5b8012c9b963c7cb",
    "filename": "src/main/java/io/github/mzmine/datamodel/MZmineProject.java",
    "status": "modified",
    "additions": 8,
    "deletions": 1,
    "changes": 9,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/MZmineProject.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/MZmineProject.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/MZmineProject.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -24,6 +24,7 @@\n import io.github.mzmine.parameters.UserParameter;\n import javafx.beans.property.ListProperty;\n import javafx.collections.ObservableList;\n+import javax.annotation.Nullable;\n \n /**\n  *\n@@ -41,7 +42,6 @@\n  * </ul>\n  *\n  * @see UserParameter\n- * @see ParameterValue\n  * @see RawDataFile\n  * @see FeatureList\n  *\n@@ -141,6 +141,13 @@\n   void setProjectParametersAndValues(\n       Hashtable<UserParameter<?, ?>, Hashtable<RawDataFile, Object>> projectParametersAndValues);\n \n+  /**\n+   * Feature list for name\n+   * @param name the exact name of the feature list\n+   * @return the last feature list with that name or null\n+   */\n+  @Nullable\n+  FeatureList getFeatureList(String name);\n \n   // void notifyObjectChanged(Object object, boolean structureChanged);\n "
  },
  {
    "sha": "eb378762d9f1072d475893a30df993912251cb5f",
    "filename": "src/main/java/io/github/mzmine/datamodel/Scan.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/Scan.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/Scan.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/Scan.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -68,7 +68,7 @@\n   PolarityType getPolarity();\n \n   /**\n-   * @return Precursor charge or 0 if this is not MSn scan or charge is unknown\n+   * @return Precursor charge, 0 if this is not MSn scan, -1 if charge is unknown\n    */\n   int getPrecursorCharge();\n "
  },
  {
    "sha": "0337020a52e32760ea2c58a4ae3de36dc3ff5e2b",
    "filename": "src/main/java/io/github/mzmine/datamodel/data_access/BinningMobilogramDataAccess.java",
    "status": "added",
    "additions": 400,
    "deletions": 0,
    "changes": 400,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/BinningMobilogramDataAccess.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/BinningMobilogramDataAccess.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/data_access/BinningMobilogramDataAccess.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -0,0 +1,400 @@\n+/*\n+ *  Copyright 2006-2020 The MZmine Development Team\n+ *\n+ *  This file is part of MZmine.\n+ *\n+ *  MZmine is free software; you can redistribute it and/or modify it under the terms of the GNU\n+ *  General Public License as published by the Free Software Foundation; either version 2 of the\n+ *  License, or (at your option) any later version.\n+ *\n+ *  MZmine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even\n+ *  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+ *  Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License along with MZmine; if not,\n+ *  write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301\n+ *  USA\n+ */\n+\n+package io.github.mzmine.datamodel.data_access;\n+\n+import com.google.common.collect.Range;\n+import com.google.common.collect.RangeMap;\n+import com.google.common.collect.TreeRangeMap;\n+import com.google.common.primitives.Booleans;\n+import io.github.mzmine.datamodel.Frame;\n+import io.github.mzmine.datamodel.IMSRawDataFile;\n+import io.github.mzmine.datamodel.MobilityType;\n+import io.github.mzmine.datamodel.featuredata.IntensitySeries;\n+import io.github.mzmine.datamodel.featuredata.IonMobilitySeries;\n+import io.github.mzmine.datamodel.featuredata.MobilitySeries;\n+import io.github.mzmine.datamodel.featuredata.impl.SummedIntensityMobilitySeries;\n+import io.github.mzmine.datamodel.features.FeatureList.FeatureListAppliedMethod;\n+import io.github.mzmine.datamodel.features.ModularFeatureList;\n+import io.github.mzmine.main.MZmineCore;\n+import io.github.mzmine.modules.dataprocessing.featdet_ionmobilitytracebuilder.IonMobilityTraceBuilderModule;\n+import io.github.mzmine.modules.dataprocessing.featdet_ionmobilitytracebuilder.IonMobilityTraceBuilderParameters;\n+import io.github.mzmine.modules.dataprocessing.featdet_ionmobilitytracebuilder.OptionalImsTraceBuilderParameters;\n+import io.github.mzmine.modules.dataprocessing.featdet_mobilogram_summing.MobilogramBinningModule;\n+import io.github.mzmine.modules.dataprocessing.featdet_mobilogram_summing.MobilogramBinningParameters;\n+import io.github.mzmine.parameters.ParameterSet;\n+import io.github.mzmine.util.DataPointUtils;\n+import io.github.mzmine.util.IonMobilityUtils;\n+import io.github.mzmine.util.MemoryMapStorage;\n+import java.nio.DoubleBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.logging.Logger;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Used to efficiently access mobilogram data of a raw data file. The data can be binned by mobility\n+ * to generate less noisy mobilograms.\n+ *\n+ * @author https://github.com/SteffenHeu\n+ */\n+public class BinningMobilogramDataAccess implements IntensitySeries, MobilitySeries {\n+\n+  private static Logger logger = Logger.getLogger(BinningMobilogramDataAccess.class.getName());\n+\n+  private final IMSRawDataFile dataFile;\n+\n+  private final double[] intensities;\n+  private final double[] mobilities;\n+  private final double[] tempMobilities;\n+  private final double[] tempIntensities;\n+  private final double binWidth;\n+\n+  public BinningMobilogramDataAccess(@Nonnull final IMSRawDataFile rawDataFile,\n+      final double binningWidth) {\n+    this.dataFile = rawDataFile;\n+    final Double maxTic = rawDataFile.getDataMaxTotalIonCurrent(1);\n+\n+    assert maxTic != null && !maxTic.isNaN();\n+\n+    final Map<Range<Double>, Frame> uniqueRanges = IonMobilityUtils\n+        .getUniqueMobilityRanges(rawDataFile);\n+\n+    // get the then most intense frames, even if empty scans have been removed, we should at least\n+    // be able to find the smallest mobility data.\n+//    final List<Frame> frames = rawDataFile.getFrames(1).stream()\n+//        .filter(frame -> frame.getTIC() >= maxTic * 0.8).limit(10).collect(\n+//            Collectors.toList());\n+    double delta = uniqueRanges.values().stream()\n+        .mapToDouble(IonMobilityUtils::getSmallestMobilityDelta).min().orElse(-1d);\n+\n+    assert Double.compare(-1, delta) != 0;\n+\n+    final double smallestDelta = delta - delta * 1E-10;\n+\n+    if (smallestDelta > binningWidth) {\n+      logger.info(() ->\n+          \"The requested binning width is smaller than the resolution of the supplied data in \"\n+              + rawDataFile.getName() + \". Bin width will be adjusted to \" + smallestDelta + \".\");\n+      this.binWidth = smallestDelta;\n+    } else {\n+      // find the closest multiple of the smallest delta that corresponds to the bin width\n+      this.binWidth = smallestDelta * Math.round(binningWidth / smallestDelta);\n+      logger.finest(\n+          () -> \"Mobilogram binning width for raw file \" + rawDataFile.getName() + \" set to \"\n+              + binWidth + \". (requested: \" + binningWidth + \")\");\n+    }\n+\n+    final RangeMap<Double, Double> mobilityToIntensity = TreeRangeMap.create();\n+    final Map<Range<Double>, Double> mapOfRanges;\n+\n+    // make a range map that contains all mobility values we could find\n+    // we need to know how many different mobility values there are to be able to store all\n+    // mobilograms later on.\n+    for (final Frame frame : uniqueRanges.values()) {\n+      double[] mobilities = DataPointUtils.getDoubleBufferAsArray(frame.getMobilities());\n+      for (int i = 0; i < mobilities.length; i++) {\n+        Entry<Range<Double>, Double> entry = mobilityToIntensity.getEntry(mobilities[i]);\n+        if (entry == null) {\n+          mobilityToIntensity.put(Range.open(mobilities[i] - smallestDelta / 2,\n+              mobilities[i] + smallestDelta / 2), mobilities[i]);\n+        }\n+      }\n+    }\n+\n+    mapOfRanges = mobilityToIntensity.asMapOfRanges();\n+    final int numEntries = mapOfRanges.size();\n+\n+    // out temp values need to be able to fit the data in any case.\n+    tempMobilities = new double[numEntries];\n+    tempIntensities = new double[numEntries];\n+\n+    // now bin the mobility values together in the requested width\n+    final List<Double> binnedValues = new ArrayList<>();\n+    double currentBinLimit = -1E10;\n+    for (Entry<Range<Double>, Double> entry : mapOfRanges.entrySet()) {\n+      final Double mobility = entry.getValue();\n+      if (Double.compare(mobility - this.binWidth / 2, currentBinLimit) == 1) {\n+        binnedValues.add(mobility + this.binWidth / 2); // add the center of the new bin\n+        currentBinLimit = mobility + this.binWidth / 2;\n+      }\n+    }\n+\n+    mobilities = binnedValues.stream().mapToDouble(Double::doubleValue).toArray();\n+    intensities = new double[mobilities.length];\n+  }\n+\n+  public static Double getPreviousBinningWith(@Nonnull final ModularFeatureList flist,\n+      MobilityType mt) {\n+    List<FeatureListAppliedMethod> methods = flist.getAppliedMethods();\n+\n+    Double binWidth = null;\n+    for (int i = methods.size() - 1; i >= 0; i--) {\n+      FeatureListAppliedMethod method = methods.get(i);\n+      if (method.getModule()\n+          .equals(MZmineCore.getModuleInstance(IonMobilityTraceBuilderModule.class))) {\n+        final ParameterSet parameterSet = method.getParameters();\n+        final var advancedParam = parameterSet\n+            .getParameter(IonMobilityTraceBuilderParameters.advancedParameters).getValue();\n+        binWidth = switch (mt) {\n+          case TIMS ->\n+              advancedParam.getParameter(OptionalImsTraceBuilderParameters.timsBinningWidth)\n+                  .getValue() ? advancedParam\n+                  .getParameter(OptionalImsTraceBuilderParameters.timsBinningWidth)\n+                  .getEmbeddedParameter().getValue()\n+                  : OptionalImsTraceBuilderParameters.DEFAULT_TIMS_BIN_WIDTH;\n+          case DRIFT_TUBE ->\n+              advancedParam.getParameter(OptionalImsTraceBuilderParameters.dtimsBinningWidth)\n+                  .getValue() ? advancedParam\n+                  .getParameter(OptionalImsTraceBuilderParameters.dtimsBinningWidth)\n+                  .getEmbeddedParameter().getValue()\n+                  : OptionalImsTraceBuilderParameters.DEFAULT_DTIMS_BIN_WIDTH;\n+          case TRAVELING_WAVE ->\n+              advancedParam.getParameter(OptionalImsTraceBuilderParameters.twimsBinningWidth)\n+                  .getValue() ? advancedParam\n+                  .getParameter(OptionalImsTraceBuilderParameters.twimsBinningWidth)\n+                  .getEmbeddedParameter().getValue()\n+                  : OptionalImsTraceBuilderParameters.DEFAULT_TWIMS_BIN_WIDTH;\n+          default -> null;\n+        };\n+        break;\n+      }\n+\n+      if (method.getModule()\n+          .equals(MZmineCore.getModuleInstance(MobilogramBinningModule.class))) {\n+        final ParameterSet parameterSet = method.getParameters();\n+        binWidth = switch (mt) {\n+          case TIMS -> parameterSet.getParameter(MobilogramBinningParameters.timsBinningWidth)\n+              .getValue();\n+          case DRIFT_TUBE -> parameterSet\n+              .getParameter(MobilogramBinningParameters.dtimsBinningWidth).getValue();\n+          case TRAVELING_WAVE -> parameterSet\n+              .getParameter(MobilogramBinningParameters.twimsBinningWidth).getValue();\n+          default -> null;\n+        };\n+        break;\n+      }\n+    }\n+    if (binWidth == null) {\n+      logger.info(\n+          () -> \"Previous binning width not recognised. Has the mobility type been implemented?\");\n+    }\n+    return binWidth;\n+  }\n+\n+  private void clearIntensities() {\n+    Arrays.fill(intensities, 0d);\n+  }\n+\n+  /**\n+   * Note that re-binning an already binned mobilogram with a lower binning width than before will\n+   * lead to 0-intensity values. Consider using {@link #setMobilogram(List)} instead.\n+   *\n+   * @param mobilityValues   the mobility values to be binned.\n+   * @param intensitiyValues the intensity values to be binned.\n+   */\n+  public void setMobilogram(@Nonnull final double[] mobilityValues,\n+      @Nonnull final double[] intensitiyValues) {\n+\n+    final int numValues = intensitiyValues.length;\n+    assert numValues <= tempIntensities.length;\n+    assert mobilityValues.length == intensitiyValues.length;\n+\n+    int order = 1;\n+    if (mobilityValues.length > 1) {\n+      if (mobilityValues[0] > mobilityValues[1]) {\n+        order = -1;\n+      }\n+    }\n+\n+    // mobilities may be sorted in decreasing order\n+    final int start = order == 1 ? 0 : numValues - 1;\n+    int rawIndex = start;\n+\n+    for (int binnedIndex = 0;\n+        binnedIndex < intensities.length && rawIndex < numValues && rawIndex >= 0;\n+        binnedIndex++) {\n+      // ensure we are above the current lower-binning-limit\n+      while (rawIndex < numValues && rawIndex >= 0\n+          && Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] - binWidth / 2)\n+          == -1) {\n+        rawIndex += order;\n+      }\n+\n+      // ensure we are below the current upper-binning-limit\n+      while (rawIndex < numValues && rawIndex >= 0\n+          && Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] + binWidth / 2)\n+          == -1) {\n+        intensities[binnedIndex] += tempIntensities[rawIndex];\n+        rawIndex += order;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Re-bins an already summed mobilogram. Note that re-binning an already binned mobilogram with a\n+   * lower binnign width than before will lead to 0-intensity values. Consider using {@link\n+   * #setMobilogram(List)} instead.\n+   *\n+   * @param summedMobilogram\n+   */\n+  public void setMobilogram(@Nonnull final SummedIntensityMobilitySeries summedMobilogram) {\n+    clearIntensities();\n+\n+    final int numValues = summedMobilogram.getNumberOfValues();\n+    assert numValues <= tempIntensities.length;\n+\n+    summedMobilogram.getIntensityValues(tempIntensities);\n+    summedMobilogram.getMobilityValues(tempMobilities);\n+\n+    int rawIndex = 0;\n+    for (int binnedIndex = 0; binnedIndex < intensities.length && rawIndex < numValues;\n+        binnedIndex++) {\n+      // ensure we are above the current lower-binning-limit\n+      while (rawIndex < numValues\n+          && Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] - binWidth / 2)\n+          == -1) {\n+        rawIndex++;\n+      }\n+\n+      // ensure we are below the current upper-binning-limit\n+      while (rawIndex < numValues &&\n+          Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] + binWidth / 2)\n+              == -1) {\n+        intensities[binnedIndex] += tempIntensities[rawIndex];\n+        rawIndex++;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Constructs a binned summed mobilogram from the supplied list of individual mobilograms.\n+   *\n+   * @param mobilograms The list of {@link IonMobilitySeries}.\n+   */\n+  public void setMobilogram(@Nonnull final List<IonMobilitySeries> mobilograms) {\n+    clearIntensities();\n+\n+    int order = 1;\n+    if (!mobilograms.isEmpty()) {\n+      order = mobilograms.get(0).getSpectrum(0).getFrame().getMobilityType()\n+          == MobilityType.TIMS ? -1 : +1;\n+    }\n+\n+    for (IonMobilitySeries ims : mobilograms) {\n+      final int numValues = ims.getNumberOfValues();\n+      ims.getIntensityValues(tempIntensities);\n+\n+      for (int i = 0; i < numValues; i++) {\n+        tempMobilities[i] = ims.getMobility(i);\n+      }\n+\n+      // in tims, the mobilograms are sorted by decreasing order\n+      final int start = order == 1 ? 0 : numValues - 1;\n+      int rawIndex = start;\n+\n+      boolean[] assigned = new boolean[numValues];\n+      Arrays.fill(assigned, false);\n+\n+      for (int binnedIndex = 0;\n+          binnedIndex < intensities.length && rawIndex < numValues && rawIndex >= 0;\n+          binnedIndex++) {\n+        // ensure we are above the current lower-binning-limit\n+        while (rawIndex < numValues && rawIndex >= 0\n+            && Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] - binWidth / 2)\n+            == -1) {\n+          rawIndex += order;\n+        }\n+\n+        // ensure we are below the current upper-binning-limit\n+        while (rawIndex < numValues && rawIndex >= 0\n+            && Double.compare(tempMobilities[rawIndex], mobilities[binnedIndex] + binWidth / 2)\n+            == -1) {\n+//          logger.info(\"Adding raw mobility \" + tempMobilities[rawIndex] + \" to range \" + (\n+//              mobilities[binnedIndex] - binWidth / 2) + \" to \" + (mobilities[binnedIndex]\n+//              + binWidth / 2));\n+          intensities[binnedIndex] += tempIntensities[rawIndex];\n+          assigned[rawIndex] = true;\n+          rawIndex += order;\n+        }\n+      }\n+      long numAssigned = Booleans.asList(assigned).stream().filter(val -> true).count();\n+      if (numAssigned != numValues) {\n+        logger.info(\"assiged \" + numAssigned + \"/\" + numValues);\n+      }\n+    }\n+  }\n+\n+  public SummedIntensityMobilitySeries toSummedMobilogram(@Nullable MemoryMapStorage storage) {\n+    int firstNonZero = -1;\n+    int lastNonZero = -1;\n+\n+    for (int i = 0; i < mobilities.length; i++) {\n+      if (firstNonZero == -1 && intensities[i] > 0d) {\n+        firstNonZero = Math.max(0, i - 1);\n+      }\n+      if (intensities[i] > 0d) {\n+        lastNonZero = i;\n+      }\n+    }\n+    lastNonZero = Math.min(lastNonZero + 1, mobilities.length - 1);\n+\n+    return new SummedIntensityMobilitySeries(storage,\n+        Arrays.copyOfRange(mobilities, firstNonZero, lastNonZero),\n+        Arrays.copyOfRange(intensities, firstNonZero, lastNonZero));\n+  }\n+\n+  @Override\n+  public DoubleBuffer getIntensityValues() {\n+    throw new UnsupportedOperationException(\n+        \"This data access is designed to loop over intensities/mobilities.\");\n+  }\n+\n+  @Override\n+  public double[] getIntensityValues(double[] dst) {\n+    throw new UnsupportedOperationException(\n+        \"This data access is designed to loop over intensities/mobilities.\");\n+  }\n+\n+  @Override\n+  public double getIntensity(int index) {\n+    return intensities[index];\n+  }\n+\n+  @Override\n+  public int getNumberOfValues() {\n+    return intensities.length;\n+  }\n+\n+  @Override\n+  public double getMobility(int index) {\n+    return mobilities[index];\n+  }\n+\n+  public IMSRawDataFile getDataFile() {\n+    return dataFile;\n+  }\n+\n+  public double getBinWidth() {\n+    return binWidth;\n+  }\n+}"
  },
  {
    "sha": "24d03a9505e835666e8abbdc84234c2eed33c344",
    "filename": "src/main/java/io/github/mzmine/datamodel/data_access/EfficientDataAccess.java",
    "status": "modified",
    "additions": 55,
    "deletions": 27,
    "changes": 82,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/EfficientDataAccess.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/EfficientDataAccess.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/data_access/EfficientDataAccess.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -17,8 +17,10 @@\n \n package io.github.mzmine.datamodel.data_access;\n \n+import io.github.mzmine.datamodel.IMSRawDataFile;\n import io.github.mzmine.datamodel.MassList;\n import io.github.mzmine.datamodel.RawDataFile;\n+import io.github.mzmine.datamodel.featuredata.IonMobilogramTimeSeries;\n import io.github.mzmine.datamodel.features.FeatureList;\n import io.github.mzmine.parameters.parametertypes.selectors.ScanSelection;\n \n@@ -29,41 +31,21 @@\n  */\n public class EfficientDataAccess {\n \n-  /**\n-   * Different types to handle feature data: {@link #ONLY_DETECTED}: Use only detected data points,\n-   * currently assigned to the feature. Features might include leading and/or trailing zeros\n-   * depending on the state of processing. Leading and trailing zeros are added during chromatogram\n-   * detection, bit might be removed during feature resolving or other processing steps.; {@link\n-   * #INCLUDE_ZEROS}: Fill all missing data points in the chromatogram with zeros;\n-   */\n-  public enum FeatureDataType {\n-    ONLY_DETECTED, INCLUDE_ZEROS\n-  }\n-\n-\n-  /**\n-   * Different types to handle Scan data: {@link #RAW}: Use raw data as imported; {@link #CENTROID}:\n-   * Use processed centroid data ({@link MassList}\n-   */\n-  public enum ScanDataType {\n-    RAW, CENTROID\n-  }\n-\n-\n   /**\n    * The intended use of this memory access is to loop over all scans in a {@link RawDataFile} and\n    * access data points via {@link ScanDataAccess#getMzValue(int)} and {@link\n    * ScanDataAccess#getIntensityValue(int)}\n    *\n-   * @param dataFile  target data file to loop over all scans or mass lists\n-   * @param type      processed or raw data\n+   * @param dataFile target data file to loop over all scans or mass lists\n+   * @param type     processed or raw data\n    */\n   public static ScanDataAccess of(RawDataFile dataFile, ScanDataType type) {\n     return of(dataFile, type, null);\n   }\n+\n   /**\n-   * The intended use of this memory access is to loop over all selected scans in a {@link RawDataFile} and\n-   * access data points via {@link ScanDataAccess#getMzValue(int)} and {@link\n+   * The intended use of this memory access is to loop over all selected scans in a {@link\n+   * RawDataFile} and access data points via {@link ScanDataAccess#getMzValue(int)} and {@link\n    * ScanDataAccess#getIntensityValue(int)}\n    *\n    * @param dataFile  target data file to loop over all scans or mass lists\n@@ -75,7 +57,6 @@ public static ScanDataAccess of(RawDataFile dataFile, ScanDataType type,\n     return new ScanDataAccess(dataFile, type, selection);\n   }\n \n-\n   /**\n    * Access the chromatographic data of features in a feature list sorted by scan ID (usually sorted\n    * by retention time)\n@@ -98,9 +79,56 @@ public static FeatureDataAccess of(FeatureList flist,\n    */\n   public static FeatureDataAccess of(FeatureList flist,\n       FeatureDataType type, RawDataFile dataFile) {\n-    return switch(type) {\n+    return switch (type) {\n       case ONLY_DETECTED -> new FeatureDetectedDataAccess(flist, dataFile);\n       case INCLUDE_ZEROS -> new FeatureFullDataAccess(flist, dataFile);\n     };\n   }\n+\n+  public static MobilogramDataAccess of(final IonMobilogramTimeSeries ionTrace,\n+      final MobilogramAccessType accessType) {\n+    return new MobilogramDataAccess(ionTrace, accessType);\n+  }\n+\n+  /**\n+   * Accesses summed mobilogram data for a specific raw data file. The data can be binned to receive\n+   * less noisy mobilograms.\n+   *\n+   * @param dataFile The {@link IMSRawDataFile}.\n+   * @param binWidth The bin width (absolute, depends on the {@link io.github.mzmine.datamodel.MobilityType}.\n+   * @return\n+   */\n+  public static BinningMobilogramDataAccess of(final IMSRawDataFile dataFile,\n+      final double binWidth) {\n+    return new BinningMobilogramDataAccess(dataFile, binWidth);\n+  }\n+\n+  /**\n+   * Different types to handle feature data: {@link #ONLY_DETECTED}: Use only detected data points,\n+   * currently assigned to the feature. Features might include leading and/or trailing zeros\n+   * depending on the state of processing. Leading and trailing zeros are added during chromatogram\n+   * detection, bit might be removed during feature resolving or other processing steps.; {@link\n+   * #INCLUDE_ZEROS}: Fill all missing data points in the chromatogram with zeros;\n+   */\n+  public enum FeatureDataType {\n+    ONLY_DETECTED, INCLUDE_ZEROS\n+  }\n+\n+  /**\n+   * Different types to handle Scan data: {@link #RAW}: Use raw data as imported; {@link #CENTROID}:\n+   * Use processed centroid data ({@link MassList}\n+   */\n+  public enum ScanDataType {\n+    RAW, CENTROID\n+  }\n+\n+  /**\n+   * {@link #ONLY_DETECTED} will only access data points stored in the mobilograms, which may or may\n+   * not contain leading and trailing zeros depending on the state of processing. {@link\n+   * #INCLUDE_ZEROS}: fill all missing data points in frame's mobility scans with 0 for the\n+   * respective mobilogram.\n+   */\n+  public enum MobilogramAccessType {\n+    ONLY_DETECTED, INCLUDE_ZEROS\n+  }\n }"
  },
  {
    "sha": "e876e5f0e4cd6f68e517923371d192dbbebec7a4",
    "filename": "src/main/java/io/github/mzmine/datamodel/data_access/FeatureFullDataAccess.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/FeatureFullDataAccess.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/FeatureFullDataAccess.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/data_access/FeatureFullDataAccess.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -21,6 +21,7 @@\n import io.github.mzmine.datamodel.Scan;\n import io.github.mzmine.datamodel.features.Feature;\n import io.github.mzmine.datamodel.features.FeatureList;\n+import java.util.Arrays;\n import java.util.List;\n import javax.annotation.Nullable;\n \n@@ -156,6 +157,12 @@ public Feature nextFeature() {\n               intensities[i] = detectedIntensities[detectedIndex];\n               mzs[i] = detectedMzs[detectedIndex];\n               detectedIndex++;\n+            } else {\n+              intensities[i] = 0d;\n+            }\n+            if(detectedIndex == detectedScans.size() && i < intensities.length - 1) {\n+              Arrays.fill(intensities, i+1, intensities.length, 0d);\n+              break;\n             }\n           }\n           currentNumberOfDataPoints = allScans.size();"
  },
  {
    "sha": "b08d61ece38bf47a8698b2ec7fcd575d2e2595d6",
    "filename": "src/main/java/io/github/mzmine/datamodel/data_access/MobilogramDataAccess.java",
    "status": "added",
    "additions": 217,
    "deletions": 0,
    "changes": 217,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/MobilogramDataAccess.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/MobilogramDataAccess.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/data_access/MobilogramDataAccess.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -0,0 +1,217 @@\n+/*\n+ *  Copyright 2006-2020 The MZmine Development Team\n+ *\n+ *  This file is part of MZmine.\n+ *\n+ *  MZmine is free software; you can redistribute it and/or modify it under the terms of the GNU\n+ *  General Public License as published by the Free Software Foundation; either version 2 of the\n+ *  License, or (at your option) any later version.\n+ *\n+ *  MZmine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even\n+ *  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+ *  Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License along with MZmine; if not,\n+ *  write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301\n+ *  USA\n+ */\n+\n+package io.github.mzmine.datamodel.data_access;\n+\n+import io.github.mzmine.datamodel.Frame;\n+import io.github.mzmine.datamodel.MobilityScan;\n+import io.github.mzmine.datamodel.data_access.EfficientDataAccess.MobilogramAccessType;\n+import io.github.mzmine.datamodel.featuredata.IonMobilitySeries;\n+import io.github.mzmine.datamodel.featuredata.IonMobilogramTimeSeries;\n+import io.github.mzmine.datamodel.featuredata.IonSeries;\n+import io.github.mzmine.datamodel.featuredata.IonSpectrumSeries;\n+import io.github.mzmine.util.MemoryMapStorage;\n+import java.nio.DoubleBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+public class MobilogramDataAccess implements IonMobilitySeries, Iterator<IonMobilitySeries> {\n+\n+  protected final IonMobilogramTimeSeries imts;\n+  protected final MobilogramAccessType accessType;\n+  protected final List<MobilityScan> currentSpectra;\n+  protected final int numMobilograms;\n+  protected final int maxMobilogramDataPoints;\n+  protected final double[] currentMzs;\n+  protected final double[] currentIntensities;\n+  protected final double[] detectedIntensities;\n+  protected final double[] detectedMzs;\n+  protected int currentMobilogramIndex;\n+  protected int currentNumDataPoints;\n+  protected IonMobilitySeries currentMobilogram;\n+\n+  protected MobilogramDataAccess(@Nonnull final IonMobilogramTimeSeries imts, @Nonnull\n+      MobilogramAccessType accessType) {\n+    assert imts.getNumberOfValues() > 0;\n+\n+    this.imts = imts;\n+    this.accessType = accessType;\n+    if (accessType == MobilogramAccessType.INCLUDE_ZEROS) {\n+      maxMobilogramDataPoints = imts.getSpectra().stream().mapToInt(Frame::getNumberOfMobilityScans)\n+          .max().getAsInt();\n+\n+      final int maxNumDetected = imts.getMobilograms().stream()\n+          .mapToInt(IonMobilitySeries::getNumberOfValues).max().getAsInt();\n+      detectedMzs = new double[maxNumDetected];\n+      detectedIntensities = new double[maxNumDetected];\n+    } else {\n+      maxMobilogramDataPoints = imts.getMobilograms().stream()\n+          .mapToInt(IonMobilitySeries::getNumberOfValues).max().getAsInt();\n+      detectedMzs = new double[maxMobilogramDataPoints];\n+      detectedIntensities = new double[maxMobilogramDataPoints];\n+    }\n+\n+    currentSpectra = new ArrayList<>();\n+    numMobilograms = imts.getNumberOfValues();\n+    currentMzs = new double[maxMobilogramDataPoints];\n+    currentIntensities = new double[maxMobilogramDataPoints];\n+    currentMobilogramIndex = -1;\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return currentMobilogramIndex + 1 < numMobilograms;\n+  }\n+\n+  @Override\n+  public IonMobilitySeries next() {\n+    if (!hasNext()) {\n+      throw new NoSuchElementException(\"Iterator has no next element\");\n+    }\n+\n+    currentMobilogramIndex++;\n+    currentMobilogram = imts.getMobilogram(currentMobilogramIndex);\n+    currentSpectra.clear();\n+\n+    final Frame currentFrame = imts.getSpectrum(currentMobilogramIndex);\n+    if (accessType == MobilogramAccessType.ONLY_DETECTED) {\n+      currentSpectra.addAll(currentMobilogram.getSpectra());\n+      currentMobilogram.getIntensityValues(currentIntensities);\n+      currentMobilogram.getMzValues(currentMzs);\n+      currentNumDataPoints = currentMobilogram.getNumberOfValues();\n+    } else {\n+      currentSpectra.addAll(currentFrame.getMobilityScans());\n+      currentMobilogram.getMzValues(detectedMzs);\n+      currentMobilogram.getIntensityValues(detectedIntensities);\n+      final int numValues = currentMobilogram.getNumberOfValues();\n+\n+      int currentSpectrumIndex = 0;\n+      int dpIndex = 0;\n+      for (int i = 0, numSpectra = currentSpectra.size(); i < numSpectra; i++) {\n+        MobilityScan mobilityScan = currentSpectra.get(i);\n+        if (mobilityScan == currentMobilogram.getSpectrum(currentSpectrumIndex)) {\n+          currentIntensities[dpIndex] = detectedIntensities[currentSpectrumIndex];\n+          currentMzs[dpIndex] = detectedMzs[currentSpectrumIndex];\n+          currentSpectrumIndex++;\n+        } else {\n+          currentIntensities[dpIndex] = 0d;\n+          currentMzs[dpIndex] = 0d;\n+        }\n+        if(currentSpectrumIndex == numValues && i < numSpectra - 1) {\n+          Arrays.fill(currentIntensities, i + 1, currentIntensities.length, 0d);\n+          break;\n+        }\n+        dpIndex++;\n+      }\n+    }\n+\n+    return currentMobilogram;\n+  }\n+\n+  @Override\n+  public DoubleBuffer getIntensityValues() {\n+    throw new IllegalArgumentException(\n+        \"MobilogramDataAccess shall be used to iterate over the mzs and intensities.\");\n+  }\n+\n+  @Override\n+  public IonSeries copy(MemoryMapStorage storage) {\n+    return currentMobilogram.copy(storage);\n+  }\n+\n+  @Override\n+  public DoubleBuffer getMZValues() {\n+    throw new IllegalArgumentException(\n+        \"MobilogramDataAccess shall be used to iterate over the mzs and intensities.\");\n+  }\n+\n+  @Override\n+  public double[] getIntensityValues(double[] dst) {\n+    assert dst.length >= currentNumDataPoints;\n+    System.arraycopy(currentIntensities, 0, dst, 0, currentNumDataPoints);\n+    return dst;\n+  }\n+\n+  @Override\n+  public double getIntensity(int index) {\n+    assert index <= currentNumDataPoints;\n+    return currentIntensities[index];\n+  }\n+\n+  @Override\n+  public double getIntensityForSpectrum(MobilityScan scan) {\n+    throw new IllegalArgumentException(\n+        \"MobilogramDataAccess shall be used to iterate over the mzs and intensities.\");\n+  }\n+\n+  @Override\n+  public double getMzForSpectrum(MobilityScan scan) {\n+    throw new IllegalArgumentException(\n+        \"MobilogramDataAccess shall be used to iterate over the mzs and intensities.\");\n+  }\n+\n+  @Override\n+  public int getNumberOfValues() {\n+    return currentNumDataPoints;\n+  }\n+\n+  @Override\n+  public MobilityScan getSpectrum(int index) {\n+    assert index < currentNumDataPoints;\n+    return currentMobilogram.getSpectrum(index);\n+  }\n+\n+  @Override\n+  public double[] getMzValues(double[] dst) {\n+    assert dst.length >= currentNumDataPoints;\n+    System.arraycopy(currentIntensities, 0, dst, 0, currentNumDataPoints);\n+    return dst;\n+  }\n+\n+  @Override\n+  public double getMZ(int index) {\n+    assert index <= currentNumDataPoints;\n+    return currentMzs[index];\n+  }\n+\n+  @Override\n+  public List<MobilityScan> getSpectra() {\n+    return Collections.unmodifiableList(currentSpectra);\n+  }\n+\n+  @Override\n+  public IonSpectrumSeries<MobilityScan> subSeries(@Nullable MemoryMapStorage storage,\n+      @Nonnull List<MobilityScan> subset) {\n+    return currentMobilogram.subSeries(storage, subset);\n+  }\n+\n+  @Override\n+  public IonSpectrumSeries<MobilityScan> copyAndReplace(@Nullable MemoryMapStorage storage,\n+      @Nonnull double[] newMzValues, @Nonnull double[] newIntensityValues) {\n+    // depending on the type of data access, we can have more scans in currentSpectra than data points. (if 0s are included)\n+    // hence, this method is unsupported. A new SimpleIonMobilitySeries should be created with the respective spectra instead.\n+    throw new IllegalArgumentException(\n+        \"MobilogramDataAccess shall be used to iterate over the mzs and intensities.\");\n+  }\n+}"
  },
  {
    "sha": "854e41332248e75afc3eb0868b28c00a1f751af4",
    "filename": "src/main/java/io/github/mzmine/datamodel/data_access/ScanDataAccess.java",
    "status": "modified",
    "additions": 16,
    "deletions": 11,
    "changes": 27,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/ScanDataAccess.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/data_access/ScanDataAccess.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/data_access/ScanDataAccess.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -43,14 +43,16 @@\n   protected final RawDataFile dataFile;\n   protected final ScanDataType type;\n   private final ScanSelection selection;\n-  protected final int scans;\n+  protected final int totalScans;\n \n   // current data\n   protected final double[] mzs;\n   protected final double[] intensities;\n-  protected int currentScan = -1;\n   protected int currentNumberOfDataPoints = -1;\n \n+  protected int scanIndex = -1;\n+  protected int currentScanInDataFile = -1;\n+\n   /**\n    * The intended use of this memory access is to loop over all scans and access data points via\n    * {@link #getMzValue(int)} and {@link #getIntensityValue(int)}\n@@ -66,15 +68,15 @@ protected ScanDataAccess(RawDataFile dataFile,\n     this.selection = selection;\n     // count matching scans\n     if (selection == null) {\n-      scans = dataFile.getScans().size();\n+      totalScans = dataFile.getScans().size();\n     } else {\n       int size = 0;\n       for (Scan s : dataFile.getScans()) {\n         if (selection.matches(s)) {\n           size++;\n         }\n       }\n-      scans = size;\n+      totalScans = size;\n     }\n     // might even use the maximum number of data points in the selected scans\n     // but seems unnecessary\n@@ -93,8 +95,8 @@ public int getNumberOfDataPoints() {\n   }\n \n   public Scan getCurrentScan() {\n-    assert currentScan >= 0 && hasNextScan();\n-    return dataFile.getScan(currentScan);\n+    assert scanIndex >= 0 && hasNextScan();\n+    return dataFile.getScan(currentScanInDataFile);\n   }\n \n   /**\n@@ -142,13 +144,16 @@ public Scan nextScan() throws MissingMassListException {\n     if (hasNextScan()) {\n       Scan scan = null;\n       do {\n-        currentScan++;\n-        scan = dataFile.getScan(currentScan);\n+        // next scan in data file\n+        currentScanInDataFile++;\n+        scan = dataFile.getScan(currentScanInDataFile);\n \n         assert scan != null;\n         // find next scan\n       } while (selection != null && !selection.matches(scan));\n \n+      // next scan found\n+      scanIndex++;\n       switch (type) {\n         case RAW -> {\n           scan.getMzValues(mzs);\n@@ -177,7 +182,7 @@ public Scan nextScan() throws MissingMassListException {\n    * @return\n    */\n   public boolean hasNextScan() {\n-    return currentScan + 1 < getNumberOfScans();\n+    return scanIndex + 1 < getNumberOfScans();\n   }\n \n   /**\n@@ -186,7 +191,7 @@ public boolean hasNextScan() {\n    * @return\n    */\n   public int getNumberOfScans() {\n-    return scans;\n+    return totalScans;\n   }\n \n   /**\n@@ -206,7 +211,7 @@ private int getMaxNumberOfDataPoints() {\n   @Override\n   public MassSpectrumType getSpectrumType() {\n     return switch (type) {\n-      case RAW -> dataFile.getScan(currentScan).getSpectrumType();\n+      case RAW -> dataFile.getScan(currentScanInDataFile).getSpectrumType();\n       case CENTROID -> MassSpectrumType.CENTROIDED;\n     };\n   }"
  },
  {
    "sha": "f2122a0f1ad951006e9118ae6bbd1a5cf11715d0",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/FeatureDataUtils.java",
    "status": "modified",
    "additions": 32,
    "deletions": 8,
    "changes": 40,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/FeatureDataUtils.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/FeatureDataUtils.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/FeatureDataUtils.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -33,10 +33,13 @@\n import io.github.mzmine.util.maths.Weighting;\n import java.nio.DoubleBuffer;\n import java.util.List;\n+import java.util.logging.Logger;\n import javax.annotation.Nullable;\n \n public class FeatureDataUtils {\n \n+  private static final Logger logger = Logger.getLogger(FeatureDataUtils.class.getName());\n+\n   public static Range<Float> getRtRange(IonTimeSeries<? extends Scan> series) {\n     final List<? extends Scan> scans = series.getSpectra();\n     return Range\n@@ -47,13 +50,29 @@\n     double min = Double.MAX_VALUE;\n     double max = Double.MIN_VALUE;\n \n-    for (int i = 0; i < series.getNumberOfValues(); i++) {\n-      final double mz = series.getMZ(i);\n-      if (mz < min) {\n-        min = mz;\n+    if (series instanceof IonMobilogramTimeSeries ionTrace) {\n+      for (IonMobilitySeries mobilogram : ionTrace.getMobilograms()) {\n+        for (int i = 0; i < mobilogram.getNumberOfValues(); i++) {\n+          final double mz = mobilogram.getMZ(i);\n+          // we add flanking 0 intensities with 0d mz during building, don't count those\n+          if (mz < min && Double.compare(mz, 0d) == 1) {\n+            min = mz;\n+          }\n+          if (mz > max) {\n+            max = mz;\n+          }\n+        }\n       }\n-      if (mz > max) {\n-        max = mz;\n+    } else {\n+      for (int i = 0; i < series.getNumberOfValues(); i++) {\n+        final double mz = series.getMZ(i);\n+        // we add flanking 0 intesities with 0d mz during building, don't count those\n+        if (mz < min && Double.compare(mz, 0d) == 1) {\n+          min = mz;\n+        }\n+        if (mz > max) {\n+          max = mz;\n+        }\n       }\n     }\n     return Range.closed(min, max);\n@@ -133,7 +152,7 @@ public static float calculateArea(IonTimeSeries<? extends Scan> series) {\n   }\n \n   public static double calculateMz(IonSeries series, CenterMeasure cm) {\n-    CenterFunction cf = new CenterFunction(cm, Weighting.logger10);\n+    CenterFunction cf = new CenterFunction(cm, Weighting.LINEAR);\n     double[][] data = DataPointUtils\n         .getDataPointsAsDoubleArray(series.getMZValues(), series.getIntensityValues());\n     return cf.calcCenter(data[0], data[1]);\n@@ -175,7 +194,12 @@ public static void recalculateIonSeriesDependingTypes(ModularFeature feature, Ce\n           mostIntenseMobilityScanIndex = i;\n         }\n       }\n-      feature.setMobility((float) summedMobilogram.getMobility(mostIntenseMobilityScanIndex));\n+      if(Double.compare(intensity, Double.MIN_VALUE) == 0) {\n+        logger.info(() -> \"Mobility cannot be specified for: \" + summedMobilogram.print());\n+        feature.setMobility(Float.NaN);\n+      } else {\n+        feature.setMobility((float) summedMobilogram.getMobility(mostIntenseMobilityScanIndex));\n+      }\n     }\n     // todo recalc quality parameters\n   }"
  },
  {
    "sha": "8da98fa9f752868eaf0b2bf9a573d2d2876d59c5",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilitySeries.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilitySeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilitySeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilitySeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -11,4 +11,5 @@\n   default double getMobility(int index) {\n     return getSpectrum(index).getMobility();\n   }\n+\n }"
  },
  {
    "sha": "baf9746f310d6ec9ec700e1abd3747292c2a24a8",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilogramTimeSeries.java",
    "status": "modified",
    "additions": 11,
    "deletions": 13,
    "changes": 24,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilogramTimeSeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilogramTimeSeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/IonMobilogramTimeSeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -19,6 +19,8 @@\n package io.github.mzmine.datamodel.featuredata;\n \n import io.github.mzmine.datamodel.Frame;\n+import io.github.mzmine.datamodel.data_access.BinningMobilogramDataAccess;\n+import io.github.mzmine.datamodel.featuredata.impl.ModifiableSpectra;\n import io.github.mzmine.datamodel.featuredata.impl.SummedIntensityMobilitySeries;\n import io.github.mzmine.util.MemoryMapStorage;\n import java.util.List;\n@@ -31,13 +33,16 @@\n  *\n  * @author https://github.com/SteffenHeu\n  */\n-public interface IonMobilogramTimeSeries extends IonTimeSeries<Frame> {\n+public interface IonMobilogramTimeSeries extends IonTimeSeries<Frame>, ModifiableSpectra<Frame> {\n \n   @Override\n   default float getRetentionTime(int index) {\n     return getSpectrum(index).getRetentionTime();\n   }\n \n+  IonMobilogramTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n+      @Nonnull List<Frame> subset, @Nonnull BinningMobilogramDataAccess mobilogramBinning);\n+\n   List<IonMobilitySeries> getMobilograms();\n \n   default IonMobilitySeries getMobilogram(int index) {\n@@ -47,22 +52,15 @@ default IonMobilitySeries getMobilogram(int index) {\n   SummedIntensityMobilitySeries getSummedMobilogram();\n \n   /**\n-   * Creates a copy of this series using the same frame list, but with new mz/intensities and new\n-   * mobilograms, e.g. after smoothing.\n+   * Allows creation of a new {@link IonMobilogramTimeSeries} with processed {@link\n+   * SummedIntensityMobilitySeries}.\n    *\n-   * @param storage                             May be null if data shall be stored in ram\n-   * @param newMzValues\n-   * @param newIntensityValues\n-   * @param newMobilograms\n-   * @param smoothedSummedMobilogramIntensities If the summed mobilogram has been smoothed, the\n-   *                                            smoothed intensities can be passed here. If null,\n-   *                                            the previous intensities will be used.\n+   * @param storage\n+   * @param summedMobilogram\n    * @return\n    */\n   IonMobilogramTimeSeries copyAndReplace(@Nullable MemoryMapStorage storage,\n-      @Nonnull double[] newMzValues, @Nonnull double[] newIntensityValues,\n-      @Nonnull List<IonMobilitySeries> newMobilograms,\n-      @Nullable double[] smoothedSummedMobilogramIntensities);\n+      @Nonnull SummedIntensityMobilitySeries summedMobilogram);\n \n   /**\n    * @param scan"
  },
  {
    "sha": "d4f79ad43bd0cb8d026cb58f202fa3b4041f748a",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/IonSpectrumSeries.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonSpectrumSeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/IonSpectrumSeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/IonSpectrumSeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -62,7 +62,7 @@ default double getMzForSpectrum(T spectrum) {\n    * Used during deconvolution, when a feature is cut into several individual features.\n    *\n    * @param storage The new storage, may be null if data shall be stored in ram.\n-   * @param subset  The subset of spectra.\n+   * @param subset  The subset of spectra. sorted by their scan number (retention time or mobility)\n    * @return The subset series.\n    */\n   IonSpectrumSeries<T> subSeries(@Nullable MemoryMapStorage storage, @Nonnull List<T> subset);"
  },
  {
    "sha": "ec3d3701d87d1f891217af54944cb9ccb81fcb0c",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/IonMobilogramTimeSeriesFactory.java",
    "status": "added",
    "additions": 154,
    "deletions": 0,
    "changes": 154,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/IonMobilogramTimeSeriesFactory.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/IonMobilogramTimeSeriesFactory.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/IonMobilogramTimeSeriesFactory.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -0,0 +1,154 @@\n+/*\n+ *  Copyright 2006-2020 The MZmine Development Team\n+ *\n+ *  This file is part of MZmine.\n+ *\n+ *  MZmine is free software; you can redistribute it and/or modify it under the terms of the GNU\n+ *  General Public License as published by the Free Software Foundation; either version 2 of the\n+ *  License, or (at your option) any later version.\n+ *\n+ *  MZmine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even\n+ *  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+ *  Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License along with MZmine; if not,\n+ *  write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301\n+ *  USA\n+ */\n+\n+package io.github.mzmine.datamodel.featuredata.impl;\n+\n+import io.github.mzmine.datamodel.Frame;\n+import io.github.mzmine.datamodel.data_access.BinningMobilogramDataAccess;\n+import io.github.mzmine.datamodel.featuredata.IonMobilitySeries;\n+import io.github.mzmine.datamodel.featuredata.IonMobilogramTimeSeries;\n+import io.github.mzmine.util.MemoryMapStorage;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * @author https://github.com/SteffenHeu\n+ */\n+public class IonMobilogramTimeSeriesFactory {\n+\n+  private IonMobilogramTimeSeriesFactory() {\n+\n+  }\n+\n+  /**\n+   * Stores a list of mobilograms. A summed intensity of each mobilogram is automatically calculated\n+   * and represents this series when plotted as a 2D intensity-vs time chart (accessed via {@link\n+   * SimpleIonMobilogramTimeSeries#getMZ(int)} and {@link SimpleIonMobilogramTimeSeries#getIntensity(int)}).\n+   * The mz representing a mobilogram is calculated by a weighted average based on the mzs in eah\n+   * mobility scan.\n+   *\n+   * @param storage     May be null if values shall be stored in ram.\n+   * @param mobilograms\n+   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[])\n+   */\n+  public static IonMobilogramTimeSeries of(@Nullable MemoryMapStorage storage,\n+      @Nonnull final List<IonMobilitySeries> mobilograms,\n+      @Nonnull final BinningMobilogramDataAccess mobilogramBinning) {\n+\n+    double[][] summedAndWeighted = sumIntensitiesWeightMzs(mobilograms);\n+\n+    mobilogramBinning.setMobilogram(mobilograms);\n+    final SummedIntensityMobilitySeries summedMobilogram = mobilogramBinning\n+        .toSummedMobilogram(storage);\n+\n+    return of(storage, summedAndWeighted[0], summedAndWeighted[1], mobilograms, summedMobilogram);\n+  }\n+\n+  public static IonMobilogramTimeSeries of(@Nullable MemoryMapStorage storage,\n+      @Nonnull final double[] rtMzs,\n+      @Nonnull final double[] rtIntensities,\n+      @Nonnull final List<IonMobilitySeries> mobilograms,\n+      @Nonnull final BinningMobilogramDataAccess mobilogramBinning) {\n+\n+    mobilogramBinning.setMobilogram(mobilograms);\n+\n+    return of(storage, rtMzs, rtIntensities, mobilograms,\n+        mobilogramBinning.toSummedMobilogram(storage));\n+  }\n+\n+  public static IonMobilogramTimeSeries of(@Nullable MemoryMapStorage storage,\n+      @Nonnull final double[] rtMzs,\n+      @Nonnull final double[] rtIntensities,\n+      @Nonnull final List<IonMobilitySeries> mobilograms,\n+      @Nonnull final double[] mobilogramMobilities,\n+      @Nonnull final double[] mobilogramIntensities) {\n+\n+    return of(storage, rtMzs, rtIntensities, mobilograms,\n+        new SummedIntensityMobilitySeries(storage, mobilogramMobilities, mobilogramIntensities));\n+  }\n+\n+  public static IonMobilogramTimeSeries of(@Nullable MemoryMapStorage storage,\n+      @Nonnull final double[] rtMzs,\n+      @Nonnull final double[] rtIntensities,\n+      @Nonnull final List<IonMobilitySeries> mobilograms,\n+      @Nonnull final SummedIntensityMobilitySeries summedMobilogram) {\n+\n+    final List<Frame> frames = new ArrayList<>(mobilograms.size());\n+    for (IonMobilitySeries ims : mobilograms) {\n+      final Frame frame = ims.getSpectra().get(0).getFrame();\n+      frames.add(frame);\n+    }\n+\n+    return of(storage, rtMzs, rtIntensities, mobilograms, frames, summedMobilogram);\n+  }\n+\n+  public static IonMobilogramTimeSeries of(@Nullable MemoryMapStorage storage,\n+      @Nonnull final double[] rtMzs,\n+      @Nonnull final double[] rtIntensities,\n+      @Nonnull final List<IonMobilitySeries> mobilograms,\n+      @Nonnull final List<Frame> frames,\n+      @Nonnull final SummedIntensityMobilitySeries summedMobilogram) {\n+\n+    return new SimpleIonMobilogramTimeSeries(storage, rtMzs, rtIntensities, mobilograms, frames,\n+        summedMobilogram);\n+  }\n+\n+  private static double[][] sumIntensitiesWeightMzs(List<IonMobilitySeries> mobilograms) {\n+    double[] summedIntensities = new double[mobilograms.size()];\n+    double[] weightedMzs = new double[mobilograms.size()];\n+\n+    final int maxNumDetected = mobilograms.stream()\n+        .mapToInt(IonMobilitySeries::getNumberOfValues).max().getAsInt();\n+\n+    final double[] tmpIntensities = new double[maxNumDetected];\n+    final double[] tmpMzs = new double[maxNumDetected];\n+\n+    for (int i = 0; i < mobilograms.size(); i++) {\n+      final IonMobilitySeries ims = mobilograms.get(i);\n+      final int numValues = ims.getNumberOfValues();\n+      ims.getIntensityValues(tmpIntensities);\n+      for (int j = 0; j < numValues; j++) {\n+        summedIntensities[i] += tmpIntensities[j];\n+      }\n+    }\n+\n+    for (int i = 0; i < mobilograms.size(); i++) {\n+      final IonMobilitySeries ims = mobilograms.get(i);\n+      final int numValues = ims.getNumberOfValues();\n+      Arrays.fill(tmpMzs, 0, numValues - 1, 0d);\n+      Arrays.fill(tmpIntensities, 0, numValues - 1, 0d);\n+      ims.getIntensityValues(tmpIntensities);\n+      ims.getMzValues(tmpMzs);\n+      double weightedMz = 0;\n+\n+      for (int j = 0; j < numValues; j++) {\n+        weightedMz += tmpMzs[j] * (tmpIntensities[j] / summedIntensities[i]);\n+      }\n+\n+      // due to added zeros, the summed intensity might have been 0 -> NaN\n+      if (Double.isNaN(weightedMz)) {\n+        weightedMz = 0d;\n+      }\n+      weightedMzs[i] = weightedMz;\n+    }\n+    return new double[][]{weightedMzs, summedIntensities};\n+  }\n+}"
  },
  {
    "sha": "5d6466523b6e7ea8a95e515f818a0899087e0310",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/ModifiableSpectra.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/ModifiableSpectra.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/ModifiableSpectra.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/ModifiableSpectra.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -30,7 +30,7 @@\n  * @param <T>\n  * @author https://github.com/SteffenHeu\n  */\n-interface ModifiableSpectra<T extends MassSpectrum> {\n+public interface ModifiableSpectra<T extends MassSpectrum> {\n \n   List<T> getSpectraModifiable();\n }"
  },
  {
    "sha": "975c2b70df12f71552362c6fde2f3c671d81eb86",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonMobilogramTimeSeries.java",
    "status": "modified",
    "additions": 96,
    "deletions": 179,
    "changes": 275,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonMobilogramTimeSeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonMobilogramTimeSeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonMobilogramTimeSeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -18,22 +18,25 @@\n \n package io.github.mzmine.datamodel.featuredata.impl;\n \n+import com.google.common.collect.Comparators;\n import io.github.mzmine.datamodel.Frame;\n import io.github.mzmine.datamodel.MobilityScan;\n+import io.github.mzmine.datamodel.MobilityType;\n import io.github.mzmine.datamodel.RawDataFile;\n+import io.github.mzmine.datamodel.Scan;\n+import io.github.mzmine.datamodel.data_access.BinningMobilogramDataAccess;\n import io.github.mzmine.datamodel.featuredata.IonMobilitySeries;\n import io.github.mzmine.datamodel.featuredata.IonMobilogramTimeSeries;\n+import io.github.mzmine.datamodel.features.ModularFeatureList;\n+import io.github.mzmine.modules.dataprocessing.featdet_ionmobilitytracebuilder.IonMobilityTraceBuilderModule;\n+import io.github.mzmine.modules.dataprocessing.featdet_mobilogram_summing.MobilogramBinningModule;\n import io.github.mzmine.util.DataPointUtils;\n import io.github.mzmine.util.MemoryMapStorage;\n-import io.github.mzmine.util.maths.CenterFunction;\n-import io.github.mzmine.util.maths.CenterMeasure;\n-import io.github.mzmine.util.maths.Weighting;\n import java.nio.DoubleBuffer;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n-import java.util.logging.Logger;\n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n \n@@ -44,11 +47,6 @@\n  */\n public class SimpleIonMobilogramTimeSeries implements IonMobilogramTimeSeries {\n \n-  private static final Logger logger = Logger.getLogger(SimpleIonTimeSeries.class.getName());\n-\n-  private static final CenterFunction mzCentering = new CenterFunction(CenterMeasure.AVG,\n-      Weighting.logger10, 0d, 4);\n-\n   protected final List<IonMobilitySeries> mobilograms;\n   protected final List<Frame> frames;\n   protected final DoubleBuffer intensityValues;\n@@ -58,105 +56,30 @@\n   protected DoubleBuffer mobilogramIntensityValues;\n \n   /**\n-   * Stores a list of mobilograms. A summed intensity of each mobilogram is automatically calculated\n-   * and represents this series when plotted as a 2D intensity-vs time chart (accessed via {@link\n-   * SimpleIonMobilogramTimeSeries#getMZ(int)} and {@link SimpleIonMobilogramTimeSeries#getIntensity(int)}).\n-   * The mz representing a mobilogram is calculated by a weighted average based on the mzs in eah\n-   * mobility scan.\n-   *\n-   * @param storage     May be null if values shall be stored in ram.\n-   * @param mobilograms\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[])\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[], List,\n-   * double[])\n-   */\n-  public SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage,\n-      @Nonnull List<IonMobilitySeries> mobilograms) {\n-    if (!checkRawFileIntegrity(mobilograms)) {\n-      throw new IllegalArgumentException(\"Cannot combine mobilograms of different raw data files.\");\n-    }\n-\n-    frames = new ArrayList<>(mobilograms.size());\n-    this.mobilograms = storeMobilograms(storage, mobilograms);\n-\n-    for (IonMobilitySeries ims : mobilograms) {\n-      final Frame frame = ims.getSpectra().get(0).getFrame();\n-      frames.add(frame);\n-    }\n-\n-    double[] summedIntensities = sumIntensities(mobilograms);\n-    double[] weightedMzs = weightMzs(mobilograms, summedIntensities);\n-    final double mz = Arrays.stream(weightedMzs).filter(val -> Double.compare(val, 0d) != 0)\n-        .average().getAsDouble();\n-\n-    summedMobilogram = new SummedIntensityMobilitySeries(storage,\n-        mobilograms, mz);\n-\n-    mzValues = StorageUtils.storeValuesToDoubleBuffer(storage, weightedMzs);\n-    intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, summedIntensities);\n-  }\n-\n-  /**\n-   * Constructor with custom mzs and intensities. Use with care. After feature creation, {@link\n-   * SimpleIonMobilogramTimeSeries#SimpleIonMobilogramTimeSeries(MemoryMapStorage, List)} might be\n-   * more applicable, to automatically calculate summed intensities for each mobilogram. This\n-   * constructor is meant to be used, when intensities have been altered, e.g. by smoothing.\n-   *\n-   * @param storage     May be null if values shall be stored in ram.\n-   * @param mzs\n-   * @param intensities\n-   * @param mobilograms\n-   * @param frames\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[])\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[], List,\n-   * double[])\n-   */\n-  private SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage, @Nonnull double[] mzs,\n-      @Nonnull double[] intensities, List<IonMobilitySeries> mobilograms,\n-      List<Frame> frames) {\n-    if (mzs.length != intensities.length || mobilograms.size() != intensities.length\n-        || mzs.length != mobilograms.size()) {\n-      throw new IllegalArgumentException(\n-          \"Length of mz, intensity, frames and/or mobilograms does not match.\");\n-    }\n-    if (!checkRawFileIntegrity(mobilograms)) {\n-      throw new IllegalArgumentException(\"Cannot combine mobilograms of different raw data files.\");\n-    }\n-\n-    this.mobilograms = storeMobilograms(storage, mobilograms);\n-    this.frames = frames;\n-\n-    summedMobilogram = new SummedIntensityMobilitySeries(storage,\n-        mobilograms, mzs[((int) mzs.length / 2)]);\n-\n-    mzValues = StorageUtils.storeValuesToDoubleBuffer(storage, mzs);\n-    intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, intensities);\n-  }\n-\n-  /**\n-   * Constructor with custom mzs and intensities. Use with care. After feature creation, {@link\n-   * SimpleIonMobilogramTimeSeries#SimpleIonMobilogramTimeSeries(MemoryMapStorage, List)} might be\n-   * more applicable, to automatically calculate summed intensities for each mobilogram. This\n-   * constructor is meant to be used, when intensities have been altered, e.g. by smoothing.\n+   * Creates a new {@link SimpleIonMobilogramTimeSeries}. For more convenient usage, see {@link\n+   * IonMobilogramTimeSeriesFactory#of(MemoryMapStorage, List, BinningMobilogramDataAccess)} The\n+   * indices of mzs, intensities, mobilograms and frames must match. All arrays/lists must have the\n+   * same length.\n    *\n-   * @param storage                             May be null if values shall be stored in ram.\n-   * @param mzs\n-   * @param intensities\n-   * @param mobilograms\n-   * @param frames\n-   * @param summedMobilogramMobilitities\n-   * @param smoothedSummedMobilogramIntensities\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[])\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[], List,\n-   * double[])\n+   * @param storage          The {@link MemoryMapStorage} to be used. May be null.\n+   * @param mzs              The mz values of this series. Should be calculated from all detected\n+   *                         signals in the {@link IonMobilitySeries} of the same index.\n+   * @param intensities      The intensity values of this series. Should be calculated from all\n+   *                         detected signals in the {@link IonMobilitySeries} of the same index.\n+   * @param mobilograms      The mobilograms of this series.\n+   * @param frames           The frames the mobilograms were detected in.\n+   * @param summedMobilogram A summed mobilogram calculated from all {@link IonMobilitySeries}.\n+   *                         Intensity should be summed within given mobility bins, specified in the\n+   *                         last module call of {@link IonMobilityTraceBuilderModule} or {@link\n+   *                         MobilogramBinningModule}. The last binning value can be obtained via\n+   *                         {@link BinningMobilogramDataAccess#getPreviousBinningWith(ModularFeatureList,\n+   *                         MobilityType)}\n    */\n-  private SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage, @Nonnull double[] mzs,\n+  public SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage, @Nonnull double[] mzs,\n       @Nonnull double[] intensities, @Nonnull List<IonMobilitySeries> mobilograms,\n-      @Nonnull List<Frame> frames, @Nullable double[] summedMobilogramMobilitities,\n-      @Nullable double[] smoothedSummedMobilogramIntensities) {\n+      @Nonnull List<Frame> frames, @Nonnull final SummedIntensityMobilitySeries summedMobilogram) {\n \n-    if (mzs.length != intensities.length || mobilograms.size() != intensities.length\n-        || mzs.length != mobilograms.size()) {\n+    if (mzs.length != intensities.length || mobilograms.size() != intensities.length) {\n       throw new IllegalArgumentException(\n           \"Length of mz, intensity, frames and/or mobilograms does not match.\");\n     }\n@@ -166,59 +89,54 @@ private SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage, @Nonnu\n \n     this.mobilograms = storeMobilograms(storage, mobilograms);\n     this.frames = frames;\n-\n-    final double mz = Arrays.stream(mzs).filter(val -> Double.compare(val, 0d) != 0).average()\n-        .getAsDouble();\n-\n-    if (smoothedSummedMobilogramIntensities != null && summedMobilogramMobilitities != null) {\n-      summedMobilogram = new SummedIntensityMobilitySeries(storage, summedMobilogramMobilitities,\n-          smoothedSummedMobilogramIntensities, mz);\n-    } else {\n-      summedMobilogram = new SummedIntensityMobilitySeries(storage, mobilograms, mz);\n-    }\n+    this.summedMobilogram = summedMobilogram;\n \n     mzValues = StorageUtils.storeValuesToDoubleBuffer(storage, mzs);\n     intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, intensities);\n   }\n \n-  /**\n-   * Private copy constructor.\n-   *\n-   * @param storage May be null if values shall be stored in ram.\n-   * @param series\n-   * @param frames  to be passed directly, since getSpectra wraps in a unmodifiable list. ->\n-   *                wrapping over and over\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[])\n-   * @see IonMobilogramTimeSeries#copyAndReplace(MemoryMapStorage, double[], double[], List,\n-   * double[])\n-   */\n-  private SimpleIonMobilogramTimeSeries(@Nullable MemoryMapStorage storage,\n-      @Nonnull IonMobilogramTimeSeries series, List<Frame> frames) {\n-    this.frames = frames;\n-    this.mobilograms = storeMobilograms(storage, series.getMobilograms());\n-\n-    double[][] data = DataPointUtils\n-        .getDataPointsAsDoubleArray(series.getMZValues(), series.getIntensityValues());\n-\n-    final double mz = Arrays.stream(data[0]).filter(val -> Double.compare(val, 0d) != 0).average()\n-        .getAsDouble();\n-\n-    summedMobilogram = new SummedIntensityMobilitySeries(storage,\n-        mobilograms, mz);\n-\n-    mzValues = StorageUtils.storeValuesToDoubleBuffer(storage, data[0]);\n-    intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, data[1]);\n+  @Override\n+  public List<Frame> getSpectraModifiable() {\n+    return frames;\n   }\n \n   @Override\n   public IonMobilogramTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n       @Nonnull List<Frame> subset) {\n+    throw new UnsupportedOperationException(\n+        \"Unsupported operation. Requires BinningMobilogramDataAccess for IonMobilogramTimeSeries.\");\n+  }\n+\n+  @Override\n+  public IonMobilogramTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n+      @Nonnull List<Frame> subset, @Nonnull final BinningMobilogramDataAccess mobilogramBinning) {\n     double[] mzs = new double[subset.size()];\n     double[] intensities = new double[subset.size()];\n \n+    final List<Frame> spectra = getSpectra();\n+    int sindex = 0;\n     for (int i = 0; i < subset.size(); i++) {\n-      mzs[i] = getMzForSpectrum(subset.get(i));\n-      intensities[i] = getIntensityForSpectrum(subset.get(i));\n+      Frame sub = subset.get(i);\n+      // find next spectrum\n+      while (spectra.get(sindex) != sub) {\n+        sindex++;\n+        if (sindex >= spectra.size()) {\n+          // exceptional case: no scan in spectra that matches sub from the subset, throw\n+          if (!Comparators.isInOrder(subset, Comparator.comparingInt(Scan::getScanNumber))) {\n+            throw new IllegalArgumentException(\n+                \"Subset of scans was not sorted by scan number (which should reflect retention time / mobility)\");\n+          }\n+          if (!Comparators.isInOrder(spectra, Comparator.comparingInt(Scan::getScanNumber))) {\n+            throw new IllegalArgumentException(\n+                \"Original IonTimeSeries scans were not sorted by scan number (which should reflect retention time / mobility)\");\n+          }\n+          throw new IllegalArgumentException(\n+              \"Not all scans of subset were present in this IonTimeSeries\");\n+        }\n+      }\n+      // set mz\n+      mzs[i] = getMZ(sindex);\n+      intensities[i] = getIntensity(sindex);\n     }\n \n     List<IonMobilitySeries> subMobilograms = new ArrayList<>(subset.size());\n@@ -228,7 +146,8 @@ public IonMobilogramTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n       }\n     }\n \n-    return new SimpleIonMobilogramTimeSeries(storage, mzs, intensities, subMobilograms, subset);\n+    return IonMobilogramTimeSeriesFactory\n+        .of(storage, mzs, intensities, subMobilograms, mobilogramBinning);\n   }\n \n   private List<IonMobilitySeries> storeMobilograms(@Nullable MemoryMapStorage storage,\n@@ -243,14 +162,14 @@ public IonMobilogramTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n     for (int i = 0; i < offsets.length; i++) {\n       IonMobilitySeries mobilogram = mobilograms.get(i);\n       List<MobilityScan> spectra;\n-      if(mobilogram instanceof ModifiableSpectra) {\n-        spectra = ((ModifiableSpectra)mobilogram).getSpectraModifiable();\n+      if (mobilogram instanceof ModifiableSpectra) {\n+        spectra = ((ModifiableSpectra) mobilogram).getSpectraModifiable();\n       } else {\n         spectra = mobilogram.getSpectra();\n       }\n \n       storedMobilograms.add(new StorableIonMobilitySeries(this, offsets[i],\n-         mobilogram.getNumberOfValues(), spectra));\n+          mobilogram.getNumberOfValues(), spectra));\n     }\n     return storedMobilograms;\n   }\n@@ -280,7 +199,10 @@ public DoubleBuffer getMZValues() {\n \n   @Override\n   public IonMobilogramTimeSeries copy(@Nullable MemoryMapStorage storage) {\n-    return new SimpleIonMobilogramTimeSeries(storage, this, frames);\n+    double[][] data = DataPointUtils\n+        .getDataPointsAsDoubleArray(getMZValues(), getIntensityValues());\n+    return IonMobilogramTimeSeriesFactory\n+        .of(storage, data[0], data[1], mobilograms, frames, summedMobilogram.copy(storage));\n   }\n \n   @Override\n@@ -291,38 +213,27 @@ public SummedIntensityMobilitySeries getSummedMobilogram() {\n   @Override\n   public IonMobilogramTimeSeries copyAndReplace(@Nullable MemoryMapStorage storage,\n       @Nonnull double[] newMzValues, @Nonnull double[] newIntensityValues) {\n-    return new SimpleIonMobilogramTimeSeries(storage, newMzValues, newIntensityValues,\n-        this.getMobilograms(), this.frames);\n+    return IonMobilogramTimeSeriesFactory\n+        .of(storage, newMzValues, newIntensityValues, mobilograms, frames,\n+            summedMobilogram.copy(storage));\n   }\n \n   /**\n-   * Used during smoothing. If smoothedSummedMobilogramIntensities are null, the intensities of the\n-   * summed mobilogram will be recalculated based on the individual mobilograms.\n+   * Allows creation of a new {@link IonMobilogramTimeSeries} with processed {@link\n+   * SummedIntensityMobilitySeries}.\n    *\n-   * @param storage                             May be null if data shall be stored in ram\n-   * @param newMzValues\n-   * @param newIntensityValues\n-   * @param newMobilograms\n-   * @param smoothedSummedMobilogramIntensities If the summed mobilogram has been smoothed, the\n-   *                                            smoothed intensities can be passed here. If null,\n-   *                                            the previous intensities will be used.\n+   * @param storage\n+   * @param summedMobilogram\n    * @return\n    */\n   @Override\n   public IonMobilogramTimeSeries copyAndReplace(@Nullable MemoryMapStorage storage,\n-      @Nonnull double[] newMzValues, @Nonnull double[] newIntensityValues,\n-      @Nonnull List<IonMobilitySeries> newMobilograms,\n-      @Nullable double[] smoothedSummedMobilogramIntensities) {\n-\n-    double[] summedMobilogramMobilities = null;\n-    if (smoothedSummedMobilogramIntensities != null) {\n-      summedMobilogramMobilities = DataPointUtils\n-          .getDoubleBufferAsArray(getSummedMobilogram().getMobilityValues());\n-    }\n+      @Nonnull SummedIntensityMobilitySeries summedMobilogram) {\n \n-    return new SimpleIonMobilogramTimeSeries(storage, newMzValues, newIntensityValues,\n-        newMobilograms, this.frames, summedMobilogramMobilities,\n-        smoothedSummedMobilogramIntensities);\n+    return new SimpleIonMobilogramTimeSeries(storage,\n+        DataPointUtils.getDoubleBufferAsArray(mzValues),\n+        DataPointUtils.getDoubleBufferAsArray(intensityValues), mobilograms, frames,\n+        summedMobilogram);\n   }\n \n   private double[] weightMzs(List<IonMobilitySeries> mobilograms,\n@@ -331,11 +242,11 @@ public IonMobilogramTimeSeries copyAndReplace(@Nullable MemoryMapStorage storage\n \n     for (int i = 0; i < mobilograms.size(); i++) {\n       IonMobilitySeries ims = mobilograms.get(i);\n-      DoubleBuffer intensities = ims.getIntensityValues();\n-      DoubleBuffer mzValues = ims.getMZValues();\n+      DoubleBuffer mobilogramIntensities = ims.getIntensityValues();\n+      DoubleBuffer mobilogramMzs = ims.getMZValues();\n       double weightedMz = 0;\n-      for (int j = 0; j < mzValues.capacity(); j++) {\n-        weightedMz += mzValues.get(j) * (intensities.get(j) / summedIntensities[i]);\n+      for (int j = 0; j < mobilogramMzs.capacity(); j++) {\n+        weightedMz += mobilogramMzs.get(j) * (mobilogramIntensities.get(j) / summedIntensities[i]);\n       }\n       // due to added zeros, the summed intensity might have been 0 -> NaN\n       if (Double.compare(weightedMz, Double.NaN) == 0) {\n@@ -358,10 +269,12 @@ public IonMobilogramTimeSeries copyAndReplace(@Nullable MemoryMapStorage storage\n     return summedIntensities;\n   }\n \n-  private boolean checkRawFileIntegrity(List<IonMobilitySeries> mobilograms) {\n-    final RawDataFile file = mobilograms.get(0).getSpectrum(0).getDataFile();\n+  private boolean checkRawFileIntegrity(@Nonnull List<IonMobilitySeries> mobilograms) {\n+    RawDataFile file = null;\n     for (IonMobilitySeries mobilogram : mobilograms) {\n-      if (mobilogram.getSpectrum(0).getDataFile() != file) {\n+      if (file == null) {\n+        file = mobilogram.getSpectrum(0).getDataFile();\n+      } else if (mobilogram.getSpectrum(0).getDataFile() != file) {\n         return false;\n       }\n     }\n@@ -395,4 +308,8 @@ protected double getMobilogramIntensityValue(StorableIonMobilitySeries mobilogra\n     assert index < mobilogram.getNumberOfValues();\n     return mobilogramIntensityValues.get(mobilogram.getStorageOffset() + index);\n   }\n+\n+  public List<IonMobilitySeries> getMobilogramsModifiable() {\n+    return mobilograms;\n+  }\n }"
  },
  {
    "sha": "32c8ac0a492ab53ab5aff2c9c810000f43b3c888",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonTimeSeries.java",
    "status": "modified",
    "additions": 27,
    "deletions": 21,
    "changes": 48,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonTimeSeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonTimeSeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SimpleIonTimeSeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -18,14 +18,15 @@\n \n package io.github.mzmine.datamodel.featuredata.impl;\n \n+import com.google.common.collect.Comparators;\n import io.github.mzmine.datamodel.Scan;\n import io.github.mzmine.datamodel.featuredata.IonSpectrumSeries;\n import io.github.mzmine.datamodel.featuredata.IonTimeSeries;\n import io.github.mzmine.util.DataPointUtils;\n import io.github.mzmine.util.MemoryMapStorage;\n-import java.io.IOException;\n import java.nio.DoubleBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n import java.util.logging.Logger;\n import javax.annotation.Nonnull;\n@@ -58,24 +59,8 @@ public SimpleIonTimeSeries(@Nullable MemoryMapStorage storage, @Nonnull double[]\n \n     this.scans = scans;\n \n-    DoubleBuffer tempMzs;\n-    DoubleBuffer tempIntensities;\n-    if (storage != null) {\n-      try {\n-        tempMzs = storage.storeData(mzValues);\n-        tempIntensities = storage.storeData(intensityValues);\n-      } catch (IOException e) {\n-        e.printStackTrace();\n-        tempMzs = DoubleBuffer.wrap(mzValues);\n-        tempIntensities = DoubleBuffer.wrap(intensityValues);\n-      }\n-    } else {\n-      tempMzs = DoubleBuffer.wrap(mzValues);\n-      tempIntensities = DoubleBuffer.wrap(intensityValues);\n-    }\n-\n-    this.mzValues = tempMzs;\n-    this.intensityValues = tempIntensities;\n+    this.mzValues = StorageUtils.storeValuesToDoubleBuffer(storage, mzValues);\n+    this.intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, intensityValues);\n   }\n \n   @Override\n@@ -84,9 +69,30 @@ public SimpleIonTimeSeries subSeries(@Nullable MemoryMapStorage storage,\n     double[] mzs = new double[subset.size()];\n     double[] intensities = new double[subset.size()];\n \n+    final List<Scan> spectra = getSpectra();\n+    int sindex = 0;\n     for (int i = 0; i < subset.size(); i++) {\n-      mzs[i] = getMzForSpectrum(subset.get(i));\n-      intensities[i] = getIntensityForSpectrum(subset.get(i));\n+      Scan sub = subset.get(i);\n+      // find next spectrum\n+      while (spectra.get(sindex) != sub) {\n+        sindex++;\n+        if (sindex >= spectra.size()) {\n+          // exceptional case: no scan in spectra that matches sub from the subset, throw\n+          if (!Comparators.isInOrder(subset, Comparator.comparingInt(Scan::getScanNumber))) {\n+            throw new IllegalArgumentException(\n+                \"Subset of scans was not sorted by scan number (which should reflect retention time / mobility)\");\n+          }\n+          if (!Comparators.isInOrder(spectra, Comparator.comparingInt(Scan::getScanNumber))) {\n+            throw new IllegalArgumentException(\n+                \"Original IonTimeSeries scans were not sorted by scan number (which should reflect retention time / mobility)\");\n+          }\n+          throw new IllegalArgumentException(\n+              \"Not all scans of subset were present in this IonTimeSeries\");\n+        }\n+      }\n+      // set mz\n+      mzs[i] = getMZ(sindex);\n+      intensities[i] = getIntensity(sindex);\n     }\n \n     return new SimpleIonTimeSeries(storage, mzs, intensities, subset);"
  },
  {
    "sha": "6a069ca109057af4acdcb7661c1a7cefee7d985f",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/StorableIonMobilitySeries.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/StorableIonMobilitySeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/StorableIonMobilitySeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/StorableIonMobilitySeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -37,12 +37,12 @@\n  *\n  * @author https://github.com/SteffenHeu\n  */\n-public class StorableIonMobilitySeries implements IonMobilitySeries, ModifiableSpectra<MobilityScan> {\n+public class StorableIonMobilitySeries implements IonMobilitySeries,\n+    ModifiableSpectra<MobilityScan> {\n \n   private static final Logger logger = Logger.getLogger(StorableIonMobilitySeries.class.getName());\n \n   protected final List<MobilityScan> scans;\n-\n   protected final int storageOffset;\n   protected final int numValues;\n   protected final SimpleIonMobilogramTimeSeries ionTrace;"
  },
  {
    "sha": "4e4d126172749e7bc17ee71260ba39f535510e91",
    "filename": "src/main/java/io/github/mzmine/datamodel/featuredata/impl/SummedIntensityMobilitySeries.java",
    "status": "modified",
    "additions": 47,
    "deletions": 56,
    "changes": 103,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SummedIntensityMobilitySeries.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SummedIntensityMobilitySeries.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/featuredata/impl/SummedIntensityMobilitySeries.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -22,28 +22,27 @@\n import com.google.common.collect.RangeMap;\n import com.google.common.collect.TreeRangeMap;\n import io.github.mzmine.datamodel.Frame;\n-import io.github.mzmine.datamodel.MobilityType;\n import io.github.mzmine.datamodel.featuredata.IntensitySeries;\n import io.github.mzmine.datamodel.featuredata.IonMobilitySeries;\n import io.github.mzmine.datamodel.featuredata.MobilitySeries;\n+import io.github.mzmine.util.DataPointUtils;\n import io.github.mzmine.util.IonMobilityUtils;\n import io.github.mzmine.util.MemoryMapStorage;\n-import java.io.IOException;\n import java.nio.DoubleBuffer;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n \n /**\n  * Stores a summed mobilogram based on the intesities of the frame-specific mobilograms in the\n- * constructor.\n+ * constructor. It is guaranteed that mobility values are ascending with index.\n  *\n  * @author https://github.com/SteffenHeu\n  */\n public class SummedIntensityMobilitySeries implements IntensitySeries, MobilitySeries {\n \n-  final double mz;\n   final DoubleBuffer intensityValues;\n   final DoubleBuffer mobilityValues;\n \n@@ -52,20 +51,14 @@\n    *\n    * @param storage     May be null, if values shall be stored in ram.\n    * @param mobilograms\n-   * @param mz\n    */\n   public SummedIntensityMobilitySeries(@Nullable MemoryMapStorage storage,\n-      List<IonMobilitySeries> mobilograms,\n-      double mz) {\n+      @Nonnull List<IonMobilitySeries> mobilograms) {\n \n-    this.mz = mz;\n     Frame exampleFrame = mobilograms.get(0).getSpectra().get(0).getFrame();\n-    double smallestDelta = IonMobilityUtils\n-        .getSmallestMobilityDelta(exampleFrame);\n+    final double smallestDelta = IonMobilityUtils.getSmallestMobilityDelta(exampleFrame);\n \n-    // we want to preserve the order of mobilities as it is ordered in the Frame.\n-    boolean ascendingMobility = exampleFrame.getMobilityType() != MobilityType.TIMS;\n-    RangeMap<Double, Double> mobilityIntensityValues = TreeRangeMap.create();\n+    final RangeMap<Double, Double> mobilityIntensityValues = TreeRangeMap.create();\n \n     for (int i = 0; i < mobilograms.size(); i++) {\n       IonMobilitySeries mobilogram = mobilograms.get(i);\n@@ -83,32 +76,15 @@ public SummedIntensityMobilitySeries(@Nullable MemoryMapStorage storage,\n       }\n     }\n \n-    // we want to preserve the order of mobilities as it is ordered in the Frame.\n-    Map<Range<Double>, Double> mapOfRanges =\n-        ascendingMobility ? mobilityIntensityValues.asMapOfRanges()\n-            : mobilityIntensityValues.asDescendingMapOfRanges();\n+    // this causes tims mobilities to be reordered\n+    Map<Range<Double>, Double> mapOfRanges = mobilityIntensityValues.asMapOfRanges();\n \n     double[] mobilities = mapOfRanges.keySet().stream()\n         .mapToDouble(key -> (key.upperEndpoint() + key.lowerEndpoint()) / 2).toArray();\n     double[] intensities = mapOfRanges.values().stream().mapToDouble(Double::doubleValue).toArray();\n \n-    DoubleBuffer tempMobility;\n-    DoubleBuffer tempIntensities;\n-    if (storage != null) {\n-      try {\n-        tempMobility = storage.storeData(mobilities);\n-        tempIntensities = storage.storeData(intensities);\n-      } catch (IOException e) {\n-        tempMobility = DoubleBuffer.wrap(mobilities);\n-        tempIntensities = DoubleBuffer.wrap(intensities);\n-        e.printStackTrace();\n-      }\n-    } else {\n-      tempMobility = DoubleBuffer.wrap(mobilities);\n-      tempIntensities = DoubleBuffer.wrap(intensities);\n-    }\n-    mobilityValues = tempMobility;\n-    intensityValues = tempIntensities;\n+    mobilityValues = StorageUtils.storeValuesToDoubleBuffer(storage, mobilities);\n+    intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, intensities);\n   }\n \n   /**\n@@ -118,28 +94,15 @@ public SummedIntensityMobilitySeries(@Nullable MemoryMapStorage storage,\n    * @param storage\n    * @param mobilities\n    * @param intensities\n-   * @param mz\n    */\n-  SummedIntensityMobilitySeries(MemoryMapStorage storage, double[] mobilities,\n-      double[] intensities, double mz) {\n-    this.mz = mz;\n-    DoubleBuffer tempMobility;\n-    DoubleBuffer tempIntensities;\n-    if (storage != null) {\n-      try {\n-        tempMobility = storage.storeData(mobilities);\n-        tempIntensities = storage.storeData(intensities);\n-      } catch (IOException e) {\n-        tempMobility = DoubleBuffer.wrap(mobilities);\n-        tempIntensities = DoubleBuffer.wrap(intensities);\n-        e.printStackTrace();\n-      }\n-    } else {\n-      tempMobility = DoubleBuffer.wrap(mobilities);\n-      tempIntensities = DoubleBuffer.wrap(intensities);\n+  public SummedIntensityMobilitySeries(@Nullable MemoryMapStorage storage, double[] mobilities,\n+      double[] intensities) {\n+    if (mobilities.length > 1) {\n+      assert mobilities[0] < mobilities[1];\n     }\n-    this.mobilityValues = tempMobility;\n-    this.intensityValues = tempIntensities;\n+\n+    mobilityValues = StorageUtils.storeValuesToDoubleBuffer(storage, mobilities);\n+    intensityValues = StorageUtils.storeValuesToDoubleBuffer(storage, intensities);\n   }\n \n   public int getNumberOfDataPoints() {\n@@ -153,6 +116,8 @@ public double getIntensity(int index) {\n   /**\n    * Note: Since this is a summed mobilogram, the data points were summed at a given mobility, not\n    * necessarily at the same mobility scan number. Therefore, a list of scans is not provided.\n+   * <p></p>\n+   * THe mobility values are guaranteed to be ascending.\n    *\n    * @param index\n    * @return\n@@ -169,8 +134,34 @@ public DoubleBuffer getMobilityValues() {\n     return mobilityValues;\n   }\n \n-  public double getMZ() {\n-    return mz;\n+  public double[] getMobilityValues(double[] dst) {\n+    if (dst.length < getNumberOfValues()) {\n+      dst = new double[getNumberOfValues()];\n+    }\n+    getMobilityValues().get(0, dst, 0, getNumberOfValues());\n+    return dst;\n+  }\n+\n+  public SummedIntensityMobilitySeries copy(@Nullable MemoryMapStorage storage) {\n+    return new SummedIntensityMobilitySeries(storage,\n+        DataPointUtils.getDoubleBufferAsArray(mobilityValues),\n+        DataPointUtils.getDoubleBufferAsArray(intensityValues));\n+  }\n+\n+  public String print() {\n+    StringBuilder builder = new StringBuilder();\n+    builder.append(\"Num values: \");\n+    builder.append(getNumberOfValues());\n+    builder.append(\"/\");\n+    builder.append(getNumberOfDataPoints());\n+    builder.append(\": \");\n+    for(int i = 0; i < getNumberOfValues(); i++) {\n+      builder.append(String.format(\"(%2.5f\", getMobility(i)));\n+      builder.append(\", \");\n+      builder.append(String.format(\"(%.1f\", getIntensity(i)));\n+      builder.append(\"), \");\n+    }\n+    return builder.toString();\n   }\n \n }"
  },
  {
    "sha": "df1582227d9f891822ad1c246e5829c0a4d2f079",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/FeatureList.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/FeatureList.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/FeatureList.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/FeatureList.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -166,22 +166,22 @@\n    *\n    * @param rtRange Retention time range\n    */\n-  public ObservableList<FeatureListRow> getRowsInsideScanRange(Range<Float> rtRange);\n+  public List<FeatureListRow> getRowsInsideScanRange(Range<Float> rtRange);\n \n   /**\n    * Returns all rows with average m/z within given range\n    *\n    * @param mzRange m/z range\n    */\n-  public ObservableList<FeatureListRow> getRowsInsideMZRange(Range<Double> mzRange);\n+  public List<FeatureListRow> getRowsInsideMZRange(Range<Double> mzRange);\n \n   /**\n    * Returns all rows with average m/z and retention time within given range\n    *\n    * @param rtRange Retention time range\n    * @param mzRange m/z range\n    */\n-  public ObservableList<FeatureListRow> getRowsInsideScanAndMZRange(Range<Float> rtRange,\n+  public List<FeatureListRow> getRowsInsideScanAndMZRange(Range<Float> rtRange,\n       Range<Double> mzRange);\n \n   /**\n@@ -190,15 +190,15 @@\n    * @param file    Raw data file\n    * @param rtRange Retention time range\n    */\n-  public ObservableList<Feature> getFeaturesInsideScanRange(RawDataFile file, Range<Float> rtRange);\n+  public List<Feature> getFeaturesInsideScanRange(RawDataFile file, Range<Float> rtRange);\n \n   /**\n    * Returns all features in a given m/z range\n    *\n    * @param file    Raw data file\n    * @param mzRange m/z range\n    */\n-  public ObservableList<Feature> getFeaturesInsideMZRange(RawDataFile file, Range<Double> mzRange);\n+  public List<Feature> getFeaturesInsideMZRange(RawDataFile file, Range<Double> mzRange);\n \n   /**\n    * Returns all features in a given m/z & retention time ranges\n@@ -207,7 +207,7 @@\n    * @param rtRange Retention time range\n    * @param mzRange m/z range\n    */\n-  public ObservableList<Feature> getFeaturesInsideScanAndMZRange(RawDataFile file,\n+  public List<Feature> getFeaturesInsideScanAndMZRange(RawDataFile file,\n       Range<Float> rtRange,\n       Range<Double> mzRange);\n "
  },
  {
    "sha": "947718c9a7e0436c93724d55ff565e88094f8370",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/ModularFeatureList.java",
    "status": "modified",
    "additions": 27,
    "deletions": 11,
    "changes": 38,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/ModularFeatureList.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/ModularFeatureList.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/ModularFeatureList.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -29,7 +29,8 @@\n public class ModularFeatureList implements FeatureList {\n \n   /**\n-   * The storage of this feature list. May be null if data points of features shall be stored in ram.\n+   * The storage of this feature list. May be null if data points of features shall be stored in\n+   * ram.\n    */\n   @Nullable\n   private final MemoryMapStorage memoryMapStorage;\n@@ -67,15 +68,17 @@\n     this(name, List.of(dataFiles));\n   }*/\n \n-  public ModularFeatureList(String name, @Nullable MemoryMapStorage storage, @Nonnull RawDataFile... dataFiles) {\n+  public ModularFeatureList(String name, @Nullable MemoryMapStorage storage,\n+      @Nonnull RawDataFile... dataFiles) {\n     this(name, storage, List.of(dataFiles));\n   }\n \n   /*public ModularFeatureList(String name, @Nonnull List<RawDataFile> dataFiles) {\n     this(name,null, dataFiles);\n   }*/\n \n-  public ModularFeatureList(String name, @Nullable MemoryMapStorage storage, @Nonnull List<RawDataFile> dataFiles) {\n+  public ModularFeatureList(String name, @Nullable MemoryMapStorage storage,\n+      @Nonnull List<RawDataFile> dataFiles) {\n     this.name = name;\n     this.dataFiles = FXCollections.observableList(dataFiles);\n     featureListRows = FXCollections.observableArrayList();\n@@ -270,19 +273,19 @@ public FeatureListRow getRow(int row) {\n   }\n \n   @Override\n-  public ObservableList<FeatureListRow> getRowsInsideMZRange(Range<Double> mzRange) {\n+  public List<FeatureListRow> getRowsInsideMZRange(Range<Double> mzRange) {\n     Range<Float> all = Range.all();\n     return getRowsInsideScanAndMZRange(all, mzRange);\n   }\n \n   @Override\n-  public ObservableList<FeatureListRow> getRowsInsideScanRange(Range<Float> rtRange) {\n+  public List<FeatureListRow> getRowsInsideScanRange(Range<Float> rtRange) {\n     Range<Double> all = Range.all();\n     return getRowsInsideScanAndMZRange(rtRange, all);\n   }\n \n   @Override\n-  public ObservableList<FeatureListRow> getRowsInsideScanAndMZRange(Range<Float> rtRange,\n+  public List<FeatureListRow> getRowsInsideScanAndMZRange(Range<Float> rtRange,\n       Range<Double> mzRange) {\n     // TODO handle if mz or rt is not present\n     return modularStream().filter(\n@@ -322,7 +325,7 @@ public void addRow(FeatureListRow row) {\n    * @return List of features\n    */\n   @Override\n-  public ObservableList<Feature> getFeaturesInsideScanRange(RawDataFile raw, Range<Float> rtRange) {\n+  public List<Feature> getFeaturesInsideScanRange(RawDataFile raw, Range<Float> rtRange) {\n     Range<Double> all = Range.all();\n     return getFeaturesInsideScanAndMZRange(raw, rtRange, all);\n   }\n@@ -331,7 +334,7 @@ public void addRow(FeatureListRow row) {\n    * @see io.github.mzmine.datamodel.features.FeatureList#getFeaturesInsideMZRange\n    */\n   @Override\n-  public ObservableList<Feature> getFeaturesInsideMZRange(RawDataFile raw, Range<Double> mzRange) {\n+  public List<Feature> getFeaturesInsideMZRange(RawDataFile raw, Range<Double> mzRange) {\n     Range<Float> all = Range.all();\n     return getFeaturesInsideScanAndMZRange(raw, all, mzRange);\n   }\n@@ -340,7 +343,7 @@ public void addRow(FeatureListRow row) {\n    * @see io.github.mzmine.datamodel.features.FeatureList#getFeaturesInsideScanAndMZRange\n    */\n   @Override\n-  public ObservableList<Feature> getFeaturesInsideScanAndMZRange(RawDataFile raw,\n+  public List<Feature> getFeaturesInsideScanAndMZRange(RawDataFile raw,\n       Range<Float> rtRange,\n       Range<Double> mzRange) {\n     // TODO solve with bindings and check for rt or mz presence in row\n@@ -509,11 +512,24 @@ public void setDateCreated(String date) {\n   /**\n    * create copy of all feature list rows and features\n    *\n-   * @param title\n+   * @param title the new title\n    * @return\n    */\n   public ModularFeatureList createCopy(String title, @Nullable MemoryMapStorage storage) {\n-    ModularFeatureList flist = new ModularFeatureList(title, storage, this.getRawDataFiles());\n+    return createCopy(title, storage, getRawDataFiles());\n+  }\n+\n+\n+  /**\n+   * create copy of all feature list rows and features. Use a different list of raw data files\n+   *\n+   * @param title     the new title\n+   * @param dataFiles the new list of raw data files\n+   * @return\n+   */\n+  public ModularFeatureList createCopy(String title, @Nullable MemoryMapStorage storage,\n+      List<RawDataFile> dataFiles) {\n+    ModularFeatureList flist = new ModularFeatureList(title, storage, dataFiles);\n     // copy all rows and features\n     this.stream().map(row -> new ModularFeatureListRow(flist, (ModularFeatureListRow) row, true))\n         .forEach(newRow -> flist.addRow(newRow));"
  },
  {
    "sha": "a6210be5a44c9c62d77cb198d7385925670cfc4c",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/types/FeatureShapeIonMobilityRetentionTimeHeatMapType.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/FeatureShapeIonMobilityRetentionTimeHeatMapType.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/FeatureShapeIonMobilityRetentionTimeHeatMapType.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/types/FeatureShapeIonMobilityRetentionTimeHeatMapType.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -20,6 +20,7 @@\n \n import io.github.mzmine.datamodel.IMSRawDataFile;\n import io.github.mzmine.datamodel.RawDataFile;\n+import io.github.mzmine.datamodel.featuredata.IonMobilogramTimeSeries;\n import io.github.mzmine.datamodel.features.ModularFeature;\n import io.github.mzmine.datamodel.features.ModularFeatureListRow;\n import io.github.mzmine.datamodel.features.types.graphicalnodes.FeatureShapeIonMobilityRetentionTimeHeatMapChart;\n@@ -51,6 +52,9 @@ public Node getCellNode(TreeTableCell<ModularFeatureListRow, Boolean> cell,\n       return null;\n     }\n     ModularFeature feature = row.getFeature(raw);\n+    if(feature == null || !(feature.getFeatureData() instanceof IonMobilogramTimeSeries)) {\n+      return null;\n+    }\n \n     // get existing buffered node from row (for column name)\n     // TODO listen to changes in features data"
  },
  {
    "sha": "6e9e9c6181547664710e1853292a740f3226b509",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/types/FeaturesType.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/FeaturesType.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/FeaturesType.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/types/FeaturesType.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -51,7 +51,6 @@\n  * @author Robin Schmid (robinschmid@uni-muenster.de)\n  *\n  */\n-// TODO: remove implements SubColumnsFactory...\n public class FeaturesType extends DataType<MapProperty<RawDataFile, ModularFeature>>\n     implements NoTextColumn {\n "
  },
  {
    "sha": "fed5202b7f5c4692569c8d281f308abc9d9449a1",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/types/MobilityUnitType.java",
    "status": "modified",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/MobilityUnitType.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/MobilityUnitType.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/types/MobilityUnitType.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -21,6 +21,7 @@\n import io.github.mzmine.datamodel.MobilityType;\n import javafx.beans.property.SimpleObjectProperty;\n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n \n public class MobilityUnitType extends DataType<SimpleObjectProperty<MobilityType>> {\n \n@@ -34,4 +35,13 @@ public String getHeaderString() {\n   public SimpleObjectProperty<MobilityType> createProperty() {\n     return new SimpleObjectProperty<>(MobilityType.NONE);\n   }\n+\n+  @Nonnull\n+  @Override\n+  public String getFormattedString(@Nullable Object value) {\n+    if (value instanceof MobilityType mt) {\n+      return mt.getUnit();\n+    }\n+    return super.getFormattedString(value);\n+  }\n }"
  },
  {
    "sha": "4f5ab4544691b7957b782ddd47e910151587e0f2",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/types/fx/DataTypeCellFactory.java",
    "status": "modified",
    "additions": 2,
    "deletions": 7,
    "changes": 9,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/fx/DataTypeCellFactory.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/fx/DataTypeCellFactory.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/types/fx/DataTypeCellFactory.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -18,16 +18,15 @@\n \n package io.github.mzmine.datamodel.features.types.fx;\n \n-import io.github.mzmine.datamodel.features.types.numbers.abstr.NumberType;\n-import java.util.logging.Logger;\n import io.github.mzmine.datamodel.RawDataFile;\n import io.github.mzmine.datamodel.features.ModularFeatureListRow;\n import io.github.mzmine.datamodel.features.types.DataType;\n import io.github.mzmine.datamodel.features.types.modifiers.GraphicalColumType;\n import io.github.mzmine.datamodel.features.types.modifiers.SubColumnsFactory;\n+import io.github.mzmine.datamodel.features.types.numbers.abstr.NumberType;\n+import java.util.logging.Logger;\n import javafx.geometry.Pos;\n import javafx.scene.Node;\n-import javafx.scene.control.Tooltip;\n import javafx.scene.control.TreeTableCell;\n import javafx.scene.control.TreeTableColumn;\n import javafx.util.Callback;\n@@ -86,16 +85,12 @@ protected void updateItem(Object item, boolean empty) {\n             setText(\n                 n != null ? null\n                     : sub.getFormattedSubColValue(subcolumn, this, param, item, raw));\n-            setTooltip(\n-                new Tooltip(sub.getFormattedSubColValue(subcolumn, this, param, item, raw)));\n           } else if (type instanceof GraphicalColumType) {\n             Node node = ((GraphicalColumType) type).getCellNode(this, param, item, raw);\n             getTableColumn().setMinWidth(((GraphicalColumType<?>) type).getColumnWidth());\n             setGraphic(node);\n             setText(null);\n-            setTooltip(new Tooltip(type.getFormattedString(item)));\n           } else {\n-            setTooltip(new Tooltip(type.getFormattedString(item)));\n             setText(type.getFormattedString(item));\n             setGraphic(null);\n           }"
  },
  {
    "sha": "e4a18118f2933d455a05d7c18494606c09b923e9",
    "filename": "src/main/java/io/github/mzmine/datamodel/features/types/numbers/ChargeType.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/numbers/ChargeType.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/features/types/numbers/ChargeType.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/features/types/numbers/ChargeType.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -64,7 +64,7 @@ public String getHeaderString() {\n               count.put(charge, n==null? 1 : n+1);\n             }\n           }\n-          return count.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).map(Map.Entry::getValue)\n+          return count.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).map(Map.Entry::getKey)\n                   .orElse(0);\n         }, prop);\n     }"
  },
  {
    "sha": "94459af95fc5d8116502218ccafcea2b243b377e",
    "filename": "src/main/java/io/github/mzmine/datamodel/impl/SimpleFrame.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/impl/SimpleFrame.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/datamodel/impl/SimpleFrame.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/datamodel/impl/SimpleFrame.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -28,6 +28,7 @@\n import io.github.mzmine.datamodel.PolarityType;\n import io.github.mzmine.datamodel.RawDataFile;\n import io.github.mzmine.datamodel.featuredata.impl.StorageUtils;\n+import io.github.mzmine.project.impl.IMSRawDataFileImpl;\n import java.nio.DoubleBuffer;\n import java.util.ArrayList;\n import java.util.Comparator;\n@@ -74,6 +75,8 @@ public SimpleFrame(@Nonnull RawDataFile dataFile, int scanNumber, int msLevel,\n \n   public void setDataPoints(double[] newMzValues, double[] newIntensityValues) {\n     super.setDataPoints(getDataFile().getMemoryMapStorage(), newMzValues, newIntensityValues);\n+    // update afterwards, an assertion might be triggered.\n+    ((IMSRawDataFileImpl) getDataFile()).updateMaxRawDataPoints(newIntensityValues.length);\n   }\n \n   /**"
  },
  {
    "sha": "f6213225beed7d786f78dcb2be6d3c5c4a76370e",
    "filename": "src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYDataset.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYDataset.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYDataset.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYDataset.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -295,6 +295,10 @@ public TaskStatus getStatus() {\n     return status.get();\n   }\n \n+  public SimpleObjectProperty<TaskStatus> statusProperty() {\n+    return status;\n+  }\n+\n   @Override\n   public String getErrorMessage() {\n     return errorMessage;"
  },
  {
    "sha": "4a226882186acd5213f0944d7623418e56a7dd29",
    "filename": "src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYZDataset.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYZDataset.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYZDataset.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/datasets/ColoredXYZDataset.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -290,4 +290,11 @@ public void run() {\n     }\n //    }\n   }\n+\n+  // Makes protected method public // TODO: possible alternatives?\n+  @Override\n+  public void fireDatasetChanged() {\n+    super.fireDatasetChanged();\n+  }\n+\n }"
  },
  {
    "sha": "4e8c7f7773192be97e34752616e99a336c8a3f8d",
    "filename": "src/main/java/io/github/mzmine/gui/chartbasics/simplechart/providers/impl/AnyXYProvider.java",
    "status": "added",
    "additions": 103,
    "deletions": 0,
    "changes": 103,
    "blob_url": "https://github.com/robinschmid/mzmine3/blob/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/providers/impl/AnyXYProvider.java",
    "raw_url": "https://github.com/robinschmid/mzmine3/raw/66ce3d09624a40b61a428d0851c91a24bd2b0651/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/providers/impl/AnyXYProvider.java",
    "contents_url": "https://api.github.com/repos/robinschmid/mzmine3/contents/src/main/java/io/github/mzmine/gui/chartbasics/simplechart/providers/impl/AnyXYProvider.java?ref=66ce3d09624a40b61a428d0851c91a24bd2b0651",
    "patch": "@@ -0,0 +1,103 @@\n+/*\n+ *  Copyright 2006-2020 The MZmine Development Team\n+ *\n+ *  This file is part of MZmine.\n+ *\n+ *  MZmine is free software; you can redistribute it and/or modify it under the terms of the GNU\n+ *  General Public License as published by the Free Software Foundation; either version 2 of the\n+ *  License, or (at your option) any later version.\n+ *\n+ *  MZmine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even\n+ *  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n+ *  Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License along with MZmine; if not,\n+ *  write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301\n+ *  USA\n+ */\n+\n+package io.github.mzmine.gui.chartbasics.simplechart.providers.impl;\n+\n+import io.github.mzmine.gui.chartbasics.simplechart.providers.PlotXYDataProvider;\n+import io.github.mzmine.taskcontrol.TaskStatus;\n+import io.github.mzmine.util.javafx.FxColorUtil;\n+import java.awt.Color;\n+import java.util.function.IntFunction;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+public class AnyXYProvider implements PlotXYDataProvider {\n+\n+  private final Color awtColor;\n+  private final String seriesKey;\n+  private final int numValues;\n+  private final IntFunction<Double> domainFunction;\n+  private final IntFunction<Double> rangeFunction;\n+\n+  public AnyXYProvider(Color awtColor, String seriesKey, int numValues,\n+      IntFunction<Double> domainFunction,\n+      IntFunction<Double> rangeFunction) {\n+    this.awtColor = awtColor;\n+    this.seriesKey = seriesKey;\n+    this.numValues = numValues;\n+    this.domainFunction = domainFunction;\n+    this.rangeFunction = rangeFunction;\n+  }\n+\n+\n+  @Nonnull\n+  @Override\n+  public Color getAWTColor() {\n+    return awtColor;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public javafx.scene.paint.Color getFXColor() {\n+    return FxColorUtil.awtColorToFX(awtColor);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getLabel(int index) {\n+    return null;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Comparable<?> getSeriesKey() {\n+    return seriesKey;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getToolTipText(int itemIndex) {\n+    return null;\n+  }\n+\n+  @Override\n+  public void computeValues(SimpleObjectProperty<TaskStatus> status) {\n+    // nothint to compute\n+  }\n+\n+  @Override\n+  public double getDomainValue(int index) {\n+    return domainFunction.apply(index);\n+  }\n+\n+  @Override\n+  public double getRangeValue(int index) {\n+    return rangeFunction.apply(index);\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return numValues;\n+  }\n+\n+  @Override\n+  public double getComputationFinishedPercentage() {\n+    return 1;\n+  }\n+}"
  }
]
