[
  {
    "sha": "571cc6c3898ea289d30b19d43abe7f108f61b96c",
    "filename": "snap-core/src/main/java/org/esa/snap/core/datamodel/ColorManipulationDefaults.java",
    "status": "added",
    "additions": 340,
    "deletions": 0,
    "changes": 340,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorManipulationDefaults.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorManipulationDefaults.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorManipulationDefaults.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -0,0 +1,340 @@\n+package org.esa.snap.core.datamodel;\n+\n+import org.esa.snap.core.util.NamingConvention;\n+import static org.esa.snap.core.util.NamingConvention.*;\n+\n+\n+/**\n+ * Configuration which contains many key parameters with defaults and labels for the color manipulation tool\n+ *\n+ * @author Daniel Knowles\n+ * @date 2/1/2020\n+ */\n+\n+public class ColorManipulationDefaults {\n+\n+    public static final boolean COLOR_MANIPULATION_DEBUG = false;\n+\n+    public static final String TOOLNAME_COLOR_MANIPULATION = NamingConvention.COLOR_MIXED_CASE + \" Manipulation\";\n+\n+\n+    // Directory names\n+    public static final String DIR_NAME_COLOR_SCHEMES = \"color_schemes\";\n+    public static final String DIR_NAME_RGB_PROFILES = \"rgb_profiles\";\n+    public static final String DIR_NAME_COLOR_PALETTES = \"color_palettes\";\n+    public static final String DIR_NAME_AUX_DATA = \"auxdata\";\n+\n+    // Palette files\n+    public static final String PALETTE_STANDARD_DEFAULT = \"oceancolor_standard.cpd\";\n+    public static final String PALETTE_UNIVERSAL_DEFAULT = \"universal_bluered.cpd\";\n+    public static final String PALETTE_GRAY_SCALE_DEFAULT = \"gray_scale.cpd\";\n+    public static final String PALETTE_ANOMALIES_DEFAULT = \"gradient_red_white_blue.cpd\";\n+    public static final String PALETTE_DEFAULT = PALETTE_GRAY_SCALE_DEFAULT;\n+\n+    // xml files used by the color scheme manager\n+    public static final String COLOR_SCHEME_LOOKUP_FILENAME = \"color_palette_scheme_lookup.xml\";\n+    public static final String COLOR_SCHEMES_FILENAME = \"color_palette_schemes.xml\";\n+\n+    // Indicates which color palette contained within the color scheme xml to use\n+    public static final String OPTION_COLOR_STANDARD_SCHEME = \"From Scheme STANDARD\";\n+    public static final String OPTION_COLOR_UNIVERSAL_SCHEME = \"From Scheme UNIVERSAL\";\n+\n+    // Color palette selections\n+    public static final String OPTION_COLOR_GRAY_SCALE = \"GRAY SCALE\";\n+    public static final String OPTION_COLOR_STANDARD = \"STANDARD\";\n+    public static final String OPTION_COLOR_UNIVERSAL = \"UNIVERSAL\";\n+    public static final String OPTION_COLOR_ANOMALIES = \"ANOMALIES\";\n+\n+    // Range options\n+    public static final String OPTION_RANGE_FROM_SCHEME = \"From Scheme\";\n+    public static final String OPTION_RANGE_FROM_DATA = \"From Data\";\n+    public static final String OPTION_RANGE_FROM_PALETTE = \"From Palette File\";\n+\n+    // Log scaling options\n+    public static final String OPTION_LOG_TRUE = \"TRUE\";\n+    public static final String OPTION_LOG_FALSE = \"FALSE\";\n+    public static final String OPTION_LOG_FROM_PALETTE = \"From Palette File\";\n+    public static final String OPTION_LOG_FROM_SCHEME = \"From Scheme\";\n+\n+    // general usage values\n+    public static final double DOUBLE_NULL = -Double.MAX_VALUE;\n+\n+\n+    //--------------------------------------------------------------------------------------------------------------\n+    // Color Manipulation Preferences parameters\n+\n+    // Preferences property prefix\n+    private static final String PROPERTY_ROOT_KEY = \"color.manipulation\";\n+\n+\n+    // General (Non-Scheme) Options\n+\n+    private static final String PROPERTY_GENERAL_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".general\";\n+\n+    public static final String PROPERTY_GENERAL_SECTION_KEY = PROPERTY_GENERAL_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_GENERAL_SECTION_LABEL = \"Standard Options\";\n+    public static final String PROPERTY_GENERAL_SECTION_TOOLTIP = \"General behavior when not using a \" + COLOR_LOWER_CASE + \" scheme\";\n+\n+    public static final String PROPERTY_GENERAL_PALETTE_KEY = PROPERTY_GENERAL_KEY_SUFFIX + \".palette\";\n+    public static final String PROPERTY_GENERAL_PALETTE_LABEL = \"Palette\";\n+    public static final String PROPERTY_GENERAL_PALETTE_TOOLTIP = \"The color palette file to use when NOT using a \" + COLOR_LOWER_CASE + \" scheme\";\n+    public static final String PROPERTY_GENERAL_PALETTE_OPTION1 = OPTION_COLOR_GRAY_SCALE;\n+    public static final String PROPERTY_GENERAL_PALETTE_OPTION2 = OPTION_COLOR_STANDARD;\n+    public static final String PROPERTY_GENERAL_PALETTE_OPTION3 = OPTION_COLOR_UNIVERSAL;\n+    public static final String PROPERTY_GENERAL_PALETTE_OPTION4 = OPTION_COLOR_ANOMALIES;\n+    public static final String PROPERTY_GENERAL_PALETTE_DEFAULT = OPTION_COLOR_GRAY_SCALE;\n+\n+    public static final String PROPERTY_GENERAL_RANGE_KEY = PROPERTY_GENERAL_KEY_SUFFIX + \".range\";\n+    public static final String PROPERTY_GENERAL_RANGE_LABEL = \"Range\";\n+    public static final String PROPERTY_GENERAL_RANGE_TOOLTIP = \"Range options to use when NOT using a \" + COLOR_LOWER_CASE + \"scheme\";\n+    public static final String PROPERTY_GENERAL_RANGE_OPTION1 = OPTION_RANGE_FROM_DATA;\n+    public static final String PROPERTY_GENERAL_RANGE_OPTION2 = OPTION_RANGE_FROM_PALETTE;\n+    public static final String PROPERTY_GENERAL_RANGE_DEFAULT = OPTION_RANGE_FROM_DATA;\n+\n+    public static final String PROPERTY_GENERAL_LOG_KEY = PROPERTY_GENERAL_KEY_SUFFIX + \".log\";\n+    public static final String PROPERTY_GENERAL_LOG_LABEL = \"Log Scaling\";\n+    public static final String PROPERTY_GENERAL_LOG_TOOLTIP = \"Log scaling options to use when NOT using a \" + COLOR_LOWER_CASE + \" scheme\";\n+    public static final String PROPERTY_GENERAL_LOG_OPTION1 = OPTION_LOG_TRUE;\n+    public static final String PROPERTY_GENERAL_LOG_OPTION2 = OPTION_LOG_FALSE;\n+    public static final String PROPERTY_GENERAL_LOG_OPTION3 = OPTION_LOG_FROM_PALETTE;\n+    public static final String PROPERTY_GENERAL_LOG_DEFAULT = OPTION_LOG_FALSE;\n+\n+\n+\n+    // Scheme option\n+\n+    private static final String PROPERTY_SCHEME_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".scheme\";\n+\n+    public static final String PROPERTY_SCHEME_SECTION_KEY = PROPERTY_SCHEME_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_SCHEME_SECTION_LABEL = \"Scheme Options\";\n+    public static final String PROPERTY_SCHEME_SECTION_TOOLTIP = \"<html>Behavior when using a \" + COLOR_LOWER_CASE + \" scheme as configured in<br>\" +\n+            \" color_palette_schemes.xml and color_palette_scheme_lookup.xml</html>\";\n+\n+    public static final String PROPERTY_SCHEME_AUTO_APPLY_KEY = PROPERTY_SCHEME_KEY_SUFFIX + \".auto.apply\";\n+    public static final String PROPERTY_SCHEME_AUTO_APPLY_LABEL = \"Apply \" + NamingConvention.COLOR_MIXED_CASE + \" Schemes Automatically\";\n+    public static final String PROPERTY_SCHEME_AUTO_APPLY_TOOLTIP = \"<html>Apply \" + NamingConvention.COLOR_LOWER_CASE +\" schemes automatically<br>\" +\n+            \" when opening a band based on its name</html>\";\n+    public static final boolean PROPERTY_SCHEME_AUTO_APPLY_DEFAULT = false;\n+\n+    public static final String PROPERTY_SCHEME_PALETTE_KEY = PROPERTY_SCHEME_KEY_SUFFIX + \".palette\";\n+    public static final String PROPERTY_SCHEME_PALETTE_LABEL = \"Palette\";\n+    public static final String PROPERTY_SCHEME_PALETTE_TOOLTIP = \"The color palette file to use for the scheme\";\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION1 = OPTION_COLOR_STANDARD_SCHEME;\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION2 = OPTION_COLOR_UNIVERSAL_SCHEME;\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION3 = OPTION_COLOR_GRAY_SCALE;\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION4 = OPTION_COLOR_STANDARD;\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION5 = OPTION_COLOR_UNIVERSAL;\n+    public static final String PROPERTY_SCHEME_PALETTE_OPTION6 = OPTION_COLOR_ANOMALIES;\n+    public static final String PROPERTY_SCHEME_PALETTE_DEFAULT = OPTION_COLOR_STANDARD_SCHEME;\n+\n+    public static final String PROPERTY_SCHEME_RANGE_KEY = PROPERTY_SCHEME_KEY_SUFFIX + \".range\";\n+    public static final String PROPERTY_SCHEME_RANGE_LABEL = \"Range\";\n+    public static final String PROPERTY_SCHEME_RANGE_TOOLTIP = \"Range options (min, max) to use for the scheme\";\n+    public static final String PROPERTY_SCHEME_RANGE_OPTION1 = OPTION_RANGE_FROM_SCHEME;\n+    public static final String PROPERTY_SCHEME_RANGE_OPTION2 = OPTION_RANGE_FROM_DATA;\n+    public static final String PROPERTY_SCHEME_RANGE_OPTION3 = OPTION_RANGE_FROM_PALETTE;\n+    public static final String PROPERTY_SCHEME_RANGE_DEFAULT = OPTION_RANGE_FROM_SCHEME;\n+\n+    public static final String PROPERTY_SCHEME_LOG_KEY = PROPERTY_SCHEME_KEY_SUFFIX + \".log\";\n+    public static final String PROPERTY_SCHEME_LOG_LABEL = \"Log Scaling\";\n+    public static final String PROPERTY_SCHEME_LOG_TOOLTIP = \"log scaling options to use for the scheme\";\n+    public static final String PROPERTY_SCHEME_LOG_OPTION1 = OPTION_LOG_FROM_SCHEME;\n+    public static final String PROPERTY_SCHEME_LOG_OPTION2 = OPTION_LOG_FROM_PALETTE;\n+    public static final String PROPERTY_SCHEME_LOG_OPTION3 = OPTION_LOG_TRUE;\n+    public static final String PROPERTY_SCHEME_LOG_OPTION4 = OPTION_LOG_FALSE;\n+    public static final String PROPERTY_SCHEME_LOG_DEFAULT = OPTION_LOG_FROM_SCHEME;\n+\n+\n+\n+    // Scheme Selector Options\n+\n+    private static final String PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".scheme.selector\";\n+\n+    public static final String PROPERTY_SCHEME_SELECTOR_SECTION_KEY = PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_SCHEME_SELECTOR_SECTION_LABEL = \"Scheme Selector Options\";\n+    public static final String PROPERTY_SCHEME_SELECTOR_SECTION_TOOLTIP = \"<html>Format options for the color schemes listed<br>\" +\n+            \" within the Scheme Selector</html>\";\n+\n+    public static final String PROPERTY_SCHEME_VERBOSE_KEY = PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX + \".verbose\";\n+    public static final String PROPERTY_SCHEME_VERBOSE_LABEL = \"Verbose\";\n+    public static final String PROPERTY_SCHEME_VERBOSE_TOOLTIP = \"<html>Scheme selector will show the verbose VERBOSE_NAME field<br>\" +\n+            \" from the color_palette_schemes.xml</html>\";\n+    public static final boolean PROPERTY_SCHEME_VERBOSE_DEFAULT = false;\n+\n+    public static final String PROPERTY_SCHEME_SHOW_DISABLED_KEY = PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX + \".show.disabled\";\n+    public static final String PROPERTY_SCHEME_SHOW_DISABLED_LABEL = \"Show Disabled\";\n+    public static final String PROPERTY_SCHEME_SHOW_DISABLED_TOOLTIP = \"<html>Scheme selector will display all schemes <br>\" +\n+            \"including schemes with missing cpd files</html>\";\n+    public static final boolean PROPERTY_SCHEME_SHOW_DISABLED_DEFAULT = false;\n+\n+    public static final String PROPERTY_SCHEME_SORT_KEY = PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX + \".sort\";\n+    public static final String PROPERTY_SCHEME_SORT_LABEL = \"Sort\";\n+    public static final String PROPERTY_SCHEME_SORT_TOOLTIP = \"<html>Scheme selector will display all schemes alphabetically sorted<br>\" +\n+            \" as opposed to the original xml order</html>\";\n+    public static final boolean PROPERTY_SCHEME_SORT_DEFAULT = true;\n+\n+    public static final String PROPERTY_SCHEME_CATEGORIZE_DISPLAY_KEY = PROPERTY_SCHEME_SELECTOR_KEY_SUFFIX + \".split\";\n+    public static final String PROPERTY_SCHEME_CATEGORIZE_DISPLAY_LABEL = \"Categorize\";\n+    public static final String PROPERTY_SCHEME_CATEGORIZE_DISPLAY_TOOLTIP = \"<html>Scheme selector will display all schemes categorized into<br>\" +\n+            \"primary and additional categories by the PRIMARY field<br> of the color_palette_schemes.xml</html>\";\n+    public static final boolean PROPERTY_SCHEME_CATEGORIZE_DISPLAY_DEFAULT = true;\n+\n+\n+    // Sliders Editor Options\n+\n+    private static final String PROPERTY_SLIDER_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".slider.options\";\n+\n+    public static final String PROPERTY_SLIDERS_SECTION_KEY = PROPERTY_SLIDER_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_SLIDERS_SECTION_LABEL = \"Sliders Editor Options\";\n+    public static final String PROPERTY_SLIDERS_SECTION_TOOLTIP = \"Options within the \\\"Sliders\\\" Editor of the \" + TOOLNAME_COLOR_MANIPULATION + \" GUI\";\n+\n+    public static final String PROPERTY_SLIDERS_SHOW_INFORMATION_KEY = PROPERTY_SLIDER_KEY_SUFFIX + \".extra.info\";\n+    public static final String PROPERTY_SLIDERS_SHOW_INFORMATION_LABEL = \"Show Information\";\n+    public static final String PROPERTY_SLIDERS_SHOW_INFORMATION_TOOLTIP = \"Display information in the histogram/slider view by default\";\n+    public static final boolean PROPERTY_SLIDERS_SHOW_INFORMATION_DEFAULT = true;\n+\n+    public static final String PROPERTY_SLIDERS_ZOOM_IN_KEY = PROPERTY_SLIDER_KEY_SUFFIX + \".zoom.in\";\n+    public static final String PROPERTY_SLIDERS_ZOOM_IN_LABEL = \"Histogram Zoom\";\n+    public static final String PROPERTY_SLIDERS_ZOOM_IN_TOOLTIP = \"Display histogram slider view zoomed in by default\";\n+    public static final boolean PROPERTY_SLIDERS_ZOOM_IN_DEFAULT = true;\n+\n+\n+\n+\n+\n+    // Range Percentile Default Options\n+\n+    private static final String PROPERTY_RANGE_PERCENTILE_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".range.percentile\";\n+\n+    public static final String PROPERTY_RANGE_PERCENTILE_SECTION_KEY = PROPERTY_RANGE_PERCENTILE_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_RANGE_PERCENTILE_SECTION_LABEL = \"Percentile Range\";\n+    public static final String PROPERTY_RANGE_PERCENTILE_SECTION_TOOLTIP = \"Default range percentile in the \" + TOOLNAME_COLOR_MANIPULATION + \" GUI\";\n+\n+    public static final String PROPERTY_RANGE_PERCENTILE_KEY = PROPERTY_RANGE_PERCENTILE_KEY_SUFFIX + \".value\";\n+    public static final String PROPERTY_RANGE_PERCENTILE_LABEL = \"Percentile Range Default\";\n+    public static final String PROPERTY_RANGE_PERCENTILE_TOOLTIP = \"The percentile of the data to use for determining min, max range\";\n+    public static final double PROPERTY_RANGE_PERCENTILE_DEFAULT = 92.0;\n+\n+\n+\n+\n+\n+\n+    // Button Enablement Options\n+\n+    private static final String PROPERTY_BUTTONS_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".button.enablement\";\n+\n+    public static final String PROPERTY_BUTTONS_SECTION_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_BUTTONS_SECTION_LABEL = \"Button Enablement\";\n+    public static final String PROPERTY_BUTTONS_SECTION_TOOLTIP = \"Button enablement options in the \" + TOOLNAME_COLOR_MANIPULATION + \" GUI\";\n+\n+    public static final String PROPERTY_100_PERCENT_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".100.button\";\n+    public static final String PROPERTY_100_PERCENT_BUTTON_LABEL = \"100% Button\";\n+    public static final String PROPERTY_100_PERCENT_BUTTON_TOOLTIP = \"Enable 100% range button in the sliders editor\";\n+    public static final boolean PROPERTY_100_PERCENT_BUTTON_DEFAULT = true;\n+\n+    public static final String PROPERTY_95_PERCENT_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".95.button\";\n+    public static final String PROPERTY_95_PERCENT_BUTTON_LABEL = \"95% Button\";\n+    public static final String PROPERTY_95_PERCENT_BUTTON_TOOLTIP = \"Enable 95% range button in the sliders editor\";\n+    public static final boolean PROPERTY_95_PERCENT_BUTTON_DEFAULT = false;\n+\n+    public static final String PROPERTY_1_SIGMA_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".1.sigma.button\";\n+    public static final String PROPERTY_1_SIGMA_BUTTON_LABEL = \"<html>1&sigma; (68.27%) Button</html>\";\n+    public static final String PROPERTY_1_SIGMA_BUTTON_TOOLTIP = \"Enable 68.27% range button in the sliders editor\";\n+    public static final boolean PROPERTY_1_SIGMA_BUTTON_DEFAULT = false;\n+\n+    public static final String PROPERTY_2_SIGMA_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".2.sigma.button\";\n+    public static final String PROPERTY_2_SIGMA_BUTTON_LABEL = \"<html>2&sigma; (95.45%) Button</html>\";\n+    public static final String PROPERTY_2_SIGMA_BUTTON_TOOLTIP = \"Enable 95.45% range button in the sliders editor\";\n+    public static final boolean PROPERTY_2_SIGMA_BUTTON_DEFAULT = true;\n+\n+    public static final String PROPERTY_3_SIGMA_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".3.sigma.button\";\n+    public static final String PROPERTY_3_SIGMA_BUTTON_LABEL = \"<html>3&sigma; (99.73%) Button</html>\";\n+    public static final String PROPERTY_3_SIGMA_BUTTON_TOOLTIP = \"Enable 99.73% range button in the sliders editor\";\n+    public static final boolean PROPERTY_3_SIGMA_BUTTON_DEFAULT = true;\n+\n+    public static final String PROPERTY_ZOOM_VERTICAL_BUTTONS_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".zoom.vertical.buttons\";\n+    public static final String PROPERTY_ZOOM_VERTICAL_BUTTONS_LABEL = \"Vertical Zoom Buttons\";\n+    public static final String PROPERTY_ZOOM_VERTICAL_BUTTONS_TOOLTIP = \"Enable zoom vertical buttons in the sliders editor\";\n+    public static final boolean PROPERTY_ZOOM_VERTICAL_BUTTONS_DEFAULT = true;\n+\n+    public static final String PROPERTY_INFORMATION_BUTTON_KEY = PROPERTY_BUTTONS_KEY_SUFFIX + \".extra.info.button\";\n+    public static final String PROPERTY_INFORMATION_BUTTON_LABEL = \"Information Button\";\n+    public static final String PROPERTY_INFORMATION_BUTTON_TOOLTIP = \"Enable histogram overlay information button in the sliders editor\";\n+    public static final boolean PROPERTY_INFORMATION_BUTTON_DEFAULT = true;\n+\n+\n+\n+\n+    // Default Palettes\n+\n+    private static final String PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".default.palette\";\n+\n+    public static final String PROPERTY_PALETTE_DEFAULT_SECTION_KEY = PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_SECTION_LABEL = \"Default Palettes\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_SECTION_TOOLTIP = \"Palettes to use\";\n+\n+    public static final String PROPERTY_PALETTE_DEFAULT_GRAY_SCALE_KEY = PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX + \".gray.scale\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_GRAY_SCALE_LABEL = OPTION_COLOR_GRAY_SCALE;\n+    public static final String PROPERTY_PALETTE_DEFAULT_GRAY_SCALE_TOOLTIP = \"The palette file to use when GRAY SCALE is selected\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_GRAY_SCALE_DEFAULT = PALETTE_GRAY_SCALE_DEFAULT;\n+\n+    public static final String PROPERTY_PALETTE_DEFAULT_STANDARD_KEY = PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX + \".standard\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_STANDARD_LABEL = OPTION_COLOR_STANDARD;\n+    public static final String PROPERTY_PALETTE_DEFAULT_STANDARD_TOOLTIP = \"The palette file to use when STANDARD \" + COLOR_UPPER_CASE +\" is selected\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_STANDARD_DEFAULT = PALETTE_STANDARD_DEFAULT;\n+\n+    public static final String PROPERTY_PALETTE_DEFAULT_UNIVERSAL_KEY = PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX + \".universal\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_UNIVERSAL_LABEL = OPTION_COLOR_UNIVERSAL;\n+    public static final String PROPERTY_PALETTE_DEFAULT_UNIVERSAL_TOOLTIP = \"<html>The color blind compliant palette file to use when <br>\" +\n+            \"UNIVERSAL \" + COLOR_UPPER_CASE + \" is selected</html>\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_UNIVERSAL_DEFAULT = PALETTE_UNIVERSAL_DEFAULT;\n+\n+    public static final String PROPERTY_PALETTE_DEFAULT_ANOMALIES_KEY = PROPERTY_PALETTE_DEFAULT_KEY_SUFFIX + \".anomalies\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_ANOMALIES_LABEL = OPTION_COLOR_ANOMALIES;\n+    public static final String PROPERTY_PALETTE_DEFAULT_ANOMALIES_TOOLTIP = \"The palette file to use when ANOMALIES is selected\";\n+    public static final String PROPERTY_PALETTE_DEFAULT_ANOMALIES_DEFAULT = PALETTE_ANOMALIES_DEFAULT;\n+\n+\n+    // RGB Options\n+\n+    private static final String PROPERTY_RGB_OPTIONS_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".rgb.options\";\n+\n+    public static final String PROPERTY_RGB_OPTIONS_SECTION_KEY = PROPERTY_RGB_OPTIONS_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_RGB_OPTIONS_SECTION_LABEL = \"RGB Options\";\n+    public static final String PROPERTY_RGB_OPTIONS_SECTION_TOOLTIP = \"Options for the RGB Image\";\n+\n+    public static final String PROPERTY_RGB_OPTIONS_MIN_KEY = PROPERTY_RGB_OPTIONS_KEY_SUFFIX + \".button.min\";\n+    public static final String PROPERTY_RGB_OPTIONS_MIN_LABEL = \"Range Button (Min)\";\n+    public static final String PROPERTY_RGB_OPTIONS_MIN_TOOLTIP = \"The min value to use in the RGB (A..B) range button\";\n+    public static final double PROPERTY_RGB_OPTIONS_MIN_DEFAULT = 0.0;\n+\n+    public static final String PROPERTY_RGB_OPTIONS_MAX_KEY = PROPERTY_RGB_OPTIONS_KEY_SUFFIX + \"button.min\";\n+    public static final String PROPERTY_RGB_OPTIONS_MAX_LABEL = \"Range Button (Max)\";\n+    public static final String PROPERTY_RGB_OPTIONS_MAX_TOOLTIP = \"The max value to use in the RGB (A..B) range button\";\n+    public static final double PROPERTY_RGB_OPTIONS_MAX_DEFAULT = 1.0;\n+\n+\n+\n+    // Restore to defaults\n+\n+    private static final String PROPERTY_RESTORE_KEY_SUFFIX = PROPERTY_ROOT_KEY + \".restore.defaults\";\n+\n+    public static final String PROPERTY_RESTORE_SECTION_KEY = PROPERTY_RESTORE_KEY_SUFFIX + \".section\";\n+    public static final String PROPERTY_RESTORE_SECTION_LABEL = \"Restore\";\n+    public static final String PROPERTY_RESTORE_SECTION_TOOLTIP = \"Restores preferences to the package defaults\";\n+\n+    public static final String PROPERTY_RESTORE_DEFAULTS_NAME = PROPERTY_RESTORE_KEY_SUFFIX + \".apply\";\n+    public static final String PROPERTY_RESTORE_DEFAULTS_LABEL = \"Default (\" + TOOLNAME_COLOR_MANIPULATION + \" Preferences)\";\n+    public static final String PROPERTY_RESTORE_DEFAULTS_TOOLTIP = \"Restore all \" + NamingConvention.COLOR_LOWER_CASE + \" preferences to the original default\";\n+    public static final boolean PROPERTY_RESTORE_DEFAULTS_DEFAULT = false;\n+\n+\n+\n+    public static void debug(String message) {\n+        if (COLOR_MANIPULATION_DEBUG) {\n+            System.out.println(message);\n+        }\n+    }\n+\n+}"
  },
  {
    "sha": "9fa02808410e2b1a136b83c24af4fa5210095f27",
    "filename": "snap-core/src/main/java/org/esa/snap/core/datamodel/ColorPaletteDef.java",
    "status": "modified",
    "additions": 409,
    "deletions": 20,
    "changes": 429,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorPaletteDef.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorPaletteDef.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorPaletteDef.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -19,10 +19,13 @@\n import org.esa.snap.core.util.DefaultPropertyMap;\n import org.esa.snap.core.util.Guardian;\n import org.esa.snap.core.util.PropertyMap;\n+import org.esa.snap.core.util.math.MathUtils;\n+import org.esa.snap.core.util.math.LogLinearTransform;\n+\n \n import java.awt.Color;\n-import java.io.File;\n-import java.io.IOException;\n+import java.io.*;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Vector;\n@@ -33,13 +36,28 @@\n  * <p> This special implementation of a gradation curve also provides separate color values for each of the tie points\n  * contained in the curve. This allows a better image interpretation because certain colors correspond to certain sample\n  * values even if the curve points are used to create color gradient palettes.\n+ *\n+ * @author Brockmann Consult\n+ * @author Daniel Knowles (NASA)\n+ * @author Bing Yang (NASA)\n+ * @version $Revision$ $Date$\n  */\n-public class ColorPaletteDef implements Cloneable  {\n+\n+// OCT 2019 - Knowles / Yang\n+//          - Add fields for logScaling\n+// DEC 2019 - Knowles / Yang\n+//          - Added capability to export color palette in cpt and pal formats.\n+// FEB 2020 - Knowles\n+//          - Added fields sourceFileMin and sourceFileMax to better track the original source values\n+\n+\n+public class ColorPaletteDef implements Cloneable {\n \n     private final static String _PROPERTY_KEY_NUM_POINTS = \"numPoints\";\n     private final static String _PROPERTY_KEY_COLOR = \"color\";\n     private final static String _PROPERTY_KEY_SAMPLE = \"sample\";\n     private final static String _PROPERTY_KEY_AUTODISTRIBUTE = \"autoDistribute\";\n+    private final static String _PROPERTY_KEY_IS_LOG_SCALED = \"isLogScaled\";\n \n     /**\n      * this curve's points\n@@ -48,19 +66,23 @@\n     private int numColors;\n     private boolean discrete;\n     private boolean autoDistribute;\n+    private boolean isLogScaled;\n+    private double sourceFileMin;\n+    private double sourceFileMax;\n+\n \n     public ColorPaletteDef(double minSample, double maxSample) {\n         this(new Point[]{\n-                    new Point(minSample, Color.BLACK),\n-                    new Point(maxSample, Color.WHITE)\n+                new Point(minSample, Color.BLACK),\n+                new Point(maxSample, Color.WHITE)\n         }, 256);\n     }\n \n     public ColorPaletteDef(double minSample, double centerSample, double maxSample) {\n         this(new Point[]{\n-                    new Point(minSample, Color.BLACK),\n-                    new Point(centerSample, Color.GRAY),\n-                    new Point(maxSample, Color.WHITE)\n+                new Point(minSample, Color.BLACK),\n+                new Point(centerSample, Color.GRAY),\n+                new Point(maxSample, Color.WHITE)\n         }, 256);\n     }\n \n@@ -157,7 +179,6 @@ public void insertPointAfter(int index, Point point) {\n      *\n      * @param index   the index\n      * @param scaling the scaling\n-     *\n      * @return true, if a point has been inserted\n      */\n     public boolean createPointAfter(int index, Scaling scaling) {\n@@ -184,14 +205,13 @@ public boolean createPointAfter(int index, Scaling scaling) {\n      *\n      * @param c1 1st color\n      * @param c2 2nd color\n-     *\n      * @return the center color\n      */\n     public static Color getCenterColor(Color c1, Color c2) {\n         return new Color(0.5F * (c1.getRed() + c2.getRed()) / 255.0F,\n-                         0.5F * (c1.getGreen() + c2.getGreen()) / 255.0F,\n-                         0.5F * (c1.getBlue() + c2.getBlue()) / 255.0F,\n-                         0.5F * (c1.getAlpha() + c2.getAlpha()) / 255.0F);\n+                0.5F * (c1.getGreen() + c2.getGreen()) / 255.0F,\n+                0.5F * (c1.getBlue() + c2.getBlue()) / 255.0F,\n+                0.5F * (c1.getAlpha() + c2.getAlpha()) / 255.0F);\n     }\n \n \n@@ -237,6 +257,7 @@ public final Object clone() {\n             def.numColors = numColors;\n             def.discrete = discrete;\n             def.autoDistribute = autoDistribute;\n+            def.isLogScaled = isLogScaled;\n             return def;\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n@@ -252,9 +273,7 @@ public ColorPaletteDef createDeepCopy() {\n      * Loads a color palette definition from the given file\n      *\n      * @param file the file\n-     *\n      * @return the color palette definition, never null\n-     *\n      * @throws IOException if an I/O error occurs\n      */\n     public static ColorPaletteDef loadColorPaletteDef(File file) throws IOException {\n@@ -263,48 +282,354 @@ public static ColorPaletteDef loadColorPaletteDef(File file) throws IOException\n         final int numPoints = propertyMap.getPropertyInt(_PROPERTY_KEY_NUM_POINTS);\n         if (numPoints < 2) {\n             throw new IOException(\"The selected file contains less than\\n\" +\n-                                  \"two colour points.\");\n+                    \"two colour points.\");\n         }\n-        final ColorPaletteDef.Point[] points = new ColorPaletteDef.Point[numPoints];\n+        final Point[] points = new Point[numPoints];\n         double lastSample = 0;\n         for (int i = 0; i < points.length; i++) {\n-            final ColorPaletteDef.Point point = new ColorPaletteDef.Point();\n+            final Point point = new Point();\n             final Color color = propertyMap.getPropertyColor(_PROPERTY_KEY_COLOR + i);\n             double sample = propertyMap.getPropertyDouble(_PROPERTY_KEY_SAMPLE + i);\n             if (i > 0 && sample < lastSample) {\n                 sample = lastSample + 1.0;\n             }\n             point.setColor(color);\n             point.setSample(sample);\n+            point.setLabel(file.getName());\n             points[i] = point;\n             lastSample = sample;\n         }\n         ColorPaletteDef paletteDef = new ColorPaletteDef(points, 256);\n         paletteDef.setAutoDistribute(propertyMap.getPropertyBool(_PROPERTY_KEY_AUTODISTRIBUTE, false));\n+        paletteDef.setLogScaled(propertyMap.getPropertyBool(_PROPERTY_KEY_IS_LOG_SCALED, false));\n+        paletteDef.setSourceFileMin(paletteDef.getMinDisplaySample());\n+        paletteDef.setSourceFileMax(paletteDef.getMaxDisplaySample());\n         return paletteDef;\n     }\n \n+\n+\n+\n+    /**\n+     * Loads a color palette definition from the given cpt format file\n+     *\n+     * @author Daniel Knowles\n+     * @param file cpt format file\n+     * @return the color palette definition, never null\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static ColorPaletteDef loadCpt(File file) throws IOException {\n+\n+        if (file == null) {\n+            throw new IOException(\"Null file in loadCpt\");\n+        }\n+\n+        if (!file.exists()) {\n+            throw new IOException(\"File='\" + file.getName() + \"'does not exist\");\n+        }\n+\n+        String label = file.getName();\n+        Point lastPoint = null;\n+\n+        ArrayList<Point> pointsArrayList = new ArrayList<Point>();\n+\n+        ArrayList<String> lines = readFileIntoArrayList(file);\n+\n+        for (String line : lines) {\n+            line = line.trim();\n+            if (!line.startsWith(\"#\")) {\n+                String[] values = line.split(\"\\\\s+\");\n+\n+                if (values != null && values.length == 8) {\n+                    Point firstPoint = string2Point(label, values[0], values[1], values[2], values[3]);\n+                    if (firstPoint != null) {\n+                        pointsArrayList.add(firstPoint);\n+                    }\n+                    lastPoint = string2Point(label, values[4], values[5], values[6], values[7]);\n+                }\n+            }\n+        }\n+\n+        if (lastPoint != null) {\n+            pointsArrayList.add(lastPoint);\n+        }\n+\n+        if (pointsArrayList == null || pointsArrayList.size() < 2) {\n+            throw new IOException(\"The selected file contains less than\\n\" +\n+                    \"two color points.\");\n+        }\n+\n+        final Point[] points = new Point[pointsArrayList.size()];\n+\n+        int i=0;\n+        for (Point point : pointsArrayList) {\n+            points[i] = point;\n+            i++;\n+        }\n+\n+        ColorPaletteDef paletteDef = new ColorPaletteDef(points, 256);\n+\n+        paletteDef.setAutoDistribute(false);\n+        paletteDef.setLogScaled(false);\n+        paletteDef.setSourceFileMin(paletteDef.getMinDisplaySample());\n+        paletteDef.setSourceFileMax(paletteDef.getMaxDisplaySample());\n+        return paletteDef;\n+    }\n+\n+\n+\n+\n+\n+\n+    public static Color string2Color(String redString, String greenString, String blueString) {\n+        Color color;\n+        int red, green, blue;\n+\n+        if (redString != null && redString.length() > 0 &&\n+                greenString != null && greenString.length() > 0 &&\n+                blueString != null && blueString.length() > 0) {\n+\n+            redString = redString.trim();\n+            greenString = greenString.trim();\n+            blueString = blueString.trim();\n+\n+            try {\n+                red = Integer.parseInt(redString);\n+                green = Integer.parseInt(greenString);\n+                blue = Integer.parseInt(blueString);\n+            } catch (NumberFormatException e) {\n+                return null;\n+            }\n+        } else {\n+            return null;\n+        }\n+\n+        try {\n+            color = new Color(red, green, blue);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+\n+        return color;\n+    }\n+\n+\n+    private static Point string2Point(String label, String sampleStr, String redStr, String greenStr, String blueStr) {\n+        boolean valid = true;\n+\n+        Point point = new Point();\n+\n+        double sample = 0.0;\n+        if (sampleStr != null && sampleStr.length() > 0) {\n+            sampleStr = sampleStr.trim();\n+            try {\n+                sample = Double.parseDouble(sampleStr);\n+            } catch (NumberFormatException e) {\n+                valid = false;\n+            }\n+        } else {\n+            valid = false;\n+        }\n+\n+        Color color = string2Color(redStr, greenStr, blueStr);\n+\n+        if (valid && color != null) {\n+            point = new Point();\n+            point.setColor(color);\n+            point.setSample(sample);\n+            point.setLabel(label);\n+            return point;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+\n+    public static ArrayList<String> readFileIntoArrayList(File file) throws IOException {\n+        String lineData;\n+        ArrayList<String> fileContents = new ArrayList<String>();\n+        BufferedReader moFile = null;\n+        try {\n+            moFile = new BufferedReader(new FileReader(file));\n+            while ((lineData = moFile.readLine()) != null) {\n+\n+                fileContents.add(lineData);\n+            }\n+        } catch (IOException e) {\n+            throw new IOException(\"Error reading file='\" + file.getName() + \"' in loadCpt\");\n+        } finally {\n+            try {\n+                moFile.close();\n+            } catch (Exception e) {\n+                //Ignore\n+            }\n+        }\n+        return fileContents;\n+    }\n+\n+\n     /**\n      * Stores this color palette definition in the given file\n      *\n      * @param colorPaletteDef thje color palette definition\n      * @param file            the file\n-     *\n      * @throws IOException if an I/O error occurs\n      */\n     public static void storeColorPaletteDef(ColorPaletteDef colorPaletteDef, File file) throws IOException {\n-        final ColorPaletteDef.Point[] points = colorPaletteDef.getPoints();\n+        final Point[] points = colorPaletteDef.getPoints();\n         final PropertyMap propertyMap = new DefaultPropertyMap();\n         final int numPoints = points.length;\n         propertyMap.setPropertyInt(_PROPERTY_KEY_NUM_POINTS, numPoints);\n         propertyMap.setPropertyBool(_PROPERTY_KEY_AUTODISTRIBUTE, colorPaletteDef.isAutoDistribute());\n+        propertyMap.setPropertyBool(_PROPERTY_KEY_IS_LOG_SCALED, colorPaletteDef.isLogScaled());\n         for (int i = 0; i < numPoints; i++) {\n             propertyMap.setPropertyColor(_PROPERTY_KEY_COLOR + i, points[i].getColor());\n             propertyMap.setPropertyDouble(_PROPERTY_KEY_SAMPLE + i, points[i].getSample());\n         }\n         propertyMap.store(file.toPath(), \"BEAM Colour Palette Definition File\"); /*I18N*/\n     }\n \n+    /**\n+     * Stores a 256 point generic color palette\n+     *\n+     * @param colorPaletteDef thje color palette definition\n+     * @param file            the file\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static void storePal(ColorPaletteDef colorPaletteDef, File file) throws IOException {\n+\n+        ArrayList<String> fileContents = new ArrayList<String>();\n+        String DELIMITER = \" \";\n+\n+        double min = colorPaletteDef.getMinDisplaySample();\n+        double max = colorPaletteDef.getMaxDisplaySample();\n+        double sample;\n+\n+        for (int i = 0; i < 256; i++) {\n+            double weight = i / 255.0;\n+\n+            if (colorPaletteDef.isLogScaled()) {\n+                sample = LogLinearTransform.getLogarithmicValueUsingLinearWeight(weight, min, max);\n+            } else {\n+                sample = weight * (max - min) + min;\n+            }\n+            Color color = colorPaletteDef.computeColor(sample);\n+            fileContents.add(getCptColorEntry(color, DELIMITER));\n+\n+        }\n+\n+        printStringArrayListToFile(file, \"Generic 256 Point RGB Color Palette\", fileContents);\n+    }\n+\n+    /**\n+     * Stores  color palette in cpt format\n+     *\n+     * @param colorPaletteDef the color palette definition\n+     * @param file            the file\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public static void storeCpt(ColorPaletteDef colorPaletteDef, File file) throws IOException {\n+\n+        ArrayList<String> cptFileContents = new ArrayList<String>();\n+        String DELIMITER = \" \\t\";\n+        String DELIMITER_BIG = \" \\t\\t\";\n+\n+        final Point[] points = colorPaletteDef.getPoints();\n+        final int numPoints = points.length;\n+        boolean discrete = colorPaletteDef.isDiscrete();\n+\n+\n+        int numEntries;\n+\n+        if (discrete) {\n+            numEntries = numPoints;\n+        } else {\n+            numEntries = numPoints - 1;\n+        }\n+\n+        for (int i = 0; i < numEntries; i++) {\n+            String currLine = null;\n+\n+//            this code would be used if one wanted to include values\n+            double currValue = colorPaletteDef.getPointAt(i).getSample();\n+            String currValueString = Double.toString(currValue);\n+\n+            double nextValue;\n+            String nextValueString = null;\n+\n+\n+            Color currColor = colorPaletteDef.getPointAt(i).getColor();\n+            String currColorString = getCptColorEntry(currColor, DELIMITER);\n+\n+//            String currValueString = Integer.toString(i) + \".0\";\n+//            String nextValueString = Integer.toString(i + 1) + \".0\";\n+\n+            if (discrete) {\n+                if (i == numPoints - 1) {\n+                    if ((i - 1) >= 0) {\n+                        double delta = colorPaletteDef.getPointAt(i).getSample() - colorPaletteDef.getPointAt(i - 1).getSample();\n+                        nextValue = colorPaletteDef.getPointAt(i).getSample() + delta;\n+                        nextValueString = Double.toString(nextValue);\n+                    }\n+                } else {\n+                    nextValue = colorPaletteDef.getPointAt(i + 1).getSample();\n+                    nextValueString = Double.toString(nextValue);\n+                }\n+\n+                if (nextValueString != null) {\n+                    currLine = \"  \" + currValueString + DELIMITER + currColorString + DELIMITER_BIG + nextValueString + DELIMITER + currColorString;\n+                }\n+            } else {\n+                nextValue = colorPaletteDef.getPointAt(i + 1).getSample();\n+                nextValueString = Double.toString(nextValue);\n+                Color nextColor = colorPaletteDef.getPointAt(i + 1).getColor();\n+                String nextColorString = getCptColorEntry(nextColor, DELIMITER);\n+                currLine = \"  \" + currValueString + DELIMITER + currColorString + DELIMITER_BIG + nextValueString + DELIMITER + nextColorString;\n+            }\n+\n+            if (currLine != null) {\n+                cptFileContents.add(currLine);\n+            }\n+\n+        }\n+\n+\n+        printStringArrayListToFile(file, \"CPT Format Color Palette\", cptFileContents);\n+    }\n+\n+\n+    private static String getCptColorEntry(Color color, String DELIMITER) {\n+\n+        String colorRed = Integer.toString(color.getRed());\n+        String colorGreen = Integer.toString(color.getGreen());\n+        String colorBlue = Integer.toString(color.getBlue());\n+        String colorString = colorRed + DELIMITER + colorGreen + DELIMITER + colorBlue;\n+\n+        return colorString;\n+\n+    }\n+\n+    private static void printStringArrayListToFile(File file, String header, ArrayList<String> contentsArrayList) {\n+\n+        BufferedWriter bos = null;\n+        try {\n+            bos = new BufferedWriter(new FileWriter(file));\n+\n+            bos.write(\"#\" + header);\n+            bos.newLine();\n+\n+            for (String currLine : contentsArrayList) {\n+                bos.write(currLine);\n+                bos.newLine();\n+            }\n+\n+            bos.close();\n+\n+        } catch (IOException e) {\n+            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+        }\n+    }\n+\n     private void check2PointsMinimum() {\n         if (getNumPoints() == 2) {\n             throw new IllegalStateException(\"gradation curve must at least have 2 points\");\n@@ -333,6 +658,42 @@ public void dispose() {\n         return colors;\n     }\n \n+    private Color computeColor(final double sample) {\n+        for (int i = 0; i < getNumPoints() - 1; i++) {\n+            final Point p1 = getPointAt(i);\n+            final Point p2 = getPointAt(i + 1);\n+            final double sample1 = p1.getSample();\n+            final double sample2 = p2.getSample();\n+            final Color color1 = p1.getColor();\n+            final Color color2 = p2.getColor();\n+            if (sample >= sample1 && sample <= sample2) {\n+                if (discrete) {\n+                    return color1;\n+                } else {\n+                    return computeColor(sample, sample1, sample2, color1, color2);\n+                }\n+            }\n+        }\n+        return Color.BLACK;\n+    }\n+\n+    private Color computeColor(double sample, double sample1, double sample2, Color color1, Color color2) {\n+        final double f = (sample - sample1) / (sample2 - sample1);\n+        final double r1 = color1.getRed();\n+        final double r2 = color2.getRed();\n+        final double g1 = color1.getGreen();\n+        final double g2 = color2.getGreen();\n+        final double b1 = color1.getBlue();\n+        final double b2 = color2.getBlue();\n+        final double a1 = color1.getAlpha();\n+        final double a2 = color2.getAlpha();\n+        final int red = (int) MathUtils.roundAndCrop(r1 + f * (r2 - r1), 0L, 255L);\n+        final int green = (int) MathUtils.roundAndCrop(g1 + f * (g2 - g1), 0L, 255L);\n+        final int blue = (int) MathUtils.roundAndCrop(b1 + f * (b2 - b1), 0L, 255L);\n+        final int alpha = (int) MathUtils.roundAndCrop(a1 + f * (a2 - a1), 0L, 255L);\n+        return new Color(red, green, blue, alpha);\n+    }\n+\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n@@ -347,6 +708,9 @@ public boolean equals(Object o) {\n         if (autoDistribute != that.autoDistribute) {\n             return false;\n         }\n+        if (isLogScaled != that.isLogScaled) {\n+            return false;\n+        }\n         if (discrete != that.discrete) {\n             return false;\n         }\n@@ -366,9 +730,34 @@ public int hashCode() {\n         result = 31 * result + numColors;\n         result = 31 * result + (discrete ? 1 : 0);\n         result = 31 * result + (autoDistribute ? 1 : 0);\n+        result = 31 * result + (isLogScaled ? 1 : 0);\n         return result;\n     }\n \n+    public boolean isLogScaled() {\n+        return isLogScaled;\n+    }\n+\n+    public void setLogScaled(boolean logScaled) {\n+        isLogScaled = logScaled;\n+    }\n+\n+    public double getSourceFileMin() {\n+        return sourceFileMin;\n+    }\n+\n+    public void setSourceFileMin(double sourceFileMin) {\n+        this.sourceFileMin = sourceFileMin;\n+    }\n+\n+    public double getSourceFileMax() {\n+        return sourceFileMax;\n+    }\n+\n+    public void setSourceFileMax(double sourceFileMax) {\n+        this.sourceFileMax = sourceFileMax;\n+    }\n+\n     public static class Point implements Cloneable {\n \n         private double sample;"
  },
  {
    "sha": "5ab06da4ec05a63b5f0e8dff6d64ebd478ad7f66",
    "filename": "snap-core/src/main/java/org/esa/snap/core/datamodel/ColorSchemeInfo.java",
    "status": "added",
    "additions": 210,
    "deletions": 0,
    "changes": 210,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorSchemeInfo.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorSchemeInfo.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/datamodel/ColorSchemeInfo.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -0,0 +1,210 @@\n+package org.esa.snap.core.datamodel;\n+\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+/**\n+ * Contains all info for a color scheme\n+ * @author Daniel Knowles (NASA)\n+ * @date Nov 2019\n+ *\n+ */\n+\n+public class ColorSchemeInfo {\n+    private String name;\n+    private String displayName;\n+    private String description;\n+    private String cpdFilenameStandard;\n+    private String cpdFilenameColorBlind;\n+    private String colorBarTitle;\n+    private String colorBarLabels;\n+    private double minValue;\n+    private double maxValue;\n+    private boolean isLogScaled;\n+    private boolean enabled;\n+    private boolean divider;\n+    private boolean primary;\n+    private File colorPaletteDir;\n+    private boolean duplicateEntry = false;\n+\n+    private boolean useDisplayName = true;\n+\n+\n+    public ColorSchemeInfo(String name, boolean primary, boolean divider, String displayName, String description, String cpdFilenameStandard, double minValue, double maxValue,\n+                           boolean isLogScaled, boolean enabled, String cpdFilenameColorBlind, String colorBarTitle, String colorBarLabels, File colorPaletteDir) {\n+        this.setName(name);\n+\n+        this.primary = primary;\n+        this.divider = divider;\n+        this.displayName = displayName;\n+        this.setDescription(description);\n+        this.setCpdFilenameStandard(cpdFilenameStandard);\n+        this.setMinValue(minValue);\n+        this.setMaxValue(maxValue);\n+        this.setLogScaled(isLogScaled);\n+        this.setEnabled(enabled);\n+        this.cpdFilenameColorBlind = cpdFilenameColorBlind;\n+        this.colorBarLabels = colorBarLabels;\n+        this.colorBarTitle = colorBarTitle;\n+        this.setColorPaletteDir(colorPaletteDir);\n+    }\n+\n+\n+    public boolean isDivider() {\n+        return divider;\n+    }\n+\n+    public void setUseDisplayName(boolean useDisplayName) {\n+        this.useDisplayName = useDisplayName;\n+    }\n+\n+    public boolean isUseDisplayName() {\n+        return this.useDisplayName;\n+    }\n+\n+\n+    public ColorPaletteDef getColorPaletteDef(boolean useColorBlindPalette) {\n+        File cpdFile = new File(colorPaletteDir, getCpdFilename(useColorBlindPalette));\n+        try {\n+            return ColorPaletteDef.loadColorPaletteDef(cpdFile);\n+\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+\n+    public String getCpdFilename(boolean isUseColorBlind) {\n+        if (isUseColorBlind) {\n+            return getCpdFilenameColorBlind();\n+        } else {\n+            return getCpdFilenameStandard();\n+        }\n+    }\n+\n+    public String getCpdFilenameStandard() {\n+        return cpdFilenameStandard;\n+    }\n+\n+    private void setCpdFilenameStandard(String cpdFilename) {\n+        this.cpdFilenameStandard = cpdFilename;\n+    }\n+\n+    public double getMinValue() {\n+        return minValue;\n+    }\n+\n+    private void setMinValue(double minValue) {\n+        this.minValue = minValue;\n+    }\n+\n+    public double getMaxValue() {\n+        return maxValue;\n+    }\n+\n+    private void setMaxValue(double maxValue) {\n+        this.maxValue = maxValue;\n+    }\n+\n+    public boolean isLogScaled() {\n+        return isLogScaled;\n+    }\n+\n+    private void setLogScaled(boolean isLogScaled) {\n+        this.isLogScaled = isLogScaled;\n+    }\n+\n+    public String toString() {\n+        return toString(isUseDisplayName());\n+    }\n+\n+    public String toString(boolean verbose) {\n+        if (verbose && displayName != null && displayName.length() > 0) {\n+            return displayName;\n+        } else {\n+            return getName();\n+        }\n+    }\n+\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.description = description;\n+    }\n+\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    private void setEnabled(boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+\n+\n+    public String getCpdFilenameColorBlind() {\n+        return cpdFilenameColorBlind;\n+    }\n+\n+    public void setCpdFilenameColorBlind(String cpdFilenameColorBlind) {\n+        this.cpdFilenameColorBlind = cpdFilenameColorBlind;\n+    }\n+\n+    public String getColorBarTitle() {\n+        return colorBarTitle;\n+    }\n+\n+    public void setColorBarTitle(String colorBarTitle) {\n+        this.colorBarTitle = colorBarTitle;\n+    }\n+\n+    public String getColorBarLabels() {\n+        return colorBarLabels;\n+    }\n+\n+    public void setColorBarLabels(String colorBarLabels) {\n+        this.colorBarLabels = colorBarLabels;\n+    }\n+\n+\n+    public File getColorPaletteDir() {\n+        return colorPaletteDir;\n+    }\n+\n+    public void setColorPaletteDir(File colorPaletteDir) {\n+        this.colorPaletteDir = colorPaletteDir;\n+    }\n+\n+    public boolean isDuplicateEntry() {\n+        return duplicateEntry;\n+    }\n+\n+    public void setDuplicateEntry(boolean duplicateEntry) {\n+        this.duplicateEntry = duplicateEntry;\n+    }\n+\n+    public boolean isPrimary() {\n+        return primary;\n+    }\n+\n+    public void setPrimary(boolean primary) {\n+        this.primary = primary;\n+    }\n+}"
  },
  {
    "sha": "514927a8026523e71503a47e819c8b1a19e227d1",
    "filename": "snap-core/src/main/java/org/esa/snap/core/datamodel/ImageInfo.java",
    "status": "modified",
    "additions": 147,
    "deletions": 5,
    "changes": 152,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ImageInfo.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/datamodel/ImageInfo.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/datamodel/ImageInfo.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -17,6 +17,7 @@\n \n import com.bc.ceres.core.Assert;\n import org.esa.snap.core.image.ImageManager;\n+import org.esa.snap.core.util.math.LogLinearTransform;\n \n import java.awt.Color;\n import java.awt.Transparency;\n@@ -29,8 +30,23 @@\n  * This class contains information about how a product's raster data node is displayed as an image.\n  *\n  * @author Norman Fomferra\n+ * @author Daniel Knowles (NASA)\n  * @version $Revision$ $Date$\n  */\n+// OCT 2019 - Knowles\n+//          - Added logic to transform weighted points between logarithmic scaling and\n+//            linear scaling in both directions.\n+//  NOV 2019 - Knowles\n+//           - Added logic to invert the direction of the color palette\n+//  DEC 2019 - Knowles\n+//           - Moved some of the log/liner transform methods into the class LogLinearTransform\n+// JAN 2020 - Knowles\n+//          - Added ColorSchemeInfo colorSchemeInfo to be able to set the color scheme selector in the ColorManipulation GUI\n+// FEB 2020 - Knowles\n+//          - Added ColorPaletteDef source->target transfer of the fields sourceFileMin and sourceFileMax\n+//          - When tranferring points of the ColorPaletteDef, log scaling field in image info is also updated\n+//          - Added zoomToHistLimits\n+\n public class ImageInfo implements Cloneable {\n \n     public static final Color NO_COLOR = new Color(0, 0, 0, 0);\n@@ -45,6 +61,9 @@\n     @Deprecated\n     public static final String HISTOGRAM_MATCHING_NORMALIZE = \"normalize\";\n \n+    private static final double FORCED_CHANGE_FACTOR = 0.0001;\n+\n+\n     /**\n      * Enumerates the possible histogram matching modes.\n      */\n@@ -60,6 +79,8 @@\n     private HistogramMatching histogramMatching;\n     private String uncertaintyBandName;\n     private boolean logScaled;\n+    private ColorSchemeInfo colorSchemeInfo = null;\n+    private Boolean zoomToHistLimits = null;\n \n     /**\n      * Enumerates the possible histogram matching modes.\n@@ -313,6 +334,9 @@ private static void transferPoints(ColorPaletteDef sourceCPD,\n                                        boolean autoDistribute,\n                                        ColorPaletteDef targetCPD) {\n \n+        targetCPD.setSourceFileMin(sourceCPD.getSourceFileMin());\n+        targetCPD.setSourceFileMax(sourceCPD.getSourceFileMax());\n+\n         if (autoDistribute || sourceCPD.isAutoDistribute()) {\n             alignNumPoints(sourceCPD, targetCPD);\n             double minDisplaySample = sourceCPD.getMinDisplaySample();\n@@ -331,6 +355,106 @@ private static void transferPoints(ColorPaletteDef sourceCPD,\n         }\n     }\n \n+    public void setColorPaletteDefInvert(ColorPaletteDef colorPaletteDef, double min, double max) {\n+        transferPointsInvert(colorPaletteDef, min, max, getColorPaletteDef());\n+    }\n+\n+    private static void transferPointsInvert(ColorPaletteDef sourceCPD, double min, double max, ColorPaletteDef targetCPD) {\n+\n+        targetCPD.setSourceFileMin(min);\n+        targetCPD.setSourceFileMax(max);\n+\n+        alignNumPoints(sourceCPD, targetCPD);\n+\n+\n+        Color[] targetColors = new Color[sourceCPD.getNumPoints()];\n+        for (int i = 0; i < sourceCPD.getNumPoints(); i++) {\n+            int targetPointIndex = sourceCPD.getNumPoints() - 1 - i;\n+            targetColors[i] = sourceCPD.getPointAt(targetPointIndex).getColor();\n+        }\n+\n+        for (int i = 0; i < sourceCPD.getNumPoints(); i++) {\n+            targetCPD.getPointAt(i).setLabel(sourceCPD.getPointAt(i).getLabel());\n+            targetCPD.getPointAt(i).setColor(targetColors[i]);\n+        }\n+\n+        targetCPD.setLogScaled(sourceCPD.isLogScaled());\n+        targetCPD.setDiscrete(sourceCPD.isDiscrete());\n+        targetCPD.setAutoDistribute(sourceCPD.isAutoDistribute());\n+    }\n+\n+\n+    public void setColorPaletteDef(ColorPaletteDef colorPaletteDef,\n+                                   double minSample,\n+                                   double maxSample, boolean autoDistribute, boolean isSourceLogScaled, boolean isTargetLogScaled) {\n+        setLogScaled(isTargetLogScaled);\n+        transferPoints(colorPaletteDef, minSample, maxSample, autoDistribute, getColorPaletteDef(), isSourceLogScaled, isTargetLogScaled);\n+    }\n+\n+\n+    private static void transferPoints(ColorPaletteDef sourceCPD,\n+                                       double minTargetValue,\n+                                       double maxTargetValue,\n+                                       boolean autoDistribute,\n+                                       ColorPaletteDef targetCPD,\n+                                       boolean isSourceLogScaled,\n+                                       boolean isTargetLogScaled) {\n+\n+        targetCPD.setSourceFileMin(sourceCPD.getSourceFileMin());\n+        targetCPD.setSourceFileMax(sourceCPD.getSourceFileMax());\n+\n+        if (autoDistribute || sourceCPD.isAutoDistribute()) {\n+            alignNumPoints(sourceCPD, targetCPD);\n+            double minSourceValue = sourceCPD.getMinDisplaySample();\n+            double maxSourceValue = sourceCPD.getMaxDisplaySample();\n+\n+            // The target CPD log status needs to be set here to be effective\n+            targetCPD.setLogScaled(isTargetLogScaled);\n+\n+            for (int i = 0; i < sourceCPD.getNumPoints(); i++) {\n+\n+                if (minTargetValue != maxTargetValue && minSourceValue != maxSourceValue) {\n+\n+                    double linearWeight;\n+                    if (isSourceLogScaled) {\n+                        double currentSourceLogValue = sourceCPD.getPointAt(i).getSample();\n+                        linearWeight = LogLinearTransform.getLinearWeightFromLogValue(currentSourceLogValue, minSourceValue, maxSourceValue);\n+\n+                    } else {\n+                        double currentSourceValue = sourceCPD.getPointAt(i).getSample();\n+                        linearWeight = (currentSourceValue - minSourceValue) / (maxSourceValue - minSourceValue);\n+                    }\n+\n+                    double currentLinearTargetValue = LogLinearTransform.getLinearValue(linearWeight, minTargetValue, maxTargetValue);\n+\n+                    if (isTargetLogScaled) {\n+                        double currentLogTargetValue = LogLinearTransform.getLogarithmicValue(currentLinearTargetValue, minTargetValue, maxTargetValue);\n+                        targetCPD.getPointAt(i).setSample(currentLogTargetValue);\n+                    } else {\n+                        targetCPD.getPointAt(i).setSample(currentLinearTargetValue);\n+                    }\n+\n+\n+                } else {\n+                    // cant do much here so just set all to min value and let user fix either palette or bad entry\n+                    targetCPD.getPointAt(i).setSample(minTargetValue);\n+                }\n+\n+                Color currentSourceColor = sourceCPD.getPointAt(i).getColor();\n+                targetCPD.getPointAt(i).setColor(currentSourceColor);\n+                targetCPD.getPointAt(i).setLabel(sourceCPD.getPointAt(i).getLabel());\n+            }\n+\n+        } else {\n+            targetCPD.setPoints(sourceCPD.getPoints().clone());\n+            targetCPD.setLogScaled(isTargetLogScaled);\n+        }\n+\n+    }\n+\n+\n+\n+\n     private static void alignNumPoints(ColorPaletteDef sourceCPD, ColorPaletteDef targetCPD) {\n         int deltaNumPoints = targetCPD.getNumPoints() - sourceCPD.getNumPoints();\n         if (deltaNumPoints < 0) {\n@@ -349,16 +473,34 @@ private static void alignNumPoints(ColorPaletteDef sourceCPD, ColorPaletteDef ta\n      *\n      * @param mode the histogram matching string\n      *\n-     * @return the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\".\n+     * @return the histogram matching. {@link HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\".\n      */\n-    public static ImageInfo.HistogramMatching getHistogramMatching(String mode) {\n-        ImageInfo.HistogramMatching histogramMatchingEnum = ImageInfo.HistogramMatching.None;\n+    public static HistogramMatching getHistogramMatching(String mode) {\n+        HistogramMatching histogramMatchingEnum = HistogramMatching.None;\n         if (\"Equalize\".equalsIgnoreCase(mode)) {\n-            histogramMatchingEnum = ImageInfo.HistogramMatching.Equalize;\n+            histogramMatchingEnum = HistogramMatching.Equalize;\n         } else if (\"Normalize\".equalsIgnoreCase(mode)) {\n-            histogramMatchingEnum = ImageInfo.HistogramMatching.Normalize;\n+            histogramMatchingEnum = HistogramMatching.Normalize;\n         }\n         return histogramMatchingEnum;\n     }\n \n+\n+    public ColorSchemeInfo getColorSchemeInfo() {\n+        return colorSchemeInfo;\n+    }\n+\n+    public void setColorSchemeInfo(ColorSchemeInfo colorSchemeInfo) {\n+        this.colorSchemeInfo = colorSchemeInfo;\n+    }\n+\n+\n+    public Boolean getZoomToHistLimits() {\n+        return zoomToHistLimits;\n+    }\n+\n+    public void setZoomToHistLimits(Boolean zoomToHistLimits) {\n+        this.zoomToHistLimits = zoomToHistLimits;\n+    }\n+\n }"
  },
  {
    "sha": "96bff91385082afd968692933451cd8a6634dc49",
    "filename": "snap-core/src/main/java/org/esa/snap/core/util/NamingConvention.java",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/NamingConvention.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/NamingConvention.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/util/NamingConvention.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -0,0 +1,15 @@\n+package org.esa.snap.core.util;\n+\n+/**\n+ * Stores tool names and spellings which may differ in packages which implement SNAP\n+ * @author Daniel Knowles (NASA)\n+ */\n+public class NamingConvention extends NamingConventionSnap {\n+\n+    // Uncomment the following for SeaDAS to override Snap naming convention :\n+\n+//    public static final String COLOR_UPPER_CASE = \"COLOR\";\n+//    public static final String COLOR_MIXED_CASE = \"Color\";\n+//    public static final String COLOR_LOWER_CASE = \"color\";\n+\n+}"
  },
  {
    "sha": "e36ce384c5352428f6f652eca30607c469e0575b",
    "filename": "snap-core/src/main/java/org/esa/snap/core/util/NamingConventionSnap.java",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/NamingConventionSnap.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/NamingConventionSnap.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/util/NamingConventionSnap.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -0,0 +1,12 @@\n+package org.esa.snap.core.util;\n+\n+/**\n+ * Stores tool names and spellings which may differ in packages which implement SNAP\n+ * @author Daniel Knowles (NASA)\n+ */\n+public class NamingConventionSnap {\n+\n+    public static final String COLOR_UPPER_CASE = \"COLOUR\";\n+    public static final String COLOR_MIXED_CASE = \"Colour\";\n+    public static final String COLOR_LOWER_CASE = \"colour\";\n+}"
  },
  {
    "sha": "590c048433fd7077a2eb5b10709c390459ab240e",
    "filename": "snap-core/src/main/java/org/esa/snap/core/util/ResourceInstaller.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/ResourceInstaller.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/ResourceInstaller.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/util/ResourceInstaller.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -87,6 +87,9 @@ public void install(String patternString, ProgressMonitor pm) throws IOException\n         }\n     }\n \n+\n+\n+\n     private void copyResources(Collection<Path> resources, ProgressMonitor pm) throws IOException {\n         synchronized (ResourceInstaller.class) {\n             pm.beginTask(\"Copying resources...\", resources.size());"
  },
  {
    "sha": "47456678d16079e881c080da480ae0c33f7eab52",
    "filename": "snap-core/src/main/java/org/esa/snap/core/util/math/Histogram.java",
    "status": "modified",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/math/Histogram.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/math/Histogram.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/util/math/Histogram.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -32,6 +32,9 @@\n  *\n  * @author Norman Fomferra\n  */\n+// Feb 2020 - Daniel Knowles\n+//          - Added method findRangeForPercent() to enable retrieval of any range between 0% and 100%\n+\n public class Histogram extends Range {\n \n     public static final float LEFT_AREA_SKIPPED_95 = 0.025F;\n@@ -121,6 +124,30 @@ public Range findRangeFor95Percent() {\n         return findRange(LEFT_AREA_SKIPPED_95, RIGHT_AREA_SKIPPED_95);\n     }\n \n+\n+\n+\n+    /**\n+     * Returns the value range for any threshold of 0% to 100% where the sum of all bin values are skipped from the the lower and\n+     * upper bounds of this histogram.\n+     *\n+     * @return the skipped value range, that include given percent of the sum of all bin values\n+     */\n+    public Range findRangeForPercent(double threshold) {\n+        if (threshold >0 && threshold <= 100) {\n+            double limits = (100 - threshold) / (100 * 2);\n+            return findRange(limits, limits);\n+        }\n+\n+        return null;\n+    }\n+\n+\n+\n+\n+\n+\n+\n     /**\n      * Returns the value range for the case that the given ratios of the sum of all bin values are skipped from the\n      * lower and upper bounds of this histogram."
  },
  {
    "sha": "6eed9df077142afa486280e52442f495fd3e7d63",
    "filename": "snap-core/src/main/java/org/esa/snap/core/util/math/LogLinearTransform.java",
    "status": "added",
    "additions": 174,
    "deletions": 0,
    "changes": 174,
    "blob_url": "https://github.com/senbox-org/snap-engine/blob/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/math/LogLinearTransform.java",
    "raw_url": "https://github.com/senbox-org/snap-engine/raw/41324abe7c7741f73cadbd02a2029524313ce9fe/snap-core/src/main/java/org/esa/snap/core/util/math/LogLinearTransform.java",
    "contents_url": "https://api.github.com/repos/senbox-org/snap-engine/contents/snap-core/src/main/java/org/esa/snap/core/util/math/LogLinearTransform.java?ref=41324abe7c7741f73cadbd02a2029524313ce9fe",
    "patch": "@@ -0,0 +1,174 @@\n+package org.esa.snap.core.util.math;\n+\n+/**\n+ * Math utils for transforming between log and linear.\n+ *\n+ * @author Daniel Knowles (NASA)\n+ * @version $Revision$ $Date$\n+ */\n+\n+\n+public class LogLinearTransform {\n+\n+\n+    private static final double FORCED_CHANGE_FACTOR = 0.0001;\n+\n+    public static double getLinearValueUsingLinearWeight(double linearWeight, double min, double max) {\n+\n+        // Prevent extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearWeight == 0) {\n+            return min;\n+        }\n+        if (linearWeight == 1) {\n+            return max;\n+        }\n+\n+        double deltaNormalized = (max - min);\n+        double linearValue = min + linearWeight * (deltaNormalized);\n+\n+        // Prevent UNEXPECTED interpolation/extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearWeight > 0 && linearValue < min) {\n+            return min;\n+        }\n+        if (linearWeight < 1 && linearValue > max) {\n+            return max;\n+        }\n+        if (linearWeight < 0 && linearValue >= min) {\n+            return min - (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+        if (linearWeight > 1 && linearValue <= max) {\n+            return max + (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+\n+        return linearValue;\n+    }\n+\n+    public static double getLogarithmicValueUsingLinearWeight(double weight, double min, double max) {\n+\n+        double linearValue = getLinearValueUsingLinearWeight(weight, min, max);\n+\n+        // Prevent extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearValue == min) {\n+            return min;\n+        }\n+        if (linearValue == max) {\n+            return max;\n+        }\n+\n+        double b = Math.log(max / min) / (max - min);\n+        double a = min / (Math.exp(b * min));\n+        double logValue = a * Math.exp(b * linearValue);\n+\n+        // Prevent UNEXPECTED interpolation/extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearValue > min && logValue < min) {\n+            return min;\n+        }\n+        if (linearValue < max && logValue > max) {\n+            return max;\n+        }\n+        if (linearValue < min && logValue >= min) {\n+            return min - (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+        if (linearValue > max && logValue <= max) {\n+            return max + (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+\n+        return logValue;\n+    }\n+\n+    public static double getLogarithmicValue(double linearValue, double min, double max) {\n+\n+        // Prevent extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearValue == min) {\n+            return min;\n+        }\n+        if (linearValue == max) {\n+            return max;\n+        }\n+\n+        double b = Math.log(max / min) / (max - min);\n+        double a = min / (Math.exp(b * min));\n+        double logValue = a * Math.exp(b * linearValue);\n+\n+        // Prevent UNEXPECTED interpolation/extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearValue > min && logValue < min) {\n+            return min;\n+        }\n+        if (linearValue < max && logValue > max) {\n+            return max;\n+        }\n+        if (linearValue < min && logValue >= min) {\n+            return min - (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+        if (linearValue > max && logValue <= max) {\n+            return max + (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+\n+        return logValue;\n+    }\n+\n+    public static double getLinearValue(double linearWeight, double min, double max) {\n+\n+        // Prevent extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearWeight == 0) {\n+            return min;\n+        }\n+        if (linearWeight == 1) {\n+            return max;\n+        }\n+\n+        double deltaNormalized = (max - min);\n+        double linearValue = min + linearWeight * (deltaNormalized);\n+\n+        // Prevent UNEXPECTED interpolation/extrapolation which could occur due to machine roundoffs in the calculations\n+        if (linearWeight > 0 && linearValue < min) {\n+            return min;\n+        }\n+        if (linearWeight < 1 && linearValue > max) {\n+            return max;\n+        }\n+        if (linearWeight < 0 && linearValue >= min) {\n+            return min - (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+        if (linearWeight > 1 && linearValue <= max) {\n+            return max + (max - min) * FORCED_CHANGE_FACTOR;\n+        }\n+\n+        return linearValue;\n+    }\n+\n+\n+    public static double getLinearWeightFromLogValue(double logValue, double min, double max) {\n+\n+        // Prevent extrapolation which could occur due to machine roundoffs in the calculations\n+        if (logValue == min) {\n+            return 0;\n+        }\n+        if (logValue == max) {\n+            return 1;\n+        }\n+\n+        double b = Math.log(max / min) / (max - min);\n+        double a = min / (Math.exp(b * min));\n+\n+//        double linearWeight = Math.log(logValue / a) / b;\n+//        linearWeight = (linearWeight - min) / (max - min);\n+        double linearWeight = ((Math.log(logValue / a) / b) - min) / (max - min);\n+\n+        // Prevent UNEXPECTED interpolation/extrapolation which could occur due to machine roundoffs in the calculations\n+        if (logValue > min && linearWeight < 0) {\n+            return 0;\n+        }\n+        if (logValue < max && linearWeight > 1) {\n+            return 1;\n+        }\n+        if (logValue < min && linearWeight >= 0) {\n+            return 0 - FORCED_CHANGE_FACTOR;\n+        }\n+        if (logValue > max && linearWeight <= 1) {\n+            return 1 + FORCED_CHANGE_FACTOR;\n+        }\n+\n+        return linearWeight;\n+    }\n+}"
  }
]
