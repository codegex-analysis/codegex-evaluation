[
  {
    "sha": "86f13e8f80b20af79526ae5a60a1b0a174fc9ff2",
    "filename": ".idea/codeStyles/Project.xml",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/.idea/codeStyles/Project.xml",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/.idea/codeStyles/Project.xml",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/.idea/codeStyles/Project.xml?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -18,6 +18,7 @@\n       </option>\n       <option name=\"NAME_COUNT_TO_USE_STAR_IMPORT\" value=\"50\" />\n       <option name=\"NAME_COUNT_TO_USE_STAR_IMPORT_FOR_MEMBERS\" value=\"50\" />\n+      <option name=\"ALLOW_TRAILING_COMMA\" value=\"true\" />\n     </JetCodeStyleSettings>\n     <XML>\n       <option name=\"XML_SPACE_INSIDE_EMPTY_TAG\" value=\"true\" />\n@@ -40,6 +41,7 @@\n       </indentOptions>\n     </codeStyleSettings>\n     <codeStyleSettings language=\"kotlin\">\n+      <option name=\"METHOD_PARAMETERS_WRAP\" value=\"5\" />\n       <indentOptions>\n         <option name=\"INDENT_SIZE\" value=\"2\" />\n         <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />"
  },
  {
    "sha": "e3620fa11c589196426136c4846c4b3827dd0dd1",
    "filename": "apollo-compiler/build.gradle.kts",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/build.gradle.kts",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/build.gradle.kts",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/build.gradle.kts?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -11,6 +11,7 @@ dependencies {\n   implementation(groovy.util.Eval.x(project, \"x.dep.moshi.adapters\"))\n   implementation(groovy.util.Eval.x(project, \"x.dep.moshi.moshi\"))\n   implementation(groovy.util.Eval.x(project, \"x.dep.poet.kotlin\"))\n+  implementation(groovy.util.Eval.x(project, \"x.dep.jgrapht\"))\n   implementation(project(\":apollo-api\"))\n \n   kapt(groovy.util.Eval.x(project, \"x.dep.moshi.kotlinCodegen\"))"
  },
  {
    "sha": "c15eecc6f1b79da86dd5f210de49414c7f783d8a",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/backend/ast/Ast.kt",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/backend/ast/Ast.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/backend/ast/Ast.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/backend/ast/Ast.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -17,7 +17,7 @@ internal data class CodeGenerationAst(\n     val fragmentTypes: List<FragmentType>,\n     val inputTypes: List<InputType>,\n     val enumTypes: List<EnumType>,\n-    val customScalarTypes: CustomScalarTypes\n+    val customScalarTypes: CustomScalarTypes,\n ) {\n \n   data class CustomScalarType(\n@@ -267,7 +267,7 @@ internal data class CodeGenerationAst(\n       /**\n        * Indicates if this is the reference to named fragment 'Data' type\n        */\n-      val isNamedFragmentDataRef: Boolean\n+      val isNamedFragmentDataRef: Boolean = false\n   )\n \n   companion object {"
  },
  {
    "sha": "b723d9a8ce04775c5b526fc95f4befd3eca343f4",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gql.kt",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gql.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gql.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gql.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -539,6 +539,10 @@ data class GQLInputValueDefinition(\n   }\n }\n \n+/**\n+ * A variable definition is very similar to an InputValue definition except it doesn't\n+ * have a description\n+ */\n data class GQLVariableDefinition(\n     override val sourceLocation: SourceLocation = SourceLocation.UNKNOWN,\n     val name: String,"
  },
  {
    "sha": "b455cb9ffce7e77ef3e01587bbd13122e301aa18",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gqltypedefinition.kt",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gqltypedefinition.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gqltypedefinition.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/frontend/gqltypedefinition.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -5,6 +5,10 @@ internal fun GQLTypeDefinition.sharesPossibleTypesWith(other: GQLTypeDefinition,\n   return possibleTypes(typeDefinitions).intersect(other.possibleTypes(typeDefinitions)).isNotEmpty()\n }\n \n+internal fun GQLTypeDefinition.possibleTypes(schema: Schema): Set<String> {\n+  return possibleTypes(schema.typeDefinitions)\n+}\n+\n // 5.5.2.3 Fragment spread is possible\n internal fun GQLTypeDefinition.possibleTypes(typeDefinitions: Map<String, GQLTypeDefinition>): Set<String> {\n   return when (this) {"
  },
  {
    "sha": "75ef49fb7c2997bea1754b884e42ca9419d31926",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/BooleanExpression.kt",
    "status": "added",
    "additions": 112,
    "deletions": 0,
    "changes": 112,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/BooleanExpression.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/BooleanExpression.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/BooleanExpression.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,112 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+/**\n+ * A condition.\n+ * It initially comes from @include/@skip directives but is extended to account for variables, type conditions and any combination\n+ */\n+sealed class BooleanExpression {\n+  abstract fun evaluate(variables: Set<String>, typeConditions: Set<String>): Boolean\n+\n+  /**\n+   * This is not super well defined but works well enough for our simple use cases\n+   */\n+  abstract fun simplify(): BooleanExpression\n+\n+  fun or(vararg other: BooleanExpression) = Or((other.toList() + this).toSet())\n+  fun and(vararg other: BooleanExpression) = And((other.toList() + this).toSet())\n+  fun not() = Not(this)\n+\n+  object True : BooleanExpression() {\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) = true\n+    override fun simplify() = this\n+    override fun toString() = \"true\"\n+  }\n+\n+  object False : BooleanExpression() {\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) = false\n+    override fun simplify() = this\n+    override fun toString() = \"false\"\n+  }\n+\n+  data class Not(val booleanExpression: BooleanExpression): BooleanExpression() {\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) = !booleanExpression.evaluate(variables, typeConditions)\n+    override fun simplify() = when(this.booleanExpression) {\n+      is True -> False\n+      is False -> True\n+      else -> this\n+    }\n+    override fun toString() = \"!$booleanExpression\"\n+  }\n+\n+  data class Or(val booleanExpressions: Set<BooleanExpression>) : BooleanExpression() {\n+    init {\n+      check(booleanExpressions.isNotEmpty()) {\n+        \"ApolloGraphQL: cannot create a 'Or' condition from an empty list\"\n+      }\n+    }\n+\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) =\n+        booleanExpressions.firstOrNull { it.evaluate(variables, typeConditions) } != null\n+\n+    override fun simplify() = booleanExpressions.filter {\n+      it != False\n+    }.map { it.simplify() }\n+        .let {\n+          when {\n+            it.contains(True) -> True\n+            it.isEmpty() -> False\n+            it.size == 1 -> it.first()\n+            else -> {\n+              Or(it.toSet())\n+            }\n+          }\n+        }\n+\n+    override fun toString() = booleanExpressions.joinToString(\" | \")\n+  }\n+\n+  data class And(val booleanExpressions: Set<BooleanExpression>) : BooleanExpression() {\n+    init {\n+      check(booleanExpressions.isNotEmpty()) {\n+        \"ApolloGraphQL: cannot create a 'And' condition from an empty list\"\n+      }\n+    }\n+\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) =\n+        booleanExpressions.firstOrNull { !it.evaluate(variables, typeConditions) } == null\n+\n+    override fun simplify() = booleanExpressions.filter {\n+      it != True\n+    }.map { it.simplify() }\n+        .let {\n+          when {\n+            it.contains(False) -> False\n+            it.isEmpty() -> True\n+            it.size == 1 -> it.first()\n+            else -> {\n+              And(it.toSet())\n+            }\n+          }\n+        }\n+    override fun toString() = booleanExpressions.joinToString(\" & \")\n+  }\n+\n+\n+  data class Variable(\n+      val name: String,\n+  ) : BooleanExpression() {\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) = variables.contains(name)\n+    override fun simplify() = this\n+    override fun toString() = \"Var($name)\"\n+  }\n+\n+  data class Type(\n+      val name: String,\n+  ) : BooleanExpression() {\n+    override fun evaluate(variables: Set<String>, typeConditions: Set<String>) = typeConditions.contains(name)\n+\n+    override fun simplify() = this\n+\n+    override fun toString() = \"Type($name)\"\n+  }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "e23041d1cd07f8719cc3c5aad3c07c21f810c2e2",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Collections.kt",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Collections.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Collections.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Collections.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,61 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+import java.math.BigInteger\n+import kotlin.sequences.toList\n+\n+/**\n+ * Helper function to compute the intersection of multiple Sets\n+ */\n+internal fun <T> Collection<Set<T>>.intersection(): Set<T> {\n+  if (isEmpty()) {\n+    return emptySet()\n+  }\n+\n+  return drop(1).fold(first()) { acc, list ->\n+    acc.intersect(list)\n+  }\n+}\n+\n+/**\n+ * Helper function to compute the intersection of multiple Sets\n+ */\n+internal fun <T> Collection<Set<T>>.union(): Set<T> {\n+  return fold(emptySet()) { acc, list ->\n+    acc.union(list)\n+  }\n+}\n+\n+internal fun <T> Collection<T>.pairs(): List<Pair<T, T>> {\n+  val result = mutableListOf<Pair<T, T>>()\n+  val asList = toList()\n+  for (i in 0.until(size)) {\n+    for (j in (i + 1).until(size)) {\n+      result.add(asList[i] to asList[j])\n+    }\n+  }\n+  return result\n+}\n+\n+/**\n+ * For a list of items, returns all possible combinations as in https://en.wikipedia.org/wiki/Combination\n+ *\n+ * Not an extension function so as not to pollute the List<T> namespace\n+ */\n+internal fun <T> combinations(list: List<T>, includeEmpty: Boolean = false): List<List<T>> {\n+  return list.run {\n+    val start = if (includeEmpty) 0 else 1\n+    val end = BigInteger.valueOf(2).pow(size).intValueExact()\n+\n+    start.until(end).fold(emptyList()) { acc, bitmask ->\n+      acc + listOf(\n+          0.until(size).mapNotNull { position ->\n+            if (bitmask.and(1.shl(position)) != 0) {\n+              get(position)\n+            } else {\n+              null\n+            }\n+          }\n+      )\n+    }\n+  }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "7b3e229136bd0df695193368c4eaea82a62ec1c3",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/FieldSetBuilder.kt",
    "status": "added",
    "additions": 257,
    "deletions": 0,
    "changes": 257,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/FieldSetBuilder.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/FieldSetBuilder.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/FieldSetBuilder.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,257 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+import com.apollographql.apollo3.compiler.frontend.GQLArgument\n+import com.apollographql.apollo3.compiler.frontend.GQLField\n+import com.apollographql.apollo3.compiler.frontend.GQLFieldDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLFragmentDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLFragmentSpread\n+import com.apollographql.apollo3.compiler.frontend.GQLInlineFragment\n+import com.apollographql.apollo3.compiler.frontend.GQLSelection\n+import com.apollographql.apollo3.compiler.frontend.GQLSelectionSet\n+import com.apollographql.apollo3.compiler.frontend.GQLType\n+import com.apollographql.apollo3.compiler.frontend.Schema\n+import com.apollographql.apollo3.compiler.frontend.coerce\n+import com.apollographql.apollo3.compiler.frontend.definitionFromScope\n+import com.apollographql.apollo3.compiler.frontend.findDeprecationReason\n+import com.apollographql.apollo3.compiler.frontend.possibleTypes\n+\n+\n+/**\n+ * For a \"base\" selectionSet (either query, named fragment or field), collect all the typeConditions\n+ * Then for each combination of typeConditions, collect all the fields recursively\n+ */\n+class FieldSetsBuilder(\n+    val schema: Schema,\n+    val allGQLFragmentDefinitions: Map<String, GQLFragmentDefinition>,\n+    val baseSelectionSet: GQLSelectionSet,\n+    val baseTypeCondition: String,\n+    val toIrType: GQLType.() -> IrType\n+) {\n+  class Result(\n+      val fieldSets: List<IrFieldSet>,\n+      val usedNamedFragments: Set<String>,\n+  )\n+\n+  private var usedNamedFragments = mutableListOf<String>()\n+\n+  /**\n+   * Return a list of set of type conditions.\n+   *\n+   * Each individual set matches a path for which we need to potentially generate a model\n+   *\n+   * {# Base type A\n+   *   ... on B {\n+   *     ... on C {\n+   *   }\n+   *   ... on B {\n+   *     ... on D {\n+   *   }\n+   * }\n+   *\n+   * Will return:\n+   * [\n+   *   [A]\n+   *   [A,B]\n+   *   [A,B,C]\n+   *   [A,B,D]\n+   * ]\n+   */\n+  private fun List<GQLSelection>.collectTypeConditions(path: Set<String>): List<Set<String>> {\n+    return listOf(path) + flatMap {\n+      when (it) {\n+        is GQLField -> emptyList()\n+        is GQLInlineFragment -> it.selectionSet.selections.collectTypeConditions(path + it.typeCondition.name)\n+        is GQLFragmentSpread -> {\n+          val fragmentDefinition = allGQLFragmentDefinitions[it.name]!!\n+          usedNamedFragments.add(it.name)\n+          fragmentDefinition.selectionSet.selections.collectTypeConditions(path + fragmentDefinition.typeCondition.name)\n+        }\n+      }\n+    }\n+  }\n+\n+  fun build(): Result {\n+    return Result(\n+        fieldSets = TypedSelectionSet(baseSelectionSet.selections, baseTypeCondition).toIrFieldSets(),\n+        usedNamedFragments = usedNamedFragments.toSet(),\n+    )\n+  }\n+\n+  private fun TypedSelectionSet.toIrFieldSets(): List<IrFieldSet> {\n+    val interfacesTypeSets = selections.collectTypeConditions(setOf(selectionSetTypeCondition)).toSet()\n+\n+    val shapeTypeSetToPossibleTypes = computeShapes(schema, interfacesTypeSets.union())\n+\n+    val shapesTypeSets = shapeTypeSetToPossibleTypes.keys\n+\n+    /**\n+     * build the relations of shape to their interfaceTypeSets\n+     *\n+     * By construction, shapes do not inherit each other\n+     */\n+    var shapeToFragmentEdges = interfacesTypeSets.flatMap { interfaceTypeSet ->\n+      shapesTypeSets.filter { shapeTypeSet ->\n+        shapeTypeSet.implements(interfaceTypeSet)\n+      }.map { shapesTypeSet ->\n+        Edge(\n+            source = ShapeNode(shapesTypeSet),\n+            target = InterfaceNode(interfaceTypeSet)\n+        )\n+      }\n+    }\n+\n+    /**\n+     * Prune interfaceTypeSets that are only implemented by one shape or less, we won't need those\n+     */\n+    val interfaceTypeSetsToGenerate = shapeToFragmentEdges.groupBy(\n+        keySelector = { it.target },\n+        valueTransform = { it.source }\n+    ).filter {\n+      it.value.size > 1\n+    }.keys\n+\n+    shapeToFragmentEdges = shapeToFragmentEdges.filter {\n+      interfaceTypeSetsToGenerate.contains(it.target)\n+    }\n+\n+    /**\n+     * build the internal relations of the different interfaceTypeSets\n+     */\n+    val fragmentToFragmentEdges = interfacesTypeSets.pairs().mapNotNull {\n+      when {\n+        it.first.implements(it.second) -> Edge(InterfaceNode(it.first), InterfaceNode(it.second))\n+        it.second.implements(it.first) -> Edge(InterfaceNode(it.second), InterfaceNode(it.first))\n+        else -> {\n+          null\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Try to simplify inheritance relations\n+     */\n+    val edges = transitiveReduce(shapeToFragmentEdges + fragmentToFragmentEdges)\n+\n+    edges.flatMap { listOf(it.source, it.target) }.distinct().forEach {\n+      toIrFieldSet(\n+          typeSet = it.typeSet,\n+          possibleTypes = (it as? ShapeNode)?.typeSet?.let { shapeTypeSetToPossibleTypes[it] } ?: emptySet(),\n+          implements = edges.filter { edge -> edge.source == it }.map { it.target.typeSet }.toSet()\n+      )\n+    }\n+    return emptyList()\n+  }\n+  \n+  /**\n+   * An intermediate class used during collection\n+   */\n+  private class CollectedField(\n+      /**\n+       * All fields with the same response name should have the same infos here\n+       */\n+      val name: String,\n+      val alias: String?,\n+      val arguments: List<IrArgument>,\n+\n+      val description: String?,\n+      val type: IrType,\n+      val deprecationReason: String?,\n+\n+      /**\n+       * Merged field will merge their conditions and selectionSets\n+       */\n+      val condition: BooleanExpression,\n+      val selections: List<GQLSelection>,\n+  ) {\n+    val responseName = alias ?: name\n+  }\n+\n+  private class TypedSelectionSet(val selections: List<GQLSelection>, val selectionSetTypeCondition: String)\n+\n+  private fun TypedSelectionSet.collectFields(typeConditions: TypeSet): List<CollectedField> {\n+    if (!typeConditions.contains(selectionSetTypeCondition)) {\n+      return emptyList()\n+    }\n+    val typeDefinition = schema.typeDefinition(selectionSetTypeCondition)\n+\n+    return selections.flatMap {\n+      when (it) {\n+        is GQLField -> {\n+          val fieldDefinition = it.definitionFromScope(schema, typeDefinition)!!\n+          listOf(\n+              CollectedField(\n+                  name = it.name,\n+                  alias = it.alias,\n+                  arguments = it.arguments?.arguments?.map { it.toIr(fieldDefinition) } ?: emptyList(),\n+                  condition = it.directives.toBooleanExpression(),\n+                  selections = it.selectionSet?.selections ?: emptyList(),\n+                  type = fieldDefinition.type.toIrType(),\n+                  description = fieldDefinition.description,\n+                  deprecationReason = fieldDefinition.directives.findDeprecationReason(),\n+              )\n+          )\n+        }\n+        is GQLInlineFragment -> {\n+          TypedSelectionSet(it.selectionSet.selections, it.typeCondition.name).collectFields(typeConditions)\n+        }\n+        is GQLFragmentSpread -> {\n+          val fragment = allGQLFragmentDefinitions[it.name]!!\n+          TypedSelectionSet(fragment.selectionSet.selections, fragment.typeCondition.name).collectFields(typeConditions)\n+        }\n+      }\n+    }\n+  }\n+\n+  private fun GQLArgument.toIr(fieldDefinition: GQLFieldDefinition): IrArgument {\n+    val argumentDefinition = fieldDefinition.arguments.first { it.name == name }\n+\n+    return IrArgument(\n+        name = name,\n+        value = value.coerce(argumentDefinition.type, schema).orThrow().toIr(),\n+        defaultValue = argumentDefinition.defaultValue?.coerce(argumentDefinition.type, schema)?.orThrow()?.toIr(),\n+        type = argumentDefinition.type.toIrType()\n+    )\n+  }\n+\n+  private fun TypedSelectionSet.toIrFieldSet(typeSet: TypeSet, possibleTypes: PossibleTypes, implements: Set<TypeSet>): IrFieldSet {\n+    val collectedFields = collectFields(typeSet)\n+\n+    val fields = collectedFields.groupBy {\n+      it.responseName\n+    }.values.map { fieldsWithSameResponseName ->\n+      /**\n+       * Sanity checks, might be removed as this should be done during validation\n+       */\n+      check(fieldsWithSameResponseName.map { it.alias }.distinct().size == 1)\n+      check(fieldsWithSameResponseName.map { it.name }.distinct().size == 1)\n+      check(fieldsWithSameResponseName.map { it.arguments }.distinct().size == 1)\n+      check(fieldsWithSameResponseName.map { it.description }.distinct().size == 1)\n+      check(fieldsWithSameResponseName.map { it.deprecationReason }.distinct().size == 1)\n+      check(fieldsWithSameResponseName.map { it.type }.distinct().size == 1)\n+\n+      val first = fieldsWithSameResponseName.first()\n+      val selections = fieldsWithSameResponseName.flatMap { it.selections }\n+\n+      val fieldSets = TypedSelectionSet(selections, first.type.leafName).toIrFieldSets()\n+      IrField(\n+          alias = first.alias,\n+          name = first.name,\n+          arguments = first.arguments,\n+          description = first.description,\n+          deprecationReason = first.deprecationReason,\n+          type = first.type,\n+\n+          condition = BooleanExpression.Or(fieldsWithSameResponseName.map { it.condition }.toSet()),\n+          fieldSets = fieldSets\n+      )\n+    }\n+    return IrFieldSet(\n+        typeSet = typeSet.toSet(),\n+        possibleTypes = possibleTypes,\n+        implements = implements,\n+        fields = fields\n+    )\n+  }\n+\n+\n+}"
  },
  {
    "sha": "0c99e4a381e98603447a9aa78641ee659952abfd",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Ir.kt",
    "status": "added",
    "additions": 202,
    "deletions": 0,
    "changes": 202,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Ir.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Ir.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/Ir.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,202 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+/*\n+* Unified IR. This builds all the possible field trees. As polymorphic fields are used, this can become\n+* quite large and will be pruned in a later step\n+* - moves @include/@skip directives on inline fragments and object fields to their children selections\n+* - interprets @deprecated directives\n+* - coerce argument values and resolves defaultValue\n+* - infers fragment variables\n+* - more generally removes all references to the GraphQL AST and \"embeds\" type definitions/field definitions\n+*/\n+data class IntermediateRepresentation(\n+    val operations: List<IrOperation>,\n+    val namedFragments: List<IrNamedFragment>,\n+    val inputObjects: List<IrInputObject>,\n+    val enums: List<IrEnum>,\n+    val customScalars: List<IrCustomScalar>\n+)\n+\n+data class IrEnum(\n+    val name: String,\n+    val description: String?,\n+    val values: List<IrEnumValue>,\n+\n+    )\n+\n+data class IrEnumValue(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?\n+)\n+\n+/**\n+ * An input field\n+ *\n+ * Note: [IrInputField], [IrArgument] and [IrVariable] are all very similar since they all share\n+ * the [com.apollographql.apollo3.compiler.frontend.GQLInputValueDefinition] type but they have\n+ * also differences:\n+ * - [IrArgument] also has a value in addition to the type definition\n+ * - [IrVariable] doesn't have a description\n+ */\n+data class IrInputField(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?,\n+    val type: IrType,\n+    val defaultValue: IrValue?\n+)\n+\n+/**\n+ * @param sourceWithFragments the executableDocument\n+ * @param filePath the path relative to the source roots\n+ */\n+data class IrOperation(\n+    val name: String,\n+    val operationType: IrOperationType,\n+    val typeCondition: String,\n+    val variables: List<IrVariable>,\n+    val description: String?,\n+    val dataField: IrField,\n+    val sourceWithFragments: String,\n+    val filePath: String\n+)\n+\n+data class IrNamedFragment(\n+    val name: String,\n+    val description: String?,\n+    val filePath: String,\n+    val dataField: IrField,\n+    /**\n+     * Fragments do not have variables per-se but we can infer them from the document\n+     * Default values will always be null for those\n+     */\n+    val variables: List<IrVariable>,\n+    val typeCondition: String,\n+)\n+\n+enum class IrOperationType {\n+  Query,\n+  Mutation,\n+  Subscription\n+}\n+\n+data class IrField(\n+    val name: String,\n+    val alias: String?,\n+    val arguments: List<IrArgument>,\n+\n+    // from the fieldDefinition\n+    val description: String?,\n+    // from the fieldDefinition\n+    val type: IrType,\n+    // from the fieldDefinition directives\n+    val deprecationReason: String?,\n+\n+    val condition: BooleanExpression,\n+    // empty for a scalar field\n+    val fieldSets: List<IrFieldSet>,\n+) {\n+  val responseName = alias ?: name\n+}\n+\n+/**\n+ * @param possibleTypes: the possibleTypes that will map to this [IrFieldSet]. If it is empty,\n+ */\n+data class IrFieldSet(\n+    val typeSet: Set<String>,\n+    val possibleTypes: Set<String>,\n+    val fields: List<IrField>,\n+    val implements: Set<TypeSet>,\n+)\n+\n+data class IrInputObject(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?,\n+    val fields: List<IrInputField>\n+)\n+\n+data class IrCustomScalar(\n+    val name: String,\n+)\n+\n+/**\n+ * See also [IrInputField]\n+ */\n+data class IrVariable(\n+    val name: String,\n+    val defaultValue: IrValue?,\n+    val type: IrType\n+    )\n+\n+data class IrArgument(\n+    val name: String,\n+    /**\n+     * the GQLValue coerced so that for an example, Ints used in Float positions are correctly transformed\n+     */\n+    val value: IrValue,\n+    /**\n+     * The defaultValue from the GQLArgumentDefinition, coerced\n+     */\n+    val defaultValue: IrValue?,\n+    val type: IrType\n+)\n+\n+sealed class IrValue\n+\n+data class IntIrValue(val value: Int) : IrValue()\n+data class FloatIrValue(val value: Double) : IrValue()\n+data class StringIrValue(val value: String) : IrValue()\n+data class BooleanIrValue(val value: Boolean) : IrValue()\n+data class EnumIrValue(val value: String) : IrValue()\n+object NullIrValue : IrValue()\n+data class ObjectIrValue(val fields: List<Field>) : IrValue() {\n+  data class Field(val name: String, val value: IrValue)\n+}\n+\n+data class ListIrValue(val values: List<IrValue>) : IrValue()\n+data class VariableIrValue(val name: String) : IrValue()\n+\n+sealed class IrType {\n+  abstract val leafName: String\n+}\n+\n+data class NonNullIrType(val ofType: IrType) : IrType() {\n+  override val leafName = ofType.leafName\n+}\n+\n+data class ListIrType(val ofType: IrType) : IrType() {\n+  override val leafName = ofType.leafName\n+}\n+\n+sealed class NamedIrType(val name: String) : IrType() {\n+  override val leafName = name\n+\n+  override fun hashCode(): Int {\n+    return name.hashCode()\n+  }\n+\n+  /**\n+   * Ideally we would have data classes here but having `name` as a base property is useful\n+   * Revisit with sealed interfaces\n+   */\n+  override fun equals(other: Any?): Boolean {\n+    if (other !is NamedIrType) {\n+      return false\n+    }\n+    return name == other.name\n+  }\n+}\n+\n+object StringIrType : NamedIrType(\"String\")\n+object IntIrType : NamedIrType(\"Int\")\n+object FloatIrType : NamedIrType(\"Float\")\n+object BooleanIrType : NamedIrType(\"Boolean\")\n+object IdIrType : NamedIrType(\"ID\")\n+class CustomScalarIrType(name: String) : NamedIrType(name)\n+class EnumIrType(name: String) : NamedIrType(name)\n+class UnionIrType(name: String) : NamedIrType(name)\n+class ObjectIrType(name: String) : NamedIrType(name)\n+class InputObjectIrType(name: String) : NamedIrType(name)\n+class InterfaceIrType(name: String) : NamedIrType(name)"
  },
  {
    "sha": "93c293c78d57a0d95b749d4e0220b8af4346c3b3",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/IrBuilder.kt",
    "status": "added",
    "additions": 312,
    "deletions": 0,
    "changes": 312,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/IrBuilder.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/IrBuilder.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/IrBuilder.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,312 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+import com.apollographql.apollo3.compiler.frontend.GQLBooleanValue\n+import com.apollographql.apollo3.compiler.frontend.GQLDirective\n+import com.apollographql.apollo3.compiler.frontend.GQLEnumTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLEnumValue\n+import com.apollographql.apollo3.compiler.frontend.GQLEnumValueDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLFloatValue\n+import com.apollographql.apollo3.compiler.frontend.GQLFragmentDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLInputObjectTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLInputValueDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLIntValue\n+import com.apollographql.apollo3.compiler.frontend.GQLInterfaceTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLListType\n+import com.apollographql.apollo3.compiler.frontend.GQLListValue\n+import com.apollographql.apollo3.compiler.frontend.GQLNamedType\n+import com.apollographql.apollo3.compiler.frontend.GQLNonNullType\n+import com.apollographql.apollo3.compiler.frontend.GQLNullValue\n+import com.apollographql.apollo3.compiler.frontend.GQLObjectTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLObjectValue\n+import com.apollographql.apollo3.compiler.frontend.GQLOperationDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLScalarTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLSelectionSet\n+import com.apollographql.apollo3.compiler.frontend.GQLStringValue\n+import com.apollographql.apollo3.compiler.frontend.GQLType\n+import com.apollographql.apollo3.compiler.frontend.GQLUnionTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLValue\n+import com.apollographql.apollo3.compiler.frontend.GQLVariableDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLVariableValue\n+import com.apollographql.apollo3.compiler.frontend.InputValueScope\n+import com.apollographql.apollo3.compiler.frontend.Schema\n+import com.apollographql.apollo3.compiler.frontend.coerce\n+import com.apollographql.apollo3.compiler.frontend.findDeprecationReason\n+import com.apollographql.apollo3.compiler.frontend.inferVariables\n+import com.apollographql.apollo3.compiler.frontend.rootTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.toUtf8\n+import com.apollographql.apollo3.compiler.frontend.toUtf8WithIndents\n+\n+class IrBuilder(\n+    private val schema: Schema,\n+    private val operationDefinitions: List<GQLOperationDefinition>,\n+    private val fragmentDefinitions: List<GQLFragmentDefinition>,\n+    metadataFragmentDefinitions: List<GQLFragmentDefinition>,\n+    private val alwaysGenerateTypesMatching: Set<String>\n+) {\n+  private val allGQLFragmentDefinitions = (metadataFragmentDefinitions + fragmentDefinitions).associateBy { it.name }\n+  private var usedEnums = mutableSetOf<String>()\n+  private var usedInputObjects = mutableSetOf<String>()\n+  private var usedCustomScalars = mutableSetOf<String>()\n+\n+  private fun shouldAlwaysGenerate(name: String) = alwaysGenerateTypesMatching.map { Regex(it) }.any { it.matches(name) }\n+\n+  fun build(): IntermediateRepresentation {\n+    val operations = operationDefinitions.map { it.toIr() }\n+    val namedFragments = fragmentDefinitions.map { it.toIr() }\n+\n+    val enums = schema.typeDefinitions.values\n+        .filterIsInstance<GQLEnumTypeDefinition>()\n+        .filter { usedEnums.contains(it.name) || shouldAlwaysGenerate(it.name) }\n+        .map { it.toIr() }\n+\n+    val inputObjects = schema.typeDefinitions.values\n+        .filterIsInstance<GQLInputObjectTypeDefinition>()\n+        .filter { usedInputObjects.contains(it.name) || shouldAlwaysGenerate(it.name) }\n+        .map { it.toIr() }\n+\n+    val customScalars = schema.typeDefinitions.values\n+        .filterIsInstance<GQLScalarTypeDefinition>()\n+        .filter { !it.isBuiltIn() }\n+        .filter { usedCustomScalars.contains(it.name) || shouldAlwaysGenerate(it.name) }\n+        .map { it.toIr() }\n+\n+    return IntermediateRepresentation(\n+        operations = operations,\n+        namedFragments = namedFragments,\n+        inputObjects = inputObjects,\n+        enums = enums,\n+        customScalars = customScalars\n+    )\n+  }\n+\n+  private fun GQLScalarTypeDefinition.toIr(): IrCustomScalar {\n+    return IrCustomScalar(name = name)\n+  }\n+\n+  private fun GQLInputObjectTypeDefinition.toIr(): IrInputObject {\n+    return IrInputObject(\n+        name = name,\n+        description = description,\n+        deprecationReason = directives.findDeprecationReason(),\n+        fields = inputFields.map { it.toIrInputField() }\n+    )\n+  }\n+\n+  /**\n+   * This is not named `toIr` as [GQLInputValueDefinition] also maps to variables and arguments\n+   */\n+  private fun GQLInputValueDefinition.toIrInputField(): IrInputField {\n+    val coercedDefaultValue = defaultValue?.coerce(type, schema)?.orThrow()\n+\n+    return IrInputField(\n+        name = name,\n+        description = description,\n+        deprecationReason = directives.findDeprecationReason(),\n+        type = type.toIr(),\n+        defaultValue = coercedDefaultValue?.toIr()\n+    )\n+  }\n+\n+  private fun GQLEnumTypeDefinition.toIr(): IrEnum {\n+    return IrEnum(\n+        name = name,\n+        description = description,\n+        values = enumValues.map { it.toIr() }\n+    )\n+  }\n+\n+  private fun GQLEnumValueDefinition.toIr(): IrEnumValue {\n+    return IrEnumValue(\n+        name = name,\n+        description = description,\n+        deprecationReason = directives.findDeprecationReason()\n+    )\n+  }\n+\n+  private fun GQLOperationDefinition.toIr(): IrOperation {\n+    val typeDefinition = this.rootTypeDefinition(schema)\n+        ?: throw IllegalStateException(\"ApolloGraphql: cannot find root type for '$operationType'\")\n+\n+    val dataFieldResult = createDataField(selectionSet, typeDefinition.name)\n+\n+    val sourceWithFragments = (toUtf8WithIndents() + \"\\n\" + dataFieldResult.usedNamedFragments.joinToString(\n+        separator = \"\\n\"\n+    ) { fragmentName ->\n+      allGQLFragmentDefinitions[fragmentName]!!.toUtf8WithIndents()\n+    }).trimEnd('\\n')\n+\n+    return IrOperation(\n+        name = name ?: throw IllegalStateException(\"Apollo doesn't support anonymous operation.\"),\n+        description = description,\n+        operationType = IrOperationType.valueOf(operationType.capitalize()),\n+        typeCondition = typeDefinition.name,\n+        variables = variableDefinitions.map { it.toIr() },\n+        dataField = dataFieldResult.field,\n+        sourceWithFragments = sourceWithFragments,\n+        filePath = sourceLocation.filePath!!\n+    )\n+  }\n+\n+  private fun GQLFragmentDefinition.toIr(): IrNamedFragment {\n+    val typeDefinition = schema.typeDefinition(typeCondition.name)\n+\n+    val dataFieldResult = createDataField(selectionSet, typeDefinition.name)\n+\n+    val variableDefinitions = inferVariables(schema, allGQLFragmentDefinitions)\n+\n+    return IrNamedFragment(\n+        name = name,\n+        description = description,\n+        filePath = sourceLocation.filePath!!,\n+        typeCondition = typeDefinition.name,\n+        variables = variableDefinitions.map { it.toIr() },\n+        dataField = dataFieldResult.field,\n+    )\n+  }\n+\n+  class DataFieldResult(\n+      val field: IrField,\n+      val usedNamedFragments: Set<String>,\n+  )\n+\n+  private fun createDataField(selectionSet: GQLSelectionSet, typeCondition: String): DataFieldResult {\n+    val builder = FieldSetsBuilder(schema, allGQLFragmentDefinitions, selectionSet, typeCondition) {\n+      toIr()\n+    }\n+\n+    val result = builder.build()\n+\n+\n+    val field = IrField(\n+        name = \"data\",\n+        alias = null,\n+        deprecationReason = null,\n+        arguments = emptyList(),\n+        type = ObjectIrType(typeCondition),\n+        condition = BooleanExpression.True,\n+        description = \"Synthetic data field\",\n+        fieldSets = result.fieldSets,\n+    )\n+\n+    return DataFieldResult(field, result.usedNamedFragments)\n+  }\n+\n+  private fun InputValueScope.VariableReference.toIr(): IrVariable {\n+    return IrVariable(\n+        name = this.variable.name,\n+        defaultValue = null,\n+        type = expectedType.toIr(),\n+    )\n+  }\n+\n+  private fun GQLVariableDefinition.toIr(): IrVariable {\n+    val coercedDefaultValue = defaultValue?.coerce(type, schema)?.orThrow()\n+\n+    return IrVariable(\n+        name = name,\n+        defaultValue = coercedDefaultValue?.toIr(),\n+        type = type.toIr(),\n+    )\n+  }\n+\n+\n+  private fun GQLType.toIr(): IrType {\n+    return when (this) {\n+      is GQLNonNullType -> NonNullIrType(ofType = type.toIr())\n+      is GQLListType -> ListIrType(ofType = type.toIr())\n+      is GQLNamedType -> when (schema.typeDefinition(name)) {\n+        is GQLScalarTypeDefinition -> {\n+          when (name) {\n+            \"String\" -> StringIrType\n+            \"Boolean\" -> BooleanIrType\n+            \"Int\" -> IntIrType\n+            \"Float\" -> FloatIrType\n+            \"ID\" -> IdIrType\n+            else -> {\n+              usedCustomScalars.add(name)\n+              CustomScalarIrType(name)\n+            }\n+          }\n+        }\n+        is GQLEnumTypeDefinition -> {\n+          usedEnums.add(name)\n+          EnumIrType(name)\n+        }\n+        is GQLObjectTypeDefinition -> ObjectIrType(name)\n+        is GQLInterfaceTypeDefinition -> InterfaceIrType(name)\n+        is GQLUnionTypeDefinition -> UnionIrType(name)\n+        is GQLInputObjectTypeDefinition -> {\n+          usedInputObjects.add(name)\n+          InputObjectIrType(name)\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+internal fun GQLValue.toIr(): IrValue {\n+  return when (this) {\n+    is GQLIntValue -> IntIrValue(value = value)\n+    is GQLStringValue -> StringIrValue(value = value)\n+    is GQLFloatValue -> FloatIrValue(value = value)\n+    is GQLBooleanValue -> BooleanIrValue(value = value)\n+    is GQLEnumValue -> EnumIrValue(value = value)\n+    is GQLNullValue -> NullIrValue\n+    is GQLVariableValue -> VariableIrValue(name = name)\n+    is GQLListValue -> ListIrValue(values = values.map { it.toIr() })\n+    is GQLObjectValue -> ObjectIrValue(\n+        fields = fields.map {\n+          ObjectIrValue.Field(name = it.name, value = it.value.toIr())\n+        }\n+    )\n+  }\n+}\n+\n+/**\n+ * This is guaranteed to return one of:\n+ * - True\n+ * - False\n+ * - (!)Variable\n+ * - (!)Variable & (!)Variable\n+ *\n+ */\n+internal fun List<GQLDirective>.toBooleanExpression(): BooleanExpression {\n+  val conditions = mapNotNull {\n+    it.toBooleanExpression()\n+  }\n+  return if (conditions.isEmpty()) {\n+    BooleanExpression.True\n+  } else {\n+    check(conditions.toSet().size == conditions.size) {\n+      \"ApolloGraphQL: duplicate @skip/@include directives are not allowed\"\n+    }\n+    // Having both @skip and @include is allowed\n+    // In that case, it's equivalent to a \"And\"\n+    // See https://spec.graphql.org/draft/#sec--include\n+    BooleanExpression.And(conditions.toSet()).simplify()\n+  }\n+}\n+\n+internal  fun GQLDirective.toBooleanExpression(): BooleanExpression? {\n+  if (setOf(\"skip\", \"include\").contains(name).not()) {\n+    // not a condition directive\n+    return null\n+  }\n+  if (arguments?.arguments?.size != 1) {\n+    throw IllegalStateException(\"ApolloGraphQL: wrong number of arguments for '$name' directive: ${arguments?.arguments?.size}\")\n+  }\n+\n+  val argument = arguments.arguments.first()\n+\n+  return when (val value = argument.value) {\n+    is GQLBooleanValue -> {\n+      if (value.value) BooleanExpression.True else BooleanExpression.False\n+    }\n+    is GQLVariableValue -> BooleanExpression.Variable(\n+        name = value.name,\n+    ).let {\n+      if (name == \"skip\") it.not() else it\n+    }\n+    else -> throw IllegalStateException(\"ApolloGraphQL: cannot pass ${value.toUtf8()} to '$name' directive\")\n+  }\n+}"
  },
  {
    "sha": "f95628947ad3b976d12950d19bb77541c2aef5c6",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/TypeSet.kt",
    "status": "added",
    "additions": 71,
    "deletions": 0,
    "changes": 71,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/TypeSet.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/TypeSet.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/TypeSet.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,71 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+import com.apollographql.apollo3.compiler.frontend.GQLObjectTypeDefinition\n+import com.apollographql.apollo3.compiler.frontend.Schema\n+import com.apollographql.apollo3.compiler.frontend.possibleTypes\n+import org.jgrapht.alg.TransitiveReduction\n+import org.jgrapht.graph.DefaultDirectedGraph\n+import org.jgrapht.graph.DefaultEdge\n+\n+internal typealias TypeSet = Set<String>\n+internal typealias PossibleTypes = Set<String>\n+\n+\n+data class Edge<V>(val source: V, val target: V)\n+\n+sealed class Node(val typeSet: TypeSet)\n+class InterfaceNode(typeSet: TypeSet): Node(typeSet)\n+class ShapeNode(typeSet: TypeSet): Node(typeSet)\n+\n+/**\n+ * Return the different possible shapes\n+ *\n+ * Note that this is not linked to the fragments typeSets\n+ *\n+ * If fragment typeSets are [[A],[A,B],[A,B,C],[A,B,D]]\n+ *\n+ * A type implementing [A,B,C,D] will match to [A,B,C,D]\n+ */\n+internal fun computeShapes(schema: Schema, typeConditions: Set<String>): Map<TypeSet, PossibleTypes> {\n+  val typeConditionToPossibleTypes = typeConditions.map {\n+    it to schema.typeDefinition(it).possibleTypes(schema)\n+  }\n+\n+  return schema.typeDefinitions.values.filterIsInstance<GQLObjectTypeDefinition>()\n+      .map { it.name }\n+      .map { concreteType ->\n+        val matchedSupers = typeConditionToPossibleTypes.filter { it.second.contains(concreteType) }\n+            .map { it.first }\n+            .toSet()\n+\n+        matchedSupers to concreteType\n+      }\n+      .groupBy(\n+          keySelector = { it.first },\n+          valueTransform = { it.second }\n+      )\n+      .mapValues { it.value.toSet() }\n+}\n+\n+internal fun TypeSet.implements(other: TypeSet) = intersect(other) == other\n+\n+\n+fun <V> transitiveReduce(\n+    edges: List<Edge<out V>>\n+): List<Edge<V>> {\n+  val graph = DefaultDirectedGraph<V, DefaultEdge>(DefaultEdge::class.java)\n+\n+  edges.flatMap { listOf(it.source, it.target) }.distinct()\n+      .forEach {\n+        graph.addVertex(it)\n+      }\n+  edges.forEach {\n+    graph.addEdge(it.source, it.target)\n+  }\n+\n+  TransitiveReduction.INSTANCE.reduce(graph)\n+\n+  return graph.edgeSet().map {\n+    Edge(graph.getEdgeSource(it), graph.getEdgeTarget(it))\n+  }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "7aae983e7fd2c5300ca9207388b69e5168ff2e61",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/AdapterBuilder.kt",
    "status": "added",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/AdapterBuilder.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/AdapterBuilder.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/AdapterBuilder.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,8 @@\n+package com.apollographql.apollo3.compiler.unified.codegen\n+\n+internal fun List<CGVariable>.toCGAdapter(name: String): CGAdapter {\n+  return CGMonomorphicAdapter(\n+      name = name,\n+      adaptedFields = emptyList()\n+  )\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "af92980f9714fb2ed6f9568826e4cb4a2be3d19c",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIr.kt",
    "status": "added",
    "additions": 185,
    "deletions": 0,
    "changes": 185,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIr.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIr.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIr.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,185 @@\n+package com.apollographql.apollo3.compiler.unified.codegen\n+\n+import com.apollographql.apollo3.compiler.backend.ast.CodeGenerationAst\n+import com.apollographql.apollo3.compiler.unified.PossibleTypes\n+import com.apollographql.apollo3.compiler.unified.TypeSet\n+\n+/**\n+ * A representation that matches the final kotlin code. It computes the inheritance between the different models and override flags\n+ * It isn't bound to KotlinPoet or escape any identifier so that it could potentially be used for other languages although for now\n+ * Kotlin remains the main target.\n+ * All the names are GraphQL names except the model names that are pre-computed for convenience\n+ * Also it doesn't know anything about paths, this is left to the final stage. This allows to easily change where we write files. For this\n+ * reason, Model references contain the filePath\n+ *\n+ * The different properties represent different logcial units.\n+ */\n+internal data class CodegenIr(\n+    val operations: List<CGOperation>,\n+    val fragments: List<CGFragment>,\n+    val inputTypes: List<CGInputObject>,\n+    val enumTypes: List<CGEnum>,\n+    val customScalars: CGCustomScalars,\n+)\n+\n+typealias ModelPath = List<String>\n+\n+fun modelName(typeSet: TypeSet, responseName: String): String {\n+  return (typeSet.sorted() + responseName).map { it.capitalize() }.joinToString(\"\")\n+}\n+\n+internal data class CGCustomScalars(\n+    val names: List<String>,\n+)\n+\n+\n+internal data class CGEnum(\n+    val name: String,\n+    val description: String?,\n+    val values: List<CGEnumValue>,\n+)\n+\n+internal data class CGEnumValue(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?,\n+)\n+\n+internal data class CGInputObject(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?,\n+    val inputFields: List<CGProperty>,\n+)\n+\n+internal data class CGProperty(\n+    val name: String,\n+    val description: String?,\n+    val deprecationReason: String?,\n+    val type: CGType,\n+    val override: Boolean,\n+)\n+\n+internal interface CGModel {\n+  /**\n+   * The path to the model. We need that from codegen to be able to create references to this model\n+   */\n+  val path: ModelPath\n+  val description: String?\n+  val deprecationReason: String?\n+  val properties: List<CGProperty>\n+  val nestedModels: List<CGModel>\n+}\n+\n+internal data class CGInterface(\n+    override val path: ModelPath,\n+    override val description: String?,\n+    override val deprecationReason: String?,\n+    override val properties: List<CGProperty>,\n+    override val nestedModels: List<CGInterface>,\n+) : CGModel\n+\n+internal data class CGImplementation(\n+    override val path: ModelPath,\n+    override val description: String?,\n+    override val deprecationReason: String?,\n+    override val properties: List<CGProperty>,\n+    override val nestedModels: List<CGImplementation>,\n+    /**\n+     * The list of implemented interfaces ordered by depth (same depth goes first)\n+     * a list of [CGOperationModelType] or [CGFragmentModelType]\n+     */\n+    val implements: List<CGType>,\n+) : CGModel\n+\n+interface CGAdapter\n+\n+internal data class CGAdaptedField(\n+    val name: String,\n+    val type: CGType,\n+)\n+\n+internal data class CGMonomorphicAdapter(\n+    val name: String,\n+    val adaptedFields: List<CGAdaptedField>,\n+) : CGAdapter\n+\n+internal data class CGPolymorphicAdapter(\n+    val name: String,\n+    val shapes: List<CGShapeAdapter>,\n+) : CGAdapter\n+\n+internal data class CGShapeAdapter(\n+    val name: String,\n+    val possibleTypes: PossibleTypes,\n+    val adaptedFields: List<CGAdaptedField>,\n+) : CGAdapter\n+\n+internal data class CGOperation(\n+    val name: String,\n+    val filePath: String,\n+    val description: String?,\n+    val variables: List<CGVariable>,\n+    val dataInterfaces: List<CGInterface>,\n+    val dataImplementations: List<CGImplementation>,\n+    val variablesAdapter: CGAdapter,\n+    val dataAdapter: CGAdapter,\n+\n+    val operationId: String,\n+    val operationDocument: String,\n+    val operationType: OperationType,\n+) {\n+  enum class OperationType {\n+    QUERY, MUTATION, SUBSCRIPTION\n+  }\n+}\n+\n+internal data class CGFragment(\n+    val name: String,\n+    val filePath: String,\n+    val description: String?,\n+    val variables: List<CGVariable>,\n+    val dataInterfaces: List<CGInterface>,\n+    val dataImplementations: List<CGImplementation>,\n+    val variablesAdapter: CGAdapter,\n+    val dataAdapter: CGAdapter,\n+)\n+\n+\n+sealed class CGType\n+\n+class CGNullableType(val ofType: CGType) : CGType()\n+\n+/**\n+ * For input values, we support wrapping them in [Input] to allow differentiating between null and absent\n+ */\n+class CGOptionalType(val ofType: CGType) : CGType()\n+class CGListType(val ofType: CGType) : CGType()\n+class CGStringType : CGType()\n+class CGFloatType : CGType()\n+class CGIntType : CGType()\n+class CGBooleanType : CGType()\n+\n+class CGCustomScalarType(val name: String) : CGType()\n+class CGEnumType(val name: String) : CGType()\n+\n+fun CGType.optional(optional: Boolean) = when {\n+  optional && this !is CGOptionalType -> CGOptionalType(this)\n+  !optional && this is CGOptionalType -> ofType\n+  else -> this\n+}\n+\n+fun CGType.nullable(nullable: Boolean) = when {\n+  nullable && this !is CGNullableType -> CGNullableType(this)\n+  !nullable && this is CGNullableType -> ofType\n+  else -> this\n+}\n+\n+class CGInputObjectType(val name: String) : CGType()\n+class CGOperationModelType(val filePath: String, modelPath: ModelPath) : CGType()\n+class CGFragmentModelType(val filePath: String, modelPath: ModelPath) : CGType()\n+\n+internal data class CGVariable(\n+    val name: String,\n+    val type: CGType,\n+)"
  },
  {
    "sha": "0399ac90f1a41ceacf8bca5e0a15ce98f04accf2",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIrBuilder.kt",
    "status": "added",
    "additions": 175,
    "deletions": 0,
    "changes": 175,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIrBuilder.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIrBuilder.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/CodegenIrBuilder.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,175 @@\n+package com.apollographql.apollo3.compiler.unified.codegen\n+\n+import com.apollographql.apollo3.compiler.PackageNameProvider\n+import com.apollographql.apollo3.compiler.operationoutput.OperationOutput\n+import com.apollographql.apollo3.compiler.operationoutput.findOperationId\n+import com.apollographql.apollo3.compiler.unified.BooleanIrType\n+import com.apollographql.apollo3.compiler.unified.CustomScalarIrType\n+import com.apollographql.apollo3.compiler.unified.EnumIrType\n+import com.apollographql.apollo3.compiler.unified.FloatIrType\n+import com.apollographql.apollo3.compiler.unified.IdIrType\n+import com.apollographql.apollo3.compiler.unified.InputObjectIrType\n+import com.apollographql.apollo3.compiler.unified.IntIrType\n+import com.apollographql.apollo3.compiler.unified.InterfaceIrType\n+import com.apollographql.apollo3.compiler.unified.IntermediateRepresentation\n+import com.apollographql.apollo3.compiler.unified.IrEnum\n+import com.apollographql.apollo3.compiler.unified.IrEnumValue\n+import com.apollographql.apollo3.compiler.unified.IrInputField\n+import com.apollographql.apollo3.compiler.unified.IrInputObject\n+import com.apollographql.apollo3.compiler.unified.IrType\n+import com.apollographql.apollo3.compiler.unified.IrVariable\n+import com.apollographql.apollo3.compiler.unified.ListIrType\n+import com.apollographql.apollo3.compiler.unified.ModelBuilder\n+import com.apollographql.apollo3.compiler.unified.NonNullIrType\n+import com.apollographql.apollo3.compiler.unified.ObjectIrType\n+import com.apollographql.apollo3.compiler.unified.StringIrType\n+import com.apollographql.apollo3.compiler.unified.UnionIrType\n+\n+class CodegenIrBuilder(\n+    private val ir: IntermediateRepresentation,\n+    private val customScalarsMapping: Map<String, String>,\n+    private val typesPackageName: String,\n+    private val fragmentsPackage: String,\n+    private val packageNameProvider: PackageNameProvider,\n+    private val operationOutput: OperationOutput,\n+    private val generateFragmentsAsInterfaces: Boolean,\n+) {\n+\n+  internal fun build(): CodegenIr {\n+\n+    val operations = ir.operations.map { irOperation ->\n+      val result = ModelBuilder(irOperation.dataField).build()\n+\n+      val variables = irOperation.variables.map { it.toCg() }\n+      CGOperation(\n+          name = irOperation.name,\n+          description = irOperation.description,\n+          filePath = irOperation.filePath,\n+          dataImplementations = result.implementations,\n+          dataInterfaces = result.interfaces,\n+          variables = variables,\n+          dataAdapter = result.adapter,\n+          variablesAdapter = variables.toCGAdapter(irOperation.name),\n+\n+          operationType = CGOperation.OperationType.valueOf(irOperation.operationType.name.toUpperCase()),\n+          // TODO: remove the the package name from here\n+          operationId = operationOutput.findOperationId(irOperation.name, \"\"),\n+          operationDocument = irOperation.sourceWithFragments,\n+      )\n+    }\n+\n+    val fragments = ir.namedFragments.map { irFragment ->\n+      val result = ModelBuilder(irFragment.dataField).build()\n+\n+      val variables = irFragment.variables.map { it.toCg() }\n+      CGFragment(\n+          name = irFragment.name,\n+          description = irFragment.description,\n+          filePath = irFragment.filePath,\n+          dataImplementations = result.implementations,\n+          dataInterfaces = result.interfaces,\n+          variables = variables,\n+          dataAdapter = result.adapter,\n+          variablesAdapter = variables.toCGAdapter(irFragment.name)\n+      )\n+    }\n+\n+    val inputObjectTypes = ir.inputObjects.map { irInputObject ->\n+      irInputObject.toCg()\n+    }\n+\n+    val enumTypes = ir.enums.map { irEnum ->\n+      irEnum.toCg()\n+    }\n+\n+    val customScalarTypes = CGCustomScalars(\n+        names = ir.customScalars.map { it.name }\n+    )\n+\n+    return CodegenIr(\n+        operations = operations,\n+        fragments = fragments,\n+        inputTypes = inputObjectTypes,\n+        enumTypes = enumTypes,\n+        customScalars = customScalarTypes,\n+    )\n+  }\n+\n+  private fun IrInputObject.toCg(): CGInputObject {\n+    return CGInputObject(\n+        name = name,\n+        description = description,\n+        deprecationReason = deprecationReason,\n+        inputFields = fields.map { irInputField ->\n+          irInputField.toCg()\n+        }\n+    )\n+  }\n+\n+  private fun IrEnum.toCg(): CGEnum {\n+    return CGEnum(\n+        name = name,\n+        description = description,\n+        values = values.map {\n+          it.toCg()\n+        }\n+    )\n+  }\n+\n+  private fun IrEnumValue.toCg(): CGEnumValue {\n+    return CGEnumValue(\n+        name = name,\n+        description = description,\n+        deprecationReason = deprecationReason\n+    )\n+  }\n+\n+  private fun IrInputField.toCg(): CGProperty {\n+    return CGProperty(\n+        name = name,\n+        description = description,\n+        deprecationReason = deprecationReason,\n+        // https://spec.graphql.org/draft/#sec-Input-Object-Required-Fields\n+        type = type.toInputCgType().optional(type !is NonNullIrType || defaultValue != null),\n+        override = false\n+    )\n+  }\n+\n+  private fun IrVariable.toCg(): CGVariable {\n+    return CGVariable(\n+        name = name,\n+        type = type.toVariableCgType().optional(type !is NonNullIrType || defaultValue != null),\n+    )\n+  }\n+}\n+\n+fun IrType.toVariableCgType(): CGType {\n+  return toCgUnsafe(null)\n+}\n+\n+fun IrType.toInputCgType(): CGType {\n+  return toCgUnsafe(null)\n+}\n+\n+fun IrType.toCgUnsafe(leafModelType: CGType?): CGType {\n+  if (this is NonNullIrType) {\n+    return ofType.toCgUnsafe(leafModelType)\n+  }\n+\n+  return when (this) {\n+    is NonNullIrType -> error(\"\") // make the compiler happy, this case is handled as a fast path\n+    is ListIrType -> CGListType(ofType = ofType.toCgUnsafe(leafModelType))\n+    is StringIrType -> CGStringType()\n+    is FloatIrType -> CGFloatType()\n+    is IntIrType -> CGIntType()\n+    is BooleanIrType -> CGBooleanType()\n+    is IdIrType -> CGStringType()\n+    is CustomScalarIrType -> CGCustomScalarType(name = name)\n+    is EnumIrType -> CGEnumType(name = name)\n+    is InputObjectIrType -> CGInputObjectType(name = name)\n+    is ObjectIrType -> leafModelType ?: error(\"A modelType is required to build this CGType\")\n+    is InterfaceIrType ->  leafModelType ?: error(\"A modelType is required to build this CGType\")\n+    is UnionIrType ->  leafModelType ?: error(\"A modelType is required to build this CGType\")\n+  }.nullable(true)\n+}\n+"
  },
  {
    "sha": "0cf18feaa5968336daeadb63ff9a145bdd77b26a",
    "filename": "apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/ModelBuilder.kt",
    "status": "added",
    "additions": 129,
    "deletions": 0,
    "changes": 129,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/ModelBuilder.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/ModelBuilder.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/main/kotlin/com/apollographql/apollo3/compiler/unified/codegen/ModelBuilder.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,129 @@\n+package com.apollographql.apollo3.compiler.unified\n+\n+import com.apollographql.apollo3.compiler.unified.codegen.CGAdapter\n+import com.apollographql.apollo3.compiler.unified.codegen.CGImplementation\n+import com.apollographql.apollo3.compiler.unified.codegen.CGInterface\n+\n+internal data class Model(\n+    val responseName: String,\n+    val typeSet: TypeSet,\n+    val irField: IrField,\n+    val irFieldSet: IrFieldSet,\n+    val children: List<Model>,\n+)\n+\n+internal data class Result(\n+    val interfaces: List<CGInterface>,\n+    val implementations: List<CGImplementation>,\n+    val adapter: CGAdapter,\n+)\n+\n+internal class ModelBuilder(val rootField: IrField) {\n+  private val edges = mutableListOf<Edge<Model>>()\n+\n+  fun build(): Result {\n+    // build the model tree without any inheritance information\n+    val rootModels = rootField.toAstExtInterfaces()\n+\n+    // then walk the tree and build the inheritance edges\n+    walk(rootModels, emptyList())\n+\n+    return Model(\n+\n+    )\n+  }\n+\n+  private fun IrField.toAstField(): AstExtField {\n+    return AstExtField(\n+        name = name,\n+        type = type.toAst(),\n+        override =\n+    )\n+  }\n+\n+\n+  private fun IrField.toAstExtInterfaces(path: ModelPath): List<AstExtInterface> {\n+    return fieldSets.map { fieldSet ->\n+      val selfPath = path + modelName(fieldSet.typeSet, responseName)\n+      AstExtInterface(\n+          path = selfPath,\n+          description = description ?: \"\",\n+          deprecationReason = deprecationReason,\n+          fields = fieldSet.fields.map { it.toAstField() },\n+          nestedModels = fieldSet.fields.flatMap { childField ->\n+            val neighbourModels = interfaces.mapNotNull { superInterface ->\n+              superInterface.nestedModels.firstOrNull { it.path.last() == childField.responseName }\n+            }\n+            childField.toAstModels(\n+                selfPath,\n+                forceInterfaces,\n+                interfaces.flatMap {\n+                  it.fields.filter { it.name == }\n+                }\n+            )\n+          },\n+          implements = interfaces\n+      )\n+\n+    }\n+  }\n+  /**\n+   * @param neighbours all the models with the same responseName path, ordered by common ancestor distance,\n+   * ie the neighbours with the closest common ancestor will come first\n+   */\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun walk(models: List<Model>, neighbours: List<Model>): Model {\n+    val models = models.sortedByDescending { it.typeSet.size }\n+    for (i in 0.until(models.size)) {\n+      val model = models[i]\n+      /**\n+       * a model cannot implement itself so start at i + 1\n+       * it can implement an interface with the same typeSet though if an implementation implements an interface\n+       */\n+      val neighbours = models.subList(i + 1, models.size) + neighbours\n+      neighbours.forEach {\n+        if (model.typeSet.implements(it.typeSet)) {\n+          edges.add(Edge(model, it))\n+        }\n+      }\n+\n+      model.children.forEach { childModel ->\n+        walk(childModel, )\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @param neighbours all the models with the same responseName path, ordered by common ancestor distance,\n+   * that this model must inherit from\n+   */\n+  private fun walk(model: Model, neighbours: List<Model>): Model {\n+    neighbours.forEach {\n+      if (model.typeSet.implements(it.typeSet)) {\n+        edges.add(Edge(model, it))\n+      }\n+    }\n+\n+    model.children.forEach {\n+\n+    }\n+\n+      model.children.forEach { childModel ->\n+        walk(childModel, )\n+      }\n+    }\n+  }\n+  private fun IrField.toModels(): List<Model> {\n+    return fieldSets.map { fieldSet ->\n+      Model(\n+          responseName = responseName,\n+          typeSet = fieldSet.typeSet,\n+          irField = this,\n+          irFieldSet = fieldSet,\n+          children = fieldSet.fields.flatMap {\n+            it.toModels()\n+          }\n+      )\n+    }\n+  }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "97e9dfb61d483c309e31afd088bc3e35905188c8",
    "filename": "apollo-compiler/src/test/kotlin/com/apollographql/apollo3/compiler/IrTest.kt",
    "status": "added",
    "additions": 86,
    "deletions": 0,
    "changes": 86,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/test/kotlin/com/apollographql/apollo3/compiler/IrTest.kt",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/apollo-compiler/src/test/kotlin/com/apollographql/apollo3/compiler/IrTest.kt",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/apollo-compiler/src/test/kotlin/com/apollographql/apollo3/compiler/IrTest.kt?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -0,0 +1,86 @@\n+package com.apollographql.apollo3.compiler\n+\n+import com.apollographql.apollo3.compiler.frontend.GQLFragmentDefinition\n+import com.apollographql.apollo3.compiler.frontend.GQLOperationDefinition\n+import com.apollographql.apollo3.compiler.frontend.GraphQLParser\n+import com.apollographql.apollo3.compiler.unified.Edge\n+import com.apollographql.apollo3.compiler.unified.IrBuilder\n+import com.apollographql.apollo3.compiler.unified.transitiveReduce\n+import org.junit.Test\n+import java.io.File\n+import java.lang.UnsupportedOperationException\n+\n+class IrTest {\n+  @Test\n+  fun test() {\n+    val schema = GraphQLParser.parseSchema(\n+        File(\"src/test/graphql/schema.sdl\")\n+    )\n+    val operation = GraphQLParser.parseOperations(\n+        File(\"src/test/graphql/com/example/hero_name/TestOperation.graphql\"),\n+        schema\n+    )\n+\n+    val ir = IrBuilder(\n+        schema = schema,\n+        operationDefinitions = operation.orThrow().definitions.filterIsInstance<GQLOperationDefinition>(),\n+        metadataFragmentDefinitions = emptyList(),\n+        fragmentDefinitions = operation.orThrow().definitions.filterIsInstance<GQLFragmentDefinition>(),\n+        alwaysGenerateTypesMatching = emptySet()\n+    ).build()\n+\n+    if (ir.operations.isEmpty()) {\n+      throw UnsupportedOperationException(\"No operation found\")\n+    }\n+    if (ir.operations.size > 1) {\n+      throw UnsupportedOperationException(\"Multiple operations are not supported\")\n+    }\n+\n+    val irOperation = ir.operations.first()\n+  }\n+\n+  @Test\n+  fun testTransitiveReduce() {\n+    /**\n+     * 1 -> 2 -> 3;\n+     * 1 -> 3; // should be removed\n+     */\n+    val input = listOf(\n+        Edge(\"1\", \"2\"),\n+        Edge(\"2\", \"3\"),\n+        Edge(\"1\", \"3\"),\n+    )\n+\n+    val output = transitiveReduce(input)\n+\n+    check(\n+        output == listOf(\n+            Edge(\"1\", \"2\"),\n+            Edge(\"2\", \"3\"),\n+        )\n+    )\n+  }\n+\n+  data class Node(val value: String)\n+\n+  @Test\n+  fun testTransitiveReduceUsesEquals() {\n+    /**\n+     * Same test as [testTransitiveReduce] but using data classes so that the test would fail if referential equality were used\n+     */\n+    val input = listOf(\n+        Edge(Node(\"1\"), Node(\"2\")),\n+        Edge(Node(\"2\"), Node(\"3\")),\n+        Edge(Node(\"1\"), Node(\"3\")),\n+    )\n+\n+    val output = transitiveReduce(input)\n+\n+    check(\n+        output == listOf(\n+            Edge(Node(\"1\"),Node( \"2\")),\n+            Edge(Node(\"2\"),Node( \"3\")),\n+        )\n+    )\n+  }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "62d050c3078d97c0a542beeaf084c32efeb9a396",
    "filename": "composite/integration-tests/build.gradle.kts",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/composite/integration-tests/build.gradle.kts",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/composite/integration-tests/build.gradle.kts",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/composite/integration-tests/build.gradle.kts?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -48,7 +48,7 @@ fun addTests(asInterfaces: Boolean, sourceSetName: String, addTask: Boolean) {\n }\n \n addTests(false, \"testAsClasses\", true)\n-addTests(true, \"testAsInterfaces\", true)\n+//addTests(true, \"testAsInterfaces\", true)\n \n fun configureApollo(asInterfaces: Boolean, sourceSetName: String) {\n   configure<ApolloExtension> {"
  },
  {
    "sha": "05939afc83ae6a42a3fa1d6269770ab2dd9f002a",
    "filename": "gradle/dependencies.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/apollographql/apollo-android/blob/63d7be7000a616b92dda1bfc6a493c67ca9abc85/gradle/dependencies.gradle",
    "raw_url": "https://github.com/apollographql/apollo-android/raw/63d7be7000a616b92dda1bfc6a493c67ca9abc85/gradle/dependencies.gradle",
    "contents_url": "https://api.github.com/repos/apollographql/apollo-android/contents/gradle/dependencies.gradle?ref=63d7be7000a616b92dda1bfc6a493c67ca9abc85",
    "patch": "@@ -97,6 +97,7 @@ ext.dep = [\n     truth                 : \"com.google.truth:truth:$versions.truth\",\n     uuid                  : \"com.benasher44:uuid:0.2.2\",\n     benManesVersions      : \"com.github.ben-manes:gradle-versions-plugin:0.33.0\",\n+    jgrapht               : \"org.jgrapht:jgrapht-core:1.5.0\"\n ]\n ext.androidConfig = [\n     compileSdkVersion: 30,"
  }
]
