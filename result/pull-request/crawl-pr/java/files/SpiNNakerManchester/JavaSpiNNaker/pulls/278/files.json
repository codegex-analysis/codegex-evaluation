[
  {
    "sha": "722cd6cc10dbbb42dbdd7881c2cb89b9c2566679",
    "filename": "SpiNNaker-comms/src/main/java/uk/ac/manchester/spinnaker/connections/SCPRequestPipeline.java",
    "status": "modified",
    "additions": 65,
    "deletions": 16,
    "changes": 81,
    "blob_url": "https://github.com/SpiNNakerManchester/JavaSpiNNaker/blob/d0f19b51a29a6f72bd0998121ffe4a356d2ea81d/SpiNNaker-comms/src/main/java/uk/ac/manchester/spinnaker/connections/SCPRequestPipeline.java",
    "raw_url": "https://github.com/SpiNNakerManchester/JavaSpiNNaker/raw/d0f19b51a29a6f72bd0998121ffe4a356d2ea81d/SpiNNaker-comms/src/main/java/uk/ac/manchester/spinnaker/connections/SCPRequestPipeline.java",
    "contents_url": "https://api.github.com/repos/SpiNNakerManchester/JavaSpiNNaker/contents/SpiNNaker-comms/src/main/java/uk/ac/manchester/spinnaker/connections/SCPRequestPipeline.java?ref=d0f19b51a29a6f72bd0998121ffe4a356d2ea81d",
    "patch": "@@ -362,27 +362,66 @@ public SCPRequestPipeline(SCPConnection connection, int numChannels,\n \tpublic <T extends CheckOKResponse> void sendRequest(SCPRequest<T> request,\n \t\t\tConsumer<T> callback, SCPErrorHandler errorCallback)\n \t\t\tthrows IOException {\n+\t\trequireNonNull(errorCallback);\n \t\t// If all the channels are used, start to receive packets\n \t\twhile (outstandingRequests.size() >= numChannels) {\n \t\t\tmultiRetrieve(intermediateChannelWaits);\n \t\t}\n \n-\t\t// Update the packet and store required details\n-\t\tint sequence = toUnsignedInt(request.scpRequestHeader\n-\t\t\t\t.issueSequenceNumber(outstandingRequests.keySet()));\n-\n-\t\tlog.debug(\"sending message with sequence {}\", sequence);\n-\t\tRequest<T> req =\n-\t\t\t\tnew Request<>(request, callback, requireNonNull(errorCallback));\n-\t\tif (outstandingRequests.put(sequence, req) != null) {\n-\t\t\tthrow new RuntimeException(\"duplicate sequence number catastrophe\");\n-\t\t}\n-\t\tnumRequests++;\n+\t\tRequest<T> req = registerRequest(request, callback, errorCallback);\n \n \t\t// Send the request\n \t\treq.send();\n \t}\n \n+\t/**\n+\t * There's a duplicate sequence number! This really shouldn't happen.\n+\t *\n+\t * @author Donal Fellows\n+\t */\n+\tprivate static class DuplicateSequenceNumberException\n+\t\t\textends IllegalThreadStateException {\n+\t\tprivate static final long serialVersionUID = -4033792283948201730L;\n+\n+\t\tDuplicateSequenceNumberException() {\n+\t\t\tsuper(\"duplicate sequence number catastrophe\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Update the packet and store required details.\n+\t *\n+\t * @param <T>\n+\t *            The type of response expected to the request.\n+\t * @param request\n+\t *            The SCP request to be sent\n+\t * @param callback\n+\t *            A callback function to call when the response has been\n+\t *            received; takes an SCPResponse as a parameter, or a\n+\t *            {@code null} if the response doesn't need to be processed.\n+\t * @param errorCallback\n+\t *            A callback function to call when an error is found when\n+\t *            processing the message; takes the original SCPRequest, and the\n+\t *            exception caught while sending it.\n+\t * @return The registered (but unsent) request.\n+\t */\n+\tprivate <T extends CheckOKResponse> Request<T> registerRequest(\n+\t\t\tSCPRequest<T> request, Consumer<T> callback,\n+\t\t\tSCPErrorHandler errorCallback) {\n+\t\tsynchronized (outstandingRequests) {\n+\t\t\tint sequence = toUnsignedInt(request.scpRequestHeader\n+\t\t\t\t\t.issueSequenceNumber(outstandingRequests.keySet()));\n+\n+\t\t\tlog.debug(\"sending message with sequence {}\", sequence);\n+\t\t\tRequest<T> req = new Request<>(request, callback, errorCallback);\n+\t\t\tif (outstandingRequests.put(sequence, req) != null) {\n+\t\t\t\tthrow new DuplicateSequenceNumberException();\n+\t\t\t}\n+\t\t\tnumRequests++;\n+\t\t\treturn req;\n+\t\t}\n+\t}\n+\n \t/**\n \t * Send a one-way request.\n \t *\n@@ -449,9 +488,13 @@ private void singleRetrieve() throws IOException {\n \t\tif (req == null) {\n \t\t\tlog.info(\"discarding message with unknown sequence number: {}\",\n \t\t\t\t\tmsg.getSequenceNumber());\n-\t\t\tlog.debug(\"current waiting on requests with seq's \");\n-\t\t\tfor (int seq : outstandingRequests.keySet()) {\n-\t\t\t\tlog.debug(\"{}\", seq);\n+\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\tsynchronized (outstandingRequests) {\n+\t\t\t\t\tlog.debug(\"current waiting on requests with seq's \");\n+\t\t\t\t\tfor (int seq : outstandingRequests.keySet()) {\n+\t\t\t\t\t\tlog.debug(\"{}\", seq);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn;\n \t\t}\n@@ -487,7 +530,11 @@ private void handleReceiveTimeout() {\n \n \t\t// If there is a timeout, all packets remaining are resent\n \t\tBitSet toRemove = new BitSet(SEQUENCE_LENGTH);\n-\t\tfor (int seq : new ArrayList<>(outstandingRequests.keySet())) {\n+\t\tArrayList<Integer> currentSeqs;\n+\t\tsynchronized (outstandingRequests) {\n+\t\t\tcurrentSeqs = new ArrayList<>(outstandingRequests.keySet());\n+\t\t}\n+\t\tfor (int seq : currentSeqs) {\n \t\t\tlog.debug(\"resending seq {}\", seq);\n \t\t\tRequest<?> req = outstandingRequests.get(seq);\n \t\t\tif (req == null) {\n@@ -506,7 +553,9 @@ private void handleReceiveTimeout() {\n \t\t}\n \t\tlog.debug(\"finish resending\");\n \n-\t\ttoRemove.stream().forEach(outstandingRequests::remove);\n+\t\tsynchronized (outstandingRequests) {\n+\t\t\ttoRemove.stream().forEach(outstandingRequests::remove);\n+\t\t}\n \t}\n \n \tprivate void resend(Request<?> req, Object reason, int seq)"
  }
]
