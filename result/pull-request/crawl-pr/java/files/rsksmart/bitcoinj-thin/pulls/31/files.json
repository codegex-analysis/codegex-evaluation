[
  {
    "sha": "7aae42593e0135f2c4ed0794b921ec3b83a377cc",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/pom.xml",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/pom.xml",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/pom.xml?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -20,7 +20,7 @@\n          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n     <modelVersion>4.0.0</modelVersion>\n     <groupId>co.rsk.bitcoinj</groupId>\n-    <version>0.14.4-rsk-10-rc</version>\n+    <version>0.14.4-rsk-10-erp</version>\n     <artifactId>bitcoinj-thin</artifactId>\n \n     <name>bitcoinj-thin</name>"
  },
  {
    "sha": "b0c55c40d5ab6088f369344f06a5856fd5ceb973",
    "filename": "src/main/java/co/rsk/bitcoinj/core/BtcTransaction.java",
    "status": "modified",
    "additions": 14,
    "deletions": 0,
    "changes": 14,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/core/BtcTransaction.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/core/BtcTransaction.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/core/BtcTransaction.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -165,6 +165,20 @@ public int compare(final BtcTransaction tx1, final BtcTransaction tx2) {\n     @Nullable\n     private String memo;\n \n+    /* Below flags apply in the context of BIP 68 */\n+    /* If this flag set, CTxIn::nSequence is NOT interpreted as a\n+     * relative lock-time. */\n+    public static final long SEQUENCE_LOCKTIME_DISABLE_FLAG = 1L << 31;\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time and this flag\n+     * is set, the relative lock-time has units of 512 seconds,\n+     * otherwise it specifies blocks with a granularity of 1. */\n+    public static final long SEQUENCE_LOCKTIME_TYPE_FLAG = 1L << 22;\n+\n+    /* If CTxIn::nSequence encodes a relative lock-time, this mask is\n+     * applied to extract that lock-time from the sequence field. */\n+    public static final long SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n+\n     public BtcTransaction(NetworkParameters params) {\n         super(params);\n         version = 1;"
  },
  {
    "sha": "6e56bf1f2411ce82978da4ef9d91e554c3b13c51",
    "filename": "src/main/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParser.java",
    "status": "added",
    "additions": 79,
    "deletions": 0,
    "changes": 79,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,79 @@\n+package co.rsk.bitcoinj.script;\n+\n+import static co.rsk.bitcoinj.script.RedeemScriptValidator.removeOpCheckMultisig;\n+\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ErpFederationRedeemScriptParser extends StandardRedeemScriptParser {\n+    private static final Logger logger = LoggerFactory.getLogger(ErpFederationRedeemScriptParser.class);\n+\n+    public ErpFederationRedeemScriptParser(\n+        ScriptType scriptType,\n+        List<ScriptChunk> redeemScriptChunks,\n+        List<ScriptChunk> rawChunks\n+    ) {\n+        super(\n+            scriptType,\n+            extractStandardRedeemScript(redeemScriptChunks).getChunks(),\n+            rawChunks\n+        );\n+        this.multiSigType = MultiSigType.ERP_FED;\n+    }\n+\n+    public static Script extractStandardRedeemScript(List<ScriptChunk> chunks) {\n+        List<ScriptChunk> chunksForRedeem = new ArrayList<>();\n+\n+        int i = 1;\n+        while (i < chunks.size() && !chunks.get(i).equalsOpCode(ScriptOpCodes.OP_ELSE)) {\n+            chunksForRedeem.add(chunks.get(i));\n+            i++;\n+        }\n+\n+        chunksForRedeem.add(new ScriptChunk(ScriptOpCodes.OP_CHECKMULTISIG, null));\n+\n+        // Validate the obtained redeem script has a valid format\n+        if (!RedeemScriptValidator.hasStandardRedeemScriptStructure(chunksForRedeem)) {\n+            String message = \"Standard redeem script obtained from ERP redeem script has an invalid structure\";\n+            logger.debug(\"[extractStandardRedeemScriptChunksFromErpRedeemScript] {}\", message);\n+            throw new VerificationException(message);\n+        }\n+\n+        return new Script(chunksForRedeem);\n+    }\n+\n+    public static Script createErpRedeemScript(\n+        Script defaultFederationRedeemScript,\n+        Script erpFederationRedeemScript,\n+        Long csvValue\n+    ) {\n+        if (!RedeemScriptValidator.hasStandardRedeemScriptStructure(defaultFederationRedeemScript.getChunks()) ||\n+            !RedeemScriptValidator.hasStandardRedeemScriptStructure(erpFederationRedeemScript.getChunks())) {\n+\n+            String message = \"Provided redeem scripts have an invalid structure, not standard\";\n+            logger.debug(\"[createErpRedeemScript] {}\", message);\n+            throw new VerificationException(message);\n+        }\n+\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+\n+        return scriptBuilder.op(ScriptOpCodes.OP_NOTIF)\n+            .addChunks(removeOpCheckMultisig(defaultFederationRedeemScript))\n+            .op(ScriptOpCodes.OP_ELSE)\n+            .data(BigInteger.valueOf(csvValue).toByteArray())\n+            .op(ScriptOpCodes.OP_CHECKSEQUENCEVERIFY)\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(removeOpCheckMultisig(erpFederationRedeemScript))\n+            .op(ScriptOpCodes.OP_ENDIF)\n+            .op(ScriptOpCodes.OP_CHECKMULTISIG)\n+            .build();\n+    }\n+\n+    public static boolean isErpFed(List<ScriptChunk> chunks) {\n+        return RedeemScriptValidator.hasErpRedeemScriptStructure(chunks);\n+    }\n+}"
  },
  {
    "sha": "5ad4d3746bdca96d09c4e2c675341fb712e4ee4b",
    "filename": "src/main/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParser.java",
    "status": "added",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,77 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FastBridgeErpRedeemScriptParser extends StandardRedeemScriptParser {\n+    private static final Logger logger = LoggerFactory.getLogger(FastBridgeErpRedeemScriptParser.class);\n+\n+    public FastBridgeErpRedeemScriptParser(\n+        ScriptType scriptType,\n+        List<ScriptChunk> redeemScriptChunks,\n+        List<ScriptChunk> rawChunks\n+    ) {\n+        super(\n+            scriptType,\n+            extractStandardRedeemScript(redeemScriptChunks).getChunks(),\n+            rawChunks\n+        );\n+        this.multiSigType = MultiSigType.FAST_BRIDGE_ERP_FED;\n+    }\n+\n+    public static Script extractStandardRedeemScript(List<ScriptChunk> chunks) {\n+        return ErpFederationRedeemScriptParser.\n+            extractStandardRedeemScript(chunks.subList(2, chunks.size()));\n+    }\n+\n+    public static Script createFastBridgeErpRedeemScript(\n+        Script erpRedeemScript,\n+        Sha256Hash derivationArgumentsHash\n+    ) {\n+        if (!RedeemScriptValidator.hasErpRedeemScriptStructure(erpRedeemScript.getChunks())) {\n+            String message = \"Provided redeem script has not ERP structure\";\n+            logger.debug(\"[createFastBridgeErpRedeemScript] {}\", message);\n+            throw new VerificationException(message);\n+        }\n+\n+        List<ScriptChunk> chunks = erpRedeemScript.getChunks();\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+\n+        return scriptBuilder\n+            .data(derivationArgumentsHash.getBytes())\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(chunks)\n+            .build();\n+    }\n+\n+    public static Script createFastBridgeErpRedeemScript(\n+        Script defaultFederationRedeemScript,\n+        Script erpFederationRedeemScript,\n+        Long csvValue,\n+        Sha256Hash derivationArgumentsHash\n+    ) {\n+        if (!RedeemScriptValidator.hasStandardRedeemScriptStructure(defaultFederationRedeemScript.getChunks()) ||\n+            !RedeemScriptValidator.hasStandardRedeemScriptStructure(erpFederationRedeemScript.getChunks())) {\n+\n+            String message = \"Provided redeem scripts have an invalid structure, not standard\";\n+            logger.debug(\"[createFastBridgeErpRedeemScript] {}\", message);\n+            throw new VerificationException(message);\n+        }\n+\n+        Script erpRedeemScript = ErpFederationRedeemScriptParser.createErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue\n+        );\n+\n+        return createFastBridgeErpRedeemScript(erpRedeemScript, derivationArgumentsHash);\n+    }\n+\n+    public static boolean isFastBridgeErpFed(List<ScriptChunk> chunks) {\n+        return RedeemScriptValidator.hasFastBridgePrefix(chunks) &&\n+            RedeemScriptValidator.hasErpRedeemScriptStructure(chunks.subList(2, chunks.size()));\n+    }\n+}"
  },
  {
    "sha": "763e92cbb7b69e2445b5cc3245c7d589efe921c7",
    "filename": "src/main/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParser.java",
    "status": "modified",
    "additions": 18,
    "deletions": 35,
    "changes": 53,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -2,7 +2,6 @@\n \n import co.rsk.bitcoinj.core.Sha256Hash;\n import co.rsk.bitcoinj.core.VerificationException;\n-import java.util.Arrays;\n import java.util.List;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -14,23 +13,23 @@\n \n     public FastBridgeRedeemScriptParser(\n         ScriptType scriptType,\n-        List<ScriptChunk> redeemScript,\n-        List<ScriptChunk> chunks\n+        List<ScriptChunk> redeemScriptChunks,\n+        List<ScriptChunk> rawChunks\n     ) {\n         super(\n             scriptType,\n-            redeemScript.subList(2, redeemScript.size()),\n-            chunks\n+            redeemScriptChunks.subList(2, redeemScriptChunks.size()),\n+            rawChunks\n         );\n         this.multiSigType = MultiSigType.FAST_BRIDGE_MULTISIG;\n-        this.derivationHash = redeemScript.get(0).data;\n+        this.derivationHash = redeemScriptChunks.get(0).data;\n     }\n \n     public byte[] getDerivationHash() {\n         return derivationHash;\n     }\n \n-    public static Script extractRedeemScriptFromMultiSigFastBridgeRedeemScript(Script redeemScript) {\n+    public static Script extractStandardRedeemScript(Script redeemScript) {\n         return ScriptBuilder.createRedeemScript(\n             redeemScript.getNumberOfSignaturesRequiredToSpend(),\n             redeemScript.getPubKeys()\n@@ -41,43 +40,27 @@ public static Script createMultiSigFastBridgeRedeemScript(\n         Script redeemScript,\n         Sha256Hash derivationArgumentsHash\n     ) {\n-        List<ScriptChunk> chunks = redeemScript.getChunks();\n-        ScriptChunk firstChunk = chunks.get(0);\n-        boolean hasFastBridgePrefix = false;\n-\n-        if (firstChunk.data != null) {\n-            hasFastBridgePrefix = firstChunk.opcode == 32 && firstChunk.data.length == 32 &&\n-                chunks.get(1).opcode == ScriptOpCodes.OP_DROP;\n-        }\n-\n-        if (hasFastBridgePrefix) {\n+        if (RedeemScriptValidator.hasFastBridgePrefix(redeemScript.getChunks())) {\n             String message = \"Provided redeem script is already a fast bridge redeem script\";\n-            logger.debug(message);\n+            logger.debug(\"[createMultiSigFastBridgeRedeemScript] {}\", message);\n             throw new VerificationException(message);\n         }\n \n         if (derivationArgumentsHash == null || derivationArgumentsHash.equals(Sha256Hash.ZERO_HASH)) {\n             String message = \"Derivation arguments are not valid\";\n-            logger.debug(message);\n+            logger.debug(\"[createMultiSigFastBridgeRedeemScript] {}\", message);\n             throw new VerificationException(message);\n         }\n \n-        byte[] program = redeemScript.getProgram();\n-        byte[] reed = Arrays.copyOf(program, program.length);\n-        byte[] prefix = new byte[33];\n-\n-        // Hash length\n-        prefix[0] = 0x20;\n-        System.arraycopy(derivationArgumentsHash.getBytes(), 0, prefix, 1,\n-            derivationArgumentsHash.getBytes().length);\n-\n-        byte[] c = new byte[prefix.length + 1 + reed.length];\n-        System.arraycopy(prefix, 0, c, 0, prefix.length);\n-\n-        // OP_DROP to ignore pushed hash\n-        c[prefix.length] = 0x75;\n-        System.arraycopy(reed, 0, c, prefix.length + 1, reed.length);\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+        return scriptBuilder.data(derivationArgumentsHash.getBytes())\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(redeemScript.getChunks())\n+            .build();\n+    }\n \n-        return new Script(c);\n+    public static boolean isFastBridgeMultiSig(List<ScriptChunk> chunks) {\n+        return RedeemScriptValidator.hasFastBridgePrefix(chunks) &&\n+            RedeemScriptValidator.hasStandardRedeemScriptStructure(chunks.subList(2, chunks.size()));\n     }\n }"
  },
  {
    "sha": "381e24f86cc277b367a0fb936fbdf443e0b02415",
    "filename": "src/main/java/co/rsk/bitcoinj/script/NoRedeemScriptParser.java",
    "status": "modified",
    "additions": 7,
    "deletions": 12,
    "changes": 19,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/NoRedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/NoRedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/NoRedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -8,18 +8,8 @@\n public class NoRedeemScriptParser implements RedeemScriptParser {\n \n     @Override\n-    public boolean isStandardMultiSig() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isFastBridgeMultiSig() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isNotMultiSig() {\n-        return true;\n+    public MultiSigType getMultiSigType() {\n+        return MultiSigType.NO_MULTISIG_TYPE;\n     }\n \n     @Override\n@@ -51,4 +41,9 @@ public int findKeyInRedeem(BtcECKey key) {\n     public int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash) {\n         return 0;\n     }\n+\n+    @Override\n+    public Script extractStandardRedeemScript() {\n+        throw new ScriptException(\"Only usable for multisig scripts.\");\n+    }\n }"
  },
  {
    "sha": "878812689e7caa684d1fb2c10bd9c2499a10e11c",
    "filename": "src/main/java/co/rsk/bitcoinj/script/RedeemScriptParser.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -10,6 +10,8 @@\n         NO_MULTISIG_TYPE,\n         STANDARD_MULTISIG,\n         FAST_BRIDGE_MULTISIG,\n+        ERP_FED,\n+        FAST_BRIDGE_ERP_FED\n     }\n \n     enum ScriptType {\n@@ -18,11 +20,7 @@\n         UNDEFINED\n     }\n \n-    boolean isStandardMultiSig();\n-\n-    boolean isFastBridgeMultiSig();\n-\n-    boolean isNotMultiSig();\n+    MultiSigType getMultiSigType();\n \n     ScriptType getScriptType();\n \n@@ -35,4 +33,6 @@\n     List<BtcECKey> getPubKeys();\n \n     int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash);\n+\n+    Script extractStandardRedeemScript();\n }"
  },
  {
    "sha": "d03ff8348d35aa57af3aac6cccd977467685be97",
    "filename": "src/main/java/co/rsk/bitcoinj/script/RedeemScriptParserFactory.java",
    "status": "modified",
    "additions": 33,
    "deletions": 57,
    "changes": 90,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParserFactory.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParserFactory.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/RedeemScriptParserFactory.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -6,12 +6,17 @@\n import co.rsk.bitcoinj.core.ScriptException;\n import co.rsk.bitcoinj.script.RedeemScriptParser.ScriptType;\n import java.util.List;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class RedeemScriptParserFactory {\n \n+    private static final Logger logger = LoggerFactory.getLogger(RedeemScriptParserFactory.class);\n+\n     public static RedeemScriptParser get(List<ScriptChunk> chunks) {\n         if (chunks.size() < 4) {\n             // A multisig redeem script must have at least 4 chunks (OP_N [PUB1 ...] OP_N CHECK_MULTISIG)\n+            logger.debug(\"[get] Less than 4 chunks, return NoRedeemScriptParser\");\n             return new NoRedeemScriptParser();\n         }\n \n@@ -21,92 +26,64 @@ public static RedeemScriptParser get(List<ScriptChunk> chunks) {\n             return new NoRedeemScriptParser();\n         }\n \n-        if (internalIsFastBridgeMultiSig(result.internalScript)) {\n+        if (FastBridgeRedeemScriptParser.isFastBridgeMultiSig(result.internalScript)) {\n+            logger.debug(\"[get] Return FastBridgeRedeemScriptParser\");\n             return new FastBridgeRedeemScriptParser(\n                 result.scriptType,\n                 result.internalScript,\n                 chunks\n             );\n-        } else if (internalIsStandardMultiSig(result.internalScript)) {\n+        }\n+        if (StandardRedeemScriptParser.isStandardMultiSig(result.internalScript)) {\n+            logger.debug(\"[get] Return StandardRedeemScriptParser\");\n             return new StandardRedeemScriptParser(\n                 result.scriptType,\n                 result.internalScript,\n                 chunks\n             );\n         }\n+        if (ErpFederationRedeemScriptParser.isErpFed(result.internalScript)) {\n+            logger.debug(\"[get] Return ErpFederationRedeemScriptParser\");\n+            return new ErpFederationRedeemScriptParser(\n+                result.scriptType,\n+                result.internalScript,\n+                chunks\n+            );\n+        }\n+        if (FastBridgeErpRedeemScriptParser.isFastBridgeErpFed(result.internalScript)) {\n+            logger.debug(\"[get] Return FastBridgeErpRedeemScriptParser\");\n+            return new FastBridgeErpRedeemScriptParser(\n+                result.scriptType,\n+                result.internalScript,\n+                chunks\n+            );\n+        }\n+\n+        logger.debug(\"[get] Return NoRedeemScriptParser\");\n         return new NoRedeemScriptParser();\n     }\n \n     private static ParseResult extractRedeemScriptFromChunks(List<ScriptChunk> chunks) {\n         ScriptChunk lastChunk = chunks.get(chunks.size() - 1);\n-        if (isRedeemLikeScript(chunks)) {\n+        if (RedeemScriptValidator.isRedeemLikeScript(chunks)) {\n             return new ParseResult(chunks, ScriptType.REDEEM_SCRIPT);\n         }\n         if (lastChunk.data != null && lastChunk.data.length > 0) {\n             int lastByte = lastChunk.data[lastChunk.data.length - 1] & 0xff;\n             if (lastByte == OP_CHECKMULTISIG || lastByte == OP_CHECKMULTISIGVERIFY) {\n                 ScriptParserResult result = ScriptParser.parseScriptProgram(lastChunk.data);\n                 if (result.getException().isPresent()) {\n-                    throw new ScriptException(\"Error trying to parse inner script\", result.getException().get());\n+                    String message = String.format(\"Error trying to parse inner script. %s\", result.getException().get());\n+                    logger.debug(\"[extractRedeemScriptFromChunks] {}\", message);\n+                    throw new ScriptException(message);\n                 }\n                 return new ParseResult(result.getChunks(), ScriptType.P2SH);\n             }\n         }\n+        logger.debug(\"[extractRedeemScriptFromChunks] Could not get redeem script from given chunks\");\n         return null;\n     }\n \n-    private static boolean isRedeemLikeScript(List<ScriptChunk> chunks) {\n-        if (chunks.size() < 4) return false;\n-        ScriptChunk chunk = chunks.get(chunks.size() - 1);\n-        // Must end in OP_CHECKMULTISIG[VERIFY]\n-        if (!chunk.isOpCode()) return false;\n-        return chunk.equalsOpCode(OP_CHECKMULTISIG) || chunk.equalsOpCode(OP_CHECKMULTISIGVERIFY);\n-    }\n-\n-    private static boolean hasRedeemScriptFormat(List<ScriptChunk> chunks) {\n-        try {\n-            // Second to last chunk must be an OP_N opcode and there should be\n-            // that many data chunks (keys).\n-            ScriptChunk n = chunks.get(chunks.size() - 2);\n-            if (!n.isOpCode()) return false;\n-            int numKeys = Script.decodeFromOpN(n.opcode);\n-            if (numKeys < 1 || chunks.size() != 3 + numKeys) return false;\n-            for (int i = 1; i < chunks.size() - 2; i++) {\n-                if (chunks.get(i).isOpCode()) return false;\n-            }\n-            // First chunk must be an OP_N opcode too.\n-            if (Script.decodeFromOpN(chunks.get(0).opcode) < 1) return false;\n-        } catch (IllegalStateException e) {\n-            return false;   // Not an OP_N opcode.\n-        }\n-        return true;\n-    }\n-\n-    private static boolean internalIsFastBridgeMultiSig(List<ScriptChunk> chunks) {\n-        if (!isRedeemLikeScript(chunks)) {\n-            return false;\n-        }\n-\n-        ScriptChunk firstChunk = chunks.get(0);\n-\n-        if (firstChunk.data == null) {\n-            return false;\n-        }\n-\n-        boolean hasFastBridgePrefix =\n-            firstChunk.opcode == 32 && firstChunk.data.length == 32 &&\n-                chunks.get(1).opcode == ScriptOpCodes.OP_DROP;\n-\n-        if (!hasFastBridgePrefix) {\n-            return false;\n-        }\n-        return hasRedeemScriptFormat(chunks.subList(2, chunks.size()));\n-    }\n-\n-    private static boolean internalIsStandardMultiSig(List<ScriptChunk> chunks) {\n-        return isRedeemLikeScript(chunks) && hasRedeemScriptFormat(chunks);\n-    }\n-\n     private static class ParseResult {\n         public final List<ScriptChunk> internalScript;\n         public final ScriptType scriptType;\n@@ -116,5 +93,4 @@ public ParseResult(List<ScriptChunk> internalScript, ScriptType scriptType) {\n             this.scriptType = scriptType;\n         }\n     }\n-\n }"
  },
  {
    "sha": "467fd4c87a099de6330a1fe8aad3777ec1000b7b",
    "filename": "src/main/java/co/rsk/bitcoinj/script/RedeemScriptValidator.java",
    "status": "added",
    "additions": 150,
    "deletions": 0,
    "changes": 150,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptValidator.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/RedeemScriptValidator.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/RedeemScriptValidator.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,150 @@\n+package co.rsk.bitcoinj.script;\n+\n+import static co.rsk.bitcoinj.script.ScriptOpCodes.OP_CHECKMULTISIG;\n+import static co.rsk.bitcoinj.script.ScriptOpCodes.OP_CHECKMULTISIGVERIFY;\n+\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+public class RedeemScriptValidator {\n+\n+    public static Long extractCsvValue(List<ScriptChunk> chunks) {\n+        for (int i = 1; i < chunks.size(); i++) {\n+            ScriptChunk chunk = chunks.get(i);\n+            if (chunk.isOpCode() && chunk.equalsOpCode(ScriptOpCodes.OP_CHECKSEQUENCEVERIFY)) {\n+                ScriptChunk csvValueChunk = chunks.get(i - 1); // CSV value goes right before CSV op code\n+                return new BigInteger(csvValueChunk.data).longValue();\n+            }\n+        }\n+\n+        throw new VerificationException(\"No CSV value found\");\n+    }\n+\n+    protected static boolean isRedeemLikeScript(List<ScriptChunk> chunks) {\n+        if (chunks.size() < 4) {\n+            return false;\n+        }\n+\n+        ScriptChunk lastChunk = chunks.get(chunks.size() - 1);\n+        // Must end in OP_CHECKMULTISIG[VERIFY]\n+        return lastChunk.isOpCode() &&\n+            (lastChunk.equalsOpCode(OP_CHECKMULTISIG) || lastChunk.equalsOpCode(OP_CHECKMULTISIGVERIFY));\n+    }\n+\n+    protected static boolean hasStandardRedeemScriptStructure(List<ScriptChunk> chunks) {\n+        try {\n+            if (!isRedeemLikeScript(chunks)) {\n+                return false;\n+            }\n+\n+            // Second to last chunk must be an OP_N opcode and there should be\n+            // that many data chunks (keys).\n+            ScriptChunk secondToLastChunk = chunks.get(chunks.size() - 2);\n+            if (!isOpN(secondToLastChunk)) {\n+                return false;\n+            }\n+\n+            int numKeys = Script.decodeFromOpN(secondToLastChunk.opcode);\n+            if (numKeys < 1 || chunks.size() != numKeys + 3) { // numKeys + M + N + OP_CHECKMULTISIG\n+                return false;\n+            }\n+\n+            for (int i = 1; i < chunks.size() - 2; i++) {\n+                if (chunks.get(i).isOpCode()) { // Should be the public keys, not op_codes\n+                    return false;\n+                }\n+            }\n+            // First chunk must be an OP_N opcode too.\n+            if (!isOpN(chunks.get(0))) {\n+                return false;\n+            }\n+        } catch (IllegalStateException e) {\n+            return false;   // Not an OP_N opcode.\n+        }\n+        return true;\n+    }\n+\n+    protected static boolean hasErpRedeemScriptStructure(List<ScriptChunk> chunks) {\n+        if (!isRedeemLikeScript(chunks)) {\n+            return false;\n+        }\n+\n+        ScriptChunk firstChunk = chunks.get(0);\n+\n+        boolean hasErpPrefix = firstChunk.opcode == ScriptOpCodes.OP_NOTIF;\n+        boolean hasEndIfOpcode = chunks.get(chunks.size() - 2).equalsOpCode(ScriptOpCodes.OP_ENDIF);\n+\n+        if (!hasErpPrefix || !hasEndIfOpcode) {\n+            return false;\n+        }\n+\n+        boolean hasErpStructure = false;\n+        int elseOpcodeIndex = 0;\n+\n+        // Check existence of OP_ELSE opcode, followed by PUSH_BYTES, CSV and OP_DROP and\n+        // get both default and ERP federations redeem scripts\n+        for (int i = 1; i < chunks.size(); i++) {\n+            if (chunks.get(i).equalsOpCode(ScriptOpCodes.OP_ELSE) && chunks.size() >= i + 3) {\n+                elseOpcodeIndex = i;\n+                ScriptChunk pushBytesOpcode = chunks.get(elseOpcodeIndex + 1);\n+                ScriptChunk csvOpcode = chunks.get(elseOpcodeIndex + 2);\n+                ScriptChunk opDrop = chunks.get(elseOpcodeIndex + 3);\n+\n+                hasErpStructure = pushBytesOpcode.opcode == 2 &&\n+                    csvOpcode.equalsOpCode(ScriptOpCodes.OP_CHECKSEQUENCEVERIFY) &&\n+                    opDrop.equalsOpCode(ScriptOpCodes.OP_DROP);\n+\n+                break;\n+            }\n+        }\n+\n+        if (!hasErpStructure) {\n+            return false;\n+        }\n+\n+        // Validate both default and erp federations redeem scripts. For this, it is\n+        // necessary to add opcode OP_CHECKMULTISIG at the end of the redeem scripts\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+        List<ScriptChunk> defaultFedRedeemScriptChunks = chunks.subList(1, elseOpcodeIndex);\n+        Script defaultFedRedeemScript = scriptBuilder.addChunks(defaultFedRedeemScriptChunks)\n+            .addChunk(new ScriptChunk(ScriptOpCodes.OP_CHECKMULTISIG, null))\n+            .build();\n+\n+        scriptBuilder = new ScriptBuilder();\n+        List<ScriptChunk> erpFedRedeemScriptChunks = chunks.subList(elseOpcodeIndex + 4, chunks.size() - 2);\n+        Script erpFedRedeemScript = scriptBuilder.addChunks(erpFedRedeemScriptChunks)\n+            .addChunk(new ScriptChunk(ScriptOpCodes.OP_CHECKMULTISIG, null))\n+            .build();\n+\n+        return hasStandardRedeemScriptStructure(defaultFedRedeemScript.getChunks()) &&\n+            hasStandardRedeemScriptStructure(erpFedRedeemScript.getChunks());\n+    }\n+\n+    protected static boolean hasFastBridgePrefix(List<ScriptChunk> chunks) {\n+        ScriptChunk firstChunk = chunks.get(0);\n+\n+        if (firstChunk.data == null || chunks.size() < 2) {\n+            return false;\n+        }\n+\n+        return firstChunk.opcode == 32 &&\n+            firstChunk.data.length == 32 &&\n+            chunks.get(1).opcode == ScriptOpCodes.OP_DROP;\n+    }\n+\n+    protected static List<ScriptChunk> removeOpCheckMultisig(Script redeemScript) {\n+        if (!RedeemScriptValidator.hasStandardRedeemScriptStructure(redeemScript.getChunks())) {\n+            String message = \"Redeem script has an invalid structure\";\n+            throw new VerificationException(message);\n+        }\n+\n+        // Remove the last chunk, which has CHECKMULTISIG op code\n+        return redeemScript.getChunks().subList(0, redeemScript.getChunks().size() - 1);\n+    }\n+\n+    protected static boolean isOpN(ScriptChunk chunk) {\n+        return chunk.isOpCode() &&\n+            chunk.opcode >= ScriptOpCodes.OP_1 && chunk.opcode <= ScriptOpCodes.OP_16;\n+    }\n+}"
  },
  {
    "sha": "00ef284ead66d125665bf093727a38ea484b62c9",
    "filename": "src/main/java/co/rsk/bitcoinj/script/Script.java",
    "status": "modified",
    "additions": 113,
    "deletions": 10,
    "changes": 123,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/Script.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/Script.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/Script.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -20,7 +20,6 @@\n \n import static co.rsk.bitcoinj.script.ScriptOpCodes.*;\n import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkState;\n \n import co.rsk.bitcoinj.core.Address;\n import co.rsk.bitcoinj.core.BtcECKey;\n@@ -32,6 +31,7 @@\n import co.rsk.bitcoinj.core.UnsafeByteArrayOutputStream;\n import co.rsk.bitcoinj.core.Utils;\n import co.rsk.bitcoinj.crypto.TransactionSignature;\n+import co.rsk.bitcoinj.script.RedeemScriptParser.MultiSigType;\n import com.google.common.collect.Lists;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n@@ -89,7 +89,8 @@\n         MINIMALDATA, // Require minimal encodings for all push operations\n         DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)\n         CLEANSTACK, // Require that only a single stack element remains after evaluation.\n-        CHECKLOCKTIMEVERIFY // Enable CHECKLOCKTIMEVERIFY operation\n+        CHECKLOCKTIMEVERIFY, // Enable CHECKLOCKTIMEVERIFY operation\n+        CHECKSEQUENCEVERIFY // Enable CHECKSEQUENCEVERIFY operation\n     }\n     public static final EnumSet<VerifyFlag> ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);\n \n@@ -435,7 +436,27 @@ public Script createEmptyInputScript(@Nullable BtcECKey key, @Nullable Script re\n             return ScriptBuilder.createInputScript(null);\n         } else if (isPayToScriptHash()) {\n             checkArgument(redeemScript != null, \"Redeem script required to create P2SH input script\");\n-            return ScriptBuilder.createP2SHMultiSigInputScript(null, redeemScript);\n+            Script emptyInputScript = ScriptBuilder.createP2SHMultiSigInputScript(null, redeemScript);\n+\n+            // Validate if redeem script is ERP or Fast Bridge ERP.\n+            // If so, recreate empty input script adding a OP_0 before redeem script.\n+            List<ScriptChunk> chunks = redeemScript.getChunks();\n+            boolean isFastBridgeErp = FastBridgeErpRedeemScriptParser.isFastBridgeErpFed(chunks);\n+            boolean isErp = RedeemScriptValidator.hasErpRedeemScriptStructure(chunks);\n+\n+            if (isErp || isFastBridgeErp) {\n+                ScriptBuilder builder = new ScriptBuilder();\n+                List<ScriptChunk> inputScriptChunks = emptyInputScript.getChunks();\n+                List<ScriptChunk> chunksWithoutRedeem = inputScriptChunks.subList(0, inputScriptChunks.size() -1);\n+                ScriptChunk redeemScriptChunk = inputScriptChunks.get(inputScriptChunks.size() -1);\n+                emptyInputScript = builder\n+                    .addChunks(chunksWithoutRedeem)\n+                    .number(ScriptOpCodes.OP_0)\n+                    .addChunk(redeemScriptChunk)\n+                    .build();\n+            }\n+\n+            return emptyInputScript;\n         } else {\n             throw new ScriptException(\"Do not understand script type: \" + this);\n         }\n@@ -627,7 +648,7 @@ public boolean isPayToScriptHash() {\n      * Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG\n      */\n     public boolean isSentToMultiSig() {\n-        return redeemScriptParser.isStandardMultiSig() || redeemScriptParser.isFastBridgeMultiSig();\n+        return !redeemScriptParser.getMultiSigType().equals(MultiSigType.NO_MULTISIG_TYPE);\n     }\n \n     public boolean isSentToCLTVPaymentChannel() {\n@@ -729,7 +750,7 @@ private static BigInteger castToBigInteger(byte[] chunk) throws ScriptException\n     /**\n      * Cast a script chunk to a BigInteger. Normally you would want\n      * {@link #castToBigInteger(byte[])} instead, this is only for cases where\n-     * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY).\n+     * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).\n      *\n      * @param maxLength the maximum length in bytes.\n      * @throws ScriptException if the chunk is longer than the specified maximum.\n@@ -1266,10 +1287,19 @@ public static void executeScript(@Nullable BtcTransaction txContainingThis, long\n                         }\n                         break;\n                     }\n-                    executeCheckLockTimeVerify(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);\n+                    executeCheckLockTimeVerify(txContainingThis, (int) index, stack);\n+                    break;\n+                case OP_CHECKSEQUENCEVERIFY:\n+                    if (!verifyFlags.contains(VerifyFlag.CHECKSEQUENCEVERIFY)) {\n+                        // not enabled; treat as a NOP3\n+                        if (verifyFlags.contains(VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)) {\n+                            throw new ScriptException(\"Script used a reserved opcode \" + opcode);\n+                        }\n+                        break;\n+                    }\n+                    executeCheckSequenceVerify(txContainingThis, (int) index, stack);\n                     break;\n                 case OP_NOP1:\n-                case OP_NOP3:\n                 case OP_NOP4:\n                 case OP_NOP5:\n                 case OP_NOP6:\n@@ -1296,9 +1326,7 @@ public static void executeScript(@Nullable BtcTransaction txContainingThis, long\n     }\n \n     // This is more or less a direct translation of the code in Bitcoin Core\n-    private static void executeCheckLockTimeVerify(BtcTransaction txContainingThis, int index, Script script, LinkedList<byte[]> stack,\n-                                                   int lastCodeSepLocation, int opcode,\n-                                                   Set<VerifyFlag> verifyFlags) throws ScriptException {\n+    private static void executeCheckLockTimeVerify(BtcTransaction txContainingThis, int index, LinkedList<byte[]> stack) throws ScriptException {\n         if (stack.size() < 1)\n             throw new ScriptException(\"Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1\");\n \n@@ -1335,6 +1363,81 @@ private static void executeCheckLockTimeVerify(BtcTransaction txContainingThis,\n             throw new ScriptException(\"Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.\");\n     }\n \n+    private static void executeCheckSequenceVerify(BtcTransaction txContainingThis, int index, LinkedList<byte[]> stack) throws ScriptException {\n+        if (stack.size() < 1)\n+            throw new ScriptException(\"Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1\");\n+\n+        // Note that elsewhere numeric opcodes are limited to\n+        // operands in the range -2**31+1 to 2**31-1, however it is\n+        // legal for opcodes to produce results exceeding that\n+        // range. This limitation is implemented by CScriptNum's\n+        // default 4-byte limit.\n+        //\n+        // Thus as a special case we tell CScriptNum to accept up\n+        // to 5-byte bignums, which are good until 2**39-1, well\n+        // beyond the 2**32-1 limit of the nSequence field itself.\n+        final long nSequence = castToBigInteger(stack.getLast(), 5).longValue();\n+\n+        // In the rare event that the argument may be < 0 due to\n+        // some arithmetic being done first, you can always use\n+        // 0 MAX CHECKSEQUENCEVERIFY.\n+        if (nSequence < 0)\n+            throw new ScriptException(\"Negative sequence\");\n+\n+        // To provide for future soft-fork extensibility, if the\n+        // operand has the disabled lock-time flag set,\n+        // CHECKSEQUENCEVERIFY behaves as a NOP.\n+        if ((nSequence & BtcTransaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)\n+            return;\n+\n+        // Compare the specified sequence number with the input.\n+        if (!checkSequence(nSequence, txContainingThis, index))\n+            throw new ScriptException(\"Unsatisfied CHECKLOCKTIMEVERIFY lock time\");\n+    }\n+\n+    private static boolean checkSequence(long nSequence, BtcTransaction txContainingThis, int index) {\n+        // Relative lock times are supported by comparing the passed\n+        // in operand to the sequence number of the input.\n+        long txToSequence = txContainingThis.getInput(index).getSequenceNumber();\n+\n+        // Fail if the transaction's version number is not set high\n+        // enough to trigger BIP 68 rules.\n+        if (txContainingThis.getVersion() < 2)\n+            return false;\n+\n+        // Sequence numbers with their most significant bit set are not\n+        // consensus constrained. Testing that the transaction's sequence\n+        // number do not have this bit set prevents using this property\n+        // to get around a CHECKSEQUENCEVERIFY check.\n+        if ((txToSequence & BtcTransaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)\n+            return false;\n+\n+        // Mask off any bits that do not have consensus-enforced meaning\n+        // before doing the integer comparisons\n+        long nLockTimeMask =  BtcTransaction.SEQUENCE_LOCKTIME_TYPE_FLAG | BtcTransaction.SEQUENCE_LOCKTIME_MASK;\n+        long txToSequenceMasked = txToSequence & nLockTimeMask;\n+        long nSequenceMasked = nSequence & nLockTimeMask;\n+\n+        // There are two kinds of nSequence: lock-by-blockheight\n+        // and lock-by-blocktime, distinguished by whether\n+        // nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n+        //\n+        // We want to compare apples to apples, so fail the script\n+        // unless the type of nSequenceMasked being tested is the same as\n+        // the nSequenceMasked in the transaction.\n+        if (!((txToSequenceMasked < BtcTransaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked < BtcTransaction.SEQUENCE_LOCKTIME_TYPE_FLAG) ||\n+            (txToSequenceMasked >= BtcTransaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= BtcTransaction.SEQUENCE_LOCKTIME_TYPE_FLAG))) {\n+            return false;\n+        }\n+\n+        // Now that we know we're comparing apples-to-apples, the\n+        // comparison is a simple numeric one.\n+        if (nSequenceMasked > txToSequenceMasked)\n+            return false;\n+\n+        return true;\n+    }\n+\n     private static void executeCheckSig(BtcTransaction txContainingThis, int index, Script script, LinkedList<byte[]> stack,\n                                         int lastCodeSepLocation, int opcode,\n                                         Set<VerifyFlag> verifyFlags) throws ScriptException {"
  },
  {
    "sha": "ed69f8948ab7de72c3820ced43c3d974dea2d6d2",
    "filename": "src/main/java/co/rsk/bitcoinj/script/ScriptBuilder.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptBuilder.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptBuilder.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/ScriptBuilder.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -64,6 +64,12 @@ public ScriptBuilder addChunk(int index, ScriptChunk chunk) {\n         return this;\n     }\n \n+    /** Adds the given list of chunks to the end of the program */\n+    public ScriptBuilder addChunks(List<ScriptChunk> chunks) {\n+        chunks.forEach(chunk -> addChunk(chunk));\n+        return this;\n+    }\n+\n     /** Adds the given opcode to the end of the program. */\n     public ScriptBuilder op(int opcode) {\n         return op(chunks.size(), opcode);"
  },
  {
    "sha": "e1c3eda922d665f2882a7e6f0ee35cbf4c74fd86",
    "filename": "src/main/java/co/rsk/bitcoinj/script/ScriptOpCodes.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptOpCodes.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptOpCodes.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/ScriptOpCodes.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -17,7 +17,6 @@\n package co.rsk.bitcoinj.script;\n \n import com.google.common.collect.ImmutableMap;\n-\n import java.util.Map;\n \n /**\n@@ -145,13 +144,16 @@\n     // block state\n     /** Check lock time of the block. Introduced in BIP 65, replacing OP_NOP2 */\n     public static final int OP_CHECKLOCKTIMEVERIFY = 0xb1;\n+    public static final int OP_CHECKSEQUENCEVERIFY = 0xb2;\n \n     // expansion\n     public static final int OP_NOP1 = 0xb0;\n     /** Deprecated by BIP 65 */\n     @Deprecated\n     public static final int OP_NOP2 = OP_CHECKLOCKTIMEVERIFY;\n-    public static final int OP_NOP3 = 0xb2;\n+    /** Deprecated by BIP 112 */\n+    @Deprecated\n+    public static final int OP_NOP3 = OP_CHECKSEQUENCEVERIFY;\n     public static final int OP_NOP4 = 0xb3;\n     public static final int OP_NOP5 = 0xb4;\n     public static final int OP_NOP6 = 0xb5;\n@@ -265,7 +267,7 @@\n         .put(OP_CHECKMULTISIGVERIFY, \"CHECKMULTISIGVERIFY\")\n         .put(OP_NOP1, \"NOP1\")\n         .put(OP_CHECKLOCKTIMEVERIFY, \"CHECKLOCKTIMEVERIFY\")\n-        .put(OP_NOP3, \"NOP3\")\n+        .put(OP_CHECKSEQUENCEVERIFY, \"CHECKSEQUENCEVERIFY\")\n         .put(OP_NOP4, \"NOP4\")\n         .put(OP_NOP5, \"NOP5\")\n         .put(OP_NOP6, \"NOP6\")\n@@ -378,6 +380,7 @@\n         .put(\"CHECKMULTISIGVERIFY\", OP_CHECKMULTISIGVERIFY)\n         .put(\"NOP1\", OP_NOP1)\n         .put(\"CHECKLOCKTIMEVERIFY\", OP_CHECKLOCKTIMEVERIFY)\n+        .put(\"CHECKSEQUENCEVERIFY\", OP_CHECKSEQUENCEVERIFY)\n         .put(\"NOP2\", OP_NOP2)\n         .put(\"NOP3\", OP_NOP3)\n         .put(\"NOP4\", OP_NOP4)"
  },
  {
    "sha": "3f6ef22e0fd5ef6edd8264e1ca2b5ad8b81b93d7",
    "filename": "src/main/java/co/rsk/bitcoinj/script/ScriptPattern.java",
    "status": "modified",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptPattern.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/ScriptPattern.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/ScriptPattern.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -19,7 +19,6 @@\n \n import co.rsk.bitcoinj.core.Sha256Hash;\n import co.rsk.bitcoinj.core.Utils;\n-\n import java.util.Arrays;\n import java.util.List;\n "
  },
  {
    "sha": "750a10846ce1efe1384ee0a9558dcf782ab0c82f",
    "filename": "src/main/java/co/rsk/bitcoinj/script/StandardRedeemScriptParser.java",
    "status": "modified",
    "additions": 34,
    "deletions": 37,
    "changes": 71,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/StandardRedeemScriptParser.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/main/java/co/rsk/bitcoinj/script/StandardRedeemScriptParser.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/main/java/co/rsk/bitcoinj/script/StandardRedeemScriptParser.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -18,34 +18,26 @@\n \n     protected MultiSigType multiSigType;\n     protected ScriptType scriptType;\n-    protected List<ScriptChunk> chunks;\n-    protected List<ScriptChunk> redeemScript;\n+    // In case of P2SH represents a scriptSig, where the last chunk is the redeem script (either standard or extended)\n+    protected List<ScriptChunk> rawChunks;\n+    // Standard redeem script\n+    protected List<ScriptChunk> redeemScriptChunks;\n \n     public StandardRedeemScriptParser(\n         ScriptType scriptType,\n-        List<ScriptChunk> redeemScript,\n-        List<ScriptChunk> chunks\n+        List<ScriptChunk> redeemScriptChunks,\n+        List<ScriptChunk> rawChunks\n     ) {\n         this.multiSigType = MultiSigType.STANDARD_MULTISIG;\n         this.scriptType = scriptType;\n-        this.redeemScript = redeemScript;\n+        this.redeemScriptChunks = redeemScriptChunks;\n \n-        this.chunks = Collections.unmodifiableList(new ArrayList<>(chunks));\n+        this.rawChunks = Collections.unmodifiableList(new ArrayList<>(rawChunks));\n     }\n \n     @Override\n-    public boolean isStandardMultiSig() {\n-        return this.multiSigType == MultiSigType.STANDARD_MULTISIG;\n-    }\n-\n-    @Override\n-    public boolean isFastBridgeMultiSig() {\n-        return this.multiSigType == MultiSigType.FAST_BRIDGE_MULTISIG;\n-    }\n-\n-    @Override\n-    public boolean isNotMultiSig() {\n-        return false;\n+    public MultiSigType getMultiSigType() {\n+        return this.multiSigType;\n     }\n \n     @Override\n@@ -55,22 +47,23 @@ public ScriptType getScriptType() {\n \n     @Override\n     public int getM() {\n-        return Script.decodeFromOpN(redeemScript.get(0).opcode);\n+        checkArgument(redeemScriptChunks.get(0).isOpCode());\n+        return Script.decodeFromOpN(redeemScriptChunks.get(0).opcode);\n     }\n \n     @Override\n     public int getSigInsertionIndex(Sha256Hash hash, BtcECKey signingKey) {\n         // Iterate over existing signatures, skipping the initial OP_0, the final redeem script\n         // and any placeholder OP_0 sigs.\n-        List<ScriptChunk> existingChunks = chunks.subList(1, chunks.size() - 1);\n-        Script redeemScript = new Script(this.redeemScript);\n+        List<ScriptChunk> existingChunks = rawChunks.subList(1, rawChunks.size() - 1);\n+        Script redeemScript = new Script(this.redeemScriptChunks);\n \n         int sigCount = 0;\n         int myIndex = redeemScript.findKeyInRedeem(signingKey);\n         Iterator chunkIterator = existingChunks.iterator();\n \n         while(chunkIterator.hasNext()) {\n-            ScriptChunk chunk = (ScriptChunk)chunkIterator.next();\n+            ScriptChunk chunk = (ScriptChunk) chunkIterator.next();\n             if (chunk.opcode != 0) {\n                 Preconditions.checkNotNull(chunk.data);\n                 if (myIndex < redeemScript.findSigInRedeem(chunk.data, hash)) {\n@@ -86,47 +79,51 @@ public int getSigInsertionIndex(Sha256Hash hash, BtcECKey signingKey) {\n \n     @Override\n     public int findKeyInRedeem(BtcECKey key) {\n-        List<ScriptChunk> chunks = redeemScript;\n-        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig\n-        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);\n+        checkArgument(redeemScriptChunks.get(0).isOpCode()); // P2SH scriptSig\n+        int numKeys = Script.decodeFromOpN(redeemScriptChunks.get(redeemScriptChunks.size() - 2).opcode);\n         for (int i = 0; i < numKeys; i++) {\n-            if (Arrays.equals(chunks.get(1 + i).data, key.getPubKey())) {\n+            if (Arrays.equals(redeemScriptChunks.get(1 + i).data, key.getPubKey())) {\n                 return i;\n             }\n         }\n \n-        throw new IllegalStateException(\n-            \"Could not find matching key \" + key.toString() + \" in script \" + this);\n+        throw new IllegalStateException(\"Could not find matching key \" + key.toString() + \" in script \" + this);\n     }\n \n     @Override\n     public List<BtcECKey> getPubKeys() {\n-        List<ScriptChunk> chunks = redeemScript;\n-\n         ArrayList<BtcECKey> result = Lists.newArrayList();\n-        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);\n+        int numKeys = Script.decodeFromOpN(redeemScriptChunks.get(redeemScriptChunks.size() - 2).opcode);\n         for (int i = 0; i < numKeys; i++) {\n-            result.add(BtcECKey.fromPublicOnly(chunks.get(1 + i).data));\n+            result.add(BtcECKey.fromPublicOnly(redeemScriptChunks.get(1 + i).data));\n         }\n \n         return result;\n     }\n \n     @Override\n     public int findSigInRedeem(byte[] signatureBytes, Sha256Hash hash) {\n-        List<ScriptChunk> chunks = redeemScript;\n-        checkArgument(chunks.get(0).isOpCode()); // P2SH scriptSig\n-        int numKeys = Script.decodeFromOpN(chunks.get(chunks.size() - 2).opcode);\n+        checkArgument(redeemScriptChunks.get(0).isOpCode()); // P2SH scriptSig\n+        int numKeys = Script.decodeFromOpN(redeemScriptChunks.get(redeemScriptChunks.size() - 2).opcode);\n         TransactionSignature signature = TransactionSignature\n             .decodeFromBitcoin(signatureBytes, true);\n         for (int i = 0; i < numKeys; i++) {\n-            if (BtcECKey.fromPublicOnly(chunks.get(i + 1).data).verify(hash, signature)) {\n+            if (BtcECKey.fromPublicOnly(redeemScriptChunks.get(i + 1).data).verify(hash, signature)) {\n                 return i;\n             }\n         }\n         throw new IllegalStateException(\n             \"Could not find matching key for signature on \" + hash.toString() + \" sig \"\n-                + Utils.HEX.encode(signatureBytes));\n+                + Utils.HEX.encode(signatureBytes)\n+        );\n+    }\n+\n+    @Override\n+    public Script extractStandardRedeemScript() {\n+        return new Script(redeemScriptChunks);\n     }\n \n+    public static boolean isStandardMultiSig(List<ScriptChunk> chunks) {\n+        return RedeemScriptValidator.hasStandardRedeemScriptStructure(chunks);\n+    }\n }"
  },
  {
    "sha": "f7304e3f452e6bd8a219ea098a3bd7900529abed",
    "filename": "src/test/java/co/rsk/bitcoinj/RedeemScriptUtil.java",
    "status": "removed",
    "additions": 0,
    "deletions": 52,
    "changes": 52,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/dadb9af0d4f7045f35a28e2570018c6cbf0f62c4/src/test/java/co/rsk/bitcoinj/RedeemScriptUtil.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/dadb9af0d4f7045f35a28e2570018c6cbf0f62c4/src/test/java/co/rsk/bitcoinj/RedeemScriptUtil.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/RedeemScriptUtil.java?ref=dadb9af0d4f7045f35a28e2570018c6cbf0f62c4",
    "patch": "@@ -1,52 +0,0 @@\n-package co.rsk.bitcoinj;\n-\n-import co.rsk.bitcoinj.core.BtcECKey;\n-import co.rsk.bitcoinj.script.Script;\n-import co.rsk.bitcoinj.script.ScriptBuilder;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public class RedeemScriptUtil {\n-\n-    public static Script createStandardRedeemScript(List<BtcECKey> btcECKeyList) {\n-        return ScriptBuilder.createRedeemScript(2, btcECKeyList);\n-    }\n-\n-    public static Script createFastBridgeRedeemScript(\n-        byte[] derivationArgumentsHashBytes,\n-        List<BtcECKey> btcECKeyList\n-    ) {\n-        Script redeem = ScriptBuilder.createRedeemScript(2, btcECKeyList);\n-        byte[] program = redeem.getProgram();\n-        byte[] reed = Arrays.copyOf(program, program.length);\n-        byte[] prefix = new byte[33];\n-\n-        // Hash length\n-        prefix[0] = 0x20;\n-        System.arraycopy(derivationArgumentsHashBytes, 0, prefix, 1,\n-            derivationArgumentsHashBytes.length);\n-\n-        byte[] c = new byte[prefix.length + 1 + reed.length];\n-        System.arraycopy(prefix, 0, c, 0, prefix.length);\n-\n-        // OP_DROP to ignore pushed hash\n-        c[prefix.length] = 0x75;\n-        System.arraycopy(reed, 0, c, prefix.length + 1, reed.length);\n-\n-        return new Script(c);\n-    }\n-\n-    public static Script createCustomRedeemScript(List<BtcECKey> btcECKeyList) {\n-            Script redeem = ScriptBuilder.createRedeemScript(2, btcECKeyList);\n-            byte[] program = redeem.getProgram();\n-            byte[] reed = Arrays.copyOf(program, program.length);\n-            byte[] c = new byte[1 + reed.length];\n-            System.arraycopy(new byte[0], 0, c, 0, 0);\n-\n-            // Add OP_DROP\n-            c[0] = 0x75;\n-            System.arraycopy(reed, 0, c, 1, reed.length);\n-\n-            return new Script(c);\n-    }\n-}"
  },
  {
    "sha": "d4188f45e7943d8c38e2c092f0e6b8255e5b1b3c",
    "filename": "src/test/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParserTest.java",
    "status": "added",
    "additions": 124,
    "deletions": 0,
    "changes": 124,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParserTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParserTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/ErpFederationRedeemScriptParserTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,124 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ErpFederationRedeemScriptParserTest {\n+\n+    private final List<BtcECKey> defaultFedBtcECKeyList = new ArrayList<>();\n+    private final List<BtcECKey> erpFedBtcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final BtcECKey ecKey4 = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+    private final BtcECKey ecKey5 = BtcECKey.fromPrivate(BigInteger.valueOf(500));\n+    private final BtcECKey ecKey6 = BtcECKey.fromPrivate(BigInteger.valueOf(600));\n+    private final BtcECKey ecKey7 = BtcECKey.fromPrivate(BigInteger.valueOf(700));\n+    private final BtcECKey ecKey8 = BtcECKey.fromPrivate(BigInteger.valueOf(800));\n+\n+    @Before\n+    public void setUp() {\n+        defaultFedBtcECKeyList.add(ecKey1);\n+        defaultFedBtcECKeyList.add(ecKey2);\n+        defaultFedBtcECKeyList.add(ecKey3);\n+        erpFedBtcECKeyList.add(ecKey4);\n+        erpFedBtcECKeyList.add(ecKey5);\n+        erpFedBtcECKeyList.add(ecKey6);\n+        erpFedBtcECKeyList.add(ecKey7);\n+        erpFedBtcECKeyList.add(ecKey8);\n+    }\n+\n+    @Test\n+    public void extractStandardRedeemScript_fromErpRedeemScript() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            100L\n+        );\n+        Script standardRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+\n+        Script obtainedRedeemScript = ErpFederationRedeemScriptParser.extractStandardRedeemScript(\n+            erpRedeemScript.getChunks()\n+        );\n+\n+        Assert.assertEquals(standardRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void extractStandardRedeemScript_fromStandardRedeemScript_fail() {\n+        Script standardRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+\n+        ErpFederationRedeemScriptParser.extractStandardRedeemScript(standardRedeemScript.getChunks());\n+    }\n+\n+    @Test\n+    public void createErpRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+\n+        Script expectedErpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue\n+        );\n+\n+        Script obtainedRedeemScript = ErpFederationRedeemScriptParser.createErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue\n+        );\n+\n+        Assert.assertEquals(expectedErpRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createErpRedeemScript_invalidDefaultFederationRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+\n+        ErpFederationRedeemScriptParser.createErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue\n+        );\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createErpRedeemScript_invalidErpFederationRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createCustomRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+\n+        ErpFederationRedeemScriptParser.createErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue\n+        );\n+    }\n+\n+    @Test\n+    public void isErpFed() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            200L\n+        );\n+\n+        Assert.assertTrue(ErpFederationRedeemScriptParser.isErpFed(erpRedeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void isErpFed_falseWithCustomRedeemScript() {\n+        Script customRedeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+\n+        Assert.assertFalse(ErpFederationRedeemScriptParser.isErpFed(customRedeemScript.getChunks()));\n+    }\n+}"
  },
  {
    "sha": "a88d0572f4fd3be815e26b84ba60f4ffe03b133c",
    "filename": "src/test/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParserTest.java",
    "status": "added",
    "additions": 162,
    "deletions": 0,
    "changes": 162,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParserTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParserTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/FastBridgeErpRedeemScriptParserTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,162 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class FastBridgeErpRedeemScriptParserTest {\n+\n+    private final List<BtcECKey> defaultFedBtcECKeyList = new ArrayList<>();\n+    private final List<BtcECKey> erpFedBtcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final BtcECKey ecKey4 = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+    private final BtcECKey ecKey5 = BtcECKey.fromPrivate(BigInteger.valueOf(500));\n+    private final BtcECKey ecKey6 = BtcECKey.fromPrivate(BigInteger.valueOf(600));\n+    private final BtcECKey ecKey7 = BtcECKey.fromPrivate(BigInteger.valueOf(700));\n+    private final BtcECKey ecKey8 = BtcECKey.fromPrivate(BigInteger.valueOf(800));\n+\n+    @Before\n+    public void setUp() {\n+        defaultFedBtcECKeyList.add(ecKey1);\n+        defaultFedBtcECKeyList.add(ecKey2);\n+        defaultFedBtcECKeyList.add(ecKey3);\n+        erpFedBtcECKeyList.add(ecKey4);\n+        erpFedBtcECKeyList.add(ecKey5);\n+        erpFedBtcECKeyList.add(ecKey6);\n+        erpFedBtcECKeyList.add(ecKey7);\n+        erpFedBtcECKeyList.add(ecKey8);\n+    }\n+\n+    @Test\n+    public void extractStandardRedeemScript_fromFastBridgeErpRedeemScript() {\n+        Long csvValue = 100L;\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue,\n+            derivationArgumentsHash.getBytes()\n+        );\n+\n+        Script standardRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+\n+        Script obtainedRedeemScript = FastBridgeErpRedeemScriptParser.extractStandardRedeemScript(\n+            fastBridgeErpRedeemScript.getChunks()\n+        );\n+\n+        Assert.assertEquals(standardRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void extractStandardRedeemScript_fromStandardRedeemScript_fail() {\n+        Script standardRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+\n+        FastBridgeErpRedeemScriptParser.extractStandardRedeemScript(standardRedeemScript.getChunks());\n+    }\n+\n+    @Test\n+    public void createFastBridgeErpRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+\n+        Script expectedErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue,\n+            derivationArgumentsHash.getBytes()\n+        );\n+\n+        Script obtainedRedeemScript = FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue,\n+            derivationArgumentsHash\n+        );\n+\n+        Assert.assertEquals(expectedErpRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test\n+    public void createFastBridgeErpRedeemScript_from_Erp_redeem_script() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            5063L\n+        );\n+\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+\n+        Script expectedRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            5063L,\n+            derivationArgumentsHash.getBytes()\n+        );\n+\n+        Script obtainedRedeemScript = FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            erpRedeemScript,\n+            derivationArgumentsHash\n+        );\n+\n+        Assert.assertEquals(expectedRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createFastBridgeErpRedeemScript_invalidDefaultFederationRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+\n+        FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue,\n+            derivationArgumentsHash\n+        );\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createFastBridgeErpRedeemScript_invalidErpFederationRedeemScript() {\n+        Script defaultFederationRedeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Script erpFederationRedeemScript = RedeemScriptUtils.createCustomRedeemScript(erpFedBtcECKeyList);\n+        Long csvValue = 200L;\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+\n+        FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            defaultFederationRedeemScript,\n+            erpFederationRedeemScript,\n+            csvValue,\n+            derivationArgumentsHash\n+        );\n+    }\n+\n+    @Test\n+    public void isFastBridgeErpFed() {\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            200L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Assert.assertTrue(FastBridgeErpRedeemScriptParser.isFastBridgeErpFed(fastBridgeErpRedeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void isFastBridgeErpFed_falseWithCustomRedeemScript() {\n+        Script customRedeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+\n+        Assert.assertFalse(FastBridgeErpRedeemScriptParser.isFastBridgeErpFed(customRedeemScript.getChunks()));\n+    }\n+}"
  },
  {
    "sha": "034511e65776610ac14e3a37a4a8eb6533a8165e",
    "filename": "src/test/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParserTest.java",
    "status": "added",
    "additions": 122,
    "deletions": 0,
    "changes": 122,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParserTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParserTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/FastBridgeRedeemScriptParserTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,122 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class FastBridgeRedeemScriptParserTest {\n+\n+    private final List<BtcECKey> btcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+\n+    @Before\n+    public void setUp() {\n+        btcECKeyList.add(ecKey1);\n+        btcECKeyList.add(ecKey2);\n+        btcECKeyList.add(ecKey3);\n+    }\n+\n+    @Test\n+    public void extractRedeemScriptFromMultiSigFastBridgeRedeemScript_fb_redeem_script() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        Script standardRedeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+\n+        Script obtainedRedeemScript = FastBridgeRedeemScriptParser.extractStandardRedeemScript(\n+            fastBridgeRedeemScript\n+        );\n+\n+        Assert.assertEquals(standardRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test\n+    public void extractRedeemScriptFromMultiSigFastBridgeRedeemScript_std_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        Script obtainedRedeemScript =\n+            FastBridgeRedeemScriptParser.extractStandardRedeemScript(redeemScript);\n+\n+        Assert.assertEquals(redeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test\n+    public void createMultiSigFastBridgeRedeemScript_valid_parameters() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+\n+        Script expectedFastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            derivationArgumentsHash.getBytes(),\n+            btcECKeyList\n+        );\n+\n+        Script obtainedRedeemScript = FastBridgeRedeemScriptParser\n+            .createMultiSigFastBridgeRedeemScript(redeemScript, derivationArgumentsHash);\n+        Assert.assertEquals(expectedFastBridgeRedeemScript, obtainedRedeemScript);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createMultiSigFastBridgeRedeemScript_fb_redeem_script() {\n+        Sha256Hash data = Sha256Hash.of(new byte[]{1});\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data.getBytes(),\n+            btcECKeyList\n+        );\n+\n+        FastBridgeRedeemScriptParser.createMultiSigFastBridgeRedeemScript(fastBridgeRedeemScript, data);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createMultiSigFastBridgeRedeemScript_null_derivation_arguments_hash() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        FastBridgeRedeemScriptParser.createMultiSigFastBridgeRedeemScript(redeemScript, null);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void createMultiSigFastBridgeRedeemScript_zero_hash_as_derivation_arguments_hash() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        FastBridgeRedeemScriptParser.createMultiSigFastBridgeRedeemScript(redeemScript, Sha256Hash.ZERO_HASH);\n+    }\n+\n+    @Test\n+    public void getDerivationArgumentsHash_from_fast_bridge_multiSig() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+        FastBridgeRedeemScriptParser fastBridgeRedeemScriptParser = (FastBridgeRedeemScriptParser) parser;\n+\n+        Assert.assertArrayEquals(fastBridgeRedeemScriptParser.getDerivationHash(), data);\n+    }\n+\n+    @Test\n+    public void isFastBridgeMultisig() {\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            derivationArgumentsHash.getBytes(),\n+            btcECKeyList\n+        );\n+\n+        Assert.assertTrue(FastBridgeRedeemScriptParser.isFastBridgeMultiSig(fastBridgeRedeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void isFastBridgeMultisig_falseWithCustomRedeemScrip() {\n+        Script customRedeemScript = RedeemScriptUtils.createCustomRedeemScript(btcECKeyList);\n+\n+        Assert.assertFalse(FastBridgeRedeemScriptParser.isFastBridgeMultiSig(customRedeemScript.getChunks()));\n+    }\n+}"
  },
  {
    "sha": "35399b0793f114d89b91fd856ec23947981e0c95",
    "filename": "src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserFactoryTest.java",
    "status": "added",
    "additions": 184,
    "deletions": 0,
    "changes": 184,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserFactoryTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserFactoryTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserFactoryTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,184 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.script.RedeemScriptParser.MultiSigType;\n+import co.rsk.bitcoinj.script.RedeemScriptParser.ScriptType;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RedeemScriptParserFactoryTest {\n+\n+    private final List<BtcECKey> defaultFedBtcECKeyList = new ArrayList<>();\n+    private final List<BtcECKey> erpFedBtcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final BtcECKey ecKey4 = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+    private final BtcECKey ecKey5 = BtcECKey.fromPrivate(BigInteger.valueOf(500));\n+    private final BtcECKey ecKey6 = BtcECKey.fromPrivate(BigInteger.valueOf(600));\n+    private final BtcECKey ecKey7 = BtcECKey.fromPrivate(BigInteger.valueOf(700));\n+    private final BtcECKey ecKey8 = BtcECKey.fromPrivate(BigInteger.valueOf(800));\n+\n+    @Before\n+    public void setUp() {\n+        defaultFedBtcECKeyList.add(ecKey1);\n+        defaultFedBtcECKeyList.add(ecKey2);\n+        defaultFedBtcECKeyList.add(ecKey3);\n+        erpFedBtcECKeyList.add(ecKey4);\n+        erpFedBtcECKeyList.add(ecKey5);\n+        erpFedBtcECKeyList.add(ecKey6);\n+        erpFedBtcECKeyList.add(ecKey7);\n+        erpFedBtcECKeyList.add(ecKey8);\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_fast_bridge_multiSig_chunk() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            defaultFedBtcECKeyList\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+        Assert.assertEquals(MultiSigType.FAST_BRIDGE_MULTISIG, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_standard_multiSig_chunk() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.STANDARD_MULTISIG, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_erp_multiSig_chunk() {\n+        Script redeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.ERP_FED, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_erp_fast_bridge_multiSig_chunk() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.FAST_BRIDGE_ERP_FED, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_fast_bridge_P2SH_chunk() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            defaultFedBtcECKeyList\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(null, fastBridgeRedeemScript);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.FAST_BRIDGE_MULTISIG, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.P2SH, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_standard_P2SH_chunk() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.STANDARD_MULTISIG, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.P2SH, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_erp_P2SH_chunk() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(null, erpRedeemScript);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.ERP_FED, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.P2SH, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_fast_bridge_erp_P2SH_chunk() {\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(null, fastBridgeErpRedeemScript);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.FAST_BRIDGE_ERP_FED, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.P2SH, parser.getScriptType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_custom_redeem_script_no_multiSig() {\n+        Script redeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.NO_MULTISIG_TYPE, parser.getMultiSigType());\n+    }\n+\n+    @Test\n+    public void create_RedeemScriptParser_object_from_custom_redeem_script_insufficient_chunks() {\n+        Script redeemScript = new Script(new byte[2]);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(MultiSigType.NO_MULTISIG_TYPE, parser.getMultiSigType());\n+        Assert.assertEquals(ScriptType.UNDEFINED, parser.getScriptType());\n+    }\n+}"
  },
  {
    "sha": "46aab5e487a6adb94e4ea65a4120476ab454f842",
    "filename": "src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 360,
    "changes": 360,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/dadb9af0d4f7045f35a28e2570018c6cbf0f62c4/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/dadb9af0d4f7045f35a28e2570018c6cbf0f62c4/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/RedeemScriptParserTest.java?ref=dadb9af0d4f7045f35a28e2570018c6cbf0f62c4",
    "patch": "@@ -1,360 +0,0 @@\n-package co.rsk.bitcoinj.script;\n-\n-import co.rsk.bitcoinj.RedeemScriptUtil;\n-import co.rsk.bitcoinj.core.BtcECKey;\n-import co.rsk.bitcoinj.core.BtcTransaction;\n-import co.rsk.bitcoinj.core.Coin;\n-import co.rsk.bitcoinj.core.NetworkParameters;\n-import co.rsk.bitcoinj.core.ScriptException;\n-import co.rsk.bitcoinj.core.Sha256Hash;\n-import co.rsk.bitcoinj.core.VerificationException;\n-import co.rsk.bitcoinj.crypto.TransactionSignature;\n-import co.rsk.bitcoinj.script.RedeemScriptParser.ScriptType;\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-public class RedeemScriptParserTest {\n-    private final List<BtcECKey> btcECKeyList = new ArrayList<>();\n-    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n-    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n-    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n-\n-    @Before\n-    public void setUp() {\n-        btcECKeyList.add(ecKey1);\n-        btcECKeyList.add(ecKey2);\n-        btcECKeyList.add(ecKey3);\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_fast_bridge_multiSig_chunk() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n-        Assert.assertTrue(ms.isFastBridgeMultiSig());\n-        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, ms.getScriptType());\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_standard_multiSig_chunk() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        Assert.assertTrue(ms.isStandardMultiSig());\n-        Assert.assertEquals(ScriptType.REDEEM_SCRIPT, ms.getScriptType());\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_fast_bridge_P2SH_chunk() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n-\n-        Script inputScript = spk.createEmptyInputScript(null, fastBridgeRedeemScript);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        Assert.assertTrue(ms.isFastBridgeMultiSig());\n-        Assert.assertEquals(ScriptType.P2SH, ms.getScriptType());\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_standard_P2SH_chunk() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-\n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n-\n-        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        Assert.assertTrue(ms.isStandardMultiSig());\n-        Assert.assertEquals(ScriptType.P2SH, ms.getScriptType());\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_custom_redeem_script_no_multiSig() {\n-        Script redeemScript = RedeemScriptUtil.createCustomRedeemScript(btcECKeyList);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        Assert.assertTrue(ms.isNotMultiSig());\n-    }\n-\n-    @Test\n-    public void create_RedeemScriptParser_object_from_custom_redeem_script_insufficient_chunks() {\n-        Script redeemScript = new Script(new byte[2]);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        Assert.assertTrue(ms.isNotMultiSig());\n-        Assert.assertEquals(ScriptType.UNDEFINED, ms.getScriptType());\n-    }\n-\n-    @Test\n-    public void getDerivationArgumentsHash_from_fast_bridge_multiSig() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        FastBridgeRedeemScriptParser ms =\n-            (FastBridgeRedeemScriptParser) RedeemScriptParserFactory.get(\n-                fastBridgeRedeemScript.getChunks()\n-            );\n-        Assert.assertArrayEquals(ms.getDerivationHash(), data);\n-    }\n-\n-    @Test\n-    public void getSigInsertionIndex_fast_bridge_redeem_script() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n-\n-        BtcTransaction fundTx = new BtcTransaction(networkParameters);\n-        fundTx.addOutput(Coin.FIFTY_COINS, ecKey1.toAddress(networkParameters));\n-\n-        BtcTransaction spendTx = new BtcTransaction(networkParameters);\n-        spendTx.addInput(fundTx.getOutput(0));\n-\n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n-\n-        Script inputScript = spk.createEmptyInputScript(null, fastBridgeRedeemScript);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        Sha256Hash sigHash = spendTx.hashForSignature(0, fastBridgeRedeemScript,\n-            BtcTransaction.SigHash.ALL, false);\n-\n-        BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n-        TransactionSignature txSig = new TransactionSignature(sign1,\n-            BtcTransaction.SigHash.ALL, false);\n-\n-        byte[] txSigEncoded = txSig.encodeToBitcoin();\n-\n-        int sigIndex = ms.getSigInsertionIndex(sigHash, ecKey1);\n-        Assert.assertEquals(0, sigIndex);\n-\n-        inputScript = ScriptBuilder.updateScriptWithSignature(inputScript, txSigEncoded,\n-            sigIndex, 1, 1);\n-\n-        RedeemScriptParser ms2 = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        sigIndex = ms2.getSigInsertionIndex(sigHash, ecKey2);\n-        Assert.assertEquals(1, sigIndex);\n-    }\n-\n-    @Test\n-    public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n-\n-        BtcTransaction fundTx = new BtcTransaction(networkParameters);\n-        fundTx.addOutput(Coin.FIFTY_COINS, ecKey1.toAddress(networkParameters));\n-\n-        BtcTransaction spendTx = new BtcTransaction(networkParameters);\n-        spendTx.addInput(fundTx.getOutput(0));\n-\n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n-\n-        Script inputScript = spk.createEmptyInputScript(redeemScript.getPubKeys().get(0),\n-            redeemScript);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        Sha256Hash sigHash = spendTx.hashForSignature(0, redeemScript,\n-            BtcTransaction.SigHash.ALL, false);\n-\n-        BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n-        TransactionSignature txSig = new TransactionSignature(sign1, BtcTransaction.SigHash.ALL, false);\n-        byte[] txSigEncoded = txSig.encodeToBitcoin();\n-\n-        int sigIndex = ms.getSigInsertionIndex(sigHash, ecKey1);\n-        Assert.assertEquals(0, sigIndex);\n-\n-        inputScript = ScriptBuilder.updateScriptWithSignature(inputScript, txSigEncoded,\n-            sigIndex, 1, 1);\n-\n-        RedeemScriptParser ms2 = RedeemScriptParserFactory.get(inputScript.getChunks());\n-\n-        sigIndex = ms2.getSigInsertionIndex(sigHash, ecKey2);\n-        Assert.assertEquals(1, sigIndex);\n-    }\n-\n-    @Test\n-    public void findKeyInRedeem_fast_bridge_redeem_script() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n-        Assert.assertTrue(ms.findKeyInRedeem(ecKey1) >= 0);\n-        Assert.assertTrue(ms.findKeyInRedeem(ecKey2) >= 0);\n-        Assert.assertTrue(ms.findKeyInRedeem(ecKey3) >= 0);\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n-    public void findKeyInRedeem_fast_bridge_redeem_script_no_matching_key() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        BtcECKey unmatchingBtcECKey = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n-\n-        ms.findKeyInRedeem(unmatchingBtcECKey);\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n-    public void findKeyInRedeem_standard_redeem_script_no_matching_key() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        BtcECKey unmatchingBtcECKey = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-\n-        ms.findKeyInRedeem(unmatchingBtcECKey);\n-    }\n-\n-    @Test\n-    public void getPubKeys_fast_bridge_redeem_script() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n-        List<BtcECKey> obtainedList = ms.getPubKeys();\n-\n-        List<String> expectedKeysList = new ArrayList<>();\n-        for (BtcECKey key : btcECKeyList) {\n-            expectedKeysList.add(key.getPublicKeyAsHex());\n-        }\n-\n-        List<String> obtainedKeysList = new ArrayList<>();\n-        for (BtcECKey key : obtainedList) {\n-            obtainedKeysList.add(key.getPublicKeyAsHex());\n-        }\n-\n-        Collections.sort(expectedKeysList);\n-        Collections.sort(obtainedKeysList);\n-\n-        Assert.assertEquals(expectedKeysList, obtainedKeysList);\n-    }\n-\n-    @Test\n-    public void getPubKeys_standard_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        List<BtcECKey> obtainedList = ms.getPubKeys();\n-\n-        List<String> expectedKeysList = new ArrayList<>();\n-        for (BtcECKey key : btcECKeyList) {\n-            expectedKeysList.add(key.getPublicKeyAsHex());\n-        }\n-\n-        List<String> obtainedKeysList = new ArrayList<>();\n-        for (BtcECKey key : obtainedList) {\n-            obtainedKeysList.add(key.getPublicKeyAsHex());\n-        }\n-\n-        Collections.sort(expectedKeysList);\n-        Collections.sort(obtainedKeysList);\n-\n-        Assert.assertEquals(expectedKeysList, obtainedKeysList);\n-    }\n-\n-    @Test(expected = ScriptException.class)\n-    public void getPubKeys_invalid_redeem_script() {\n-        Script script = ScriptBuilder.createP2SHOutputScript(new byte[20]);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(script.getChunks());\n-        ms.getPubKeys();\n-    }\n-\n-    @Test\n-    public void extractRedeemScriptFromMultiSigFastBridgeRedeemScript_fb_redeem_script() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        Script standardRedeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-\n-        Script obtainedRedeemScript = FastBridgeRedeemScriptParser.extractRedeemScriptFromMultiSigFastBridgeRedeemScript(\n-            fastBridgeRedeemScript);\n-\n-        Assert.assertEquals(standardRedeemScript, obtainedRedeemScript);\n-    }\n-\n-    @Test\n-    public void extractRedeemScriptFromMultiSigFastBridgeRedeemScript_std_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        Script obtainedRedeemScript =\n-            FastBridgeRedeemScriptParser.extractRedeemScriptFromMultiSigFastBridgeRedeemScript(redeemScript);\n-\n-        Assert.assertEquals(redeemScript, obtainedRedeemScript);\n-    }\n-\n-    @Test\n-    public void createMultiSigFastBridgeRedeemScript_valid_parameters() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n-\n-        Script expectedFastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            derivationArgumentsHash.getBytes(), btcECKeyList);\n-\n-        Assert.assertEquals(expectedFastBridgeRedeemScript,\n-            FastBridgeRedeemScriptParser\n-                .createMultiSigFastBridgeRedeemScript(redeemScript, derivationArgumentsHash));\n-    }\n-\n-    @Test(expected = VerificationException.class)\n-    public void createMultiSigFastBridgeRedeemScript_fb_redeem_script() {\n-        Sha256Hash data = Sha256Hash.of(new byte[]{1});\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data.getBytes(), btcECKeyList);\n-\n-        FastBridgeRedeemScriptParser\n-            .createMultiSigFastBridgeRedeemScript(fastBridgeRedeemScript, data);\n-    }\n-\n-    @Test(expected = VerificationException.class)\n-    public void createMultiSigFastBridgeRedeemScript_null_derivation_arguments_hash() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        FastBridgeRedeemScriptParser.createMultiSigFastBridgeRedeemScript(redeemScript, null);\n-    }\n-\n-    @Test(expected = VerificationException.class)\n-    public void createMultiSigFastBridgeRedeemScript_zero_hash_as_derivation_arguments_hash() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        FastBridgeRedeemScriptParser.createMultiSigFastBridgeRedeemScript(redeemScript, Sha256Hash.ZERO_HASH);\n-    }\n-\n-    @Test\n-    public void getM_from_no_multiSig() {\n-        Script redeemScript = new Script(new byte[2]);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        Assert.assertEquals(-1, ms.getM());\n-    }\n-\n-    @Test\n-    public void getM_from_multiSig_fast_bridge_redeem_script() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n-\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n-        Assert.assertEquals(2, ms.getM());\n-    }\n-\n-    @Test\n-    public void getM_from_multiSig_standard_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        RedeemScriptParser ms = RedeemScriptParserFactory.get(redeemScript.getChunks());\n-        Assert.assertEquals(2, ms.getM());\n-    }\n-}"
  },
  {
    "sha": "bdbea8d92dfc4b749fbc8c3bc63ce6f50671736a",
    "filename": "src/test/java/co/rsk/bitcoinj/script/RedeemScriptUtils.java",
    "status": "added",
    "additions": 94,
    "deletions": 0,
    "changes": 94,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptUtils.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptUtils.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/RedeemScriptUtils.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,94 @@\n+package co.rsk.bitcoinj.script;\n+\n+import static co.rsk.bitcoinj.script.RedeemScriptValidator.removeOpCheckMultisig;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+public class RedeemScriptUtils {\n+\n+    public static Script createStandardRedeemScript(List<BtcECKey> btcECKeyList) {\n+        return ScriptBuilder.createRedeemScript(btcECKeyList.size() / 2 + 1, btcECKeyList);\n+    }\n+\n+    public static Script createFastBridgeRedeemScript(\n+        byte[] derivationArgumentsHashBytes,\n+        List<BtcECKey> btcECKeyList\n+    ) {\n+        Script redeem = ScriptBuilder.createRedeemScript(\n+            btcECKeyList.size() / 2 + 1,\n+            btcECKeyList\n+        );\n+\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+        return scriptBuilder.data(derivationArgumentsHashBytes)\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(redeem.getChunks())\n+            .build();\n+    }\n+\n+    public static Script createErpRedeemScript(\n+        List<BtcECKey> defaultFedBtcECKeyList,\n+        List<BtcECKey> erpFedBtcECKeyList,\n+        Long csvValue\n+    ) {\n+        Script defaultFedRedeemScript =\n+            ScriptBuilder.createRedeemScript(\n+                defaultFedBtcECKeyList.size() / 2 + 1,\n+                defaultFedBtcECKeyList\n+            );\n+\n+        Script erpFedRedeemScript =\n+            ScriptBuilder.createRedeemScript(\n+                erpFedBtcECKeyList.size() / 2 + 1,\n+                erpFedBtcECKeyList\n+            );\n+\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+\n+        return scriptBuilder.op(ScriptOpCodes.OP_NOTIF)\n+            .addChunks(removeOpCheckMultisig(defaultFedRedeemScript))\n+            .op(ScriptOpCodes.OP_ELSE)\n+            .data(BigInteger.valueOf(csvValue).toByteArray())\n+            .op(ScriptOpCodes.OP_CHECKSEQUENCEVERIFY)\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(removeOpCheckMultisig(erpFedRedeemScript))\n+            .op(ScriptOpCodes.OP_ENDIF)\n+            .op(ScriptOpCodes.OP_CHECKMULTISIG)\n+            .build();\n+    }\n+\n+    public static Script createFastBridgeErpRedeemScript(\n+        List<BtcECKey> defaultFedBtcECKeyList,\n+        List<BtcECKey> erpFedBtcECKeyList,\n+        Long csvValue,\n+        byte[] derivationArgumentsHashBytes\n+    ) {\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+\n+        Script erpRedeemScript = createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue\n+        );\n+\n+        return scriptBuilder\n+            .data(derivationArgumentsHashBytes)\n+            .op(ScriptOpCodes.OP_DROP)\n+            .addChunks(erpRedeemScript.getChunks())\n+            .build();\n+    }\n+\n+    public static Script createCustomRedeemScript(List<BtcECKey> btcECKeyList) {\n+        Script redeem = ScriptBuilder.createRedeemScript(\n+            btcECKeyList.size() / 2 + 1,\n+            btcECKeyList\n+        );\n+\n+        ScriptBuilder scriptBuilder = new ScriptBuilder();\n+        return scriptBuilder.op(ScriptOpCodes.OP_DROP)\n+            .addChunks(redeem.getChunks())\n+            .build();\n+    }\n+}"
  },
  {
    "sha": "012a2377a6cb05d55ad1ecb2e2360a9eab986293",
    "filename": "src/test/java/co/rsk/bitcoinj/script/RedeemScriptValidatorTest.java",
    "status": "added",
    "additions": 216,
    "deletions": 0,
    "changes": 216,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptValidatorTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/RedeemScriptValidatorTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/RedeemScriptValidatorTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,216 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.core.VerificationException;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RedeemScriptValidatorTest {\n+    private final List<BtcECKey> defaultFedBtcECKeyList = new ArrayList<>();\n+    private final List<BtcECKey> erpFedBtcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final BtcECKey ecKey4 = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+    private final BtcECKey ecKey5 = BtcECKey.fromPrivate(BigInteger.valueOf(500));\n+    private final BtcECKey ecKey6 = BtcECKey.fromPrivate(BigInteger.valueOf(600));\n+    private final BtcECKey ecKey7 = BtcECKey.fromPrivate(BigInteger.valueOf(700));\n+    private final BtcECKey ecKey8 = BtcECKey.fromPrivate(BigInteger.valueOf(800));\n+\n+    @Before\n+    public void setUp() {\n+        defaultFedBtcECKeyList.add(ecKey1);\n+        defaultFedBtcECKeyList.add(ecKey2);\n+        defaultFedBtcECKeyList.add(ecKey3);\n+        erpFedBtcECKeyList.add(ecKey4);\n+        erpFedBtcECKeyList.add(ecKey5);\n+        erpFedBtcECKeyList.add(ecKey6);\n+        erpFedBtcECKeyList.add(ecKey7);\n+        erpFedBtcECKeyList.add(ecKey8);\n+    }\n+\n+    @Test\n+    public void extractCsvValue_fromErpRedeemScript() {\n+        Long csvValue = 100L;\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue\n+        );\n+\n+        Long obtainedCsvValue = RedeemScriptValidator.extractCsvValue(erpRedeemScript.getChunks());\n+\n+        Assert.assertEquals(csvValue, obtainedCsvValue);\n+    }\n+\n+    @Test\n+    public void extractCsvValue_fromFastBridgeErpRedeemScript() {\n+        Long csvValue = 100L;\n+        Sha256Hash derivationArgumentsHash = Sha256Hash.of(new byte[]{1});\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            csvValue,\n+            derivationArgumentsHash.getBytes()\n+        );\n+\n+        Long obtainedCsvValue = RedeemScriptValidator.extractCsvValue(fastBridgeErpRedeemScript.getChunks());\n+\n+        Assert.assertEquals(csvValue, obtainedCsvValue);\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void extractCsvValue_noValue() {\n+        Script customRedeemScript = RedeemScriptUtils.createCustomRedeemScript(defaultFedBtcECKeyList);\n+\n+        RedeemScriptValidator.extractCsvValue(customRedeemScript.getChunks());\n+    }\n+\n+    @Test\n+    public void isRedeemLikeScript_invalid_redeem_script_missing_checkSig() {\n+        List<ScriptChunk> chunksWithoutCheckSig = RedeemScriptValidator.removeOpCheckMultisig(\n+            RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList)\n+        );\n+\n+        Assert.assertFalse(RedeemScriptValidator.isRedeemLikeScript(chunksWithoutCheckSig));\n+    }\n+\n+    @Test\n+    public void isRedeemLikeScript_invalid_redeem_script_insufficient_chunks() {\n+        ScriptBuilder builder = new ScriptBuilder();\n+        Script redeemScript = builder\n+            .data(ecKey1.getPubKey())\n+            .data(ecKey2.getPubKey())\n+            .data(ecKey3.getPubKey())\n+            .build();\n+\n+        Assert.assertFalse(RedeemScriptValidator.isRedeemLikeScript(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasStandardRedeemScriptStructure_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Assert.assertTrue(RedeemScriptValidator.hasStandardRedeemScriptStructure(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasStandardRedeemScriptStructure_non_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L\n+        );\n+\n+        Assert.assertFalse(RedeemScriptValidator.hasStandardRedeemScriptStructure(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasErpRedeemScriptStructure_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Assert.assertFalse(RedeemScriptValidator.hasErpRedeemScriptStructure(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasErpRedeemScriptStructure_fast_bridge_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            Sha256Hash.of(new byte[]{1}).getBytes(),\n+            defaultFedBtcECKeyList\n+        );\n+\n+        Assert.assertFalse(RedeemScriptValidator.hasErpRedeemScriptStructure(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasErpRedeemScriptStructure_erp_fed_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L\n+        );\n+\n+        Assert.assertTrue(RedeemScriptValidator.hasErpRedeemScriptStructure(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasErpRedeemScriptStructure_fast_bridge_erp_redeem_script_removing_prefix() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        // Remove fast bridge prefix\n+        List<ScriptChunk> chunks = redeemScript.getChunks();\n+        List<ScriptChunk> chunksWithoutFastBridgePrefix = chunks.subList(2, chunks.size());\n+\n+        Assert.assertTrue(RedeemScriptValidator.hasErpRedeemScriptStructure(\n+            chunksWithoutFastBridgePrefix)\n+        );\n+    }\n+\n+    @Test\n+    public void hasFastBridgePrefix_fast_bridge_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            Sha256Hash.of(new byte[]{1}).getBytes(),\n+            defaultFedBtcECKeyList\n+        );\n+\n+        Assert.assertTrue(RedeemScriptValidator.hasFastBridgePrefix(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasFastBridgePrefix_erp_fast_bridge_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Assert.assertTrue(RedeemScriptValidator.hasFastBridgePrefix(redeemScript.getChunks()));\n+    }\n+\n+    @Test\n+    public void hasFastBridgePrefix_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        Assert.assertFalse(RedeemScriptValidator.hasFastBridgePrefix(redeemScript.getChunks()));\n+    }\n+\n+    @Test(expected = VerificationException.class)\n+    public void removeOpCheckMultiSig_non_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            defaultFedBtcECKeyList,\n+            erpFedBtcECKeyList,\n+            500L\n+        );\n+\n+        RedeemScriptValidator.removeOpCheckMultisig(redeemScript);\n+    }\n+\n+    @Test\n+    public void removeOpCheckMultiSig_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(defaultFedBtcECKeyList);\n+        List<ScriptChunk> chunks = RedeemScriptValidator.removeOpCheckMultisig(redeemScript);\n+\n+        Assert.assertEquals(5, chunks.size());\n+        Assert.assertFalse(RedeemScriptValidator.isRedeemLikeScript(chunks));\n+    }\n+\n+    @Test\n+    public void isOpN_valid_opcode() {\n+        ScriptChunk chunk = new ScriptChunk(ScriptOpCodes.OP_2, null);\n+        Assert.assertTrue(RedeemScriptValidator.isOpN(chunk));\n+    }\n+\n+    @Test\n+    public void isOpnN_invalid_opcode() {\n+        ScriptChunk chunk = new ScriptChunk(ScriptOpCodes.OP_DROP, null);\n+        Assert.assertFalse(RedeemScriptValidator.isOpN(chunk));\n+    }\n+}"
  },
  {
    "sha": "b9c83ef155e762e5c87444492661a1f45996ead0",
    "filename": "src/test/java/co/rsk/bitcoinj/script/ScriptTest.java",
    "status": "modified",
    "additions": 281,
    "deletions": 123,
    "changes": 404,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/ScriptTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/ScriptTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/ScriptTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -17,7 +17,6 @@\n \n package co.rsk.bitcoinj.script;\n \n-import static co.rsk.bitcoinj.core.Utils.HEX;\n import static co.rsk.bitcoinj.script.ScriptOpCodes.OP_0;\n import static co.rsk.bitcoinj.script.ScriptOpCodes.OP_INVALIDOPCODE;\n import static org.hamcrest.core.IsEqual.equalTo;\n@@ -28,7 +27,6 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n-import co.rsk.bitcoinj.RedeemScriptUtil;\n import co.rsk.bitcoinj.core.Address;\n import co.rsk.bitcoinj.core.BtcECKey;\n import co.rsk.bitcoinj.core.BtcTransaction;\n@@ -56,7 +54,7 @@\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.math.BigInteger;\n-import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EnumSet;\n@@ -72,6 +70,7 @@\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.spongycastle.util.encoders.Hex;\n \n public class ScriptTest {\n     // From tx 05e04c26c12fe408a3c1b71aa7996403f6acad1045252b1c62e055496f4d2cb1 on the testnet.\n@@ -81,21 +80,31 @@\n     private static final NetworkParameters PARAMS = TestNet3Params.get();\n     private static final Logger log = LoggerFactory.getLogger(ScriptTest.class);\n     private final List<BtcECKey> btcECKeyList = new ArrayList<>();\n+    private final List<BtcECKey> erpFedECKeyList = new ArrayList<>();\n     private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n     private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n     private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final BtcECKey ecKey4 = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+    private final BtcECKey ecKey5 = BtcECKey.fromPrivate(BigInteger.valueOf(500));\n+    private final BtcECKey ecKey6 = BtcECKey.fromPrivate(BigInteger.valueOf(600));\n+    private final BtcECKey ecKey7 = BtcECKey.fromPrivate(BigInteger.valueOf(700));\n+    private final BtcECKey ecKey8 = BtcECKey.fromPrivate(BigInteger.valueOf(800));\n \n     @Before\n-    public void setUp() throws Exception {\n-        //Context context = new Context(PARAMS);\n+    public void setUp() {\n         btcECKeyList.add(ecKey1);\n         btcECKeyList.add(ecKey2);\n         btcECKeyList.add(ecKey3);\n+        erpFedECKeyList.add(ecKey4);\n+        erpFedECKeyList.add(ecKey5);\n+        erpFedECKeyList.add(ecKey6);\n+        erpFedECKeyList.add(ecKey7);\n+        erpFedECKeyList.add(ecKey8);\n     }\n \n     @Test\n-    public void testScriptSig() throws Exception {\n-        byte[] sigProgBytes = HEX.decode(sigProg);\n+    public void testScriptSig() {\n+        byte[] sigProgBytes = Hex.decode(sigProg);\n         Script script = new Script(sigProgBytes);\n         // Test we can extract the from address.\n         byte[] hash160 = Utils.sha256hash160(script.getPubKey());\n@@ -104,17 +113,17 @@ public void testScriptSig() throws Exception {\n     }\n \n     @Test\n-    public void testScriptPubKey() throws Exception {\n+    public void testScriptPubKey() {\n         // Check we can extract the to address\n-        byte[] pubkeyBytes = HEX.decode(pubkeyProg);\n+        byte[] pubkeyBytes = Hex.decode(pubkeyProg);\n         Script pubkey = new Script(pubkeyBytes);\n         assertEquals(\"DUP HASH160 PUSHDATA(20)[33e81a941e64cda12c6a299ed322ddbdd03f8d0e] EQUALVERIFY CHECKSIG\", pubkey.toString());\n         Address toAddr = new Address(PARAMS, pubkey.getPubKeyHash());\n         assertEquals(\"mkFQohBpy2HDXrCwyMrYL5RtfrmeiuuPY2\", toAddr.toString());\n     }\n \n     @Test\n-    public void testMultiSig() throws Exception {\n+    public void testMultiSig() {\n         List<BtcECKey> keys = Lists.newArrayList(new BtcECKey(), new BtcECKey(), new BtcECKey());\n         assertTrue(ScriptBuilder.createMultiSigOutputScript(2, keys).isSentToMultiSig());\n         Script script = ScriptBuilder.createMultiSigOutputScript(3, keys);\n@@ -140,14 +149,14 @@ public void testMultiSig() throws Exception {\n     }\n \n     @Test\n-    public void testP2SHOutputScript() throws Exception {\n+    public void testP2SHOutputScript() {\n         Address p2shAddress = Address.fromBase58(MainNetParams.get(), \"35b9vsyH1KoFT5a5KtrKusaCcPLkiSo1tU\");\n         assertTrue(ScriptBuilder.createOutputScript(p2shAddress).isPayToScriptHash());\n     }\n \n     @Test\n-    public void testIp() throws Exception {\n-        byte[] bytes = HEX.decode(\"41043e96222332ea7848323c08116dddafbfa917b8e37f0bdf63841628267148588a09a43540942d58d49717ad3fabfe14978cf4f0a8b84d2435dad16e9aa4d7f935ac\");\n+    public void testIp() {\n+        byte[] bytes = Hex.decode(\"41043e96222332ea7848323c08116dddafbfa917b8e37f0bdf63841628267148588a09a43540942d58d49717ad3fabfe14978cf4f0a8b84d2435dad16e9aa4d7f935ac\");\n         Script s = new Script(bytes);\n         assertTrue(s.isSentToRawPubKey());\n     }\n@@ -159,7 +168,7 @@ public void testCreateMultiSigInputScript() {\n         BtcECKey key2 = DumpedPrivateKey.fromBase58(PARAMS, \"cTine92s8GLpVqvebi8rYce3FrUYq78ZGQffBYCS1HmDPJdSTxUo\").getKey();\n         BtcECKey key3 = DumpedPrivateKey.fromBase58(PARAMS, \"cVHwXSPRZmL9adctwBwmn4oTZdZMbaCsR5XF6VznqMgcvt1FDDxg\").getKey();\n         Script multisigScript = ScriptBuilder.createMultiSigOutputScript(2, Arrays.asList(key1, key2, key3));\n-        byte[] bytes = HEX.decode(\"01000000013df681ff83b43b6585fa32dd0e12b0b502e6481e04ee52ff0fdaf55a16a4ef61000000006b483045022100a84acca7906c13c5895a1314c165d33621cdcf8696145080895cbf301119b7cf0220730ff511106aa0e0a8570ff00ee57d7a6f24e30f592a10cae1deffac9e13b990012102b8d567bcd6328fd48a429f9cf4b315b859a58fd28c5088ef3cb1d98125fc4e8dffffffff02364f1c00000000001976a91439a02793b418de8ec748dd75382656453dc99bcb88ac40420f000000000017a9145780b80be32e117f675d6e0ada13ba799bf248e98700000000\");\n+        byte[] bytes = Hex.decode(\"01000000013df681ff83b43b6585fa32dd0e12b0b502e6481e04ee52ff0fdaf55a16a4ef61000000006b483045022100a84acca7906c13c5895a1314c165d33621cdcf8696145080895cbf301119b7cf0220730ff511106aa0e0a8570ff00ee57d7a6f24e30f592a10cae1deffac9e13b990012102b8d567bcd6328fd48a429f9cf4b315b859a58fd28c5088ef3cb1d98125fc4e8dffffffff02364f1c00000000001976a91439a02793b418de8ec748dd75382656453dc99bcb88ac40420f000000000017a9145780b80be32e117f675d6e0ada13ba799bf248e98700000000\");\n         BtcTransaction transaction = PARAMS.getDefaultSerializer().makeTransaction(bytes);\n         TransactionOutput output = transaction.getOutput(1);\n         BtcTransaction spendTx = new BtcTransaction(PARAMS);\n@@ -177,7 +186,7 @@ public void testCreateMultiSigInputScript() {\n         Script inputScript = ScriptBuilder.createP2SHMultiSigInputScript(ImmutableList.of(party1TransactionSignature, party2TransactionSignature), multisigScript);\n \n         // Assert that the input script contains 4 chunks\n-        assertTrue(inputScript.getChunks().size() == 4);\n+        assertEquals(4, inputScript.getChunks().size());\n \n         // Assert that the input script created contains the original multisig\n         // script as the last chunk\n@@ -188,7 +197,7 @@ public void testCreateMultiSigInputScript() {\n         inputScript = ScriptBuilder.createMultiSigInputScript(ImmutableList.of(party1TransactionSignature, party2TransactionSignature));\n \n         // Assert that the input script only contains 3 chunks\n-        assertTrue(inputScript.getChunks().size() == 3);\n+        assertEquals(3, inputScript.getChunks().size());\n \n         // Assert that the input script created does not end with the original\n         // multisig script\n@@ -197,7 +206,7 @@ public void testCreateMultiSigInputScript() {\n     }\n \n     @Test\n-    public void createAndUpdateEmptyInputScript() throws Exception {\n+    public void createAndUpdateEmptyInputScript() {\n         TransactionSignature dummySig = TransactionSignature.dummy();\n         BtcECKey key = new BtcECKey();\n \n@@ -261,56 +270,6 @@ public void testOp0() {\n         Script.executeScript(tx, 0, script, stack, Script.ALL_VERIFY_FLAGS);\n         assertEquals(\"OP_0 push length\", 0, stack.get(0).length);\n     }\n-\n-    private Script parseScriptString(String string) throws IOException {\n-        String[] words = string.split(\"[ \\\\t\\\\n]\");\n-        \n-        UnsafeByteArrayOutputStream out = new UnsafeByteArrayOutputStream();\n-\n-        for(String w : words) {\n-            if (w.equals(\"\"))\n-                continue;\n-            if (w.matches(\"^-?[0-9]*$\")) {\n-                // Number\n-                long val = Long.parseLong(w);\n-                if (val >= -1 && val <= 16)\n-                    out.write(Script.encodeToOpN((int)val));\n-                else\n-                    Script.writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(val), false)));\n-            } else if (w.matches(\"^0x[0-9a-fA-F]*$\")) {\n-                // Raw hex data, inserted NOT pushed onto stack:\n-                out.write(HEX.decode(w.substring(2).toLowerCase()));\n-            } else if (w.length() >= 2 && w.startsWith(\"'\") && w.endsWith(\"'\")) {\n-                // Single-quoted string, pushed as data. NOTE: this is poor-man's\n-                // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n-                Script.writeBytes(out, w.substring(1, w.length() - 1).getBytes(Charset.forName(\"UTF-8\")));\n-            } else if (ScriptOpCodes.getOpCode(w) != OP_INVALIDOPCODE) {\n-                // opcode, e.g. OP_ADD or OP_1:\n-                out.write(ScriptOpCodes.getOpCode(w));\n-            } else if (w.startsWith(\"OP_\") && ScriptOpCodes.getOpCode(w.substring(3)) != OP_INVALIDOPCODE) {\n-                // opcode, e.g. OP_ADD or OP_1:\n-                out.write(ScriptOpCodes.getOpCode(w.substring(3)));\n-            } else {\n-                throw new RuntimeException(\"Invalid Data\");\n-            }                        \n-        }\n-        \n-        return new Script(out.toByteArray());\n-    }\n-\n-    private Set<VerifyFlag> parseVerifyFlags(String str) {\n-        Set<VerifyFlag> flags = EnumSet.noneOf(VerifyFlag.class);\n-        if (!\"NONE\".equals(str)) {\n-            for (String flag : str.split(\",\")) {\n-                try {\n-                    flags.add(VerifyFlag.valueOf(flag));\n-                } catch (IllegalArgumentException x) {\n-                    log.debug(\"Cannot handle verify flag {} -- ignored.\", flag);\n-                }\n-            }\n-        }\n-        return flags;\n-    }\n     \n     @Test\n     public void dataDrivenValidScripts() throws Exception {\n@@ -348,18 +307,6 @@ public void dataDrivenInvalidScripts() throws Exception {\n             }\n         }\n     }\n-    \n-    private Map<TransactionOutPoint, Script> parseScriptPubKeys(JsonNode inputs) throws IOException {\n-        Map<TransactionOutPoint, Script> scriptPubKeys = new HashMap<TransactionOutPoint, Script>();\n-        for (JsonNode input : inputs) {\n-            String hash = input.get(0).asText();\n-            int index = input.get(1).asInt();\n-            String script = input.get(2).asText();\n-            Sha256Hash sha256Hash = Sha256Hash.wrap(HEX.decode(hash));\n-            scriptPubKeys.put(new TransactionOutPoint(PARAMS, index, sha256Hash), parseScriptString(script));\n-        }\n-        return scriptPubKeys;\n-    }\n \n     @Test\n     public void dataDrivenValidTransactions() throws Exception {\n@@ -371,7 +318,7 @@ public void dataDrivenValidTransactions() throws Exception {\n             BtcTransaction transaction = null;\n             try {\n                 Map<TransactionOutPoint, Script> scriptPubKeys = parseScriptPubKeys(test.get(0));\n-                transaction = PARAMS.getDefaultSerializer().makeTransaction(HEX.decode(test.get(1).asText().toLowerCase()));\n+                transaction = PARAMS.getDefaultSerializer().makeTransaction(Hex.decode(test.get(1).asText().toLowerCase()));\n                 transaction.verify();\n                 Set<VerifyFlag> verifyFlags = parseVerifyFlags(test.get(2).asText());\n \n@@ -400,7 +347,7 @@ public void dataDrivenInvalidTransactions() throws Exception {\n             if (test.isArray() && test.size() == 1 && test.get(0).isTextual())\n                 continue; // This is a comment.\n             Map<TransactionOutPoint, Script> scriptPubKeys = parseScriptPubKeys(test.get(0));\n-            BtcTransaction transaction = PARAMS.getDefaultSerializer().makeTransaction(HEX.decode(test.get(1).asText().toLowerCase()));\n+            BtcTransaction transaction = PARAMS.getDefaultSerializer().makeTransaction(Hex.decode(test.get(1).asText().toLowerCase()));\n             Set<VerifyFlag> verifyFlags = parseVerifyFlags(test.get(2).asText());\n \n             boolean valid = true;\n@@ -442,7 +389,7 @@ public void testCLTVPaymentChannelOutput() {\n     }\n \n     @Test\n-    public void getToAddress() throws Exception {\n+    public void getToAddress() {\n         // pay to pubkey\n         BtcECKey toKey = new BtcECKey();\n         Address toAddress = toKey.toAddress(PARAMS);\n@@ -456,7 +403,7 @@ public void getToAddress() throws Exception {\n     }\n \n     @Test(expected = ScriptException.class)\n-    public void getToAddressNoPubKey() throws Exception {\n+    public void getToAddressNoPubKey() {\n         ScriptBuilder.createOutputScript(new BtcECKey()).getToAddress(PARAMS, false);\n     }\n \n@@ -524,59 +471,219 @@ public void numberBuilderNegative() {\n     @Test\n     public void getNumberOfSignaturesRequiredToSpend_fast_bridge_redeem_script() {\n         byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n             data, btcECKeyList);\n \n         Assert.assertEquals(2, fastBridgeRedeemScript.getNumberOfSignaturesRequiredToSpend());\n     }\n \n+    @Test\n+    public void getNumberOfSignaturesRequiredToSpend_erp_redeem_script() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L\n+        );\n+\n+        Assert.assertEquals(2, erpRedeemScript.getNumberOfSignaturesRequiredToSpend());\n+    }\n+\n+    @Test\n+    public void getNumberOfSignaturesRequiredToSpend_fast_bridge_erp_redeem_script() {\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Assert.assertEquals(2, fastBridgeErpRedeemScript.getNumberOfSignaturesRequiredToSpend());\n+    }\n+\n     @Test\n     public void getNumberOfSignaturesRequiredToSpend_no_fast_bridge_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n         Assert.assertEquals(2, redeemScript.getNumberOfSignaturesRequiredToSpend());\n     }\n \n     @Test\n     public void getSigInsertionIndex_fast_bridge_redeem_script() {\n         byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n             data, btcECKeyList);\n \n-        NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n+        testGetSigInsertionIndex(fastBridgeRedeemScript);\n+    }\n \n-        BtcTransaction fundTx = new BtcTransaction(networkParameters);\n-        fundTx.addOutput(Coin.FIFTY_COINS, ecKey1.toAddress(networkParameters));\n+    @Test\n+    public void getSigInsertionIndex_erp_redeem_script() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L\n+        );\n+\n+        testGetSigInsertionIndex(erpRedeemScript);\n+    }\n \n-        BtcTransaction spendTx = new BtcTransaction(networkParameters);\n-        spendTx.addInput(fundTx.getOutput(0));\n+    @Test\n+    public void getSigInsertionIndex_fast_bridge_erp_redeem_script() {\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        testGetSigInsertionIndex(fastBridgeErpRedeemScript);\n+    }\n \n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n+    @Test\n+    public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        testGetSigInsertionIndex(redeemScript);\n+    }\n \n-        Script inputScript = spk.createEmptyInputScript(null, fastBridgeRedeemScript);\n+    @Test\n+    public void isSentToMultiSig_fast_bridge_multiSig() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n \n-        Sha256Hash sigHash = spendTx.hashForSignature(0, fastBridgeRedeemScript,\n-            BtcTransaction.SigHash.ALL, false);\n+        Assert.assertTrue(fastBridgeRedeemScript.isSentToMultiSig());\n+    }\n \n-        BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n-        TransactionSignature txSig = new TransactionSignature(sign1,\n-            BtcTransaction.SigHash.ALL, false);\n+    @Test\n+    public void isSentToMultiSig_erp_multiSig() {\n+        Script erpRedeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L\n+        );\n+\n+        Assert.assertTrue(erpRedeemScript.isSentToMultiSig());\n+    }\n \n-        byte[] txSigEncoded = txSig.encodeToBitcoin();\n+    @Test\n+    public void isSentToMultiSig_fast_bridge_erp_multiSig() {\n+        Script fastBridgeErpRedeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Assert.assertTrue(fastBridgeErpRedeemScript.isSentToMultiSig());\n+    }\n \n-        int sigIndex = inputScript.getSigInsertionIndex(sigHash, ecKey1);\n-        Assert.assertEquals(0, sigIndex);\n+    @Test\n+    public void isStandardMultiSig_standard_multiSig() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        Assert.assertTrue(redeemScript.isSentToMultiSig());\n+    }\n \n-        inputScript = ScriptBuilder.updateScriptWithSignature(inputScript, txSigEncoded,\n-            sigIndex, 1, 1);\n+    @Test\n+    public void createEmptyInputScript_standard_redeemScript() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        Script spk = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n+\n+        assertInputScriptStructure(\n+            inputScript.getChunks(),\n+            4,\n+            3,\n+            redeemScript.getProgram()\n+        );\n+    }\n \n-        sigIndex = inputScript.getSigInsertionIndex(sigHash, ecKey2);\n-        Assert.assertEquals(1, sigIndex);\n+    @Test\n+    public void createEmptyInputScript_fast_bridge_redeemScript() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            Sha256Hash.of(new byte[]{1}).getBytes(),\n+            btcECKeyList\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n+\n+        assertInputScriptStructure(\n+            inputScript.getChunks(),\n+            4,\n+            3,\n+            redeemScript.getProgram()\n+        );\n     }\n \n     @Test\n-    public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n+    public void createEmptyInputScript_erp_redeemScript() {\n+        Script redeemScript = RedeemScriptUtils.createErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n+\n+        // The expected Erp input script structure is:\n+        // First element: OP_0 - Belonging to the standard of BTC\n+        // M elements OP_0 - Belonging to M/N amount of signatures\n+        // OP_0 - Belonging to ERP\n+        // Last element: Program of redeem script\n+\n+        assertInputScriptStructure(\n+            inputScript.getChunks(),\n+            5,\n+            4,\n+            redeemScript.getProgram()\n+        );\n+    }\n+\n+    @Test\n+    public void createEmptyInputScript_fast_bridge_erp_redeemScript() {\n+        Script redeemScript = RedeemScriptUtils.createFastBridgeErpRedeemScript(\n+            btcECKeyList,\n+            erpFedECKeyList,\n+            500L,\n+            Sha256Hash.of(new byte[]{1}).getBytes()\n+        );\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n+\n+        // The expected Erp input script structure is:\n+        // First element: OP_0 - Belonging to the standard of BTC\n+        // M elements OP_0 - Belonging to M/N amount of signatures\n+        // OP_0 - Belonging to ERP\n+        // Last element: Program of redeem script\n+\n+        assertInputScriptStructure(\n+            inputScript.getChunks(),\n+            5,\n+            4,\n+            redeemScript.getProgram()\n+        );\n+    }\n+\n+    private void assertInputScriptStructure(\n+        List<ScriptChunk> chunks,\n+        int expectedChunksSize,\n+        int expectedOpZeroes,\n+        byte[] redeemScriptProgram\n+    ) {\n+        // Validate input scripts chunks\n+        Assert.assertEquals(expectedChunksSize, chunks.size());\n+\n+        for (int i = 0; i < expectedOpZeroes; i++) {\n+            Assert.assertTrue(chunks.get(i).equalsOpCode(OP_0));\n+        }\n+\n+        Assert.assertArrayEquals(redeemScriptProgram, chunks.get(chunks.size() - 1).data);\n+    }\n+\n+    private void testGetSigInsertionIndex(Script redeemScript) {\n         NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n \n         BtcTransaction fundTx = new BtcTransaction(networkParameters);\n@@ -585,17 +692,17 @@ public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n         BtcTransaction spendTx = new BtcTransaction(networkParameters);\n         spendTx.addInput(fundTx.getOutput(0));\n \n-        Script spk = ScriptBuilder.createP2SHOutputScript(2,\n-            Arrays.asList(ecKey1, ecKey2, ecKey3));\n+        Script spk = ScriptBuilder.createP2SHOutputScript(redeemScript);\n \n-        Script inputScript = spk.createEmptyInputScript(redeemScript.getPubKeys().get(0),\n-            redeemScript);\n+        Script inputScript = spk.createEmptyInputScript(null, redeemScript);\n \n         Sha256Hash sigHash = spendTx.hashForSignature(0, redeemScript,\n             BtcTransaction.SigHash.ALL, false);\n \n         BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n-        TransactionSignature txSig = new TransactionSignature(sign1, BtcTransaction.SigHash.ALL, false);\n+        TransactionSignature txSig = new TransactionSignature(sign1,\n+            BtcTransaction.SigHash.ALL, false);\n+\n         byte[] txSigEncoded = txSig.encodeToBitcoin();\n \n         int sigIndex = inputScript.getSigInsertionIndex(sigHash, ecKey1);\n@@ -604,22 +711,73 @@ public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n         inputScript = ScriptBuilder.updateScriptWithSignature(inputScript, txSigEncoded,\n             sigIndex, 1, 1);\n \n+        Assert.assertFalse(inputScript.getChunks().get(1).equalsOpCode(OP_0));\n+        Assert.assertArrayEquals(txSigEncoded, inputScript.getChunks().get(1).data);\n+\n         sigIndex = inputScript.getSigInsertionIndex(sigHash, ecKey2);\n         Assert.assertEquals(1, sigIndex);\n     }\n \n-    @Test\n-    public void isSentToMultiSig_fast_bridge_multiSig() {\n-        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n-        Script fastBridgeRedeemScript = RedeemScriptUtil.createFastBridgeRedeemScript(\n-            data, btcECKeyList);\n+    private Script parseScriptString(String string) throws IOException {\n+        String[] words = string.split(\"[ \\\\t\\\\n]\");\n \n-        Assert.assertTrue(fastBridgeRedeemScript.isSentToMultiSig());\n+        UnsafeByteArrayOutputStream out = new UnsafeByteArrayOutputStream();\n+\n+        for(String w : words) {\n+            if (w.equals(\"\"))\n+                continue;\n+            if (w.matches(\"^-?[0-9]*$\")) {\n+                // Number\n+                long val = Long.parseLong(w);\n+                if (val >= -1 && val <= 16)\n+                    out.write(Script.encodeToOpN((int)val));\n+                else\n+                    Script.writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(val), false)));\n+            } else if (w.matches(\"^0x[0-9a-fA-F]*$\")) {\n+                // Raw hex data, inserted NOT pushed onto stack:\n+                out.write(Hex.decode(w.substring(2).toLowerCase()));\n+            } else if (w.length() >= 2 && w.startsWith(\"'\") && w.endsWith(\"'\")) {\n+                // Single-quoted string, pushed as data. NOTE: this is poor-man's\n+                // parsing, spaces/tabs/newlines in single-quoted strings won't work.\n+                Script.writeBytes(out, w.substring(1, w.length() - 1).getBytes(\n+                    StandardCharsets.UTF_8));\n+            } else if (ScriptOpCodes.getOpCode(w) != OP_INVALIDOPCODE) {\n+                // opcode, e.g. OP_ADD or OP_1:\n+                out.write(ScriptOpCodes.getOpCode(w));\n+            } else if (w.startsWith(\"OP_\") && ScriptOpCodes.getOpCode(w.substring(3)) != OP_INVALIDOPCODE) {\n+                // opcode, e.g. OP_ADD or OP_1:\n+                out.write(ScriptOpCodes.getOpCode(w.substring(3)));\n+            } else {\n+                throw new RuntimeException(\"Invalid Data\");\n+            }\n+        }\n+\n+        return new Script(out.toByteArray());\n     }\n \n-    @Test\n-    public void isStandardMultiSig_standard_multiSig() {\n-        Script redeemScript = RedeemScriptUtil.createStandardRedeemScript(btcECKeyList);\n-        Assert.assertTrue(redeemScript.isSentToMultiSig());\n+    private Set<VerifyFlag> parseVerifyFlags(String str) {\n+        Set<VerifyFlag> flags = EnumSet.noneOf(VerifyFlag.class);\n+        if (!\"NONE\".equals(str)) {\n+            for (String flag : str.split(\",\")) {\n+                try {\n+                    flags.add(VerifyFlag.valueOf(flag));\n+                } catch (IllegalArgumentException x) {\n+                    log.debug(\"Cannot handle verify flag {} -- ignored.\", flag);\n+                }\n+            }\n+        }\n+        return flags;\n+    }\n+\n+    private Map<TransactionOutPoint, Script> parseScriptPubKeys(JsonNode inputs) throws IOException {\n+        Map<TransactionOutPoint, Script> scriptPubKeys = new HashMap<TransactionOutPoint, Script>();\n+        for (JsonNode input : inputs) {\n+            String hash = input.get(0).asText();\n+            int index = input.get(1).asInt();\n+            String script = input.get(2).asText();\n+            Sha256Hash sha256Hash = Sha256Hash.wrap(Hex.decode(hash));\n+            scriptPubKeys.put(new TransactionOutPoint(PARAMS, index, sha256Hash), parseScriptString(script));\n+        }\n+        return scriptPubKeys;\n     }\n }"
  },
  {
    "sha": "c8c2ae8c4b995eb11711f731d1db94d7134a71f6",
    "filename": "src/test/java/co/rsk/bitcoinj/script/StandardRedeemScriptParserTest.java",
    "status": "added",
    "additions": 268,
    "deletions": 0,
    "changes": 268,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/StandardRedeemScriptParserTest.java",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/java/co/rsk/bitcoinj/script/StandardRedeemScriptParserTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/java/co/rsk/bitcoinj/script/StandardRedeemScriptParserTest.java?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -0,0 +1,268 @@\n+package co.rsk.bitcoinj.script;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.BtcTransaction;\n+import co.rsk.bitcoinj.core.Coin;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.bitcoinj.core.ScriptException;\n+import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.crypto.TransactionSignature;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class StandardRedeemScriptParserTest {\n+\n+    private final List<BtcECKey> btcECKeyList = new ArrayList<>();\n+    private final BtcECKey ecKey1 = BtcECKey.fromPrivate(BigInteger.valueOf(100));\n+    private final BtcECKey ecKey2 = BtcECKey.fromPrivate(BigInteger.valueOf(200));\n+    private final BtcECKey ecKey3 = BtcECKey.fromPrivate(BigInteger.valueOf(300));\n+    private final NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n+\n+    @Before\n+    public void setUp() {\n+        btcECKeyList.add(ecKey1);\n+        btcECKeyList.add(ecKey2);\n+        btcECKeyList.add(ecKey3);\n+    }\n+\n+    @Test\n+    public void getSigInsertionIndex_fast_bridge_redeem_script() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        BtcTransaction fundTx = new BtcTransaction(networkParameters);\n+        fundTx.addOutput(Coin.FIFTY_COINS, ecKey1.toAddress(networkParameters));\n+\n+        BtcTransaction spendTx = new BtcTransaction(networkParameters);\n+        spendTx.addInput(fundTx.getOutput(0));\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(null, fastBridgeRedeemScript);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Sha256Hash sigHash = spendTx.hashForSignature(\n+            0,\n+            fastBridgeRedeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n+        TransactionSignature txSig = new TransactionSignature(\n+            sign1,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        byte[] txSigEncoded = txSig.encodeToBitcoin();\n+\n+        int sigIndex = parser.getSigInsertionIndex(sigHash, ecKey1);\n+        Assert.assertEquals(0, sigIndex);\n+\n+        inputScript = ScriptBuilder.updateScriptWithSignature(\n+            inputScript,\n+            txSigEncoded,\n+            sigIndex,\n+            1,\n+            1\n+        );\n+\n+        parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        sigIndex = parser.getSigInsertionIndex(sigHash, ecKey2);\n+        Assert.assertEquals(1, sigIndex);\n+    }\n+\n+    @Test\n+    public void getSigInsertionIndex_no_fast_bridge_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+\n+        BtcTransaction fundTx = new BtcTransaction(networkParameters);\n+        fundTx.addOutput(Coin.FIFTY_COINS, ecKey1.toAddress(networkParameters));\n+\n+        BtcTransaction spendTx = new BtcTransaction(networkParameters);\n+        spendTx.addInput(fundTx.getOutput(0));\n+\n+        Script spk = ScriptBuilder.createP2SHOutputScript(\n+            2,\n+            Arrays.asList(ecKey1, ecKey2, ecKey3)\n+        );\n+\n+        Script inputScript = spk.createEmptyInputScript(\n+            redeemScript.getPubKeys().get(0),\n+            redeemScript\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        Sha256Hash sigHash = spendTx.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        BtcECKey.ECDSASignature sign1 = ecKey1.sign(sigHash);\n+        TransactionSignature txSig = new TransactionSignature(\n+            sign1,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+        byte[] txSigEncoded = txSig.encodeToBitcoin();\n+\n+        int sigIndex = parser.getSigInsertionIndex(sigHash, ecKey1);\n+        Assert.assertEquals(0, sigIndex);\n+\n+        inputScript = ScriptBuilder.updateScriptWithSignature(\n+            inputScript,\n+            txSigEncoded,\n+            sigIndex,\n+            1,\n+            1\n+        );\n+\n+        parser = RedeemScriptParserFactory.get(inputScript.getChunks());\n+\n+        sigIndex = parser.getSigInsertionIndex(sigHash, ecKey2);\n+        Assert.assertEquals(1, sigIndex);\n+    }\n+\n+    @Test\n+    public void findKeyInRedeem_fast_bridge_redeem_script() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+\n+        Assert.assertTrue(parser.findKeyInRedeem(ecKey1) >= 0);\n+        Assert.assertTrue(parser.findKeyInRedeem(ecKey2) >= 0);\n+        Assert.assertTrue(parser.findKeyInRedeem(ecKey3) >= 0);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void findKeyInRedeem_fast_bridge_redeem_script_no_matching_key() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        BtcECKey unmatchingBtcECKey = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+\n+        parser.findKeyInRedeem(unmatchingBtcECKey);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void findKeyInRedeem_standard_redeem_script_no_matching_key() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        BtcECKey unmatchingBtcECKey = BtcECKey.fromPrivate(BigInteger.valueOf(400));\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        parser.findKeyInRedeem(unmatchingBtcECKey);\n+    }\n+\n+    @Test\n+    public void getPubKeys_fast_bridge_redeem_script() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+        List<BtcECKey> obtainedList = parser.getPubKeys();\n+\n+        List<String> expectedKeysList = new ArrayList<>();\n+        for (BtcECKey key : btcECKeyList) {\n+            expectedKeysList.add(key.getPublicKeyAsHex());\n+        }\n+\n+        List<String> obtainedKeysList = new ArrayList<>();\n+        for (BtcECKey key : obtainedList) {\n+            obtainedKeysList.add(key.getPublicKeyAsHex());\n+        }\n+\n+        Collections.sort(expectedKeysList);\n+        Collections.sort(obtainedKeysList);\n+\n+        Assert.assertEquals(expectedKeysList, obtainedKeysList);\n+    }\n+\n+    @Test\n+    public void getPubKeys_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+        List<BtcECKey> obtainedList = parser.getPubKeys();\n+\n+        List<String> expectedKeysList = new ArrayList<>();\n+        for (BtcECKey key : btcECKeyList) {\n+            expectedKeysList.add(key.getPublicKeyAsHex());\n+        }\n+\n+        List<String> obtainedKeysList = new ArrayList<>();\n+        for (BtcECKey key : obtainedList) {\n+            obtainedKeysList.add(key.getPublicKeyAsHex());\n+        }\n+\n+        Collections.sort(expectedKeysList);\n+        Collections.sort(obtainedKeysList);\n+\n+        Assert.assertEquals(expectedKeysList, obtainedKeysList);\n+    }\n+\n+    @Test(expected = ScriptException.class)\n+    public void getPubKeys_invalid_redeem_script() {\n+        Script script = ScriptBuilder.createP2SHOutputScript(new byte[20]);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(script.getChunks());\n+\n+        parser.getPubKeys();\n+    }\n+\n+    @Test\n+    public void getM_from_no_multiSig() {\n+        Script redeemScript = new Script(new byte[2]);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(-1, parser.getM());\n+    }\n+\n+    @Test\n+    public void getM_from_multiSig_fast_bridge_redeem_script() {\n+        byte[] data = Sha256Hash.of(new byte[]{1}).getBytes();\n+        Script fastBridgeRedeemScript = RedeemScriptUtils.createFastBridgeRedeemScript(\n+            data,\n+            btcECKeyList\n+        );\n+\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(fastBridgeRedeemScript.getChunks());\n+\n+        Assert.assertEquals(2, parser.getM());\n+    }\n+\n+    @Test\n+    public void getM_from_multiSig_standard_redeem_script() {\n+        Script redeemScript = RedeemScriptUtils.createStandardRedeemScript(btcECKeyList);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+        Assert.assertEquals(2, parser.getM());\n+    }\n+}"
  },
  {
    "sha": "cd47da20eb47112b50ec7dc4e80a7ddd9c85ddbd",
    "filename": "src/test/resources/co/rsk/bitcoinj/script/tx_invalid.json",
    "status": "modified",
    "additions": 54,
    "deletions": 0,
    "changes": 54,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/resources/co/rsk/bitcoinj/script/tx_invalid.json",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/resources/co/rsk/bitcoinj/script/tx_invalid.json",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/resources/co/rsk/bitcoinj/script/tx_invalid.json?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -182,5 +182,59 @@\n [[[\"a54b3bff74c910adff4f81b641587440c9f3b02a67c69b06d4eea36c0d199bac\", 0, \"DUP HASH160 0x14 0x33b9fe6942f268ae728136046e638c8863bed91f EQUALVERIFY CHECKSIG\"]],\n \"0100000001ac9b190d6ca3eed4069bc6672ab0f3c940745841b6814fffad10c974ff3b4ba5000000006c493046022100c16257354c7ec7fedda7ce724abfc6a8f26fd433d08b1a11bd01a8f0f157b1fb0221009069419fa4454cd52f1d3219c395b96c3dc0404257196f96d819d71e4f95b8290121039770779101a01dbbf6c25466df8869e648dc75a51d64ebf5136c824c32fcc9c8ffffffff0100000000000000001976a914aaf0529f46a86271255621ed566e79e67345916d88ac00000000\", \"P2SH,LOW_S\"],\n \n+[\"CHECKSEQUENCEVERIFY tests\"],\n+\n+[\"By-height locks, with argument just beyond txin.nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feff40000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"By-time locks, with argument just beyond txin.nSequence (but within numerical boundries)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194305 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feff40000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument missing\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument negative with by-blockheight txin.nSequence=0\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument negative with by-blocktime txin.nSequence=CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"-1 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument/tx height/time mismatch, both versions\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"65535 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"6 byte non-minimally-encoded arguments are invalid even if their contents are valid\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x06 0x000000000000 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffff00000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Failure due to failing CHECKSEQUENCEVERIFY in scriptSig\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1\"]],\n+  \"02000000010001000000000000000000000000000000000000000000000000000000000000000000000251b2000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Failure due to failing CHECKSEQUENCEVERIFY in redeemScript\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7c17aff532f22beb54069942f9bf567a66133eaf EQUAL\"]],\n+  \"0200000001000100000000000000000000000000000000000000000000000000000000000000000000030251b2000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Failure due to insufficient tx.nVersion (<2)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n+  \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+  \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n [\"Make diffs cleaner by leaving a comment here without comma at the end\"]\n ]"
  },
  {
    "sha": "7e2d4bcef9d1ff308611b0b6b52c076f11633375",
    "filename": "src/test/resources/co/rsk/bitcoinj/script/tx_valid.json",
    "status": "modified",
    "additions": 84,
    "deletions": 0,
    "changes": 84,
    "blob_url": "https://github.com/rsksmart/bitcoinj-thin/blob/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/resources/co/rsk/bitcoinj/script/tx_valid.json",
    "raw_url": "https://github.com/rsksmart/bitcoinj-thin/raw/fd0f493ba8c32e3c2a0d19b6e315305139b936ac/src/test/resources/co/rsk/bitcoinj/script/tx_valid.json",
    "contents_url": "https://api.github.com/repos/rsksmart/bitcoinj-thin/contents/src/test/resources/co/rsk/bitcoinj/script/tx_valid.json?ref=fd0f493ba8c32e3c2a0d19b6e315305139b936ac",
    "patch": "@@ -232,5 +232,89 @@\n [[[\"a54b3bff74c910adff4f81b641587440c9f3b02a67c69b06d4eea36c0d199bac\", 0, \"DUP HASH160 0x14 0x33b9fe6942f268ae728136046e638c8863bed91f EQUALVERIFY CHECKSIG\"]],\n \"0100000001ac9b190d6ca3eed4069bc6672ab0f3c940745841b6814fffad10c974ff3b4ba5000000006c493046022100c16257354c7ec7fedda7ce724abfc6a8f26fd433d08b1a11bd01a8f0f157b1fb0221009069419fa4454cd52f1d3219c395b96c3dc0404257196f96d819d71e4f95b8290121039770779101a01dbbf6c25466df8869e648dc75a51d64ebf5136c824c32fcc9c8ffffffff0100000000000000001976a914aaf0529f46a86271255621ed566e79e67345916d88ac00000000\", \"P2SH\"],\n \n+[\"CHECKSEQUENCEVERIFY tests\"],\n+\n+[\"By-height locks, with argument == 0 and == txin.nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"65535 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffff00000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"65535 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffbf7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffbf7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"By-time locks, with argument == 0 and == txin.nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffff40000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4259839 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffff7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffff7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Upper sequence with upper sequence is fine\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000800100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000800100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000feffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument 2^31 with various nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffbf7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffff7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483648 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument 2^32-1 with various nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffbf7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffff7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4294967295 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Argument 3<<31 with various nSequence\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"6442450944 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffbf7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"6442450944 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffff7f0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"6442450944 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"5 byte non-minimally-encoded operandss are valid\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x05 0x0000000000 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"The argument can be calculated rather than created directly by a PUSHDATA\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194303 1ADD CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 1SUB CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000ffff00000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"An ADD producing a 5-byte result that sets CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483647 65536 CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"2147483647 4259840 ADD CHECKSEQUENCEVERIFY 1\"]],\n+  \"020000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Valid CHECKSEQUENCEVERIFY in scriptSig\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"1\"]],\n+  \"02000000010001000000000000000000000000000000000000000000000000000000000000000000000251b2010000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n+[\"Valid CHECKSEQUENCEVERIFY in redeemScript\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7c17aff532f22beb54069942f9bf567a66133eaf EQUAL\"]],\n+  \"0200000001000100000000000000000000000000000000000000000000000000000000000000000000030251b2010000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n+\n [\"Make diffs cleaner by leaving a comment here without comma at the end\"]\n ]"
  }
]
