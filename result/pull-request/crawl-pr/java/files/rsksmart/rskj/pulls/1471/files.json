[
  {
    "sha": "b09b56adfaeb7d7068730dc9e79f642e286b8be8",
    "filename": "gradle/verification-metadata.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/gradle/verification-metadata.xml",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/gradle/verification-metadata.xml",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/gradle/verification-metadata.xml?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -46,12 +46,12 @@\n             <sha256 value=\"fdc35a9ab3a43880c1714de0a8e5f98b0a41b7e7d8cd805cfbf028392f2b1a14\" origin=\"Generated by Gradle\"/>\n          </artifact>\n       </component>\n-      <component group=\"co.rsk.bitcoinj\" name=\"bitcoinj-thin\" version=\"0.14.4-rsk-10-rc\">\n-         <artifact name=\"bitcoinj-thin-0.14.4-rsk-10-rc.jar\">\n-            <sha256 value=\"033a3386d27f2f20cf5aa997d3ea98e0070c796eb9cb1035f5820eee2a049654\" origin=\"Generated by Gradle\"/>\n+      <component group=\"co.rsk.bitcoinj\" name=\"bitcoinj-thin\" version=\"0.14.4-rsk-10-erp\">\n+         <artifact name=\"bitcoinj-thin-0.14.4-rsk-10-erp.jar\">\n+            <sha256 value=\"dea3df78f99af2fd44108d37a832885d2631ea59d4a933a42c95832997d711cb\" origin=\"Generated by Gradle\"/>\n          </artifact>\n-         <artifact name=\"bitcoinj-thin-0.14.4-rsk-10-rc.pom\">\n-            <sha256 value=\"cc0f88b7339d309fc49efe0b51729e92e942ec85387c5f627a8eee283a6bb7b4\" origin=\"Generated by Gradle\"/>\n+         <artifact name=\"bitcoinj-thin-0.14.4-rsk-10-erp.pom\">\n+            <sha256 value=\"9e75caf991c8c622fc36258087312a1245e6c4c848a44d1635b8c8b0b37c07c8\" origin=\"Generated by Gradle\"/>\n          </artifact>\n       </component>\n       <component group=\"com.fasterxml\" name=\"oss-parent\" version=\"27\">"
  },
  {
    "sha": "97228776b31fd4ede0a6c544863bc2cf1236766d",
    "filename": "rskj-core/build.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/build.gradle",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/build.gradle",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/build.gradle?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -65,7 +65,7 @@ ext {\n     powermockitoVersion = '2.0.2'\n     rskLllVersion = '0.0.2'\n     logbackVersion = '1.2.2'\n-    bitcoinjVersion = '0.14.4-rsk-10-rc'\n+    bitcoinjVersion = '0.14.4-rsk-10-erp'\n     nettyVersion = '4.0.56.Final'\n     nativeLibrary = '1.2.0'\n }"
  },
  {
    "sha": "771853f98ab201c7625a9d9f2be4ba3cff9a7510",
    "filename": "rskj-core/src/main/java/co/rsk/config/BridgeConstants.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeConstants.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeConstants.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/config/BridgeConstants.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -18,10 +18,12 @@\n \n package co.rsk.config;\n \n+import co.rsk.bitcoinj.core.BtcECKey;\n import co.rsk.bitcoinj.core.Coin;\n import co.rsk.bitcoinj.core.NetworkParameters;\n import co.rsk.peg.AddressBasedAuthorizer;\n import co.rsk.peg.Federation;\n+import java.util.List;\n \n public class BridgeConstants {\n     protected String btcParamsString;\n@@ -66,6 +68,12 @@\n \n     protected int maxDepthBlockchainAccepted;\n \n+    protected long erpFedActivationDelay;\n+\n+    protected List<BtcECKey> erpFedPubKeysList;\n+\n+    protected String oldFederationAddress;\n+\n     public NetworkParameters getBtcParams() {\n         return NetworkParameters.fromID(btcParamsString);\n     }\n@@ -128,6 +136,18 @@ public long getFundsMigrationAgeSinceActivationEnd() {\n \n     public int getMaxDepthToSearchBlocksBelowIndexActivation() { return maxDepthToSearchBlocksBelowIndexActivation; }\n \n+    public long getErpFedActivationDelay() {\n+        return erpFedActivationDelay;\n+    }\n+\n+    public List<BtcECKey> getErpFedPubKeysList() {\n+        return erpFedPubKeysList;\n+    }\n+\n+    public String getOldFederationAddress() {\n+        return oldFederationAddress;\n+    }\n+\n     public long getMinSecondsBetweenCallsToReceiveHeader() { return minSecondsBetweenCallsReceiveHeader; }\n \n     public int getMaxDepthBlockchainAccepted() { return maxDepthBlockchainAccepted; }"
  },
  {
    "sha": "469c47edbdf722083342eefa3a248d2a8c52bb16",
    "filename": "rskj-core/src/main/java/co/rsk/config/BridgeDevNetConstants.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeDevNetConstants.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeDevNetConstants.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/config/BridgeDevNetConstants.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -132,6 +132,21 @@ public BridgeDevNetConstants(List<BtcECKey> federationPublicKeys) {\n         btcHeightWhenBlockIndexActivates = 700_000; //TODO define this value when Iris activation height in RSK is determined\n \n         maxDepthToSearchBlocksBelowIndexActivation = 1_000; //TODO define this value with Sergio\n+\n+        erpFedActivationDelay = 1000;\n+\n+        // Keys generated with GenNodeKey using generators 'erp-fed-01' through 'erp-fed-05'\n+        erpFedPubKeysList = Arrays.stream(new String[]{\n+                \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+                \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+                \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+                \"03776b1fd8f86da3c1db3d69699e8250a15877d286734ea9a6da8e9d8ad25d16c1\",\n+                \"03ab0e2cd7ed158687fc13b88019990860cdb72b1f5777b58513312550ea1584bc\"\n+            }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList()\n+        );\n+\n+        oldFederationAddress = \"2N7ZgQyhFKm17RbaLqygYbS7KLrQfapyZzu\";\n+\n         minSecondsBetweenCallsReceiveHeader = 600;  // 10 minutes in Seconds\n \n         maxDepthBlockchainAccepted = 25;"
  },
  {
    "sha": "7fa7ce14bdc1971147577c33ae4cb94c22482be5",
    "filename": "rskj-core/src/main/java/co/rsk/config/BridgeMainNetConstants.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeMainNetConstants.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeMainNetConstants.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/config/BridgeMainNetConstants.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -7,6 +7,7 @@\n import co.rsk.peg.Federation;\n import co.rsk.peg.FederationMember;\n import com.google.common.collect.Lists;\n+import java.util.ArrayList;\n import org.bouncycastle.util.encoders.Hex;\n import org.ethereum.crypto.ECKey;\n \n@@ -130,6 +131,14 @@\n         btcHeightWhenBlockIndexActivates = 700_000; //TODO define this value when Iris activation height in RSK is determined\n         maxDepthToSearchBlocksBelowIndexActivation = 1_000; //TODO define this value with Sergio\n \n+        // TODO: This value is not real\n+        erpFedActivationDelay = 5063;\n+\n+        // TODO: WE NEED TO DEFINE THESE KEYS\n+        erpFedPubKeysList = new ArrayList<>();\n+\n+        oldFederationAddress = \"35JUi1FxabGdhygLhnNUEFG4AgvpNMgxK1\";\n+\n         minSecondsBetweenCallsReceiveHeader = 600;  // 10 minutes in Seconds\n         maxDepthBlockchainAccepted = 25;\n     }"
  },
  {
    "sha": "c24352f015ae8ee4c308938af946bb9e2f470b8c",
    "filename": "rskj-core/src/main/java/co/rsk/config/BridgeRegTestConstants.java",
    "status": "modified",
    "additions": 15,
    "deletions": 1,
    "changes": 16,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeRegTestConstants.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeRegTestConstants.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/config/BridgeRegTestConstants.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -47,7 +47,7 @@\n             .map(key -> BtcECKey.fromPublicOnly(key.getPubKey()))\n             .collect(Collectors.toList());\n \n-    private static BridgeRegTestConstants instance = new BridgeRegTestConstants(REGTEST_FEDERATION_PUBLIC_KEYS);\n+    private static final BridgeRegTestConstants instance = new BridgeRegTestConstants(REGTEST_FEDERATION_PUBLIC_KEYS);\n \n     public BridgeRegTestConstants(List<BtcECKey> federationPublicKeys) {\n         btcParamsString = NetworkParameters.ID_REGTEST;\n@@ -137,6 +137,20 @@ public BridgeRegTestConstants(List<BtcECKey> federationPublicKeys) {\n \n         btcHeightWhenBlockIndexActivates = 10;\n         maxDepthToSearchBlocksBelowIndexActivation = 1_000; //TODO define this value with Sergio\n+\n+        erpFedActivationDelay = 1000;\n+\n+        // Keys generated with GenNodeKey using generators 'erp-fed-01' through 'erp-fed-05'\n+        erpFedPubKeysList = Arrays.stream(new String[]{\n+                \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+                \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+                \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+                \"03776b1fd8f86da3c1db3d69699e8250a15877d286734ea9a6da8e9d8ad25d16c1\",\n+                \"03ab0e2cd7ed158687fc13b88019990860cdb72b1f5777b58513312550ea1584bc\"\n+            }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList()\n+        );\n+\n+        oldFederationAddress = \"2N7ZgQyhFKm17RbaLqygYbS7KLrQfapyZzu\";\n     }\n \n     public static BridgeRegTestConstants getInstance() {"
  },
  {
    "sha": "447f2477ca6243d39a16b519c639019f16d4754c",
    "filename": "rskj-core/src/main/java/co/rsk/config/BridgeTestNetConstants.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeTestNetConstants.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/config/BridgeTestNetConstants.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/config/BridgeTestNetConstants.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -24,6 +24,7 @@\n import co.rsk.peg.AddressBasedAuthorizer;\n import co.rsk.peg.Federation;\n import co.rsk.peg.FederationMember;\n+import java.util.ArrayList;\n import org.bouncycastle.util.encoders.Hex;\n import org.ethereum.crypto.ECKey;\n \n@@ -130,6 +131,14 @@\n         btcHeightWhenBlockIndexActivates = 700_000; //TODO define this value when Iris activation height in RSK is determined\n         maxDepthToSearchBlocksBelowIndexActivation = 1_000; //TODO define this value with Sergio\n \n+        // TODO: These value is not real\n+        erpFedActivationDelay = 5063;\n+\n+        // TODO: WE NEED TO DEFINE THESE KEYS\n+        erpFedPubKeysList = new ArrayList<>();\n+\n+        oldFederationAddress = \"2N7ZgQyhFKm17RbaLqygYbS7KLrQfapyZzu\";\n+\n         minSecondsBetweenCallsReceiveHeader = 600;  // 10 minutes in Seconds\n         maxDepthBlockchainAccepted = 25;\n     }"
  },
  {
    "sha": "c9e292774f9173afcbbeae2a51ac8c7caa82a111",
    "filename": "rskj-core/src/main/java/co/rsk/peg/BridgeSerializationUtils.java",
    "status": "modified",
    "additions": 33,
    "deletions": 5,
    "changes": 38,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeSerializationUtils.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeSerializationUtils.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/BridgeSerializationUtils.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -20,6 +20,7 @@\n \n import co.rsk.bitcoinj.core.*;\n import co.rsk.bitcoinj.script.Script;\n+import co.rsk.config.BridgeConstants;\n import co.rsk.core.RskAddress;\n import co.rsk.crypto.Keccak256;\n import co.rsk.peg.bitcoin.CoinbaseInformation;\n@@ -243,7 +244,7 @@ private BridgeSerializationUtils(){}\n     }\n \n     // For the serialization format, see BridgeSerializationUtils::serializeFederationWithSerializer\n-    private static Federation deserializeFederationWithDesserializer(\n+    private static Federation deserializeFederationWithDeserializer(\n         byte[] data,\n         NetworkParameters networkParameters,\n         FederationMemberDesserializer federationMemberDesserializer) {\n@@ -285,7 +286,7 @@ private static Federation deserializeFederationWithDesserializer(\n \n     // For the serialization format, see BridgeSerializationUtils::serializeFederationOnlyBtcKeys\n     public static Federation deserializeFederationOnlyBtcKeys(byte[] data, NetworkParameters networkParameters) {\n-        return deserializeFederationWithDesserializer(data, networkParameters,\n+        return deserializeFederationWithDeserializer(data, networkParameters,\n                 (pubKeyBytes -> FederationMember.getFederationMemberFromKey(BtcECKey.fromPublicOnly(pubKeyBytes))));\n     }\n \n@@ -299,9 +300,36 @@ public static Federation deserializeFederationOnlyBtcKeys(byte[] data, NetworkPa\n     }\n \n     // For the serialization format, see BridgeSerializationUtils::serializeFederation\n-    public static Federation deserializeFederation(byte[] data, NetworkParameters networkParameters) {\n-        return deserializeFederationWithDesserializer(data, networkParameters,\n-                BridgeSerializationUtils::deserializeFederationMember);\n+    public static Federation deserializeFederation(\n+        byte[] data,\n+        NetworkParameters networkParameters\n+    ) {\n+        return deserializeFederationWithDeserializer(\n+            data,\n+            networkParameters,\n+            BridgeSerializationUtils::deserializeFederationMember\n+        );\n+    }\n+\n+    public static ErpFederation deserializeErpFederation(\n+        byte[] data,\n+        NetworkParameters networkParameters,\n+        BridgeConstants bridgeConstants\n+    ) {\n+        Federation federation = deserializeFederationWithDeserializer(\n+            data,\n+            networkParameters,\n+            BridgeSerializationUtils::deserializeFederationMember\n+        );\n+\n+        return new ErpFederation(\n+            federation.getMembers(),\n+            federation.creationTime,\n+            federation.getCreationBlockNumber(),\n+            federation.getBtcParams(),\n+            bridgeConstants.getErpFedPubKeysList(),\n+            bridgeConstants.getErpFedActivationDelay()\n+        );\n     }\n \n     /**"
  },
  {
    "sha": "ad0b28b62c2526452150e1bbc42366df1020cf75",
    "filename": "rskj-core/src/main/java/co/rsk/peg/BridgeStorageProvider.java",
    "status": "modified",
    "additions": 78,
    "deletions": 28,
    "changes": 106,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeStorageProvider.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeStorageProvider.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/BridgeStorageProvider.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -76,6 +76,7 @@\n     private static final DataWord OLD_FEDERATION_FORMAT_VERSION = DataWord.fromString(\"oldFederationFormatVersion\");\n     private static final DataWord PENDING_FEDERATION_FORMAT_VERSION = DataWord.fromString(\"pendingFederationFormatVersion\");\n     private static final Integer FEDERATION_FORMAT_VERSION_MULTIKEY = 1000;\n+    private static final Integer ERP_FEDERATION_FORMAT_VERSION = 2000;\n \n     // Dummy value to use when saved Fast Bridge Derivation Argument Hash\n     private static final byte FAST_BRIDGE_FEDERATION_DERIVATION_ARGUMENTS_HASH_TRUE_VALUE = (byte) 1;\n@@ -84,6 +85,7 @@\n     private final RskAddress contractAddress;\n     private final NetworkParameters networkParameters;\n     private final ActivationConfig.ForBlock activations;\n+    private final BridgeConstants bridgeConstants;\n \n     private Map<Sha256Hash, Long> btcTxHashesAlreadyProcessed;\n \n@@ -142,6 +144,7 @@ public BridgeStorageProvider(\n         this.networkParameters = bridgeConstants.getBtcParams();\n         this.activations = activations;\n         this.storageVersion = new HashMap<>();\n+        this.bridgeConstants = bridgeConstants;\n     }\n \n     public List<UTXO> getNewFederationBtcUTXOs() throws IOException {\n@@ -345,12 +348,20 @@ public Federation getNewFederation() {\n \n         Optional<Integer> storageVersion = getStorageVersion(NEW_FEDERATION_FORMAT_VERSION);\n \n-        newFederation = safeGetFromRepository(NEW_FEDERATION_KEY,\n-                data ->\n-                        data == null\n-                        ? null\n-                        : deserializeFederationAccordingToVersion(data, storageVersion)\n+        newFederation = safeGetFromRepository(\n+            NEW_FEDERATION_KEY,\n+            data -> {\n+                if (data == null) {\n+                    return null;\n+                }\n+                if (storageVersion.isPresent()) {\n+                    return deserializeFederationAccordingToVersion(data, storageVersion.get(), bridgeConstants);\n+                }\n+\n+                return BridgeSerializationUtils.deserializeFederationOnlyBtcKeys(data, networkParameters);\n+            }\n         );\n+\n         return newFederation;\n     }\n \n@@ -370,7 +381,17 @@ public void saveNewFederation() {\n         RepositorySerializer<Federation> serializer = BridgeSerializationUtils::serializeFederationOnlyBtcKeys;\n \n         if (activations.isActive(RSKIP123)) {\n-            saveStorageVersion(NEW_FEDERATION_FORMAT_VERSION, FEDERATION_FORMAT_VERSION_MULTIKEY);\n+            if (activations.isActive(RSKIP201) && newFederation instanceof ErpFederation) {\n+                saveStorageVersion(\n+                    NEW_FEDERATION_FORMAT_VERSION,\n+                    ERP_FEDERATION_FORMAT_VERSION\n+                );\n+            } else {\n+                saveStorageVersion(\n+                    NEW_FEDERATION_FORMAT_VERSION,\n+                    FEDERATION_FORMAT_VERSION_MULTIKEY\n+                );\n+            }\n             serializer = BridgeSerializationUtils::serializeFederation;\n         }\n \n@@ -384,11 +405,20 @@ public Federation getOldFederation() {\n \n         Optional<Integer> storageVersion = getStorageVersion(OLD_FEDERATION_FORMAT_VERSION);\n \n-        oldFederation = safeGetFromRepository(OLD_FEDERATION_KEY,\n-                data -> data == null\n-                        ? null\n-                        : deserializeFederationAccordingToVersion(data, storageVersion)\n+        oldFederation = safeGetFromRepository(\n+            OLD_FEDERATION_KEY,\n+            data -> {\n+                if (data == null) {\n+                    return null;\n+                }\n+                if (storageVersion.isPresent()) {\n+                    return deserializeFederationAccordingToVersion(data, storageVersion.get(), bridgeConstants);\n+                }\n+\n+                return BridgeSerializationUtils.deserializeFederationOnlyBtcKeys(data, networkParameters);\n+            }\n         );\n+\n         return oldFederation;\n     }\n \n@@ -402,10 +432,22 @@ public void setOldFederation(Federation federation) {\n      */\n     public void saveOldFederation() {\n         if (shouldSaveOldFederation) {\n-            RepositorySerializer<Federation> serializer = BridgeSerializationUtils::serializeFederationOnlyBtcKeys;\n+            RepositorySerializer<Federation> serializer =\n+                BridgeSerializationUtils::serializeFederationOnlyBtcKeys;\n \n             if (activations.isActive(RSKIP123)) {\n-                saveStorageVersion(OLD_FEDERATION_FORMAT_VERSION, FEDERATION_FORMAT_VERSION_MULTIKEY);\n+                if (activations.isActive(RSKIP201) && oldFederation instanceof ErpFederation) {\n+                    saveStorageVersion(\n+                        OLD_FEDERATION_FORMAT_VERSION,\n+                        ERP_FEDERATION_FORMAT_VERSION\n+                    );\n+                } else {\n+                    saveStorageVersion(\n+                        OLD_FEDERATION_FORMAT_VERSION,\n+                        FEDERATION_FORMAT_VERSION_MULTIKEY\n+                    );\n+                }\n+\n                 serializer = BridgeSerializationUtils::serializeFederation;\n             }\n \n@@ -420,11 +462,20 @@ public PendingFederation getPendingFederation() {\n \n         Optional<Integer> storageVersion = getStorageVersion(PENDING_FEDERATION_FORMAT_VERSION);\n \n-        pendingFederation = safeGetFromRepository(PENDING_FEDERATION_KEY,\n-                data -> data == null\n-                        ? null :\n-                        deserializePendingFederationAccordingToVersion(data, storageVersion)\n+        pendingFederation = safeGetFromRepository(\n+            PENDING_FEDERATION_KEY,\n+            data -> {\n+                if (data == null) {\n+                    return null;\n+                }\n+                if (storageVersion.isPresent()) {\n+                    return BridgeSerializationUtils.deserializePendingFederation(data); // Assume this is the multi-key version\n+                }\n+\n+                return BridgeSerializationUtils.deserializePendingFederationOnlyBtcKeys(data);\n+            }\n         );\n+\n         return pendingFederation;\n     }\n \n@@ -915,24 +966,23 @@ private void saveStorageVersion(DataWord versionKey, Integer version) {\n         storageVersion.put(versionKey, Optional.of(version));\n     }\n \n-    private Federation deserializeFederationAccordingToVersion(byte[] data, Optional<Integer> version) {\n-        if (!version.isPresent()) {\n-            return BridgeSerializationUtils.deserializeFederationOnlyBtcKeys(data, networkParameters);\n+    private Federation deserializeFederationAccordingToVersion(\n+        byte[] data,\n+        Integer version,\n+        BridgeConstants bridgeConstants\n+    ) {\n+        if (version.equals(ERP_FEDERATION_FORMAT_VERSION)) {\n+            return BridgeSerializationUtils.deserializeErpFederation(\n+                data,\n+                networkParameters,\n+                bridgeConstants\n+            );\n         }\n \n         // Assume this is the multi-key version\n         return BridgeSerializationUtils.deserializeFederation(data, networkParameters);\n     }\n \n-    private PendingFederation deserializePendingFederationAccordingToVersion(byte[] data, Optional<Integer> version) {\n-        if (!version.isPresent()) {\n-            return BridgeSerializationUtils.deserializePendingFederationOnlyBtcKeys(data);\n-        }\n-\n-        // Assume this is the multi-key version\n-        return BridgeSerializationUtils.deserializePendingFederation(data);\n-    }\n-\n     private <T> T safeGetFromRepository(DataWord keyAddress, RepositoryDeserializer<T> deserializer) {\n         try {\n             return getFromRepository(keyAddress, deserializer);"
  },
  {
    "sha": "f65ca44feedec99436f93b2af867bb7d6ae23728",
    "filename": "rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java",
    "status": "modified",
    "additions": 33,
    "deletions": 3,
    "changes": 36,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/BridgeSupport.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -419,6 +419,13 @@ public void registerBtcTransaction(Transaction rskTx, byte[] btcTxSerialized, in\n     protected TxType getTransactionType(BtcTransaction btcTx) {\n         Script retiredFederationP2SHScript = provider.getLastRetiredFederationP2SHScript().orElse(null);\n \n+        /************************************************************************/\n+        /** Special case to migrate funds from an old federation               **/\n+        /************************************************************************/\n+        if (activations.isActive(ConsensusRule.RSKIP199) && txIsFromOldFederation(btcTx)) {\n+            return TxType.MIGRATION;\n+        }\n+\n         if (BridgeUtils.isPegInTx(btcTx, getLiveFederations(), retiredFederationP2SHScript, btcContext, bridgeConstants)) {\n             return TxType.PEGIN;\n         }\n@@ -441,6 +448,20 @@ protected TxType getTransactionType(BtcTransaction btcTx) {\n         return TxType.UNKNOWN;\n     }\n \n+    private boolean txIsFromOldFederation(BtcTransaction btcTx) {\n+        Address oldFederationAddress = Address.fromBase58(bridgeConstants.getBtcParams(), bridgeConstants.getOldFederationAddress());\n+        Script p2shScript = ScriptBuilder.createP2SHOutputScript(oldFederationAddress.getHash160());\n+\n+        for (int i = 0; i < btcTx.getInputs().size(); i++) {\n+            if (BridgeUtils.scriptCorrectlySpendsTx(btcTx, i, p2shScript)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+\n     protected void processPegIn(\n         BtcTransaction btcTx,\n         Transaction rskTx,\n@@ -960,7 +981,8 @@ private void processReleaseRequests() {\n                 btcContext.getParams(),\n                 activeFederationWallet,\n                 getFederationAddress(),\n-                getFeePerKb()\n+                getFeePerKb(),\n+                activations\n         );\n \n         releaseRequestQueue.process(MAX_RELEASE_ITERATIONS, (ReleaseRequestQueue.Entry releaseRequest) -> {\n@@ -1820,7 +1842,14 @@ protected Integer commitFederation(boolean dryRun, Keccak256 hash) throws IOExce\n         Instant creationTime = Instant.ofEpochMilli(rskExecutionBlock.getTimestamp());\n         Federation oldFederation = getActiveFederation();\n         provider.setOldFederation(oldFederation);\n-        provider.setNewFederation(currentPendingFederation.buildFederation(creationTime, rskExecutionBlock.getNumber(), bridgeConstants.getBtcParams()));\n+        provider.setNewFederation(\n+            currentPendingFederation.buildFederation(\n+                creationTime,\n+                rskExecutionBlock.getNumber(),\n+                bridgeConstants,\n+                activations\n+            )\n+        );\n         provider.setPendingFederation(null);\n \n         // Clear votes on election\n@@ -2747,7 +2776,8 @@ private void generateRejectionRelease(\n             btcContext.getParams(),\n             walletProvider.provide(btcTx, spendingAddress),\n             btcRefundAddress,\n-            getFeePerKb()\n+            getFeePerKb(),\n+            activations\n         );\n \n         Optional<ReleaseTransactionBuilder.BuildResult> buildReturnResult = txBuilder.buildEmptyWalletTo(btcRefundAddress);"
  },
  {
    "sha": "02c07887435fd968facba695034605a4daa06910",
    "filename": "rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java",
    "status": "modified",
    "additions": 32,
    "deletions": 5,
    "changes": 37,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/BridgeUtils.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -20,6 +20,9 @@\n \n import co.rsk.bitcoinj.core.*;\n import co.rsk.bitcoinj.crypto.TransactionSignature;\n+import co.rsk.bitcoinj.script.RedeemScriptParser;\n+import co.rsk.bitcoinj.script.RedeemScriptParser.MultiSigType;\n+import co.rsk.bitcoinj.script.RedeemScriptParserFactory;\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.script.ScriptChunk;\n import co.rsk.bitcoinj.wallet.Wallet;\n@@ -128,7 +131,7 @@ public static Wallet getFederationsSpendWallet(\n         return wallet;\n     }\n \n-    private static boolean scriptCorrectlySpendsTx(BtcTransaction tx, int index, Script script) {\n+    public static boolean scriptCorrectlySpendsTx(BtcTransaction tx, int index, Script script) {\n         try {\n             TransactionInput txInput = tx.getInput(index);\n             txInput.getScriptSig().correctlySpends(tx, index, script, Script.ALL_VERIFY_FLAGS);\n@@ -262,8 +265,18 @@ public static int countMissingSignatures(Context btcContext, BtcTransaction btcT\n         TransactionInput input = btcTx.getInput(0);\n         Script scriptSig = input.getScriptSig();\n         List<ScriptChunk> chunks = scriptSig.getChunks();\n+        Script redeemScript = new Script(chunks.get(chunks.size() - 1).data);\n+        RedeemScriptParser parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n \n-        for (int i = 1; i < chunks.size() - 1; i++) {\n+        int lastChunk;\n+\n+        if (parser.getMultiSigType() == MultiSigType.STANDARD_MULTISIG) {\n+            lastChunk = chunks.size() - 1;\n+        } else {\n+            lastChunk = chunks.size() - 2;\n+        }\n+\n+        for (int i = 1; i < lastChunk; i++) {\n             ScriptChunk chunk = chunks.get(i);\n             if (!chunk.isOpCode() && chunk.data.length == 0) {\n                 unsigned++;\n@@ -282,10 +295,24 @@ public static boolean hasEnoughSignatures(Context btcContext, BtcTransaction btc\n         // When the tx is constructed OP_0 are placed where signature should go.\n         // Check all OP_0 have been replaced with actual signatures in all inputs\n         Context.propagate(btcContext);\n+        Script scriptSig;\n+        List<ScriptChunk> chunks;\n+        Script redeemScript;\n+        RedeemScriptParser parser;\n+\n+        int lastChunk;\n         for (TransactionInput input : btcTx.getInputs()) {\n-            Script scriptSig = input.getScriptSig();\n-            List<ScriptChunk> chunks = scriptSig.getChunks();\n-            for (int i = 1; i < chunks.size(); i++) {\n+            scriptSig = input.getScriptSig();\n+            chunks = scriptSig.getChunks();\n+            redeemScript = new Script(chunks.get(chunks.size() - 1).data);\n+            parser = RedeemScriptParserFactory.get(redeemScript.getChunks());\n+\n+            if (parser.getMultiSigType() == MultiSigType.STANDARD_MULTISIG) {\n+                lastChunk = chunks.size() - 1;\n+            } else {\n+                lastChunk = chunks.size() - 2;\n+            }\n+            for (int i = 1; i < lastChunk; i++) {\n                 ScriptChunk chunk = chunks.get(i);\n                 if (!chunk.isOpCode() && chunk.data.length == 0) {\n                     return false;"
  },
  {
    "sha": "d2dd70974916dae6f6cf0c048b5f8badabbf8ceb",
    "filename": "rskj-core/src/main/java/co/rsk/peg/ErpFederation.java",
    "status": "added",
    "additions": 113,
    "deletions": 0,
    "changes": 113,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/ErpFederation.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/ErpFederation.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/ErpFederation.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -0,0 +1,113 @@\n+package co.rsk.peg;\n+\n+import co.rsk.bitcoinj.core.Address;\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.bitcoinj.script.ErpFederationRedeemScriptParser;\n+import co.rsk.bitcoinj.script.Script;\n+import co.rsk.bitcoinj.script.ScriptBuilder;\n+import co.rsk.peg.utils.EcKeyUtils;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class ErpFederation extends Federation {\n+    private final List<BtcECKey> erpPubKeys;\n+    private final long activationDelay;\n+\n+    public ErpFederation(\n+        List<FederationMember> members,\n+        Instant creationTime,\n+        long creationBlockNumber,\n+        NetworkParameters btcParams,\n+        List<BtcECKey> erpPubKeys,\n+        long activationDelay\n+    ) {\n+        super(members, creationTime, creationBlockNumber, btcParams);\n+        this.erpPubKeys = EcKeyUtils.getCompressedPubKeysList(erpPubKeys);\n+        this.activationDelay = activationDelay;\n+    }\n+\n+    public List<BtcECKey> getErpPubKeys() {\n+        return Collections.unmodifiableList(erpPubKeys);\n+    }\n+\n+    public long getActivationDelay() {\n+        return activationDelay;\n+    }\n+\n+    @Override\n+    public Script getRedeemScript() {\n+        if (redeemScript == null) {\n+            redeemScript = ErpFederationRedeemScriptParser.createErpRedeemScript(\n+                ScriptBuilder.createRedeemScript(getNumberOfSignaturesRequired(), getBtcPublicKeys()),\n+                ScriptBuilder.createRedeemScript(erpPubKeys.size() / 2 + 1, erpPubKeys),\n+                activationDelay\n+            );\n+        }\n+\n+        return redeemScript;\n+    }\n+\n+    @Override\n+    public Script getStandardRedeemScript() {\n+        return ErpFederationRedeemScriptParser.extractStandardRedeemScript(\n+            getRedeemScript().getChunks()\n+        );\n+    }\n+\n+    @Override\n+    public Script getP2SHScript() {\n+        if (p2shScript == null) {\n+            p2shScript = ScriptBuilder.createP2SHOutputScript(getRedeemScript());\n+        }\n+\n+        return p2shScript;\n+    }\n+\n+    @Override\n+    public Address getAddress() {\n+        if (address == null) {\n+            address = Address.fromP2SHScript(btcParams, getP2SHScript());\n+        }\n+\n+        return address;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other == null || this.getClass() != other.getClass()) {\n+            return false;\n+        }\n+\n+        ErpFederation otherErpFederation = (ErpFederation) other;\n+\n+        return this.getNumberOfSignaturesRequired() == otherErpFederation.getNumberOfSignaturesRequired() &&\n+            this.getSize() == otherErpFederation.getSize() &&\n+            this.getCreationTime().equals(otherErpFederation.getCreationTime()) &&\n+            this.creationBlockNumber == otherErpFederation.creationBlockNumber &&\n+            this.btcParams.equals(otherErpFederation.btcParams) &&\n+            this.members.equals(otherErpFederation.members) &&\n+            this.erpPubKeys.equals(otherErpFederation.erpPubKeys) &&\n+            this.activationDelay == otherErpFederation.activationDelay;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        // Can use java.util.Objects.hash since all of Instant, int and List<BtcECKey> have\n+        // well-defined hashCode()s\n+        return Objects.hash(\n+            getCreationTime(),\n+            this.creationBlockNumber,\n+            getNumberOfSignaturesRequired(),\n+            getBtcPublicKeys(),\n+            getErpPubKeys(),\n+            getActivationDelay()\n+        );\n+    }\n+}"
  },
  {
    "sha": "afb0977da1594d8605482f39226c497bc266be92",
    "filename": "rskj-core/src/main/java/co/rsk/peg/FastBridgeCompatibleBtcWallet.java",
    "status": "modified",
    "additions": 23,
    "deletions": 4,
    "changes": 27,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/FastBridgeCompatibleBtcWallet.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/FastBridgeCompatibleBtcWallet.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/FastBridgeCompatibleBtcWallet.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -1,8 +1,12 @@\n package co.rsk.peg;\n \n import co.rsk.bitcoinj.core.Context;\n-import co.rsk.bitcoinj.script.FastBridgeRedeemScriptParser;\n import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.script.FastBridgeErpRedeemScriptParser;\n+import co.rsk.bitcoinj.script.FastBridgeRedeemScriptParser;\n+import co.rsk.bitcoinj.script.RedeemScriptParser;\n+import co.rsk.bitcoinj.script.RedeemScriptParser.MultiSigType;\n+import co.rsk.bitcoinj.script.RedeemScriptParserFactory;\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.wallet.RedeemData;\n import co.rsk.peg.fastbridge.FastBridgeFederationInformation;\n@@ -40,9 +44,24 @@ public RedeemData findRedeemDataFromScriptHash(byte[] payToScriptHash) {\n \n             Federation destinationFederationInstance = destinationFederation.get();\n             Script fedRedeemScript = destinationFederationInstance.getRedeemScript();\n-            Script fastBridgeRedeemScript = FastBridgeRedeemScriptParser\n-                .createMultiSigFastBridgeRedeemScript(fedRedeemScript,\n-                    Sha256Hash.wrap(fastBridgeFederationInformationInstance.getDerivationHash().getBytes()));\n+\n+            RedeemScriptParser parser = RedeemScriptParserFactory.get(fedRedeemScript.getChunks());\n+            Script fastBridgeRedeemScript;\n+\n+            if (parser.getMultiSigType() == MultiSigType.ERP_FED) {\n+                fastBridgeRedeemScript = FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+                    fedRedeemScript,\n+                    Sha256Hash.wrap(fastBridgeFederationInformationInstance\n+                        .getDerivationHash()\n+                        .getBytes()\n+                    )\n+                );\n+            } else {\n+                fastBridgeRedeemScript = FastBridgeRedeemScriptParser\n+                    .createMultiSigFastBridgeRedeemScript(fedRedeemScript,\n+                        Sha256Hash.wrap(fastBridgeFederationInformationInstance.getDerivationHash()\n+                            .getBytes()));\n+            }\n \n             return RedeemData.of(destinationFederationInstance.getBtcPublicKeys(), fastBridgeRedeemScript);\n         }"
  },
  {
    "sha": "67ecfd784d54d1072e453caa72b06143908b9390",
    "filename": "rskj-core/src/main/java/co/rsk/peg/Federation.java",
    "status": "modified",
    "additions": 12,
    "deletions": 8,
    "changes": 20,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/Federation.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/Federation.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/Federation.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -39,15 +39,15 @@\n  * @author Ariel Mendelzon\n  */\n \n-public final class Federation {\n-    private final List<FederationMember> members;\n-    private final Instant creationTime;\n-    private final long creationBlockNumber;\n-    private final NetworkParameters btcParams;\n+public class Federation {\n+    protected final List<FederationMember> members;\n+    protected final Instant creationTime;\n+    protected final long creationBlockNumber;\n+    protected final NetworkParameters btcParams;\n \n-    private Script redeemScript;\n-    private Script p2shScript;\n-    private Address address;\n+    protected Script redeemScript;\n+    protected Script p2shScript;\n+    protected Address address;\n \n     public Federation(List<FederationMember> members, Instant creationTime, long creationBlockNumber,  NetworkParameters btcParams) {\n         // Sorting members ensures same order of federation members for same members\n@@ -104,6 +104,10 @@ public Script getRedeemScript() {\n         return redeemScript;\n     }\n \n+    public Script getStandardRedeemScript() {\n+        return getRedeemScript();\n+    }\n+\n     public Script getP2SHScript() {\n         if (p2shScript == null) {\n             p2shScript = ScriptBuilder.createP2SHOutputScript(getNumberOfSignaturesRequired(), getBtcPublicKeys());"
  },
  {
    "sha": "4df582d249e867bc56110e9c36b7e736aa50beb4",
    "filename": "rskj-core/src/main/java/co/rsk/peg/PendingFederation.java",
    "status": "modified",
    "additions": 30,
    "deletions": 6,
    "changes": 36,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/PendingFederation.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/PendingFederation.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/PendingFederation.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -19,8 +19,10 @@\n package co.rsk.peg;\n \n import co.rsk.bitcoinj.core.BtcECKey;\n-import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.config.BridgeConstants;\n import co.rsk.crypto.Keccak256;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n import org.ethereum.crypto.HashUtil;\n \n import java.time.Instant;\n@@ -29,6 +31,8 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Immutable representation of an RSK Pending Federation.\n@@ -39,9 +43,10 @@\n  * @author Ariel Mendelzon\n  */\n public final class PendingFederation {\n+    private static final Logger logger = LoggerFactory.getLogger(\"PendingFederation\");\n     private static final int MIN_MEMBERS_REQUIRED = 2;\n \n-    private List<FederationMember> members;\n+    private final List<FederationMember> members;\n \n     public PendingFederation(List<FederationMember> members) {\n         // Sorting members ensures same order for members\n@@ -57,7 +62,7 @@ public PendingFederation(List<FederationMember> members) {\n \n     public List<BtcECKey> getBtcPublicKeys() {\n         // Copy keys since we don't control immutability of BtcECKey(s)\n-        return members.stream().map(m -> m.getBtcPublicKey()).collect(Collectors.toList());\n+        return members.stream().map(FederationMember::getBtcPublicKey).collect(Collectors.toList());\n     }\n \n     public boolean isComplete() {\n@@ -78,19 +83,38 @@ public PendingFederation addMember(FederationMember member) {\n     /**\n      * Builds a Federation from this PendingFederation\n      * @param creationTime the creation time for the new Federation\n-     * @param btcParams the bitcoin parameters for the new Federation\n+     * @param bridgeConstants to get the bitcoin parameters for the new Federation,\n+     * and the keys for creating an ERP Federation\n+     * @param activations Activation configuration to check hard fork\n      * @return a Federation\n      */\n-    public Federation buildFederation(Instant creationTime, long blockNumber, NetworkParameters btcParams) {\n+    public Federation buildFederation(\n+        Instant creationTime,\n+        long blockNumber,\n+        BridgeConstants bridgeConstants,\n+        ActivationConfig.ForBlock activations\n+        ) {\n         if (!this.isComplete()) {\n             throw new IllegalStateException(\"PendingFederation is incomplete\");\n         }\n \n+        if (activations.isActive(ConsensusRule.RSKIP201)) {\n+            logger.info(\"[buildFederation] Going to create an ERP Federation\");\n+            return new ErpFederation(\n+                members,\n+                creationTime,\n+                blockNumber,\n+                bridgeConstants.getBtcParams(),\n+                bridgeConstants.getErpFedPubKeysList(),\n+                bridgeConstants.getErpFedActivationDelay()\n+            );\n+        }\n+\n         return new Federation(\n                 members,\n                 creationTime,\n                 blockNumber,\n-                btcParams\n+                bridgeConstants.getBtcParams()\n         );\n     }\n "
  },
  {
    "sha": "2ae0da859dbb745ef740a7273c255b9ef31d6493",
    "filename": "rskj-core/src/main/java/co/rsk/peg/ReleaseTransactionBuilder.java",
    "status": "modified",
    "additions": 17,
    "deletions": 2,
    "changes": 19,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/ReleaseTransactionBuilder.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/ReleaseTransactionBuilder.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/ReleaseTransactionBuilder.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -21,6 +21,8 @@\n import co.rsk.bitcoinj.core.*;\n import co.rsk.bitcoinj.wallet.SendRequest;\n import co.rsk.bitcoinj.wallet.Wallet;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -65,12 +67,20 @@ public BtcTransaction getBtcTx() {\n     private final Wallet wallet;\n     private final Address changeAddress;\n     private final Coin feePerKb;\n-\n-    public ReleaseTransactionBuilder(NetworkParameters params, Wallet wallet, Address changeAddress, Coin feePerKb) {\n+    private final ActivationConfig.ForBlock activations;\n+\n+    public ReleaseTransactionBuilder(\n+        NetworkParameters params,\n+        Wallet wallet,\n+        Address changeAddress,\n+        Coin feePerKb,\n+        ActivationConfig.ForBlock activations\n+    ) {\n         this.params = params;\n         this.wallet = wallet;\n         this.changeAddress = changeAddress;\n         this.feePerKb = feePerKb;\n+        this.activations = activations;\n     }\n \n     public Wallet getWallet() {\n@@ -106,6 +116,11 @@ public Coin getFeePerKb() {\n \n         // Build a tx and send request and configure it\n         BtcTransaction btcTx = new BtcTransaction(params);\n+\n+        if (activations.isActive(ConsensusRule.RSKIP201)) {\n+            btcTx.setVersion(2);\n+        }\n+\n         SendRequest sr = SendRequest.forTx(btcTx);\n         // Default settings\n         defaultSettingsConfigurator.configure(sr);"
  },
  {
    "sha": "b624f30aa91456f880dbdf720b6e0c66c046cbee",
    "filename": "rskj-core/src/main/java/co/rsk/peg/utils/EcKeyUtils.java",
    "status": "added",
    "additions": 24,
    "deletions": 0,
    "changes": 24,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/utils/EcKeyUtils.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/co/rsk/peg/utils/EcKeyUtils.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/co/rsk/peg/utils/EcKeyUtils.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -0,0 +1,24 @@\n+package co.rsk.peg.utils;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public final class EcKeyUtils {\n+\n+    private EcKeyUtils() {}\n+\n+    public static List<BtcECKey> getCompressedPubKeysList(List<BtcECKey> pubKeys) {\n+        List<BtcECKey> compressedPubKeysList = new ArrayList<>();\n+\n+        for (BtcECKey key: pubKeys) {\n+            compressedPubKeysList.add(\n+                BtcECKey.fromPublicOnly(\n+                    key.getPubKeyPoint().getEncoded(true)\n+                )\n+            );\n+        }\n+\n+        return compressedPubKeysList;\n+    }\n+}"
  },
  {
    "sha": "d49e91b7fcf77f4b0c6dc0aa9bc2c086f2e8e6c0",
    "filename": "rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/java/org/ethereum/config/blockchain/upgrades/ConsensusRule.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -66,7 +66,8 @@\n     RSKIP191(\"rskip191\"),\n     RSKIP197(\"rskip197\"), //Handle error in Precompile Contracts execution.\n     RSKIP199(\"rskip199\"),\n-    RSKIP200(\"rskip200\");\n+    RSKIP200(\"rskip200\"),\n+    RSKIP201(\"rskip201\");\n \n     private String configKey;\n "
  },
  {
    "sha": "f85edc591932937dd73ee8e04688a6d6d1ca3ad6",
    "filename": "rskj-core/src/main/resources/expected.conf",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/resources/expected.conf",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/resources/expected.conf",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/resources/expected.conf?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -62,6 +62,7 @@ blockchain = {\n              rskip197 = <hardforkName>\n              rskip199 = <hardforkName>\n              rskip200 = <hardforkName>\n+             rskip201 = <hardforkName>\n          }\n     }\n     gc = {"
  },
  {
    "sha": "62023be4ca8312a4f7fdd78ee5ecaf23eec8b015",
    "filename": "rskj-core/src/main/resources/reference.conf",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/resources/reference.conf",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/main/resources/reference.conf",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/main/resources/reference.conf?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -53,6 +53,7 @@ blockchain = {\n             rskip197 = iris300\n             rskip199 = iris300\n             rskip200 = iris300\n+            rskip201 = iris300\n         }\n     }\n     gc = {"
  },
  {
    "sha": "68aef9785df972944cdd13a8e40a4684480555ba",
    "filename": "rskj-core/src/test/java/co/rsk/peg/BridgeSerializationUtilsTest.java",
    "status": "modified",
    "additions": 58,
    "deletions": 18,
    "changes": 76,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeSerializationUtilsTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeSerializationUtilsTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/BridgeSerializationUtilsTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -21,6 +21,8 @@\n import co.rsk.bitcoinj.core.*;\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.script.ScriptBuilder;\n+import co.rsk.config.BridgeConstants;\n+import co.rsk.config.BridgeRegTestConstants;\n import co.rsk.core.RskAddress;\n import co.rsk.peg.fastbridge.FastBridgeFederationInformation;\n import co.rsk.peg.whitelist.LockWhitelist;\n@@ -227,25 +229,12 @@ public void deserializeFederationOnlyBtcKeys_wrongListSize() throws Exception {\n \n     @Test\n     public void serializeAndDeserializeFederation() {\n-        final int NUM_CASES = 20;\n-\n-        final NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n-\n-        for (int i = 0; i < NUM_CASES; i++) {\n-            int numMembers = randomInRange(2, 14);\n-            List<FederationMember> members = new ArrayList<>();\n-            for (int j = 0; j < numMembers; j++) {\n-                members.add(new FederationMember(new BtcECKey(), new ECKey(), new ECKey()));\n-            }\n-            Federation testFederation = new Federation(members, Instant.now(), 123, networkParameters);\n-\n-            byte[] serializedTestFederation = BridgeSerializationUtils.serializeFederation(testFederation);\n-\n-            Federation deserializedTestFederation = BridgeSerializationUtils.deserializeFederation(\n-                    serializedTestFederation, networkParameters);\n+        testSerializeAndDeserializeFederation(false);\n+    }\n \n-            Assert.assertEquals(testFederation, deserializedTestFederation);\n-        }\n+    @Test\n+    public void serializeAndDeserializeErpFederation() {\n+        testSerializeAndDeserializeFederation(true);\n     }\n \n     @Test\n@@ -1122,6 +1111,57 @@ public void serializeFastBridgeInformation_Ok() {\n         Assert.assertArrayEquals(fastBridge.getFastBridgeScriptHash(), result.getFastBridgeScriptHash());\n     }\n \n+    private void testSerializeAndDeserializeFederation(boolean isErpFed) {\n+        final int NUM_CASES = 20;\n+        final NetworkParameters networkParameters = NetworkParameters.fromID(NetworkParameters.ID_REGTEST);\n+        final BridgeConstants bridgeConstants = BridgeRegTestConstants.getInstance();\n+\n+        for (int i = 0; i < NUM_CASES; i++) {\n+            int numMembers = randomInRange(2, 14);\n+            List<FederationMember> members = new ArrayList<>();\n+\n+            for (int j = 0; j < numMembers; j++) {\n+                members.add(new FederationMember(new BtcECKey(), new ECKey(), new ECKey()));\n+            }\n+\n+            Federation testFederation;\n+\n+            if (isErpFed) {\n+                 testFederation = new ErpFederation(\n+                    members,\n+                    Instant.now(),\n+                    123,\n+                    networkParameters,\n+                    bridgeConstants.getErpFedPubKeysList(),\n+                    bridgeConstants.getErpFedActivationDelay()\n+                );\n+            } else {\n+                testFederation = new Federation(\n+                    members,\n+                    Instant.now(),\n+                    123,\n+                    networkParameters\n+                );\n+            }\n+\n+            byte[] serializedTestFederation = BridgeSerializationUtils.serializeFederation(testFederation);\n+            Federation deserializedTestFederation;\n+\n+            if (isErpFed) {\n+                deserializedTestFederation = BridgeSerializationUtils.deserializeErpFederation(\n+                    serializedTestFederation,\n+                    networkParameters,\n+                    bridgeConstants\n+                );\n+            } else {\n+                deserializedTestFederation = BridgeSerializationUtils.deserializeFederation(\n+                    serializedTestFederation, networkParameters);\n+            }\n+\n+            Assert.assertEquals(testFederation, deserializedTestFederation);\n+        }\n+    }\n+\n     private Address mockAddressHash160(String hash160) {\n         Address result = mock(Address.class);\n         when(result.getHash160()).thenReturn(Hex.decode(hash160));"
  },
  {
    "sha": "b87111d713fccb9fccf2ebfa7ac31f4c566db858",
    "filename": "rskj-core/src/test/java/co/rsk/peg/BridgeStorageProviderTest.java",
    "status": "modified",
    "additions": 293,
    "deletions": 203,
    "changes": 496,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeStorageProviderTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeStorageProviderTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/BridgeStorageProviderTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -42,6 +42,7 @@\n import org.apache.commons.lang3.tuple.Pair;\n import org.bouncycastle.util.encoders.Hex;\n import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig.ForBlock;\n import org.ethereum.config.blockchain.upgrades.ActivationConfigsForTest;\n import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n import org.ethereum.core.Repository;\n@@ -298,7 +299,7 @@ public void createSaveAndRecreateInstanceWithUTXOS() throws IOException {\n     }\n \n     @Test\n-    public void getNewFederation_initialVersion() throws IOException {\n+    public void getNewFederation_initialVersion() {\n         List<Integer> storageCalls = new ArrayList<>();\n         List<Integer> deserializeCalls = new ArrayList<>();\n         Federation newFederation = buildMockFederation(100, 200, 300);\n@@ -348,7 +349,7 @@ public void getNewFederation_initialVersion() throws IOException {\n     }\n \n     @Test\n-    public void getNewFederation_initialVersion_nullBytes() throws IOException {\n+    public void getNewFederation_initialVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -388,56 +389,28 @@ public void getNewFederation_initialVersion_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void getNewFederation_multiKeyVersion() throws IOException {\n-        List<Integer> storageCalls = new ArrayList<>();\n-        List<Integer> deserializeCalls = new ArrayList<>();\n+    public void getNewFederation_multiKeyVersion() {\n         Federation newFederation = buildMockFederation(100, 200, 300);\n-        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n-        Repository repositoryMock = mock(Repository.class);\n-        BridgeStorageProvider storageProvider = new BridgeStorageProvider(\n-            repositoryMock,\n-            mockAddress(\"aabbccdd\"),\n-            config.getNetworkConstants().getBridgeConstants(),\n-            activationsBeforeFork\n-        );\n-\n-        when(repositoryMock.getStorageBytes(any(RskAddress.class), any(DataWord.class))).then((InvocationOnMock invocation) -> {\n-            storageCalls.add(0);\n-            RskAddress contractAddress = invocation.getArgument(0);\n-            DataWord address = invocation.getArgument(1);\n-\n-            Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-\n-            if (storageCalls.size() == 1) {\n-                // First call is storage version getter\n-                Assert.assertEquals(DataWord.fromString(\"newFederationFormatVersion\"), address);\n-                return RLP.encodeBigInteger(BigInteger.valueOf(1234));\n-            } else {\n-                // Second call is the actual storage getter\n-                Assert.assertEquals(2, storageCalls.size());\n-                Assert.assertEquals(DataWord.fromString(\"newFederation\"), address);\n-                return new byte[]{(byte) 0xaa};\n-            }\n-        });\n+        testGetNewFederationPostMultiKey(newFederation, activationsBeforeFork);\n+    }\n \n-        PowerMockito.when(BridgeSerializationUtils.deserializeFederation(any(byte[].class), any(NetworkParameters.class))).then((InvocationOnMock invocation) -> {\n-            deserializeCalls.add(0);\n-            byte[] data = invocation.getArgument(0);\n-            NetworkParameters networkParameters = invocation.getArgument(1);\n-            // Make sure we're deserializing what just came from the repo with the correct BTC context\n-            Assert.assertTrue(Arrays.equals(new byte[]{(byte)0xaa}, data));\n-            Assert.assertEquals(networkParameters, config.getNetworkConstants().getBridgeConstants().getBtcParams());\n-            return newFederation;\n-        });\n+    @Test\n+    public void getNewFederation_RSKIP_201_active_erp_fed() {\n+        Federation newFederation = buildMockFederation(100, 200, 300);\n+        ErpFederation erpFederation = new ErpFederation(\n+            newFederation.getMembers(),\n+            newFederation.getCreationTime(),\n+            newFederation.getCreationBlockNumber(),\n+            newFederation.getBtcParams(),\n+            config.getNetworkConstants().getBridgeConstants().getErpFedPubKeysList(),\n+            config.getNetworkConstants().getBridgeConstants().getErpFedActivationDelay()\n+        );\n \n-        Assert.assertEquals(newFederation, storageProvider.getNewFederation());\n-        Assert.assertEquals(newFederation, storageProvider.getNewFederation());\n-        Assert.assertEquals(2, storageCalls.size());\n-        Assert.assertEquals(1, deserializeCalls.size());\n+        testGetNewFederationPostMultiKey(erpFederation, activationsAllForks);\n     }\n \n     @Test\n-    public void getNewFederation_multiKeyVersion_nullBytes() throws IOException {\n+    public void getNewFederation_multiKeyVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -477,7 +450,7 @@ public void getNewFederation_multiKeyVersion_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void saveNewFederation_preMultikey() throws IOException {\n+    public void saveNewFederation_preMultikey() {\n         Federation newFederation = buildMockFederation(100, 200, 300);\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         List<Integer> serializeCalls = new ArrayList<>();\n@@ -504,9 +477,10 @@ public void saveNewFederation_preMultikey() throws IOException {\n             DataWord address = invocation.getArgument(1);\n             byte[] data = invocation.getArgument(2);\n             // Make sure the bytes are set to the correct address in the repo and that what's saved is what was serialized\n-            Assert.assertTrue(Arrays.equals(new byte[]{(byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd}, contractAddress.getBytes()));\n+            assertArrayEquals(new byte[]{(byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd},\n+                contractAddress.getBytes());\n             Assert.assertEquals(DataWord.valueOf(\"newFederation\".getBytes(StandardCharsets.UTF_8)), address);\n-            Assert.assertTrue(Arrays.equals(new byte[]{(byte)0xbb}, data));\n+            assertArrayEquals(new byte[]{(byte) 0xbb}, data);\n             return null;\n         }).when(repositoryMock).addStorageBytes(any(RskAddress.class), any(DataWord.class), any(byte[].class));\n \n@@ -521,59 +495,30 @@ public void saveNewFederation_preMultikey() throws IOException {\n     }\n \n     @Test\n-    public void saveNewFederation_postMultikey() throws IOException {\n+    public void saveNewFederation_postMultiKey() {\n         Federation newFederation = buildMockFederation(100, 200, 300);\n-        List<Integer> storageBytesCalls = new ArrayList<>();\n-        List<Integer> serializeCalls = new ArrayList<>();\n-        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n-        useOriginalIntegerSerialization();\n-        Repository repositoryMock = mock(Repository.class);\n-        BridgeStorageProvider storageProvider = new BridgeStorageProvider(\n-            repositoryMock,\n-            mockAddress(\"aabbccdd\"),\n-            config.getNetworkConstants().getBridgeConstants(),\n-            activationsAllForks\n-        );\n+        testSaveNewFederationPostMultiKey(newFederation, 1000);\n+    }\n \n-        PowerMockito.when(BridgeSerializationUtils.serializeFederation(any(Federation.class))).then((InvocationOnMock invocation) -> {\n-            Federation federation = invocation.getArgument(0);\n-            Assert.assertEquals(newFederation, federation);\n-            serializeCalls.add(0);\n-            return new byte[]{(byte)0xbb};\n-        });\n-        Mockito.doAnswer((InvocationOnMock invocation) -> {\n-            storageBytesCalls.add(0);\n-            RskAddress contractAddress = invocation.getArgument(0);\n-            DataWord address = invocation.getArgument(1);\n-            byte[] data = invocation.getArgument(2);\n+    @Test\n+    public void saveNewFederation_postMultiKey_RSKIP_201_active_erp_fed() {\n+        BridgeConstants bridgeConstants = config.getNetworkConstants().getBridgeConstants();\n+        Federation newFederation = buildMockFederation(100, 200, 300);\n \n-            if (storageBytesCalls.size() == 1) {\n-                // First call is the version setting\n-                Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-                Assert.assertEquals(DataWord.fromString(\"newFederationFormatVersion\"), address);\n-                Assert.assertEquals(BigInteger.valueOf(1000), RLP.decodeBigInteger(data, 0));\n-            } else {\n-                Assert.assertEquals(2, storageBytesCalls.size());\n-                // Make sure the bytes are set to the correct address in the repo and that what's saved is what was serialized\n-                Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-                Assert.assertEquals(DataWord.fromString(\"newFederation\"), address);\n-                Assert.assertTrue(Arrays.equals(new byte[]{(byte) 0xbb}, data));\n-            }\n-            return null;\n-        }).when(repositoryMock).addStorageBytes(any(RskAddress.class), any(DataWord.class), any(byte[].class));\n+        ErpFederation erpFederation = new ErpFederation(\n+            newFederation.getMembers(),\n+            newFederation.getCreationTime(),\n+            newFederation.getCreationBlockNumber(),\n+            newFederation.getBtcParams(),\n+            bridgeConstants.getErpFedPubKeysList(),\n+            bridgeConstants.getErpFedActivationDelay()\n+        );\n \n-        storageProvider.saveNewFederation();\n-        // Shouldn't have tried to save nor serialize anything\n-        Assert.assertEquals(0, storageBytesCalls.size());\n-        Assert.assertEquals(0, serializeCalls.size());\n-        storageProvider.setNewFederation(newFederation);\n-        storageProvider.saveNewFederation();\n-        Assert.assertEquals(2, storageBytesCalls.size());\n-        Assert.assertEquals(1, serializeCalls.size());\n+        testSaveNewFederationPostMultiKey(erpFederation, 2000);\n     }\n \n     @Test\n-    public void getOldFederation_initialVersion() throws IOException {\n+    public void getOldFederation_initialVersion() {\n         List<Integer> storageCalls = new ArrayList<>();\n         List<Integer> deserializeCalls = new ArrayList<>();\n         Federation oldFederation = buildMockFederation(100, 200, 300);\n@@ -621,7 +566,7 @@ public void getOldFederation_initialVersion() throws IOException {\n     }\n \n     @Test\n-    public void getOldFederation_initialVersion_nullBytes() throws IOException {\n+    public void getOldFederation_initialVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -661,55 +606,29 @@ public void getOldFederation_initialVersion_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void getOldFederation_multiKeyVersion() throws IOException {\n-        List<Integer> storageCalls = new ArrayList<>();\n-        List<Integer> deserializeCalls = new ArrayList<>();\n+    public void getOldFederation_multiKeyVersion() {\n         Federation oldFederation = buildMockFederation(100, 200, 300);\n-        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n-        Repository repositoryMock = mock(Repository.class);\n-        BridgeStorageProvider storageProvider = new BridgeStorageProvider(\n-            repositoryMock,\n-            mockAddress(\"aabbccdd\"),\n-            config.getNetworkConstants().getBridgeConstants(),\n-            activationsBeforeFork\n-        );\n-\n-        when(repositoryMock.getStorageBytes(any(RskAddress.class), any(DataWord.class))).then((InvocationOnMock invocation) -> {\n-            storageCalls.add(0);\n-            RskAddress contractAddress = invocation.getArgument(0);\n-            DataWord address = invocation.getArgument(1);\n-\n-            Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-\n-            if (storageCalls.size() == 1) {\n-                // First call is storage version getter\n-                Assert.assertEquals(DataWord.fromString(\"oldFederationFormatVersion\"), address);\n-                return RLP.encodeBigInteger(BigInteger.valueOf(1234));\n-            } else {\n-                // Second call is the actual storage getter\n-                Assert.assertEquals(2, storageCalls.size());\n-                Assert.assertEquals(DataWord.fromString(\"oldFederation\"), address);\n-                return new byte[]{(byte) 0xaa};\n-            }\n-        });\n+        testGetOldFederation(oldFederation, activationsBeforeFork);\n+    }\n \n-        PowerMockito.when(BridgeSerializationUtils.deserializeFederation(any(byte[].class), any(NetworkParameters.class))).then((InvocationOnMock invocation) -> {\n-            deserializeCalls.add(0);\n-            byte[] data = invocation.getArgument(0);\n-            NetworkParameters networkParameters = invocation.getArgument(1);\n-            // Make sure we're deserializing what just came from the repo with the correct BTC context\n-            Assert.assertTrue(Arrays.equals(new byte[]{(byte)0xaa}, data));\n-            Assert.assertEquals(networkParameters, config.getNetworkConstants().getBridgeConstants().getBtcParams());\n-            return oldFederation;\n-        });\n+    @Test\n+    public void getOldFederation_RSKIP_201_active_erp_fed() {\n+        BridgeConstants bridgeConstants = config.getNetworkConstants().getBridgeConstants();\n+        Federation oldFederation = buildMockFederation(100, 200, 300);\n+        ErpFederation erpFederation = new ErpFederation(\n+            oldFederation.getMembers(),\n+            oldFederation.getCreationTime(),\n+            oldFederation.getCreationBlockNumber(),\n+            oldFederation.getBtcParams(),\n+            bridgeConstants.getErpFedPubKeysList(),\n+            bridgeConstants.getErpFedActivationDelay()\n+        );\n \n-        Assert.assertEquals(oldFederation, storageProvider.getOldFederation());\n-        Assert.assertEquals(2, storageCalls.size());\n-        Assert.assertEquals(1, deserializeCalls.size());\n+        testGetOldFederation(erpFederation, activationsAllForks);\n     }\n \n     @Test\n-    public void getOldFederation_multiKeyVersion_nullBytes() throws IOException {\n+    public void getOldFederation_multiKeyVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -749,7 +668,7 @@ public void getOldFederation_multiKeyVersion_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void saveOldFederation_preMultikey() throws IOException {\n+    public void saveOldFederation_preMultikey() {\n         Federation oldFederation = buildMockFederation(100, 200, 300);\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         List<Integer> serializeCalls = new ArrayList<>();\n@@ -792,54 +711,29 @@ public void saveOldFederation_preMultikey() throws IOException {\n     }\n \n     @Test\n-    public void saveOldFederation_postMultikey() throws IOException {\n+    public void saveOldFederation_postMultikey() {\n         Federation oldFederation = buildMockFederation(100, 200, 300);\n-        List<Integer> storageBytesCalls = new ArrayList<>();\n-        List<Integer> serializeCalls = new ArrayList<>();\n-        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n-        useOriginalIntegerSerialization();\n-        Repository repositoryMock = mock(Repository.class);\n-        BridgeStorageProvider storageProvider = new BridgeStorageProvider(repositoryMock, mockAddress(\"aabbccdd\"), config.getNetworkConstants().getBridgeConstants(), activationsAllForks);\n-\n-        PowerMockito.when(BridgeSerializationUtils.serializeFederation(any(Federation.class))).then((InvocationOnMock invocation) -> {\n-            Federation federation = invocation.getArgument(0);\n-            Assert.assertEquals(oldFederation, federation);\n-            serializeCalls.add(0);\n-            return new byte[]{(byte)0xbb};\n-        });\n-        Mockito.doAnswer((InvocationOnMock invocation) -> {\n-            storageBytesCalls.add(0);\n-            RskAddress contractAddress = invocation.getArgument(0);\n-            DataWord address = invocation.getArgument(1);\n-            byte[] data = invocation.getArgument(2);\n+        testSaveOldFederation(oldFederation, 1000);\n+    }\n \n-            if (storageBytesCalls.size() == 1) {\n-                // First call is the version setting\n-                Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-                Assert.assertEquals(DataWord.fromString(\"oldFederationFormatVersion\"), address);\n-                Assert.assertEquals(BigInteger.valueOf(1000), RLP.decodeBigInteger(data, 0));\n-            } else {\n-                Assert.assertEquals(2, storageBytesCalls.size());\n-                // Make sure the bytes are set to the correct address in the repo and that what's saved is what was serialized\n-                Assert.assertTrue(Arrays.equals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes()));\n-                Assert.assertEquals(DataWord.fromString(\"oldFederation\"), address);\n-                Assert.assertTrue(Arrays.equals(new byte[]{(byte) 0xbb}, data));\n-            }\n-            return null;\n-        }).when(repositoryMock).addStorageBytes(any(RskAddress.class), any(DataWord.class), any(byte[].class));\n+    @Test\n+    public void saveOldFederation_postMultikey_RSKIP_201_active_erp_fed() {\n+        BridgeConstants bridgeConstants = config.getNetworkConstants().getBridgeConstants();\n+        Federation oldFederation = buildMockFederation(100, 200, 300);\n+        ErpFederation erpFederation = new ErpFederation(\n+            oldFederation.getMembers(),\n+            oldFederation.getCreationTime(),\n+            oldFederation.getCreationBlockNumber(),\n+            oldFederation.getBtcParams(),\n+            bridgeConstants.getErpFedPubKeysList(),\n+            bridgeConstants.getErpFedActivationDelay()\n+        );\n \n-        storageProvider.saveOldFederation();\n-        // Shouldn't have tried to save nor serialize anything\n-        Assert.assertEquals(0, storageBytesCalls.size());\n-        Assert.assertEquals(0, serializeCalls.size());\n-        storageProvider.setOldFederation(oldFederation);\n-        storageProvider.saveOldFederation();\n-        Assert.assertEquals(2, storageBytesCalls.size());\n-        Assert.assertEquals(1, serializeCalls.size());\n+        testSaveOldFederation(erpFederation, 2000);\n     }\n \n     @Test\n-    public void saveOldFederation_preMultikey_setToNull() throws IOException {\n+    public void saveOldFederation_preMultikey_setToNull() {\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         useOriginalIntegerSerialization();\n@@ -873,7 +767,7 @@ public void saveOldFederation_preMultikey_setToNull() throws IOException {\n     }\n \n     @Test\n-    public void saveOldFederation_postMultikey_setToNull() throws IOException {\n+    public void saveOldFederation_postMultikey_setToNull() {\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         useOriginalIntegerSerialization();\n@@ -915,7 +809,7 @@ public void saveOldFederation_postMultikey_setToNull() throws IOException {\n     }\n \n     @Test\n-    public void getPendingFederation_initialVersion() throws IOException {\n+    public void getPendingFederation_initialVersion() {\n         List<Integer> storageCalls = new ArrayList<>();\n         List<Integer> deserializeCalls = new ArrayList<>();\n         PendingFederation pendingFederation = buildMockPendingFederation(100, 200, 300);\n@@ -956,7 +850,7 @@ public void getPendingFederation_initialVersion() throws IOException {\n     }\n \n     @Test\n-    public void getPendingFederation_initialVersion_nullBytes() throws IOException {\n+    public void getPendingFederation_initialVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -989,7 +883,7 @@ public void getPendingFederation_initialVersion_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void getPendingFederation_multiKeyVersion() throws IOException {\n+    public void getPendingFederation_multiKeyVersion() {\n         List<Integer> storageCalls = new ArrayList<>();\n         List<Integer> deserializeCalls = new ArrayList<>();\n         PendingFederation pendingFederation = buildMockPendingFederation(100, 200, 300);\n@@ -1030,7 +924,7 @@ public void getPendingFederation_multiKeyVersion() throws IOException {\n     }\n \n     @Test\n-    public void getPendingFederation_multiKeyVersion_nullBytes() throws IOException {\n+    public void getPendingFederation_multiKeyVersion_nullBytes() {\n         List<Integer> storageCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -1063,7 +957,7 @@ public void getPendingFederation_multiKeyVersion_nullBytes() throws IOException\n     }\n \n     @Test\n-    public void savePendingFederation_preMultikey() throws IOException {\n+    public void savePendingFederation_preMultikey() {\n         PendingFederation pendingFederation = buildMockPendingFederation(100, 200, 300);\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         List<Integer> serializeCalls = new ArrayList<>();\n@@ -1100,7 +994,7 @@ public void savePendingFederation_preMultikey() throws IOException {\n     }\n \n     @Test\n-    public void savePendingFederation_preMultikey_setToNull() throws IOException {\n+    public void savePendingFederation_preMultikey_setToNull() {\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         Repository repositoryMock = mock(Repository.class);\n@@ -1132,7 +1026,7 @@ public void savePendingFederation_preMultikey_setToNull() throws IOException {\n     }\n \n     @Test\n-    public void savePendingFederation_postMultikey() throws IOException {\n+    public void savePendingFederation_postMultikey() {\n         PendingFederation pendingFederation = buildMockPendingFederation(100, 200, 300);\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         List<Integer> serializeCalls = new ArrayList<>();\n@@ -1178,7 +1072,7 @@ public void savePendingFederation_postMultikey() throws IOException {\n     }\n \n     @Test\n-    public void savePendingFederation_postMultikey_setToNull() throws IOException {\n+    public void savePendingFederation_postMultikey_setToNull() {\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         PowerMockito.mockStatic(BridgeSerializationUtils.class);\n         useOriginalIntegerSerialization();\n@@ -1219,7 +1113,7 @@ public void savePendingFederation_postMultikey_setToNull() throws IOException {\n     }\n \n     @Test\n-    public void getFederationElection_nonNullBytes() throws IOException {\n+    public void getFederationElection_nonNullBytes() {\n         List<Integer> calls = new ArrayList<>();\n         AddressBasedAuthorizer authorizerMock = mock(AddressBasedAuthorizer.class);\n         ABICallElection electionMock = mock(ABICallElection.class);\n@@ -1251,7 +1145,7 @@ public void getFederationElection_nonNullBytes() throws IOException {\n     }\n \n     @Test\n-    public void getFederationElection_nullBytes() throws IOException {\n+    public void getFederationElection_nullBytes() {\n         List<Integer> calls = new ArrayList<>();\n         AddressBasedAuthorizer authorizerMock = mock(AddressBasedAuthorizer.class);\n         ABICallElection electionMock = mock(ABICallElection.class);\n@@ -1280,7 +1174,7 @@ public void getFederationElection_nullBytes() throws IOException {\n     }\n \n     @Test\n-    public void saveFederationElection() throws IOException {\n+    public void saveFederationElection() {\n         ABICallElection electionMock = mock(ABICallElection.class);\n         List<Integer> storageBytesCalls = new ArrayList<>();\n         List<Integer> serializeCalls = new ArrayList<>();\n@@ -1996,7 +1890,8 @@ public void setLockingCapAndGetLockingCap() {\n     }\n \n     @Test\n-    public void getHeightIfBtcTxhashIsAlreadyProcessed_before_RSKIP134_does_not_use_new_storage() throws IOException {\n+    public void getHeightIfBtcTxhashIsAlreadyProcessed_before_RSKIP134_does_not_use_new_storage()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Sha256Hash hash = Sha256Hash.ZERO_HASH;\n@@ -2020,7 +1915,8 @@ public void getHeightIfBtcTxhashIsAlreadyProcessed_before_RSKIP134_does_not_use_\n     }\n \n     @Test\n-    public void getHeightIfBtcTxhashIsAlreadyProcessed_after_RSKIP134_uses_new_storage() throws IOException {\n+    public void getHeightIfBtcTxhashIsAlreadyProcessed_after_RSKIP134_uses_new_storage()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Sha256Hash hash1 = Sha256Hash.ZERO_HASH;\n@@ -2070,7 +1966,8 @@ public void getHeightIfBtcTxhashIsAlreadyProcessed_after_RSKIP134_uses_new_stora\n     }\n \n     @Test\n-    public void setHeightBtcTxhashAlreadyProcessed_before_RSKIP134_does_not_use_new_storage() throws IOException {\n+    public void setHeightBtcTxhashAlreadyProcessed_before_RSKIP134_does_not_use_new_storage()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Sha256Hash hash = Sha256Hash.ZERO_HASH;\n@@ -2093,7 +1990,8 @@ public void setHeightBtcTxhashAlreadyProcessed_before_RSKIP134_does_not_use_new_\n     }\n \n     @Test\n-    public void setHeightBtcTxhashAlreadyProcessed_before_RSKIP134_uses_new_storage() throws IOException {\n+    public void setHeightBtcTxhashAlreadyProcessed_before_RSKIP134_uses_new_storage()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Sha256Hash hash = Sha256Hash.ZERO_HASH;\n@@ -2901,12 +2799,11 @@ public void saveDerivationArgumentsScriptHash_afterRSKIP176_Ok() throws IOExcept\n     }\n \n     @Test\n-    public void saveDerivationArgumentsScriptHash_afterRSKIP176_nullBtcTxHash_notSaved() throws IOException {\n+    public void saveDerivationArgumentsScriptHash_afterRSKIP176_nullBtcTxHash_notSaved()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Keccak256 derivationHash = PegTestUtils.createHash3(1);\n-        Sha256Hash btcTxHash = null;\n-\n         ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n         when(activations.isActive(ConsensusRule.RSKIP176)).thenReturn(true);\n \n@@ -2917,15 +2814,16 @@ public void saveDerivationArgumentsScriptHash_afterRSKIP176_nullBtcTxHash_notSav\n                 activations\n         );\n \n-        provider.markFastBridgeFederationDerivationHashAsUsed(btcTxHash, derivationHash);\n+        provider.markFastBridgeFederationDerivationHashAsUsed(null, derivationHash);\n \n         provider.save();\n \n         verifyZeroInteractions(repository);\n     }\n \n     @Test\n-    public void saveDerivationArgumentsScriptHash_afterRSKIP176_nullDerivationHash_notSaved() throws IOException {\n+    public void saveDerivationArgumentsScriptHash_afterRSKIP176_nullDerivationHash_notSaved()\n+        throws IOException {\n         Repository repository = mock(Repository.class);\n \n         Keccak256 derivationHash = null;\n@@ -3293,6 +3191,198 @@ public void saveReceiveHeadersLastTimestamp_not_set() throws IOException {\n         );\n     }\n \n+    private void testGetOldFederation(Federation oldFederation, ForBlock activations) {\n+        BridgeConstants bridgeConstants = config.getNetworkConstants().getBridgeConstants();\n+        List<Integer> storageCalls = new ArrayList<>();\n+        List<Integer> deserializeCalls = new ArrayList<>();\n+        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n+        Repository repositoryMock = mock(Repository.class);\n+        BridgeStorageProvider storageProvider =\n+            new BridgeStorageProvider(\n+                repositoryMock,\n+                mockAddress(\"aabbccdd\"),\n+                bridgeConstants,\n+                activations\n+            );\n+\n+        when(repositoryMock.getStorageBytes(any(RskAddress.class), any(DataWord.class))).then((InvocationOnMock invocation) -> {\n+            storageCalls.add(0);\n+            RskAddress contractAddress = invocation.getArgument(0);\n+            DataWord address = invocation.getArgument(1);\n+\n+            assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+\n+            if (storageCalls.size() == 1) {\n+                // First call is storage version getter\n+                Assert.assertEquals(DataWord.fromString(\"oldFederationFormatVersion\"), address);\n+                return RLP.encodeBigInteger(BigInteger.valueOf(1234));\n+            } else {\n+                // Second call is the actual storage getter\n+                Assert.assertEquals(2, storageCalls.size());\n+                Assert.assertEquals(DataWord.fromString(\"oldFederation\"), address);\n+                return new byte[]{(byte) 0xaa};\n+            }\n+        });\n+\n+        PowerMockito.when(BridgeSerializationUtils.deserializeFederation(any(byte[].class), any(NetworkParameters.class))).then((InvocationOnMock invocation) -> {\n+            deserializeCalls.add(0);\n+            byte[] data = invocation.getArgument(0);\n+            NetworkParameters networkParameters = invocation.getArgument(1);\n+            // Make sure we're deserializing what just came from the repo with the correct BTC context\n+            assertArrayEquals(new byte[]{(byte) 0xaa}, data);\n+            Assert.assertEquals(networkParameters, bridgeConstants.getBtcParams());\n+            return oldFederation;\n+        });\n+\n+        Assert.assertEquals(oldFederation, storageProvider.getOldFederation());\n+        Assert.assertEquals(2, storageCalls.size());\n+        Assert.assertEquals(1, deserializeCalls.size());\n+    }\n+\n+    private void testSaveOldFederation(Federation oldFederation, int version) {\n+        List<Integer> storageBytesCalls = new ArrayList<>();\n+        List<Integer> serializeCalls = new ArrayList<>();\n+        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n+        useOriginalIntegerSerialization();\n+        Repository repositoryMock = mock(Repository.class);\n+        BridgeStorageProvider storageProvider = new BridgeStorageProvider(repositoryMock, mockAddress(\"aabbccdd\"), config.getNetworkConstants().getBridgeConstants(), activationsAllForks);\n+\n+        PowerMockito.when(BridgeSerializationUtils.serializeFederation(any(Federation.class))).then((InvocationOnMock invocation) -> {\n+            Federation federation = invocation.getArgument(0);\n+            Assert.assertEquals(oldFederation, federation);\n+            serializeCalls.add(0);\n+            return new byte[]{(byte)0xbb};\n+        });\n+        Mockito.doAnswer((InvocationOnMock invocation) -> {\n+            storageBytesCalls.add(0);\n+            RskAddress contractAddress = invocation.getArgument(0);\n+            DataWord address = invocation.getArgument(1);\n+            byte[] data = invocation.getArgument(2);\n+\n+            if (storageBytesCalls.size() == 1) {\n+                // First call is the version setting\n+                assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+                Assert.assertEquals(DataWord.fromString(\"oldFederationFormatVersion\"), address);\n+                Assert.assertEquals(BigInteger.valueOf(version), RLP.decodeBigInteger(data, 0));\n+            } else {\n+                Assert.assertEquals(2, storageBytesCalls.size());\n+                // Make sure the bytes are set to the correct address in the repo and that what's saved is what was serialized\n+                assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+                Assert.assertEquals(DataWord.fromString(\"oldFederation\"), address);\n+                assertArrayEquals(new byte[]{(byte) 0xbb}, data);\n+            }\n+            return null;\n+        }).when(repositoryMock).addStorageBytes(any(RskAddress.class), any(DataWord.class), any(byte[].class));\n+\n+        storageProvider.saveOldFederation();\n+        // Shouldn't have tried to save nor serialize anything\n+        Assert.assertEquals(0, storageBytesCalls.size());\n+        Assert.assertEquals(0, serializeCalls.size());\n+        storageProvider.setOldFederation(oldFederation);\n+        storageProvider.saveOldFederation();\n+        Assert.assertEquals(2, storageBytesCalls.size());\n+        Assert.assertEquals(1, serializeCalls.size());\n+    }\n+\n+    private void testGetNewFederationPostMultiKey(Federation federation, ForBlock activations) {\n+        List<Integer> storageCalls = new ArrayList<>();\n+        List<Integer> deserializeCalls = new ArrayList<>();\n+        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n+        Repository repositoryMock = mock(Repository.class);\n+        BridgeConstants bridgeConstants = config.getNetworkConstants().getBridgeConstants();\n+        BridgeStorageProvider storageProvider =\n+            new BridgeStorageProvider(\n+                repositoryMock,\n+                mockAddress(\"aabbccdd\"),\n+                bridgeConstants,\n+                activations\n+            );\n+\n+        when(repositoryMock.getStorageBytes(any(RskAddress.class), any(DataWord.class))).then((InvocationOnMock invocation) -> {\n+            storageCalls.add(0);\n+            RskAddress contractAddress = invocation.getArgument(0);\n+            DataWord address = invocation.getArgument(1);\n+\n+            assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+\n+            if (storageCalls.size() == 1) {\n+                // First call is storage version getter\n+                Assert.assertEquals(DataWord.fromString(\"newFederationFormatVersion\"), address);\n+                return RLP.encodeBigInteger(BigInteger.valueOf(1234));\n+            } else {\n+                // Second call is the actual storage getter\n+                Assert.assertEquals(2, storageCalls.size());\n+                Assert.assertEquals(DataWord.fromString(\"newFederation\"), address);\n+                return new byte[]{(byte) 0xaa};\n+            }\n+        });\n+\n+        PowerMockito.when(BridgeSerializationUtils.deserializeFederation(any(byte[].class), any(NetworkParameters.class))).then((InvocationOnMock invocation) -> {\n+            deserializeCalls.add(0);\n+            byte[] data = invocation.getArgument(0);\n+            NetworkParameters networkParameters = invocation.getArgument(1);\n+            // Make sure we're deserializing what just came from the repo with the correct BTC context\n+            assertArrayEquals(new byte[]{(byte) 0xaa}, data);\n+            Assert.assertEquals(networkParameters, bridgeConstants.getBtcParams());\n+            return federation;\n+        });\n+\n+        Assert.assertEquals(federation, storageProvider.getNewFederation());\n+        Assert.assertEquals(2, storageCalls.size());\n+        Assert.assertEquals(1, deserializeCalls.size());\n+    }\n+\n+    private void testSaveNewFederationPostMultiKey(Federation newFederation, int version) {\n+        List<Integer> storageBytesCalls = new ArrayList<>();\n+        List<Integer> serializeCalls = new ArrayList<>();\n+        PowerMockito.mockStatic(BridgeSerializationUtils.class);\n+        useOriginalIntegerSerialization();\n+        Repository repositoryMock = mock(Repository.class);\n+        BridgeStorageProvider storageProvider =\n+            new BridgeStorageProvider(\n+                repositoryMock,\n+                mockAddress(\"aabbccdd\"),\n+                config.getNetworkConstants().getBridgeConstants(),\n+                activationsAllForks\n+            );\n+\n+        PowerMockito.when(BridgeSerializationUtils.serializeFederation(any(Federation.class))).then((InvocationOnMock invocation) -> {\n+            Federation federation = invocation.getArgument(0);\n+            Assert.assertEquals(newFederation, federation);\n+            serializeCalls.add(0);\n+            return new byte[]{(byte)0xbb};\n+        });\n+        Mockito.doAnswer((InvocationOnMock invocation) -> {\n+            storageBytesCalls.add(0);\n+            RskAddress contractAddress = invocation.getArgument(0);\n+            DataWord address = invocation.getArgument(1);\n+            byte[] data = invocation.getArgument(2);\n+\n+            if (storageBytesCalls.size() == 1) {\n+                // First call is the version setting\n+                assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+                Assert.assertEquals(DataWord.fromString(\"newFederationFormatVersion\"), address);\n+                Assert.assertEquals(BigInteger.valueOf(version), RLP.decodeBigInteger(data, 0));\n+            } else {\n+                Assert.assertEquals(2, storageBytesCalls.size());\n+                // Make sure the bytes are set to the correct address in the repo and that what's saved is what was serialized\n+                assertArrayEquals(Hex.decode(\"aabbccdd\"), contractAddress.getBytes());\n+                Assert.assertEquals(DataWord.fromString(\"newFederation\"), address);\n+                assertArrayEquals(new byte[]{(byte) 0xbb}, data);\n+            }\n+            return null;\n+        }).when(repositoryMock).addStorageBytes(any(RskAddress.class), any(DataWord.class), any(byte[].class));\n+\n+        storageProvider.saveNewFederation();\n+        // Shouldn't have tried to save nor serialize anything\n+        Assert.assertEquals(0, storageBytesCalls.size());\n+        Assert.assertEquals(0, serializeCalls.size());\n+        storageProvider.setNewFederation(newFederation);\n+        storageProvider.saveNewFederation();\n+        Assert.assertEquals(2, storageBytesCalls.size());\n+        Assert.assertEquals(1, serializeCalls.size());\n+    }\n+\n     private BtcTransaction createTransaction() {\n         BtcTransaction tx = new BtcTransaction(networkParameters);\n         tx.addInput(PegTestUtils.createHash(), transactionOffset++, ScriptBuilder.createInputScript(new TransactionSignature(BigInteger.ONE, BigInteger.TEN)));"
  },
  {
    "sha": "5c9a32b32d5837a231ec6eb051db983eeab07b11",
    "filename": "rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java",
    "status": "modified",
    "additions": 262,
    "deletions": 65,
    "changes": 327,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/BridgeSupportTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -16,6 +16,7 @@\n import co.rsk.crypto.Keccak256;\n import co.rsk.db.MutableTrieCache;\n import co.rsk.db.MutableTrieImpl;\n+import co.rsk.peg.BridgeSupport.TxType;\n import co.rsk.peg.bitcoin.CoinbaseInformation;\n import co.rsk.peg.bitcoin.MerkleBranch;\n import co.rsk.peg.btcLockSender.BtcLockSender;\n@@ -92,6 +93,11 @@\n     private static final String DATA = \"80af2871\";\n     private static final co.rsk.core.Coin LIMIT_MONETARY_BASE = new co.rsk.core.Coin(new BigInteger(\"21000000000000000000000000\"));\n     private static final RskAddress contractAddress = PrecompiledContracts.BRIDGE_ADDR;\n+    private static final List<BtcECKey> REGTEST_OLD_FEDERATION_PRIVATE_KEYS = Arrays.asList(\n+        BtcECKey.fromPrivate(Hex.decode(\"47129ffed2c0273c75d21bb8ba020073bb9a1638df0e04853407461fdd9e8b83\")),\n+        BtcECKey.fromPrivate(Hex.decode(\"9f72d27ba603cfab5a0201974a6783ca2476ec3d6b4e2625282c682e0e5f1c35\")),\n+        BtcECKey.fromPrivate(Hex.decode(\"e1b17fcd0ef1942465eee61b20561b16750191143d365e71de08b33dd84a9788\"))\n+    );\n \n     private BridgeConstants bridgeConstants;\n     private NetworkParameters btcParams;\n@@ -5656,49 +5662,53 @@ public void addSignatureMultipleInputsPartiallyValid() throws Exception {\n     }\n \n     @Test\n-    public void getTransactionType_lock_tx() {\n+    public void getTransactionType_pegin_tx() {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class));\n+\n         BtcTransaction btcTx = new BtcTransaction(btcParams);\n         btcTx.addOutput(Coin.COIN.multiply(10), bridgeConstants.getGenesisFederation().getAddress());\n         btcTx.addInput(PegTestUtils.createHash(1), 0, new Script(new byte[]{}));\n-        Assert.assertEquals(BridgeSupport.TxType.PEGIN, bridgeSupport.getTransactionType(btcTx));\n+\n+        Assert.assertEquals(TxType.PEGIN, bridgeSupport.getTransactionType(btcTx));\n     }\n \n     @Test\n-    public void getTransactionType_release_tx() {\n+    public void getTransactionType_pegout_tx() {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class), mock(ActivationConfig.ForBlock.class));\n         Federation federation = bridgeConstants.getGenesisFederation();\n         List<BtcECKey> federationPrivateKeys = BridgeRegTestConstants.REGTEST_FEDERATION_PRIVATE_KEYS;\n-        co.rsk.bitcoinj.core.Address randomAddress =\n-                new co.rsk.bitcoinj.core.Address(\n+        Address randomAddress = new Address(\n                         btcParams,\n-                        org.bouncycastle.util.encoders.Hex.decode(\"4a22c3c4cbb31e4d03b15550636762bda0baf85a\"));\n+                        Hex.decode(\"4a22c3c4cbb31e4d03b15550636762bda0baf85a\")\n+        );\n \n         // Create a tx from the Fed to a random btc address\n         BtcTransaction releaseTx1 = new BtcTransaction(btcParams);\n-        releaseTx1.addOutput(co.rsk.bitcoinj.core.Coin.COIN, randomAddress);\n-        co.rsk.bitcoinj.core.TransactionInput releaseInput1 =\n-                new co.rsk.bitcoinj.core.TransactionInput(btcParams,\n-                        releaseTx1,\n-                        new byte[]{},\n-                        new co.rsk.bitcoinj.core.TransactionOutPoint(\n-                                btcParams,\n-                                0,\n-                                co.rsk.bitcoinj.core.Sha256Hash.ZERO_HASH)\n-                );\n+        releaseTx1.addOutput(Coin.COIN, randomAddress);\n+        TransactionInput releaseInput1 = new TransactionInput(\n+            btcParams,\n+            releaseTx1,\n+            new byte[]{},\n+            new TransactionOutPoint(\n+                btcParams,\n+                0,\n+                Sha256Hash.ZERO_HASH\n+            )\n+        );\n \n         releaseTx1.addInput(releaseInput1);\n \n         // Sign it using the Federation members\n-        co.rsk.bitcoinj.script.Script redeemScript = createBaseRedeemScriptThatSpendsFromTheFederation(federation);\n-        co.rsk.bitcoinj.script.Script inputScript = createBaseInputScriptThatSpendsFromTheFederation(federation);\n+        Script redeemScript = createBaseRedeemScriptThatSpendsFromTheFederation(federation);\n+        Script inputScript = createBaseInputScriptThatSpendsFromTheFederation(federation);\n         releaseInput1.setScriptSig(inputScript);\n \n-        co.rsk.bitcoinj.core.Sha256Hash sighash = releaseTx1.hashForSignature(\n-                0,\n-                redeemScript,\n-                BtcTransaction.SigHash.ALL,\n-                false);\n+        Sha256Hash sighash = releaseTx1.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n \n         for (int i = 0; i < federation.getNumberOfSignaturesRequired(); i++) {\n             BtcECKey federatorPrivKey = federationPrivateKeys.get(i);\n@@ -5708,99 +5718,283 @@ public void getTransactionType_release_tx() {\n             TransactionSignature txSig = new TransactionSignature(sig, BtcTransaction.SigHash.ALL, false);\n \n             int sigIndex = inputScript.getSigInsertionIndex(sighash, federatorPublicKey);\n-            inputScript = ScriptBuilder.updateScriptWithSignature(inputScript,\n-                    txSig.encodeToBitcoin(),\n-                    sigIndex,\n-                    1,\n-                    1);\n+            inputScript = ScriptBuilder.updateScriptWithSignature(\n+                inputScript,\n+                txSig.encodeToBitcoin(),\n+                sigIndex,\n+                1,\n+                1\n+            );\n         }\n         releaseInput1.setScriptSig(inputScript);\n-        Assert.assertEquals(BridgeSupport.TxType.PEGOUT, bridgeSupport.getTransactionType(releaseTx1));\n+\n+        Assert.assertEquals(TxType.PEGOUT, bridgeSupport.getTransactionType(releaseTx1));\n     }\n \n     @Test\n     public void getTransactionType_migration_tx() {\n         FederationSupport mockFederationSupport = mock(FederationSupport.class);\n         BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n         BridgeSupport bridgeSupport = new BridgeSupport(\n-                bridgeConstants,\n-                provider,\n-                mock(BridgeEventLogger.class),\n-                new BtcLockSenderProvider(),\n-                new PeginInstructionsProvider(),\n-                mock(Repository.class),\n-                mock(Block.class),\n-                new Context(bridgeConstants.getBtcParams()),\n-                mockFederationSupport,\n-                null,\n-                mock(ActivationConfig.ForBlock.class)\n+            bridgeConstants,\n+            provider,\n+            mock(BridgeEventLogger.class),\n+            new BtcLockSenderProvider(),\n+            new PeginInstructionsProvider(),\n+            mock(Repository.class),\n+            mock(Block.class),\n+            new Context(bridgeConstants.getBtcParams()),\n+            mockFederationSupport,\n+            null,\n+            mock(ActivationConfig.ForBlock.class)\n         );\n \n         Federation retiringFederation = bridgeConstants.getGenesisFederation();\n         List<BtcECKey> retiringFederationPrivateKeys = BridgeRegTestConstants.REGTEST_FEDERATION_PRIVATE_KEYS;\n \n         List<BtcECKey> activeFederationKeys = Stream.of(\n-                BtcECKey.fromPrivate(Hex.decode(\"fb01\")),\n-                BtcECKey.fromPrivate(Hex.decode(\"fb02\")),\n-                BtcECKey.fromPrivate(Hex.decode(\"fb03\"))\n+            BtcECKey.fromPrivate(Hex.decode(\"fb01\")),\n+            BtcECKey.fromPrivate(Hex.decode(\"fb02\")),\n+            BtcECKey.fromPrivate(Hex.decode(\"fb03\"))\n         ).sorted(BtcECKey.PUBKEY_COMPARATOR).collect(Collectors.toList());\n         Federation activeFederation = new Federation(\n-                FederationTestUtils.getFederationMembersWithBtcKeys(activeFederationKeys),\n-                Instant.ofEpochMilli(1000L),\n-                1L,\n-                btcParams);\n+            FederationTestUtils.getFederationMembersWithBtcKeys(activeFederationKeys),\n+            Instant.ofEpochMilli(1000L),\n+            1L,\n+            btcParams\n+        );\n \n         when(mockFederationSupport.getActiveFederation()).thenReturn(activeFederation);\n         when(mockFederationSupport.getRetiringFederation()).thenReturn(retiringFederation);\n \n         BtcTransaction migrationTx = new BtcTransaction(btcParams);\n         migrationTx.addOutput(Coin.COIN, activeFederation.getAddress());\n         TransactionInput migrationTxInput = new TransactionInput(\n+            btcParams,\n+            null,\n+            new byte[]{},\n+            new TransactionOutPoint(\n                 btcParams,\n-                null,\n-                new byte[]{},\n-                new TransactionOutPoint(btcParams, 0, Sha256Hash.ZERO_HASH)\n+                0,\n+                Sha256Hash.ZERO_HASH\n+            )\n         );\n \n         migrationTx.addInput(migrationTxInput);\n \n         // Sign it using the Federation members\n-        co.rsk.bitcoinj.script.Script redeemScript =\n-                createBaseRedeemScriptThatSpendsFromTheFederation(retiringFederation);\n-        co.rsk.bitcoinj.script.Script inputScript =\n-                createBaseInputScriptThatSpendsFromTheFederation(retiringFederation);\n+        Script redeemScript = createBaseRedeemScriptThatSpendsFromTheFederation(retiringFederation);\n+        Script inputScript = createBaseInputScriptThatSpendsFromTheFederation(retiringFederation);\n         migrationTxInput.setScriptSig(inputScript);\n \n-        co.rsk.bitcoinj.core.Sha256Hash sighash = migrationTx.hashForSignature(0, redeemScript,\n-                BtcTransaction.SigHash.ALL, false);\n+        Sha256Hash sighash = migrationTx.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n \n         for (int i = 0; i < retiringFederation.getNumberOfSignaturesRequired(); i++) {\n             BtcECKey federatorPrivKey = retiringFederationPrivateKeys.get(i);\n             BtcECKey federatorPublicKey = retiringFederation.getBtcPublicKeys().get(i);\n \n             BtcECKey.ECDSASignature sig = federatorPrivKey.sign(sighash);\n-            TransactionSignature txSig = new TransactionSignature(sig, BtcTransaction.SigHash.ALL, false);\n+            TransactionSignature txSig = new TransactionSignature(\n+                sig,\n+                BtcTransaction.SigHash.ALL,\n+                false\n+            );\n \n             int sigIndex = inputScript.getSigInsertionIndex(sighash, federatorPublicKey);\n-            inputScript = ScriptBuilder.updateScriptWithSignature(inputScript,\n-                    txSig.encodeToBitcoin(),\n-                    sigIndex,\n-                    1,\n-                    1);\n+            inputScript = ScriptBuilder.updateScriptWithSignature(\n+                inputScript,\n+                txSig.encodeToBitcoin(),\n+                sigIndex,\n+                1,\n+                1\n+            );\n         }\n         migrationTxInput.setScriptSig(inputScript);\n-        Assert.assertEquals(BridgeSupport.TxType.MIGRATION, bridgeSupport.getTransactionType(migrationTx));\n+        Assert.assertEquals(TxType.MIGRATION, bridgeSupport.getTransactionType(migrationTx));\n \n         when(mockFederationSupport.getRetiringFederation()).thenReturn(null);\n         when(provider.getLastRetiredFederationP2SHScript()).thenReturn(Optional.of(retiringFederation.getP2SHScript()));\n-        Assert.assertEquals(BridgeSupport.TxType.MIGRATION, bridgeSupport.getTransactionType(migrationTx));\n+        Assert.assertEquals(TxType.MIGRATION, bridgeSupport.getTransactionType(migrationTx));\n+    }\n+\n+    @Test\n+    public void getTransactionType_sentFromOldFed_afterRskip199_migration_tx() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP199)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            activations\n+        );\n+\n+        int multisigSigners = 2;\n+        Federation activeFederation = bridgeConstants.getGenesisFederation();\n+        List<BtcECKey> oldFederationPrivateKeys = REGTEST_OLD_FEDERATION_PRIVATE_KEYS;\n+        Script redeemScript = ScriptBuilder.createRedeemScript(multisigSigners, oldFederationPrivateKeys);\n+        Script outputScript = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Address sender = Address.fromP2SHScript(btcParams, outputScript);\n+\n+        Assert.assertEquals(bridgeConstants.getOldFederationAddress(), sender.toBase58());\n+\n+        // Create a tx from the old fed address to the active fed\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        tx.addOutput(Coin.COIN, activeFederation.getAddress());\n+        tx.addInput(Sha256Hash.ZERO_HASH, 0, redeemScript);\n+\n+        Script inputScript = outputScript.createEmptyInputScript(null, redeemScript);\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Sha256Hash sighash = tx.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        for (int i = 0; i < multisigSigners; i++) {\n+            BtcECKey privateKey = oldFederationPrivateKeys.get(i);\n+            BtcECKey publicKey = BtcECKey.fromPublicOnly(privateKey.getPubKeyPoint().getEncoded(true));\n+\n+            BtcECKey.ECDSASignature sig = privateKey.sign(sighash);\n+            TransactionSignature txSig = new TransactionSignature(sig, BtcTransaction.SigHash.ALL, false);\n+\n+            int sigIndex = inputScript.getSigInsertionIndex(sighash, publicKey);\n+            inputScript = ScriptBuilder.updateScriptWithSignature(\n+                inputScript,\n+                txSig.encodeToBitcoin(),\n+                sigIndex,\n+                1,\n+                1\n+            );\n+        }\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Assert.assertEquals(TxType.MIGRATION, bridgeSupport.getTransactionType(tx));\n+    }\n+\n+    @Test\n+    public void getTransactionType_sentFromOldFed_beforeRskip199_pegin_tx() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP199)).thenReturn(false);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            activations\n+        );\n+\n+        int multisigSigners = 2;\n+        Federation activeFederation = bridgeConstants.getGenesisFederation();\n+        List<BtcECKey> oldFederationPrivateKeys = REGTEST_OLD_FEDERATION_PRIVATE_KEYS;\n+        Script redeemScript = ScriptBuilder.createRedeemScript(multisigSigners, oldFederationPrivateKeys);\n+        Script outputScript = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Address sender = Address.fromP2SHScript(btcParams, outputScript);\n+\n+        Assert.assertEquals(bridgeConstants.getOldFederationAddress(), sender.toBase58());\n+\n+        // Create a tx from the old fed address to the active fed\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        tx.addOutput(Coin.COIN, activeFederation.getAddress());\n+        tx.addInput(Sha256Hash.ZERO_HASH, 0, redeemScript);\n+\n+        Script inputScript = outputScript.createEmptyInputScript(null, redeemScript);\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Sha256Hash sighash = tx.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        for (int i = 0; i < multisigSigners; i++) {\n+            BtcECKey privateKey = oldFederationPrivateKeys.get(i);\n+            BtcECKey publicKey = BtcECKey.fromPublicOnly(privateKey.getPubKeyPoint().getEncoded(true));\n+\n+            BtcECKey.ECDSASignature sig = privateKey.sign(sighash);\n+            TransactionSignature txSig = new TransactionSignature(sig, BtcTransaction.SigHash.ALL, false);\n+\n+            int sigIndex = inputScript.getSigInsertionIndex(sighash, publicKey);\n+            inputScript = ScriptBuilder.updateScriptWithSignature(\n+                inputScript,\n+                txSig.encodeToBitcoin(),\n+                sigIndex,\n+                1,\n+                1\n+            );\n+        }\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Assert.assertEquals(TxType.PEGIN, bridgeSupport.getTransactionType(tx));\n+    }\n+\n+    @Test\n+    public void getTransactionType_sentFromP2SH_afterRskip199_pegin_tx() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP199)).thenReturn(true);\n+\n+        BridgeSupport bridgeSupport = getBridgeSupport(\n+            bridgeConstants,\n+            mock(BridgeStorageProvider.class),\n+            activations\n+        );\n+\n+        int multisigSigners = 2;\n+        Federation activeFederation = bridgeConstants.getGenesisFederation();\n+        List<BtcECKey> privateKeys = Arrays.asList(new BtcECKey(), new BtcECKey(), new BtcECKey());\n+        Script redeemScript = ScriptBuilder.createRedeemScript(multisigSigners, privateKeys);\n+        Script outputScript = ScriptBuilder.createP2SHOutputScript(redeemScript);\n+        Address sender = Address.fromP2SHScript(btcParams, outputScript);\n+\n+        Assert.assertNotEquals(bridgeConstants.getOldFederationAddress(), sender.toBase58());\n+\n+        // Create a tx from a p2sh multisig address to the active fed\n+        BtcTransaction tx = new BtcTransaction(btcParams);\n+        tx.addOutput(Coin.COIN, activeFederation.getAddress());\n+        tx.addInput(Sha256Hash.ZERO_HASH, 0, redeemScript);\n+\n+        Script inputScript = outputScript.createEmptyInputScript(null, redeemScript);\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Sha256Hash sighash = tx.hashForSignature(\n+            0,\n+            redeemScript,\n+            BtcTransaction.SigHash.ALL,\n+            false\n+        );\n+\n+        for (int i = 0; i < multisigSigners; i++) {\n+            BtcECKey privateKey = privateKeys.get(i);\n+            BtcECKey publicKey = BtcECKey.fromPublicOnly(privateKey.getPubKeyPoint().getEncoded(true));\n+\n+            BtcECKey.ECDSASignature sig = privateKey.sign(sighash);\n+            TransactionSignature txSig = new TransactionSignature(sig, BtcTransaction.SigHash.ALL, false);\n+\n+            int sigIndex = inputScript.getSigInsertionIndex(sighash, publicKey);\n+            inputScript = ScriptBuilder.updateScriptWithSignature(\n+                inputScript,\n+                txSig.encodeToBitcoin(),\n+                sigIndex,\n+                1,\n+                1\n+            );\n+        }\n+        tx.getInput(0).setScriptSig(inputScript);\n+\n+        Assert.assertEquals(TxType.PEGIN, bridgeSupport.getTransactionType(tx));\n     }\n \n     @Test\n     public void getTransactionType_unknown_tx() {\n         BridgeSupport bridgeSupport = getBridgeSupport(bridgeConstants, mock(BridgeStorageProvider.class), mock(ActivationConfig.ForBlock.class));\n         BtcTransaction btcTx = new BtcTransaction(btcParams);\n-        Assert.assertEquals(BridgeSupport.TxType.UNKNOWN, bridgeSupport.getTransactionType(btcTx));\n+        Assert.assertEquals(TxType.UNKNOWN, bridgeSupport.getTransactionType(btcTx));\n     }\n \n     @Test\n@@ -7894,6 +8088,9 @@ private BridgeSupport getBridgeSupport(BridgeConstants constants, BridgeStorageP\n         if (blockStoreFactory == null) {\n             blockStoreFactory = mock(BtcBlockStoreWithCache.Factory.class);\n         }\n+        if (activations == null) {\n+            activations = mock(ActivationConfig.ForBlock.class);\n+        }\n         return new BridgeSupport(\n                 constants,\n                 provider,"
  },
  {
    "sha": "bb08691fe0f7f46ec38bbe563ab4d1f855e75739",
    "filename": "rskj-core/src/test/java/co/rsk/peg/ErpFederationTest.java",
    "status": "added",
    "additions": 126,
    "deletions": 0,
    "changes": 126,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/ErpFederationTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/ErpFederationTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/ErpFederationTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -0,0 +1,126 @@\n+package co.rsk.peg;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.bitcoinj.script.Script;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ErpFederationTest {\n+    private ErpFederation federation;\n+\n+    // ERP federation keys\n+    private static final List<BtcECKey> ERP_FED_KEYS = Arrays.stream(new String[]{\n+        \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+        \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+        \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+        \"03776b1fd8f86da3c1db3d69699e8250a15877d286734ea9a6da8e9d8ad25d16c1\",\n+        \"03ab0e2cd7ed158687fc13b88019990860cdb72b1f5777b58513312550ea1584bc\"\n+    }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList());\n+\n+    private static final long ACTIVATION_DELAY_VALUE = 5063;\n+\n+    @Before\n+    public void createErpFederation() {\n+        federation = new ErpFederation(\n+            FederationTestUtils.getFederationMembersFromPks(100, 200, 300),\n+            ZonedDateTime.parse(\"2017-06-10T02:30:00Z\").toInstant(),\n+            0L,\n+            NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+            ERP_FED_KEYS,\n+            ACTIVATION_DELAY_VALUE\n+        );\n+    }\n+\n+    @Test\n+    public void getErpPubKeys() {\n+        Assert.assertEquals(ERP_FED_KEYS, federation.getErpPubKeys());\n+    }\n+\n+    @Test\n+    public void getActivationDelay() {\n+        Assert.assertEquals(ACTIVATION_DELAY_VALUE, federation.getActivationDelay());\n+    }\n+\n+    @Test\n+    public void getRedeemScript() {\n+        Script redeemScript = federation.getRedeemScript();\n+        Assert.assertEquals(19, redeemScript.getChunks().size());\n+\n+        // First element: OP_0 - Belonging to the standard of BTC\n+        // M elements OP_0 - Belonging to M/N amount of signatures\n+        // OP_0 - Belonging to ERP\n+        // Last element: Program of redeem script\n+        String expectedProgram = \"64522102ed3bace23c5e17652e174c835fb72bf53ee306b3406a26890221b4ce\"\n+            + \"f7500f88210385a7b790fc9d962493788317e4874a4ab07f1e9c78c773c47f2f6c96df756f052103cd5\"\n+            + \"a3be41717d65683fe7a9de8ae5b4b8feced69f26a8b55eeefbcc2e74b75fb53670213c7b2755321029c\"\n+            + \"ecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e433012103284178e5fbcc63c54\"\n+            + \"c3b38e3ef88adf2da6c526313650041b0ef955763634ebd2103776b1fd8f86da3c1db3d69699e8250a1\"\n+            + \"5877d286734ea9a6da8e9d8ad25d16c12103ab0e2cd7ed158687fc13b88019990860cdb72b1f5777b58\"\n+            + \"513312550ea1584bc2103b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b\"\n+            + \"245568ae\";\n+\n+        Assert.assertEquals(expectedProgram, Hex.toHexString(redeemScript.getProgram()));\n+    }\n+\n+    @Test\n+    public void getP2SHScript() {\n+        Script p2shs = federation.getP2SHScript();\n+        String expectedProgram = \"a914bbb7b7942d0fb850bd619b399e96d8b8b36ff89187\";\n+\n+        Assert.assertEquals(expectedProgram, Hex.toHexString(p2shs.getProgram()));\n+        Assert.assertEquals(3, p2shs.getChunks().size());\n+        Assert.assertEquals(\n+            federation.getAddress(),\n+            p2shs.getToAddress(NetworkParameters.fromID(NetworkParameters.ID_REGTEST))\n+        );\n+    }\n+\n+    @Test\n+    public void getAddress() {\n+        String fedAddress = federation.getAddress().toBase58();\n+        String expectedAddress = \"2NAMnS3XpcWw1KrYkszRw7gWHFkxuMYrU2Z\";\n+\n+        Assert.assertEquals(expectedAddress, fedAddress);\n+    }\n+\n+    @Test\n+    public void getErpPubKeys_compressed_public_keys() {\n+        Assert.assertEquals(ERP_FED_KEYS, federation.getErpPubKeys());\n+    }\n+\n+    @Test\n+    public void getErpPubKeys_uncompressed_public_keys() {\n+        // Public keys used for creating federation, but uncompressed format now\n+        List<BtcECKey> erpPubKeysList = Arrays.stream(new String[]{\n+            \"04b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b9\"\n+                + \"67e6b243635dfd897d936044b05344860cd5494283aad8508d52a784eb6a1f4527e2c9f\",\n+            \"049cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301b069\"\n+                + \"dfae714467c15649fbdb61c70e367fb43f326dc807691923cd16698af99e\",\n+            \"04284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd4076b8bb\"\n+                + \"c11b4a3f559c8041b03a903d7d7efacc4dd3796a27df324c7aa3bc5d\",\n+            \"04776b1fd8f86da3c1db3d69699e8250a15877d286734ea9a6da8e9d8ad25d16c118424627ece3cba0\" \n+                + \"028fcbd4a0372485641a02383f4cdcee932542efd60d1029\",\n+            \"04ab0e2cd7ed158687fc13b88019990860cdb72b1f5777b58513312550ea1584bc08b4554783b4960c6a\"\n+                + \"bb761979d24d76a08ac38e775d72b960cd5644e1a54f01\"\n+        }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList());\n+\n+        // Recreate federation\n+        federation = new ErpFederation(\n+            FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500),\n+            ZonedDateTime.parse(\"2017-06-10T02:30:00Z\").toInstant(),\n+            0L,\n+            NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+            erpPubKeysList,\n+            ACTIVATION_DELAY_VALUE\n+        );\n+\n+        Assert.assertEquals(ERP_FED_KEYS, federation.getErpPubKeys());\n+    }\n+}"
  },
  {
    "sha": "7baa3fd5029a0099f5347e609f41e23061ba293b",
    "filename": "rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithSingleScriptTest.java",
    "status": "modified",
    "additions": 48,
    "deletions": 0,
    "changes": 48,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithSingleScriptTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithSingleScriptTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithSingleScriptTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -2,16 +2,21 @@\n \n import static org.mockito.Mockito.mock;\n \n+import co.rsk.bitcoinj.core.BtcECKey;\n import co.rsk.bitcoinj.core.Context;\n import co.rsk.bitcoinj.core.NetworkParameters;\n import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.script.FastBridgeErpRedeemScriptParser;\n import co.rsk.bitcoinj.script.FastBridgeRedeemScriptParser;\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.wallet.RedeemData;\n import co.rsk.peg.fastbridge.FastBridgeFederationInformation;\n import java.time.Instant;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n+import org.bouncycastle.util.encoders.Hex;\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -23,7 +28,23 @@\n         NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n     );\n \n+    private static final List<BtcECKey> erpFedKeys = Arrays.stream(new String[]{\n+        \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+        \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+        \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+    }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList());\n+\n+    private final ErpFederation erpFederation = new ErpFederation(\n+        FederationTestUtils.getFederationMembers(3),\n+        Instant.ofEpochMilli(1000),\n+        0L,\n+        NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+        erpFedKeys,\n+        5063\n+    );\n+\n     private final List<Federation> federationList = Collections.singletonList(federation);\n+    private final List<Federation> erpFederationList = Collections.singletonList(erpFederation);\n \n     @Test\n     public void findRedeemDataFromScriptHash_null_destination_federation() {\n@@ -64,4 +85,31 @@ public void findRedeemDataFromScriptHash_with_fastBridgeInformation() {\n         Assert.assertNotNull(redeemData);\n         Assert.assertEquals(fastBridgeRedeemScript, redeemData.redeemScript);\n     }\n+\n+    @Test\n+    public void findRedeemDataFromScriptHash_with_fastBridgeInformation_and_erp_federation() {\n+        byte[] fastBridgeScriptHash = new byte[]{(byte)0x22};\n+        FastBridgeFederationInformation fastBridgeFederationInformation =\n+            new FastBridgeFederationInformation(\n+                PegTestUtils.createHash3(2),\n+                erpFederation.getP2SHScript().getPubKeyHash(),\n+                fastBridgeScriptHash);\n+\n+        FastBridgeCompatibleBtcWalletWithSingleScript fastBridgeCompatibleBtcWalletWithSingleScript =\n+            new FastBridgeCompatibleBtcWalletWithSingleScript(\n+                mock(Context.class),\n+                erpFederationList,\n+                fastBridgeFederationInformation);\n+\n+        RedeemData redeemData = fastBridgeCompatibleBtcWalletWithSingleScript.findRedeemDataFromScriptHash(\n+            erpFederation.getP2SHScript().getPubKeyHash());\n+\n+        Script fastBridgeRedeemScript = FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            erpFederation.getRedeemScript(),\n+            Sha256Hash.wrap(fastBridgeFederationInformation.getDerivationHash().getBytes())\n+        );\n+\n+        Assert.assertNotNull(redeemData);\n+        Assert.assertEquals(fastBridgeRedeemScript, redeemData.redeemScript);\n+    }\n }"
  },
  {
    "sha": "7ef45ceabd248d6574e57960d0b178abf4483d27",
    "filename": "rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithStorageTest.java",
    "status": "modified",
    "additions": 59,
    "deletions": 1,
    "changes": 60,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithStorageTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithStorageTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/FastBridgeCompatibleBtcWalletWithStorageTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -4,20 +4,24 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n+import co.rsk.bitcoinj.core.BtcECKey;\n import co.rsk.bitcoinj.core.Context;\n import co.rsk.bitcoinj.core.NetworkParameters;\n import co.rsk.bitcoinj.core.Sha256Hash;\n+import co.rsk.bitcoinj.script.FastBridgeErpRedeemScriptParser;\n import co.rsk.bitcoinj.script.FastBridgeRedeemScriptParser;\n-import co.rsk.bitcoinj.script.RedeemScriptParser;\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.script.ScriptBuilder;\n import co.rsk.bitcoinj.wallet.RedeemData;\n import co.rsk.crypto.Keccak256;\n import co.rsk.peg.fastbridge.FastBridgeFederationInformation;\n import java.time.Instant;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.bouncycastle.util.encoders.Hex;\n import org.junit.Assert;\n import org.junit.Test;\n \n@@ -29,7 +33,24 @@\n         NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n     );\n \n+    private static final List<BtcECKey> erpFedKeys = Arrays.stream(new String[]{\n+        \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+        \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+        \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+    }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList()\n+    );\n+\n+    private final ErpFederation erpFederation = new ErpFederation(\n+        FederationTestUtils.getFederationMembers(3),\n+        Instant.ofEpochMilli(1000),\n+        0L,\n+        NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+        erpFedKeys,\n+        5063\n+    );\n+\n     private final List<Federation> federationList = Collections.singletonList(federation);\n+    private final List<Federation> erpFederationList = Collections.singletonList(erpFederation);\n \n     @Test\n     public void findRedeemDataFromScriptHash_with_no_fastBridgeInformation_in_storage_call_super() {\n@@ -76,6 +97,43 @@ public void findRedeemDataFromScriptHash_with_fastBridgeInformation_in_storage()\n         Assert.assertEquals(fastBridgeRedeemScript, redeemData.redeemScript);\n     }\n \n+    @Test\n+    public void findRedeemDataFromScriptHash_with_fastBridgeInformation_in_storage_and_erp_fed() {\n+        BridgeStorageProvider provider = mock(BridgeStorageProvider.class);\n+        Keccak256 derivationArgumentsHash = PegTestUtils.createHash3(1);\n+\n+        Script fastBridgeRedeemScript = FastBridgeErpRedeemScriptParser.createFastBridgeErpRedeemScript(\n+            erpFederation.getRedeemScript(),\n+            Sha256Hash.wrap(derivationArgumentsHash.getBytes()\n+            )\n+        );\n+\n+        Script p2SHOutputScript = ScriptBuilder.createP2SHOutputScript(fastBridgeRedeemScript);\n+        byte[] fastBridgeFederationP2SH = p2SHOutputScript.getPubKeyHash();\n+\n+        FastBridgeFederationInformation fastBridgeFederationInformation =\n+            new FastBridgeFederationInformation(\n+                derivationArgumentsHash,\n+                erpFederation.getP2SHScript().getPubKeyHash(),\n+                fastBridgeFederationP2SH);\n+\n+        when(provider.getFastBridgeFederationInformation(fastBridgeFederationP2SH))\n+            .thenReturn(Optional.of(fastBridgeFederationInformation));\n+\n+        FastBridgeCompatibleBtcWalletWithStorage fastBridgeCompatibleBtcWalletWithStorage =\n+            new FastBridgeCompatibleBtcWalletWithStorage(\n+                mock(Context.class),\n+                erpFederationList,\n+                provider\n+        );\n+\n+        RedeemData redeemData = fastBridgeCompatibleBtcWalletWithStorage\n+            .findRedeemDataFromScriptHash(fastBridgeFederationP2SH);\n+\n+        Assert.assertNotNull(redeemData);\n+        Assert.assertEquals(fastBridgeRedeemScript, redeemData.redeemScript);\n+    }\n+\n     @Test\n     public void findRedeemDataFromScriptHash_null_destination_federation() {\n         Keccak256 derivationArgumentsHash = PegTestUtils.createHash3(2);"
  },
  {
    "sha": "b0f45706033371d90806233613f210a5b5948052",
    "filename": "rskj-core/src/test/java/co/rsk/peg/FederationTest.java",
    "status": "modified",
    "additions": 18,
    "deletions": 18,
    "changes": 36,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FederationTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/FederationTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/FederationTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -108,12 +108,12 @@ public void redeemScript() {\n             Assert.assertEquals(4, numberOfSignaturesRequired);\n             Assert.assertEquals(6, publicKeys.size());\n             for (int i = 0; i < sortedPublicKeys.size(); i++) {\n-                Assert.assertTrue(Arrays.equals(sortedPublicKeys.get(i).getPubKey(), publicKeys.get(i).getPubKey()));\n+                Assert.assertArrayEquals(sortedPublicKeys.get(i).getPubKey(),\n+                    publicKeys.get(i).getPubKey());\n             }\n             return new Script(new byte[]{(byte)0xaa});\n         });\n-        Assert.assertTrue(Arrays.equals(federation.getRedeemScript().getProgram(), new byte[]{(byte) 0xaa}));\n-        Assert.assertTrue(Arrays.equals(federation.getRedeemScript().getProgram(), new byte[]{(byte) 0xaa}));\n+        Assert.assertArrayEquals(federation.getRedeemScript().getProgram(), new byte[]{(byte) 0xaa});\n         // Make sure the script creation happens only once\n         Assert.assertEquals(1, calls.size());\n     }\n@@ -130,12 +130,12 @@ public void P2SHScript() {\n             Assert.assertEquals(4, numberOfSignaturesRequired);\n             Assert.assertEquals(6, publicKeys.size());\n             for (int i = 0; i < sortedPublicKeys.size();i ++) {\n-                Assert.assertTrue(Arrays.equals(sortedPublicKeys.get(i).getPubKey(), publicKeys.get(i).getPubKey()));\n+                Assert.assertArrayEquals(sortedPublicKeys.get(i).getPubKey(),\n+                    publicKeys.get(i).getPubKey());\n             }\n             return new Script(new byte[]{(byte)0xaa});\n         });\n-        Assert.assertTrue(Arrays.equals(federation.getP2SHScript().getProgram(), new byte[]{(byte) 0xaa}));\n-        Assert.assertTrue(Arrays.equals(federation.getP2SHScript().getProgram(), new byte[]{(byte) 0xaa}));\n+        Assert.assertArrayEquals(federation.getP2SHScript().getProgram(), new byte[]{(byte) 0xaa});\n         // Make sure the script creation happens only once\n         Assert.assertEquals(1, calls.size());\n     }\n@@ -156,12 +156,12 @@ public void Address() {\n             Assert.assertEquals(4, numberOfSignaturesRequired);\n             Assert.assertEquals(6, publicKeys.size());\n             for (int i = 0; i < sortedPublicKeys.size();i ++) {\n-                Assert.assertTrue(Arrays.equals(sortedPublicKeys.get(i).getPubKey(), publicKeys.get(i).getPubKey()));\n+                Assert.assertArrayEquals(sortedPublicKeys.get(i).getPubKey(),\n+                    publicKeys.get(i).getPubKey());\n             }\n             return new Script(Hex.decode(\"a914896ed9f3446d51b5510f7f0b6ef81b2bde55140e87\"));\n         });\n \n-        Assert.assertEquals(\"2N5muMepJizJE1gR7FbHJU6CD18V3BpNF9p\", federation.getAddress().toBase58());\n         Assert.assertEquals(\"2N5muMepJizJE1gR7FbHJU6CD18V3BpNF9p\", federation.getAddress().toBase58());\n         // Make sure the address creation happens only once\n         Assert.assertEquals(1, calls.size());\n@@ -171,9 +171,9 @@ public void Address() {\n     public void testEquals_basic() {\n         Assert.assertTrue(federation.equals(federation));\n \n-        Assert.assertFalse(federation.equals(null));\n-        Assert.assertFalse(federation.equals(new Object()));\n-        Assert.assertFalse(federation.equals(\"something else\"));\n+        Assert.assertNotEquals(null, federation);\n+        Assert.assertNotEquals(federation, new Object());\n+        Assert.assertNotEquals(\"something else\", federation);\n     }\n \n     @Test\n@@ -184,7 +184,7 @@ public void testEquals_differentNumberOfMembers() {\n                 0L,\n                 NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n         );\n-        Assert.assertFalse(federation.equals(otherFederation));\n+        Assert.assertNotEquals(federation, otherFederation);\n     }\n \n     @Test\n@@ -195,7 +195,7 @@ public void testEquals_differentCreationTime() {\n                 0L,\n                 NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n         );\n-        Assert.assertFalse(federation.equals(otherFederation));\n+        Assert.assertNotEquals(federation, otherFederation);\n     }\n \n     @Test\n@@ -217,7 +217,7 @@ public void testEquals_differentNetworkParameters() {\n                 0L,\n                 NetworkParameters.fromID(NetworkParameters.ID_TESTNET)\n         );\n-        Assert.assertFalse(federation.equals(otherFederation));\n+        Assert.assertNotEquals(federation, otherFederation);\n     }\n \n     @Test\n@@ -241,9 +241,9 @@ public void testEquals_differentMembers() {\n                 NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n         );\n \n-        Assert.assertFalse(otherFederation.equals(yetOtherFederation));\n-        Assert.assertFalse(federation.equals(otherFederation));\n-        Assert.assertFalse(federation.equals(yetOtherFederation));\n+        Assert.assertNotEquals(otherFederation, yetOtherFederation);\n+        Assert.assertNotEquals(federation, otherFederation);\n+        Assert.assertNotEquals(federation, yetOtherFederation);\n     }\n \n     @Test\n@@ -254,7 +254,7 @@ public void testEquals_same() {\n                 0L,\n                 NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n         );\n-        Assert.assertTrue(federation.equals(otherFederation));\n+        Assert.assertEquals(federation, otherFederation);\n     }\n \n     @Test"
  },
  {
    "sha": "5458057a65562c6b62506189005d94e4be86181e",
    "filename": "rskj-core/src/test/java/co/rsk/peg/PendingFederationTest.java",
    "status": "modified",
    "additions": 69,
    "deletions": 18,
    "changes": 87,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/PendingFederationTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/PendingFederationTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/PendingFederationTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -18,9 +18,17 @@\n \n package co.rsk.peg;\n \n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n import co.rsk.bitcoinj.core.BtcECKey;\n import co.rsk.bitcoinj.core.NetworkParameters;\n+import co.rsk.config.BridgeConstants;\n+import co.rsk.config.BridgeRegTestConstants;\n import co.rsk.crypto.Keccak256;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig.ForBlock;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n import org.ethereum.crypto.ECKey;\n import org.ethereum.crypto.HashUtil;\n import org.junit.Assert;\n@@ -38,6 +46,7 @@\n @RunWith(PowerMockRunner.class)\n public class PendingFederationTest {\n     private PendingFederation pendingFederation;\n+    private final BridgeConstants bridgeConstants = BridgeRegTestConstants.getInstance();\n \n     @Before\n     public void createPendingFederation() {\n@@ -76,17 +85,17 @@ public void isComplete_not() {\n \n     @Test\n     public void testEquals_basic() {\n-        Assert.assertTrue(pendingFederation.equals(pendingFederation));\n+        Assert.assertEquals(pendingFederation, pendingFederation);\n \n-        Assert.assertFalse(pendingFederation.equals(null));\n-        Assert.assertFalse(pendingFederation.equals(new Object()));\n-        Assert.assertFalse(pendingFederation.equals(\"something else\"));\n+        Assert.assertNotEquals(null, pendingFederation);\n+        Assert.assertNotEquals(pendingFederation, new Object());\n+        Assert.assertNotEquals(\"something else\", pendingFederation);\n     }\n \n     @Test\n     public void testEquals_differentNumberOfMembers() {\n         PendingFederation otherPendingFederation = new PendingFederation(FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600, 700));\n-        Assert.assertFalse(pendingFederation.equals(otherPendingFederation));\n+        Assert.assertNotEquals(pendingFederation, otherPendingFederation);\n     }\n \n     @Test\n@@ -100,15 +109,15 @@ public void testEquals_differentMembers() {\n         members.add(new FederationMember(BtcECKey.fromPrivate(BigInteger.valueOf(600)), ECKey.fromPrivate(BigInteger.valueOf(610)), ECKey.fromPrivate(BigInteger.valueOf(630))));\n         PendingFederation yetOtherPendingFederation = new PendingFederation(members);\n \n-        Assert.assertFalse(otherPendingFederation.equals(yetOtherPendingFederation));\n-        Assert.assertFalse(pendingFederation.equals(otherPendingFederation));\n-        Assert.assertFalse(pendingFederation.equals(yetOtherPendingFederation));\n+        Assert.assertNotEquals(otherPendingFederation, yetOtherPendingFederation);\n+        Assert.assertNotEquals(pendingFederation, otherPendingFederation);\n+        Assert.assertNotEquals(pendingFederation, yetOtherPendingFederation);\n     }\n \n     @Test\n     public void testEquals_same() {\n         PendingFederation otherPendingFederation = new PendingFederation(FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600));\n-        Assert.assertTrue(pendingFederation.equals(otherPendingFederation));\n+        Assert.assertEquals(pendingFederation, otherPendingFederation);\n     }\n \n     @Test\n@@ -119,8 +128,9 @@ public void testToString() {\n     }\n \n     @Test\n-    public void buildFederation_ok_a() {\n-        PendingFederation otherPendingFederation = new PendingFederation(FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600));\n+    public void buildFederation_ok_6_members_before_RSKIP_199_activation() {\n+        PendingFederation otherPendingFederation = new PendingFederation(\n+            FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600));\n \n         Federation expectedFederation = new Federation(\n                 FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600),\n@@ -133,20 +143,25 @@ public void buildFederation_ok_a() {\n                 otherPendingFederation.buildFederation(\n                         Instant.ofEpochMilli(1234L),\n                         0L,\n-                        NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n+                        bridgeConstants,\n+                    mock(ForBlock.class)\n                 )\n         );\n     }\n \n     @Test\n-    public void buildFederation_ok_b() {\n-        PendingFederation otherPendingFederation = new PendingFederation(FederationTestUtils.getFederationMembersFromPks(\n+    public void buildFederation_ok_9_members_before_RSKIP_199_activation() {\n+        PendingFederation otherPendingFederation = new PendingFederation(\n+            FederationTestUtils.getFederationMembersFromPks(\n                 100, 200, 300, 400, 500, 600, 700, 800, 900\n         ));\n \n         Federation expectedFederation = new Federation(\n-                FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600, 700, 800, 900),\n-                Instant.ofEpochMilli(1234L), 0L,\n+                FederationTestUtils.getFederationMembersFromPks(\n+                    100, 200, 300, 400, 500, 600, 700, 800, 900\n+                ),\n+                Instant.ofEpochMilli(1234L),\n+            0L,\n                 NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n         );\n \n@@ -155,17 +170,53 @@ public void buildFederation_ok_b() {\n                 otherPendingFederation.buildFederation(\n                         Instant.ofEpochMilli(1234L),\n                         0L,\n-                        NetworkParameters.fromID(NetworkParameters.ID_REGTEST)\n+                        bridgeConstants,\n+                    mock(ForBlock.class)\n                 )\n         );\n     }\n \n+    @Test\n+    public void buildFederation_erp_ok_after_RSKIP_201_activation() {\n+        ActivationConfig.ForBlock activations = mock(ActivationConfig.ForBlock.class);\n+        when(activations.isActive(ConsensusRule.RSKIP201)).thenReturn(true);\n+\n+        PendingFederation otherPendingFederation =\n+            new PendingFederation(FederationTestUtils.getFederationMembersFromPks(\n+                100, 200, 300, 400, 500, 600)\n+            );\n+\n+        ErpFederation expectedFederation = new ErpFederation(\n+            FederationTestUtils.getFederationMembersFromPks(100, 200, 300, 400, 500, 600),\n+            Instant.ofEpochMilli(1234L),\n+            0L,\n+            NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+            bridgeConstants.getErpFedPubKeysList(),\n+            bridgeConstants.getErpFedActivationDelay()\n+        );\n+\n+        Assert.assertEquals(\n+            expectedFederation,\n+            otherPendingFederation.buildFederation(\n+                Instant.ofEpochMilli(1234L),\n+                0L,\n+                bridgeConstants,\n+                activations\n+            )\n+        );\n+    }\n+\n     @Test\n     public void buildFederation_incomplete() {\n         PendingFederation otherPendingFederation = new PendingFederation(FederationTestUtils.getFederationMembersFromPks(100));\n \n         try {\n-            otherPendingFederation.buildFederation(Instant.ofEpochMilli(12L), 0L, NetworkParameters.fromID(NetworkParameters.ID_REGTEST));\n+            otherPendingFederation.buildFederation(\n+                Instant.ofEpochMilli(12L),\n+                0L,\n+                null,\n+                null\n+            );\n         } catch (Exception e) {\n             Assert.assertEquals(\"PendingFederation is incomplete\", e.getMessage());\n             return;"
  },
  {
    "sha": "9585b6ea90396e3a29b1cfbcc3edfa2940b9612d",
    "filename": "rskj-core/src/test/java/co/rsk/peg/ReleaseTransactionBuilderTest.java",
    "status": "modified",
    "additions": 100,
    "deletions": 75,
    "changes": 175,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/ReleaseTransactionBuilderTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/ReleaseTransactionBuilderTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/ReleaseTransactionBuilderTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -22,6 +22,9 @@\n import co.rsk.bitcoinj.script.Script;\n import co.rsk.bitcoinj.wallet.SendRequest;\n import co.rsk.bitcoinj.wallet.Wallet;\n+import java.util.Collections;\n+import org.ethereum.config.blockchain.upgrades.ActivationConfig;\n+import org.ethereum.config.blockchain.upgrades.ConsensusRule;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -43,12 +46,19 @@\n     private Wallet wallet;\n     private Address changeAddress;\n     private ReleaseTransactionBuilder builder;\n+    private ActivationConfig.ForBlock activations;\n \n     @Before\n     public void createBuilder() {\n         wallet = mock(Wallet.class);\n         changeAddress = mockAddress(1000);\n-        builder = new ReleaseTransactionBuilder(NetworkParameters.fromID(NetworkParameters.ID_REGTEST), wallet, changeAddress, Coin.MILLICOIN.multiply(2));\n+        activations = mock(ActivationConfig.ForBlock.class);\n+        builder = new ReleaseTransactionBuilder(\n+            NetworkParameters.fromID(NetworkParameters.ID_REGTEST),\n+            wallet,\n+            changeAddress,\n+            Coin.MILLICOIN.multiply(2),\n+            activations);\n     }\n \n     @Test\n@@ -224,81 +234,15 @@ public void buildAmountTo_utxoProviderException() throws InsufficientMoneyExcept\n     }\n \n     @Test\n-    public void buildEmptyWalletTo_ok() throws InsufficientMoneyException, UTXOProviderException {\n-        Context btcContext = new Context(NetworkParameters.fromID(NetworkParameters.ID_REGTEST));\n-        Address to = mockAddress(123);\n-\n-        List<UTXO> availableUTXOs = Arrays.asList(\n-                mockUTXO(\"one\", 0, Coin.COIN),\n-                mockUTXO(\"two\", 2, Coin.FIFTY_COINS),\n-                mockUTXO(\"two\", 0, Coin.COIN.times(7)),\n-                mockUTXO(\"three\", 0, Coin.CENT.times(3))\n-        );\n-\n-        UTXOProvider utxoProvider = mock(UTXOProvider.class);\n-        when(wallet.getUTXOProvider()).thenReturn(utxoProvider);\n-        when(wallet.getWatchedAddresses()).thenReturn(Arrays.asList(to));\n-        when(utxoProvider.getOpenTransactionOutputs(any(List.class))).then((InvocationOnMock m) -> {\n-            List<Address> addresses = m.<List>getArgument(0);\n-            Assert.assertEquals(Arrays.asList(to), addresses);\n-            return availableUTXOs;\n-        });\n-\n-        Mockito.doAnswer((InvocationOnMock m) -> {\n-            SendRequest sr = m.<SendRequest>getArgument(0);\n-\n-            Assert.assertEquals(Coin.MILLICOIN.multiply(2), sr.feePerKb);\n-            Assert.assertEquals(Wallet.MissingSigsMode.USE_OP_ZERO, sr.missingSigsMode);\n-            Assert.assertEquals(to, sr.changeAddress);\n-            Assert.assertFalse(sr.shuffleOutputs);\n-            Assert.assertTrue(sr.recipientsPayFees);\n-            Assert.assertTrue(sr.emptyWallet);\n-\n-            BtcTransaction tx = sr.tx;\n-\n-            Assert.assertEquals(1, tx.getOutputs().size());\n-            Assert.assertEquals(Coin.ZERO, tx.getOutput(0).getValue());\n-            Assert.assertEquals(to, tx.getOutput(0).getAddressFromP2PKHScript(NetworkParameters.fromID(NetworkParameters.ID_REGTEST)));\n-\n-            tx.addInput(mockUTXOHash(\"one\"), 0, mock(Script.class));\n-            tx.addInput(mockUTXOHash(\"two\"), 2, mock(Script.class));\n-            tx.addInput(mockUTXOHash(\"two\"), 0, mock(Script.class));\n-            tx.addInput(mockUTXOHash(\"three\"), 0, mock(Script.class));\n-            tx.getOutput(0).setValue(Coin.FIFTY_COINS);\n-\n-            return null;\n-        }).when(wallet).completeTx(any(SendRequest.class));\n-\n-        Optional<ReleaseTransactionBuilder.BuildResult> result = builder.buildEmptyWalletTo(to);\n-\n-        Assert.assertTrue(result.isPresent());\n-\n-        BtcTransaction tx = result.get().getBtcTx();\n-        List<UTXO> selectedUTXOs = result.get().getSelectedUTXOs();\n-\n-        Assert.assertEquals(1, tx.getOutputs().size());\n-        Assert.assertEquals(Coin.FIFTY_COINS, tx.getOutput(0).getValue());\n-        Assert.assertEquals(to, tx.getOutput(0).getAddressFromP2PKHScript(NetworkParameters.fromID(NetworkParameters.ID_REGTEST)));\n-\n-        Assert.assertEquals(4, tx.getInputs().size());\n-        Assert.assertEquals(mockUTXOHash(\"one\"), tx.getInput(0).getOutpoint().getHash());\n-        Assert.assertEquals(0, tx.getInput(0).getOutpoint().getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"two\"), tx.getInput(1).getOutpoint().getHash());\n-        Assert.assertEquals(2, tx.getInput(1).getOutpoint().getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"two\"), tx.getInput(2).getOutpoint().getHash());\n-        Assert.assertEquals(0, tx.getInput(2).getOutpoint().getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"three\"), tx.getInput(3).getOutpoint().getHash());\n-        Assert.assertEquals(0, tx.getInput(3).getOutpoint().getIndex());\n+    public void buildEmptyWalletTo_ok_before_RSKIP_199_activation() throws\n+        InsufficientMoneyException, UTXOProviderException {\n+        test_buildEmptyWalletTo_ok(false, 1);\n+    }\n \n-        Assert.assertEquals(4, selectedUTXOs.size());\n-        Assert.assertEquals(mockUTXOHash(\"one\"), selectedUTXOs.get(0).getHash());\n-        Assert.assertEquals(0, selectedUTXOs.get(0).getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"two\"), selectedUTXOs.get(1).getHash());\n-        Assert.assertEquals(2, selectedUTXOs.get(1).getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"two\"), selectedUTXOs.get(2).getHash());\n-        Assert.assertEquals(0, selectedUTXOs.get(2).getIndex());\n-        Assert.assertEquals(mockUTXOHash(\"three\"), selectedUTXOs.get(3).getHash());\n-        Assert.assertEquals(0, selectedUTXOs.get(3).getIndex());\n+    @Test\n+    public void buildEmptyWalletTo_ok_after_RSKIP_199_activation()\n+        throws InsufficientMoneyException, UTXOProviderException {\n+        test_buildEmptyWalletTo_ok(true, 2);\n     }\n \n     @Test\n@@ -391,6 +335,87 @@ public void buildEmptyWalletTo_utxoProviderException() throws InsufficientMoneyE\n         Assert.assertFalse(result.isPresent());\n     }\n \n+    private void test_buildEmptyWalletTo_ok(boolean isRSKIPActive, int expectedTxVersion)\n+        throws InsufficientMoneyException, UTXOProviderException {\n+        Context btcContext = new Context(NetworkParameters.fromID(NetworkParameters.ID_REGTEST));\n+        when(activations.isActive(ConsensusRule.RSKIP201)).thenReturn(isRSKIPActive);\n+        Address to = mockAddress(123);\n+\n+        List<UTXO> availableUTXOs = Arrays.asList(\n+            mockUTXO(\"one\", 0, Coin.COIN),\n+            mockUTXO(\"two\", 2, Coin.FIFTY_COINS),\n+            mockUTXO(\"two\", 0, Coin.COIN.times(7)),\n+            mockUTXO(\"three\", 0, Coin.CENT.times(3))\n+        );\n+\n+        UTXOProvider utxoProvider = mock(UTXOProvider.class);\n+        when(wallet.getUTXOProvider()).thenReturn(utxoProvider);\n+        when(wallet.getWatchedAddresses()).thenReturn(Collections.singletonList(to));\n+        when(utxoProvider.getOpenTransactionOutputs(any(List.class))).then((InvocationOnMock m) -> {\n+            List<Address> addresses = m.<List>getArgument(0);\n+            Assert.assertEquals(Collections.singletonList(to), addresses);\n+            return availableUTXOs;\n+        });\n+\n+        Mockito.doAnswer((InvocationOnMock m) -> {\n+            SendRequest sr = m.<SendRequest>getArgument(0);\n+\n+            Assert.assertEquals(Coin.MILLICOIN.multiply(2), sr.feePerKb);\n+            Assert.assertEquals(Wallet.MissingSigsMode.USE_OP_ZERO, sr.missingSigsMode);\n+            Assert.assertEquals(to, sr.changeAddress);\n+            Assert.assertFalse(sr.shuffleOutputs);\n+            Assert.assertTrue(sr.recipientsPayFees);\n+            Assert.assertTrue(sr.emptyWallet);\n+\n+            BtcTransaction tx = sr.tx;\n+\n+            Assert.assertEquals(1, tx.getOutputs().size());\n+            Assert.assertEquals(Coin.ZERO, tx.getOutput(0).getValue());\n+            Assert.assertEquals(to, tx.getOutput(0).getAddressFromP2PKHScript(NetworkParameters.fromID(NetworkParameters.ID_REGTEST)));\n+\n+            tx.addInput(mockUTXOHash(\"one\"), 0, mock(Script.class));\n+            tx.addInput(mockUTXOHash(\"two\"), 2, mock(Script.class));\n+            tx.addInput(mockUTXOHash(\"two\"), 0, mock(Script.class));\n+            tx.addInput(mockUTXOHash(\"three\"), 0, mock(Script.class));\n+            tx.getOutput(0).setValue(Coin.FIFTY_COINS);\n+\n+            return null;\n+        }).when(wallet).completeTx(any(SendRequest.class));\n+\n+        Optional<ReleaseTransactionBuilder.BuildResult> result = builder.buildEmptyWalletTo(to);\n+\n+        Assert.assertTrue(result.isPresent());\n+\n+        BtcTransaction tx = result.get().getBtcTx();\n+        List<UTXO> selectedUTXOs = result.get().getSelectedUTXOs();\n+\n+        Assert.assertEquals(1, tx.getOutputs().size());\n+        Assert.assertEquals(Coin.FIFTY_COINS, tx.getOutput(0).getValue());\n+        Assert.assertEquals(to, tx.getOutput(0).getAddressFromP2PKHScript(NetworkParameters.fromID(NetworkParameters.ID_REGTEST)));\n+\n+        Assert.assertEquals(4, tx.getInputs().size());\n+        Assert.assertEquals(mockUTXOHash(\"one\"), tx.getInput(0).getOutpoint().getHash());\n+        Assert.assertEquals(0, tx.getInput(0).getOutpoint().getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"two\"), tx.getInput(1).getOutpoint().getHash());\n+        Assert.assertEquals(2, tx.getInput(1).getOutpoint().getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"two\"), tx.getInput(2).getOutpoint().getHash());\n+        Assert.assertEquals(0, tx.getInput(2).getOutpoint().getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"three\"), tx.getInput(3).getOutpoint().getHash());\n+        Assert.assertEquals(0, tx.getInput(3).getOutpoint().getIndex());\n+\n+        Assert.assertEquals(4, selectedUTXOs.size());\n+        Assert.assertEquals(mockUTXOHash(\"one\"), selectedUTXOs.get(0).getHash());\n+        Assert.assertEquals(0, selectedUTXOs.get(0).getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"two\"), selectedUTXOs.get(1).getHash());\n+        Assert.assertEquals(2, selectedUTXOs.get(1).getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"two\"), selectedUTXOs.get(2).getHash());\n+        Assert.assertEquals(0, selectedUTXOs.get(2).getIndex());\n+        Assert.assertEquals(mockUTXOHash(\"three\"), selectedUTXOs.get(3).getHash());\n+        Assert.assertEquals(0, selectedUTXOs.get(3).getIndex());\n+\n+        Assert.assertEquals(expectedTxVersion, tx.getVersion());\n+    }\n+\n     private void mockCompleteTxWithThrowForBuildToAmount(Wallet wallet, Coin expectedAmount, Address expectedAddress, Throwable t) throws InsufficientMoneyException {\n         Mockito.doAnswer((InvocationOnMock m) -> {\n             SendRequest sr = m.<SendRequest>getArgument(0);"
  },
  {
    "sha": "c79c63332987660392bc0788fab5b101526003d6",
    "filename": "rskj-core/src/test/java/co/rsk/peg/utils/EcKeyUtilsTest.java",
    "status": "added",
    "additions": 42,
    "deletions": 0,
    "changes": 42,
    "blob_url": "https://github.com/rsksmart/rskj/blob/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/utils/EcKeyUtilsTest.java",
    "raw_url": "https://github.com/rsksmart/rskj/raw/1691b2da6019f834afef301bf944ef7f9be7675c/rskj-core/src/test/java/co/rsk/peg/utils/EcKeyUtilsTest.java",
    "contents_url": "https://api.github.com/repos/rsksmart/rskj/contents/rskj-core/src/test/java/co/rsk/peg/utils/EcKeyUtilsTest.java?ref=1691b2da6019f834afef301bf944ef7f9be7675c",
    "patch": "@@ -0,0 +1,42 @@\n+package co.rsk.peg.utils;\n+\n+import co.rsk.bitcoinj.core.BtcECKey;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.bouncycastle.util.encoders.Hex;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class EcKeyUtilsTest {\n+    private final List<BtcECKey> compressedPubKeysList = Arrays.stream(new String[]{\n+        \"03b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b967e6b24\",\n+        \"029cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301\",\n+        \"03284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd\",\n+    }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList());\n+\n+    private final List<BtcECKey> uncompressedPubKeysList = Arrays.stream(new String[]{\n+        \"04b9fc46657cf72a1afa007ecf431de1cd27ff5cc8829fa625b66ca47b9\"\n+            + \"67e6b243635dfd897d936044b05344860cd5494283aad8508d52a784eb6a1f4527e2c9f\",\n+        \"049cecea902067992d52c38b28bf0bb2345bda9b21eca76b16a17c477a64e43301b069\"\n+            + \"dfae714467c15649fbdb61c70e367fb43f326dc807691923cd16698af99e\",\n+        \"04284178e5fbcc63c54c3b38e3ef88adf2da6c526313650041b0ef955763634ebd4076b8bb\"\n+            + \"c11b4a3f559c8041b03a903d7d7efacc4dd3796a27df324c7aa3bc5d\",\n+    }).map(hex -> BtcECKey.fromPublicOnly(Hex.decode(hex))).collect(Collectors.toList());\n+\n+    @Test\n+    public void getCompressedPubKeysList_compressed_public_keys_list() {\n+        Assert.assertEquals(\n+            compressedPubKeysList,\n+            EcKeyUtils.getCompressedPubKeysList(compressedPubKeysList)\n+        );\n+    }\n+\n+    @Test\n+    public void getCompressedPubKeysList_uncompressed_public_keys_list() {\n+        Assert.assertEquals(\n+            compressedPubKeysList,\n+            EcKeyUtils.getCompressedPubKeysList(uncompressedPubKeysList)\n+        );\n+    }\n+}"
  }
]
