[
  {
    "sha": "d1fd6159dbc7c26ceca5feab92625c6f134e9bc1",
    "filename": "src/peergos/client/JsUtil.java",
    "status": "modified",
    "additions": 21,
    "deletions": 0,
    "changes": 21,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/client/JsUtil.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/client/JsUtil.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/client/JsUtil.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -2,6 +2,7 @@\n \n import jsinterop.annotations.*;\n \n+import java.time.LocalDateTime;\n import java.util.*;\n import java.util.stream.Collectors;\n \n@@ -20,4 +21,24 @@\n         return Arrays.asList(array).stream().collect(Collectors.toSet());\n     }\n \n+    @JsMethod\n+    public static <T> List<T> emptyList() {\n+        return Collections.emptyList();\n+    }\n+\n+    @JsMethod\n+    public static <T> Optional<T> emptyOptional() {\n+        return Optional.empty();\n+    }\n+\n+    @JsMethod\n+    public static <T> Optional<T> optionalOf(T of) {\n+        return Optional.of(of);\n+    }\n+\n+\n+    @JsMethod\n+    public static LocalDateTime now() {\n+        return LocalDateTime.now();\n+    }\n }"
  },
  {
    "sha": "a531690c31c1088221e0e86f4558a2f58cd09121",
    "filename": "src/peergos/client/PathUtils.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/client/PathUtils.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/client/PathUtils.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/client/PathUtils.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -10,6 +10,11 @@\n \n public class PathUtils {\n \n+    @JsMethod\n+    public static Path getParent(Path another) {\n+        return another.getParent();\n+    }\n+\n     @JsMethod\n     public static Path directoryToPath(String[] parts) {\n         if (parts == null || parts.length == 0) {"
  },
  {
    "sha": "aac229bcf53871d80d51458545b3d919287b18e2",
    "filename": "src/peergos/gwt/emu/java/time/LocalDate.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/time/LocalDate.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/time/LocalDate.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/gwt/emu/java/time/LocalDate.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -67,6 +67,14 @@ public static LocalDate now(Clock clock) {\n         long epochDay = Math.floorDiv(epochSec, SECONDS_PER_DAY);\n         return LocalDate.ofEpochDay(epochDay);\n     }\n+\n+    public int getYear() {\n+        return this.year;\n+    }\n+\n+    public int getMonthValue() {\n+        return this.month;\n+    }\n     \n     public static LocalDate ofEpochDay(long epochDay) {\n         long zeroDay = epochDay + DAYS_0000_TO_1970;"
  },
  {
    "sha": "cd6fe521edc7de13e4b1b62e843e6a26ff03144b",
    "filename": "src/peergos/gwt/emu/java/time/LocalDateTime.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/time/LocalDateTime.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/time/LocalDateTime.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/gwt/emu/java/time/LocalDateTime.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -62,6 +62,14 @@ public static LocalDateTime now() {\n         return now(Clock.systemDefaultZone());\n     }\n \n+    public int getYear() {\n+        return date.getYear();\n+    }\n+\n+    public int getMonthValue() {\n+        return date.getMonthValue();\n+    }\n+\n     public LocalDateTime plusNanos(long nanos) {\n         return null;\n     }"
  },
  {
    "sha": "cb01f615e8caecbc3cbc7a4caef09be974b96168",
    "filename": "src/peergos/gwt/emu/java/util/UUID.java",
    "status": "modified",
    "additions": 62,
    "deletions": 1,
    "changes": 63,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/util/UUID.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/gwt/emu/java/util/UUID.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/gwt/emu/java/util/UUID.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -1,7 +1,68 @@\n package java.util;\n \n public final class UUID {\n+\n+    private final String uuid;\n+    private UUID(String uuid) {\n+        this.uuid = uuid;\n+    }\n     public static UUID randomUUID() {\n-        return null;\n+        return new UUID(uuid());\n+    }\n+\n+    public String toString() {\n+        return uuid;\n+    }\n+\n+    //https://stackoverflow.com/questions/3759590/generate-uuid-with-gwt\n+    //lead to this:\n+    //http://web.archive.org/web/20160707055604/http://www.pst.ifi.lmu.de/~rauschma/download/UUID.java\n+    /*\n+File: Math.uuid.js\n+Version: 1.3\n+Change History:\n+  v1.0 - first release\n+  v1.1 - less code and 2x performance boost (by minimizing calls to Math.random())\n+  v1.2 - Add support for generating non-standard uuids of arbitrary length\n+  v1.3 - Fixed IE7 bug (can't use []'s to access string chars.  Thanks, Brian R.)\n+  v1.4 - Changed method to be \"Math.uuid\". Added support for radix argument.  Use module pattern for better encapsulation.\n+\n+Latest version:   http://www.broofa.com/Tools/Math.uuid.js\n+Information:      http://www.broofa.com/blog/?p=151\n+Contact:          robert@broofa.com\n+----\n+Copyright (c) 2008, Robert Kieffer\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n+    * Neither the name of Robert Kieffer nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+    private static final char[] CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".toCharArray();\n+    /**\n+     * Generate a RFC4122, version 4 ID. Example:\n+     * \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n+     */\n+    private static String uuid() {\n+        char[] uuid = new char[36];\n+        int r;\n+\n+        // rfc4122 requires these characters\n+        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n+        uuid[14] = '4';\n+\n+        // Fill in random data.  At i==19 set the high bits of clock sequence as\n+        // per rfc4122, sec. 4.1.5\n+        for (int i = 0; i < 36; i++) {\n+            if (uuid[i] == 0) {\n+                r = (int) (Math.random()*16);\n+                uuid[i] = CHARS[(i == 19) ? (r & 0x3) | 0x8 : r & 0xf];\n+            }\n+        }\n+        return new String(uuid);\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "913ca13e709f52da7aa68eb9429ede12b4fa5f0e",
    "filename": "src/peergos/server/crypto/hash/ScryptJava.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/crypto/hash/ScryptJava.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/crypto/hash/ScryptJava.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/server/crypto/hash/ScryptJava.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -10,6 +10,7 @@\n import peergos.shared.io.ipfs.multihash.*;\n import peergos.server.crypto.hash.lambdaworks.crypto.SCrypt;\n import peergos.shared.user.*;\n+import peergos.shared.user.fs.*;\n import peergos.shared.util.*;\n \n public class ScryptJava implements Hasher {\n@@ -74,4 +75,10 @@\n     public byte[] blake2b(byte[] input, int outputBytes) {\n         return Blake2b.Digest.newInstance(outputBytes).digest(input);\n     }\n+\n+    @Override\n+    public CompletableFuture<Multihash> hash(AsyncReader stream, long length) {\n+        return Hash.sha256(stream, length)\n+                .thenApply(h -> new Multihash(Multihash.Type.sha2_256, h));\n+    }\n }"
  },
  {
    "sha": "01cb1c5eef5157fdc3910edbdaedcd111ddfadb8",
    "filename": "src/peergos/server/tests/MultiUserTests.java",
    "status": "modified",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/tests/MultiUserTests.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/tests/MultiUserTests.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/server/tests/MultiUserTests.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -169,6 +169,26 @@ public void socialFeed() {\n         PeergosNetworkUtils.socialFeed(network, random);\n     }\n \n+    @Test\n+    public void socialPostPropagation() {\n+        PeergosNetworkUtils.socialPostPropagation(network, random);\n+    }\n+\n+    @Test\n+    public void socialFeedBug() {\n+        PeergosNetworkUtils.socialFeedBug(network, random);\n+    }\n+\n+    @Test\n+    public void socialFeedAndUnfriending() {\n+        PeergosNetworkUtils.socialFeedAndUnfriending(network, random);\n+    }\n+\n+    @Test\n+    public void socialFeedCommentOnSharedFile() throws Exception {\n+        PeergosNetworkUtils.socialFeedCommentOnSharedFile(network, network, random);\n+    }\n+\n     @Test\n     public void socialFeedVariations() {\n         PeergosNetworkUtils.socialFeedVariations(network, random);"
  },
  {
    "sha": "f53b38397e670575c6f3bd0fef40de42442eb801",
    "filename": "src/peergos/server/tests/PeergosNetworkUtils.java",
    "status": "modified",
    "additions": 270,
    "deletions": 7,
    "changes": 277,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/tests/PeergosNetworkUtils.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/server/tests/PeergosNetworkUtils.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/server/tests/PeergosNetworkUtils.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -5,19 +5,20 @@\n import peergos.server.storage.ResetableFileInputStream;\n import peergos.shared.Crypto;\n import peergos.shared.NetworkAccess;\n+import peergos.shared.crypto.hash.*;\n import peergos.shared.crypto.symmetric.SymmetricKey;\n+import peergos.shared.io.ipfs.multihash.Multihash;\n import peergos.shared.social.*;\n import peergos.shared.user.*;\n import peergos.shared.user.fs.*;\n import peergos.shared.user.fs.FileWrapper;\n import peergos.shared.user.fs.cryptree.*;\n-import peergos.shared.util.ArrayOps;\n-import peergos.shared.util.Serialize;\n-import peergos.shared.util.TriFunction;\n+import peergos.shared.util.*;\n \n import java.io.File;\n import java.io.IOException;\n import java.nio.file.*;\n+import java.time.*;\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.stream.*;\n@@ -36,6 +37,7 @@ public static String generatePassword() {\n     }\n \n     public static final Crypto crypto = Main.initCrypto();\n+    public static final Hasher hasher = crypto.hasher;\n \n     public static String randomString() {\n         return UUID.randomUUID().toString();\n@@ -177,6 +179,64 @@ public static void grantAndRevokeFileReadAccess(NetworkAccess sharerNode, Networ\n         Assert.assertTrue(Arrays.equals(newFileContents, ArrayOps.concat(originalFileContents, suffix)));\n     }\n \n+    public static void socialFeedCommentOnSharedFile(NetworkAccess sharerNode, NetworkAccess shareeNode, Random random) throws Exception {\n+        //sign up a user on sharerNode\n+        String sharerUsername = randomUsername(\"sharer-\", random);\n+        String sharerPassword = generatePassword();\n+        UserContext sharer = ensureSignedUp(sharerUsername, sharerPassword, sharerNode.clear(), crypto);\n+\n+        //sign up some users on shareeNode\n+        int shareeCount = 1;\n+        List<String> shareePasswords = IntStream.range(0, shareeCount)\n+                .mapToObj(i -> generatePassword())\n+                .collect(Collectors.toList());\n+        List<UserContext> shareeUsers = getUserContextsForNode(shareeNode, random, shareeCount, shareePasswords);\n+        UserContext sharee = shareeUsers.get(0);\n+\n+        // friend sharer with others\n+        friendBetweenGroups(Arrays.asList(sharer), shareeUsers);\n+\n+        // upload a file to \"a\"'s space\n+        FileWrapper u1Root = sharer.getUserRoot().get();\n+        String filename = \"somefile.txt\";\n+        File f = File.createTempFile(\"peergos\", \"\");\n+        byte[] originalFileContents = sharer.crypto.random.randomBytes(10*1024*1024);\n+        Files.write(f.toPath(), originalFileContents);\n+        ResetableFileInputStream resetableFileInputStream = new ResetableFileInputStream(f);\n+        FileWrapper uploaded = u1Root.uploadOrReplaceFile(filename, resetableFileInputStream, f.length(),\n+                sharer.network, crypto, l -> {}, crypto.random.randomBytes(32)).get();\n+\n+        // share the file from sharer to each of the sharees\n+        Set<String> shareeNames = shareeUsers.stream()\n+                .map(u -> u.username)\n+                .collect(Collectors.toSet());\n+        sharer.shareReadAccessWith(Paths.get(sharer.username, filename), shareeNames).join();\n+\n+        SocialFeed receiverFeed = sharee.getSocialFeed().join().update().join();\n+        List<Pair<SharedItem, FileWrapper>> files = receiverFeed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 3);\n+        FileWrapper sharedFile = files.get(files.size() -1).right;\n+        SharedItem sharedItem = files.get(files.size() -1).left;\n+\n+        Multihash hash = sharedFile.getContentHash(sharee.network, sharee.crypto).join();\n+        String replyText = \"reply\";\n+        SocialPost.Type type = peergos.shared.social.SocialPost.Type.Text;\n+        SocialPost.Resharing resharingType = SocialPost.Resharing.Friends;\n+        SocialPost.Ref parent = new SocialPost.Ref(sharedItem.path, sharedItem.cap, hash);\n+        SocialPost replySocialPost = SocialPost.createComment(parent, resharingType, type, sharee.username,\n+                Arrays.asList(new SocialPost.Content.Text(replyText)));\n+        Pair<Path, FileWrapper> result = receiverFeed.createNewPost(replySocialPost).join();\n+        String friendGroup = SocialState.FRIENDS_GROUP_NAME;\n+        String receiverGroupUid = sharee.getSocialState().join().groupNameToUid.get(friendGroup);\n+        Boolean res = sharee.shareReadAccessWith(result.left, Set.of(receiverGroupUid)).join();\n+\n+        //now sharer should see the reply\n+        SocialFeed feed = sharer.getSocialFeed().join().update().join();\n+        files = feed.getSharedFiles(0, 100).join();\n+        //assertTrue(files.size() == 5);\n+\n+    }\n+\n     public static void grantAndRevokeFileWriteAccess(NetworkAccess sharerNode, NetworkAccess shareeNode, int shareeCount, Random random) throws Exception {\n         Assert.assertTrue(0 < shareeCount);\n         //sign up a user on sharerNode\n@@ -1194,9 +1254,6 @@ public static void socialFeed(NetworkAccess network, Random random) {\n \n         // friends are now connected\n         // share a file from u1 to u2\n-        FileWrapper u1Root = sharer.getUserRoot().join();\n-\n-        String filename = \"somefile.txt\";\n         byte[] fileData = sharer.crypto.random.randomBytes(1*1024*1024);\n         Path file1 = Paths.get(sharer.username, \"first-file.txt\");\n         uploadAndShare(fileData, file1, sharer, a.username);\n@@ -1253,13 +1310,219 @@ public static void socialFeed(NetworkAccess network, Random random) {\n \n         // now check feed\n         SocialFeed updatedFeed3 = freshFeed.update().join();\n-        List<SharedItem> items3 = updatedFeed3.getShared(feedSize + 2, feedSize + 3, a.crypto, a.network).join();\n+        List<SharedItem> items3 = updatedFeed3.getShared(feedSize + 2, feedSize + 4, a.crypto, a.network).join();\n         Assert.assertTrue(items3.size() > 0);\n         SharedItem item3 = items3.get(0);\n         Assert.assertTrue(item3.owner.equals(sharer.username));\n         Assert.assertTrue(item3.sharer.equals(sharer.username));\n         AbsoluteCapability readCap3 = sharer.getByPath(file3).join().get().getPointer().capability.readOnly();\n         Assert.assertTrue(item3.cap.equals(readCap3));\n+\n+        // social post\n+        List<SocialPost.Content.Text> postBody = Arrays.asList(new SocialPost.Content.Text(\"G'day, skip!\"));\n+        SocialPost post = new SocialPost(SocialPost.Type.Text, sharer.username, postBody, LocalDateTime.now(),\n+                SocialPost.Resharing.Friends, Optional.empty(), Collections.emptyList(), Collections.emptyList());\n+        Pair<Path, FileWrapper> p = sharer.getSocialFeed().join().createNewPost(post).join();\n+        sharer.shareReadAccessWith(p.left, Set.of(a.username)).join();\n+        List<SharedItem> withPost = freshFeed.update().join().getShared(0, feedSize + 5, crypto, fresherA.network).join();\n+        SharedItem sharedPost = withPost.get(withPost.size() - 1);\n+        FileWrapper postFile = fresherA.getByPath(sharedPost.path).join().get();\n+        assertTrue(postFile.getFileProperties().isSocialPost());\n+        SocialPost receivedPost = Serialize.parse(postFile.getInputStream(network, crypto, x -> {}).join(),\n+                postFile.getSize(), SocialPost::fromCbor).join();\n+        assertTrue(receivedPost.body.equals(post.body));\n+    }\n+\n+    public static void socialPostPropagation(NetworkAccess network, Random random) {\n+        CryptreeNode.setMaxChildLinkPerBlob(10);\n+\n+        String password = \"notagoodone\";\n+\n+        UserContext a = PeergosNetworkUtils.ensureSignedUp(\"a\"+generateUsername(random), password, network, crypto);\n+\n+        List<UserContext> shareeUsers = getUserContextsForNode(network, random, 2, Arrays.asList(password, password));\n+        UserContext b = shareeUsers.get(0);\n+        UserContext c = shareeUsers.get(1);\n+\n+        // friend a with others, b and c are not friends\n+        friendBetweenGroups(Arrays.asList(a), shareeUsers);\n+\n+        // friends are now connected\n+        // test social post propagation (comment from b on post from a gets to c)\n+        SocialPost post = new SocialPost(SocialPost.Type.Text, a.username,\n+                Arrays.asList(new SocialPost.Content.Text(\"G'day, skip!\")), LocalDateTime.now(),\n+                SocialPost.Resharing.Friends, Optional.empty(),\n+                Collections.emptyList(), Collections.emptyList());\n+        Pair<Path, FileWrapper> p = a.getSocialFeed().join().createNewPost(post).join();\n+        String aFriendsUid = a.getGroupUid(SocialState.FRIENDS_GROUP_NAME).join().get();\n+        a.shareReadAccessWith(p.left, Set.of(aFriendsUid)).join();\n+\n+        // b receives the post\n+        SocialFeed bFeed = b.getSocialFeed().join().update().join();\n+        List<Pair<SharedItem, FileWrapper>> bPosts = bFeed.getSharedFiles(0, 25).join();\n+        Pair<SharedItem, FileWrapper> sharedPost = bPosts.get(bPosts.size() - 1);\n+\n+        // b now comments on post from a\n+        SocialPost reply = new SocialPost(SocialPost.Type.Text, b.username,\n+                Arrays.asList(new SocialPost.Content.Text(\"What an entrance!\")), LocalDateTime.now(),\n+                SocialPost.Resharing.Friends,\n+                Optional.of(new SocialPost.Ref(sharedPost.left.path, sharedPost.left.cap, post.contentHash(hasher).join())),\n+                Collections.emptyList(), Collections.emptyList());\n+        Pair<Path, FileWrapper> replyFromB = bFeed.createNewPost(reply).join();\n+        String bFriendsUid = b.getGroupUid(SocialState.FRIENDS_GROUP_NAME).join().get();\n+        b.shareReadAccessWith(replyFromB.left, Set.of(bFriendsUid)).join();\n+\n+        // make sure a includes a ref to the comment on the original\n+        a.getSocialFeed().join().update().join();\n+\n+        // check c gets the post and it references the comment\n+        List<Pair<SharedItem, FileWrapper>> cPosts = c.getSocialFeed().join().update().join().getSharedFiles(0, 25).join();\n+        Pair<SharedItem, FileWrapper> cPost = cPosts.get(cPosts.size() - 1);\n+        SocialPost receivedPost = Serialize.parse(cPost.right.getInputStream(network, crypto, x -> {}).join(),\n+                cPost.right.getSize(), SocialPost::fromCbor).join();\n+        Assert.assertTrue(receivedPost.author.equals(a.username));\n+        Assert.assertTrue(receivedPost.comments.get(0).cap.equals(replyFromB.right.readOnlyPointer()));\n+    }\n+\n+    public static void socialFeedBug(NetworkAccess network, Random random) {\n+        CryptreeNode.setMaxChildLinkPerBlob(10);\n+\n+        String password = \"notagoodone\";\n+\n+        UserContext sharer = PeergosNetworkUtils.ensureSignedUp(randomUsername(\"sharer-\", random), password, network, crypto);\n+\n+        List<UserContext> shareeUsers = getUserContextsForNode(network, random, 1, Arrays.asList(password, password));\n+        UserContext sharee = shareeUsers.get(0);\n+\n+        // friend sharer with others\n+        friendBetweenGroups(Arrays.asList(sharer), shareeUsers);\n+\n+\n+        byte[] fileData = sharer.crypto.random.randomBytes(1*1024*1024);\n+        AsyncReader reader = new AsyncReader.ArrayBacked(fileData);\n+\n+        SocialFeed feed = sharer.getSocialFeed().join();\n+        SocialPost.Ref ref = feed.uploadMediaForPost(reader, fileData.length, LocalDateTime.now(), c -> {}).join().right;\n+        SocialPost.Resharing resharingType = SocialPost.Resharing.Friends;\n+        SocialPost.Type commentType = SocialPost.Type.Image;\n+        List<? extends SocialPost.Content> body = Arrays.asList(new SocialPost.Content.Text(\"aaaa\"), new SocialPost.Content.Reference(ref));\n+        SocialPost socialPost = SocialPost.createInitialPost(commentType, sharer.username, body, resharingType);\n+\n+        Pair<Path, FileWrapper> result = feed.createNewPost(socialPost).join();\n+\n+        LocalDateTime postTime = LocalDateTime.now();\n+        String updatedBody = \"bbbbb\";\n+        socialPost = socialPost.edit(Arrays.asList(new SocialPost.Content.Text(updatedBody)), postTime);\n+\n+        String uuid = result.left.getFileName().toString();\n+        result = feed.updatePost(uuid, socialPost).join();\n+\n+        String friendGroup = SocialState.FRIENDS_GROUP_NAME;\n+        SocialState state = sharer.getSocialState().join();\n+        String groupUid = state.groupNameToUid.get(friendGroup);\n+        // was Set.of(groupUid)\n+        //boolean res = sharer.shareReadAccessWith(result.left, Set.of(sharee.username)).join();\n+        boolean res = sharer.shareReadAccessWith(result.left, Set.of(groupUid)).join();\n+\n+        SocialFeed receiverFeed = sharee.getSocialFeed().join().update().join();\n+        List<Pair<SharedItem, FileWrapper>> files = receiverFeed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 3);\n+        FileWrapper socialFile = files.get(files.size() -1).right;\n+        SharedItem sharedItem = files.get(files.size() -1).left;\n+        FileProperties props = socialFile.getFileProperties();\n+        SocialPost loadedSocialPost = Serialize.parse(socialFile, SocialPost::fromCbor, sharee.network, crypto).join();\n+        assertTrue(loadedSocialPost.body.equals(updatedBody));\n+\n+        SocialPost.Ref mediaRef = ((SocialPost.Content.Reference)loadedSocialPost.body.get(1)).ref;\n+        Optional<FileWrapper> optFile = sharee.network.getFile(mediaRef.cap, sharer.username).join();\n+        assertTrue(optFile.isPresent());\n+\n+        //create a reply\n+        String replyText = \"reply\";\n+        Multihash hash = loadedSocialPost.contentHash(sharee.crypto.hasher).join();\n+        SocialPost.Type type = peergos.shared.social.SocialPost.Type.Text;\n+        SocialPost.Ref parent = new SocialPost.Ref(sharedItem.path, sharedItem.cap, hash);\n+        SocialPost replySocialPost = SocialPost.createComment(parent, resharingType, type, sharee.username, Arrays.asList(new SocialPost.Content.Text(replyText)));\n+        result = receiverFeed.createNewPost(replySocialPost).join();\n+        String receiverGroupUid = sharee.getSocialState().join().groupNameToUid.get(friendGroup);\n+        res = sharee.shareReadAccessWith(result.left, Set.of(receiverGroupUid)).join();\n+\n+        //now sharer should see the reply\n+        sharer = UserContext.signIn(sharer.username, password, sharer.network, sharer.crypto, c -> {}).join();\n+        feed = sharer.getSocialFeed().join().update().join();\n+        files = feed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 5);\n+        socialFile = files.get(files.size() -1).right;\n+        loadedSocialPost = Serialize.parse(socialFile, SocialPost::fromCbor, sharer.network, crypto).join();\n+        assertTrue(loadedSocialPost.body.equals(replyText));\n+    }\n+\n+    public static void socialFeedAndUnfriending(NetworkAccess network, Random random) {\n+        CryptreeNode.setMaxChildLinkPerBlob(10);\n+\n+        String password = \"notagoodone\";\n+\n+        UserContext sharer = PeergosNetworkUtils.ensureSignedUp(randomUsername(\"sharer-\", random), password, network, crypto);\n+\n+        List<UserContext> shareeUsers = getUserContextsForNode(network, random, 1, Arrays.asList(password, password));\n+        UserContext sharee = shareeUsers.get(0);\n+\n+        // friend sharer with others\n+        friendBetweenGroups(Arrays.asList(sharer), shareeUsers);\n+\n+\n+        SocialFeed feed = sharer.getSocialFeed().join();\n+        SocialPost.Resharing resharingType = SocialPost.Resharing.Friends;\n+        SocialPost.Type commentType = SocialPost.Type.Text;\n+        String bodyText = \"aaaa\";\n+        List<SocialPost.Content.Text> body = Arrays.asList(new SocialPost.Content.Text(bodyText));\n+        SocialPost socialPost = SocialPost.createInitialPost(commentType, sharer.username, body, resharingType);\n+        Pair<Path, FileWrapper> result = feed.createNewPost(socialPost).join();\n+\n+        String friendGroup = SocialState.FRIENDS_GROUP_NAME;\n+        SocialState state = sharer.getSocialState().join();\n+        String groupUid = state.groupNameToUid.get(friendGroup);\n+        boolean res = sharer.shareReadAccessWith(result.left, Set.of(groupUid)).join();\n+\n+        SocialFeed receiverFeed = sharee.getSocialFeed().join().update().join();\n+        List<Pair<SharedItem, FileWrapper>> files = receiverFeed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 3);\n+        FileWrapper socialFile = files.get(files.size() - 1).right;\n+        SharedItem sharedItem = files.get(files.size() - 1).left;\n+        FileProperties props = socialFile.getFileProperties();\n+        SocialPost loadedSocialPost = Serialize.parse(socialFile, SocialPost::fromCbor, sharee.network, crypto).join();\n+        assertTrue(loadedSocialPost.body.equals(bodyText));\n+\n+        //create a reply\n+        String replyText = \"reply\";\n+        Multihash hash = loadedSocialPost.contentHash(sharee.crypto.hasher).join();\n+        SocialPost.Type type = peergos.shared.social.SocialPost.Type.Text;\n+        SocialPost.Ref parent = new SocialPost.Ref(sharedItem.path, sharedItem.cap, hash);\n+        SocialPost replySocialPost = SocialPost.createComment(parent, resharingType, type, sharee.username,\n+                Arrays.asList(new SocialPost.Content.Text(replyText)));\n+        result = receiverFeed.createNewPost(replySocialPost).join();\n+        String receiverGroupUid = sharee.getSocialState().join().groupNameToUid.get(friendGroup);\n+        res = sharee.shareReadAccessWith(result.left, Set.of(receiverGroupUid)).join();\n+\n+        //now sharer should see the reply\n+        feed = sharer.getSocialFeed().join().update().join();\n+        files = feed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 5);\n+        FileWrapper original = files.get(files.size() - 2).right;\n+        FileWrapper reply = files.get(files.size() - 1).right;\n+        SocialPost originalPost = Serialize.parse(original, SocialPost::fromCbor, sharer.network, crypto).join();\n+        SocialPost replyPost = Serialize.parse(reply, SocialPost::fromCbor, sharer.network, crypto).join();\n+        assertTrue(originalPost.body.equals(bodyText));\n+        assertTrue(replyPost.body.equals(replyText));\n+\n+        sharer.removeFollower(sharee.username).join();\n+        feed = sharer.getSocialFeed().join().update().join();\n+        files = feed.getSharedFiles(0, 100).join();\n+        assertTrue(files.size() == 5);\n+        FileWrapper post = files.get(files.size() - 2).right;\n+        SocialPost remainingSocialPost = Serialize.parse(post, SocialPost::fromCbor, sharer.network, crypto).join();\n+        assertTrue(remainingSocialPost.body.equals(bodyText));\n+\n     }\n \n     private static void uploadAndShare(byte[] data, Path file, UserContext sharer, String sharee) {"
  },
  {
    "sha": "bd2e15797d45740114ce0ed5369b3c4a6f5d7646",
    "filename": "src/peergos/shared/NetworkAccess.java",
    "status": "modified",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/NetworkAccess.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/NetworkAccess.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/NetworkAccess.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -361,6 +361,7 @@ private static NetworkAccess build(ContentAddressedStorage dht,\n                 });\n     }\n \n+    @JsMethod\n     public CompletableFuture<Optional<FileWrapper>> getFile(AbsoluteCapability cap, String owner) {\n         return synchronizer.getValue(cap.owner, cap.writer)\n                 .thenCompose(version -> getFile(version, cap, Optional.empty(), owner))"
  },
  {
    "sha": "9d34b142abe601129032e9794944d6d3ce29503f",
    "filename": "src/peergos/shared/cbor/CborObject.java",
    "status": "modified",
    "additions": 12,
    "deletions": 1,
    "changes": 13,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/cbor/CborObject.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/cbor/CborObject.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/cbor/CborObject.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -166,7 +166,8 @@ public Multihash getMerkleLink(String key) {\n         }\n \n         public boolean getBoolean(String key) {\n-            return ((CborBoolean) get(key)).value;\n+            CborBoolean val = (CborBoolean) get(key);\n+            return val != null && val.value;\n         }\n \n         public boolean getBoolean(String key, boolean def) {\n@@ -198,6 +199,8 @@ public boolean getBoolean(String key, boolean def) {\n \n         public <T> List<T> getList(String key, Function<Cborable, T> fromCbor) {\n             CborList cborList = (CborList) get(key);\n+            if (cborList == null)\n+                return Collections.emptyList();\n             return cborList.value\n                     .stream()\n                     .map(fromCbor)\n@@ -328,6 +331,10 @@ public CborList(Map<? extends Cborable, ? extends Cborable> map) {\n                 .collect(Collectors.toList());\n         }\n \n+        public static <T> CborList build(List<T> in, Function<T, Cborable> toCbor) {\n+            return new CborList(in.stream().map(toCbor).collect(Collectors.toList()));\n+        }\n+\n         @Override\n         public void serialize(CborEncoder encoder) {\n             try {\n@@ -368,6 +375,10 @@ public int hashCode() {\n                 .collect(Collectors.toList());\n         }\n \n+        public long getLong(int index) {\n+            return ((CborLong)value.get(index)).value;\n+        }\n+\n         public <T> T get(int index, Function<? super Cborable, T> fromCbor) {\n             return fromCbor.apply(value.get(index));\n         }"
  },
  {
    "sha": "6a5d3d96cd76fcb0666816fd3ba775dbfd22f5da",
    "filename": "src/peergos/shared/crypto/hash/Hasher.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/Hasher.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/Hasher.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/crypto/hash/Hasher.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -4,6 +4,7 @@\n import peergos.shared.io.ipfs.cid.*;\n import peergos.shared.io.ipfs.multihash.*;\n import peergos.shared.user.*;\n+import peergos.shared.user.fs.*;\n \n import java.util.concurrent.CompletableFuture;\n \n@@ -15,13 +16,20 @@\n \n     CompletableFuture<byte[]> sha256(byte[] input);\n \n+    CompletableFuture<Multihash> hash(AsyncReader stream, long length);\n+\n     byte[] blake2b(byte[] input, int outputBytes);\n \n     default CompletableFuture<Multihash> hash(byte[] input, boolean isRaw) {\n         return sha256(input)\n                 .thenApply(h -> Cid.buildCidV1(isRaw ? Cid.Codec.Raw : Cid.Codec.DagCbor, Multihash.Type.sha2_256, h));\n     }\n \n+    default CompletableFuture<Multihash> bareHash(byte[] input) {\n+        return sha256(input)\n+                .thenApply(h -> new Multihash(Multihash.Type.sha2_256, h));\n+    }\n+\n     default Multihash identityHash(byte[] input, boolean isRaw) {\n         if (input.length > Multihash.MAX_IDENTITY_HASH_SIZE)\n             throw new IllegalStateException(\"Exceeded maximum size for identity multihashes!\");"
  },
  {
    "sha": "6099f02e9311d2dc3df1776331b0add405242710",
    "filename": "src/peergos/shared/crypto/hash/NativeScryptJS.java",
    "status": "modified",
    "additions": 3,
    "deletions": 0,
    "changes": 3,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/NativeScryptJS.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/NativeScryptJS.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/crypto/hash/NativeScryptJS.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -3,6 +3,7 @@\n import jsinterop.annotations.*;\n import peergos.shared.crypto.*;\n import peergos.shared.user.*;\n+import peergos.shared.user.fs.*;\n \n import java.util.concurrent.*;\n \n@@ -16,4 +17,6 @@\n     public native CompletableFuture<byte[]> sha256(byte[] input);\n \n     public native byte[] blake2b(byte[] input, int outputBytes);\n+\n+    public native CompletableFuture<byte[]> streamSha256(AsyncReader stream, int length);\n }"
  },
  {
    "sha": "2a21655a8afac819f32b1119738e3a0d384f86f6",
    "filename": "src/peergos/shared/crypto/hash/ScryptJS.java",
    "status": "modified",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/ScryptJS.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/crypto/hash/ScryptJS.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/crypto/hash/ScryptJS.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -1,7 +1,9 @@\n package peergos.shared.crypto.hash;\n \n import peergos.shared.crypto.*;\n+import peergos.shared.io.ipfs.multihash.*;\n import peergos.shared.user.*;\n+import peergos.shared.user.fs.*;\n \n import java.util.concurrent.CompletableFuture;\n \n@@ -28,4 +30,10 @@\n     public byte[] blake2b(byte[] input, int outputBytes) {\n         return scriptJS.blake2b(input, outputBytes);\n     }\n+\n+    @Override\n+    public CompletableFuture<Multihash> hash(AsyncReader stream, long length) {\n+        return scriptJS.streamSha256(stream, (int) length)\n+                .thenApply(h -> new Multihash(Multihash.Type.sha2_256, h));\n+    }\n }"
  },
  {
    "sha": "a43cce59e9c56e09a8769b62b9e125a73543d4ab",
    "filename": "src/peergos/shared/social/SharedItem.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SharedItem.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SharedItem.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/social/SharedItem.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -55,4 +55,9 @@ public static SharedItem fromCbor(Cborable cbor) {\n         String path = m.getString(\"p\");\n         return new SharedItem(cap, owner, sharer, path);\n     }\n+\n+    @Override\n+    public String toString() {\n+        return path + \" via \" + sharer;\n+    }\n }"
  },
  {
    "sha": "f4654224979edc959d5b4bb72521d2534f7426d2",
    "filename": "src/peergos/shared/social/SocialFeed.java",
    "status": "modified",
    "additions": 152,
    "deletions": 21,
    "changes": 173,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SocialFeed.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SocialFeed.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/social/SocialFeed.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -9,6 +9,7 @@\n \n import java.io.*;\n import java.nio.file.*;\n+import java.time.*;\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.stream.*;\n@@ -32,6 +33,8 @@\n     private long feedSizeBytes;\n     private Map<String, ProcessedCaps> currentCapBytesProcessed;\n     private final UserContext context;\n+    private final NetworkAccess network;\n+    private final Crypto crypto;\n \n     public SocialFeed(FileWrapper dataDir,\n                       FileWrapper stateFile,\n@@ -44,13 +47,83 @@ public SocialFeed(FileWrapper dataDir,\n         this.feedSizeBytes = state.feedSizeBytes;\n         this.currentCapBytesProcessed = new HashMap<>(state.currentCapBytesProcessed);\n         this.context = context;\n+        this.network = context.network;\n+        this.crypto = context.crypto;\n+    }\n+\n+    /** Create a new post file under /username/.posts/$year/$month/#uuid\n+     *\n+     * @param post\n+     * @return\n+     */\n+    @JsMethod\n+    public CompletableFuture<Pair<Path, FileWrapper>> createNewPost(SocialPost post) {\n+        if (! post.author.equals(context.username))\n+            throw new IllegalStateException(\"You can only post as yourself!\");\n+        String postFilename = UUID.randomUUID().toString() + \".cbor\";\n+        Path dir = getDirFromHome(post);\n+        byte[] raw = post.serialize();\n+        AsyncReader reader = AsyncReader.build(raw);\n+        return context.getUserRoot()\n+                .thenCompose(home -> home.getOrMkdirs(dir, network, true, crypto))\n+                .thenCompose(postDir -> postDir.uploadAndReturnFile(postFilename, reader, raw.length, false,\n+                        network, crypto)\n+                        .thenApply(f -> new Pair<>(Paths.get(post.author).resolve(dir).resolve(postFilename), f)))\n+                .thenCompose(p -> addToFeed(Arrays.asList(new SharedItem(p.right.readOnlyPointer(),\n+                        context.username, context.username, p.left.toString())))\n+                        .thenApply(f -> p));\n+    }\n+\n+    @JsMethod\n+    public CompletableFuture<Pair<Path, FileWrapper>> updatePost(String uuid, SocialPost post) {\n+        if (! post.author.equals(context.username))\n+            throw new IllegalStateException(\"You can only post as yourself!\");\n+        Path dir = getDirFromHome(post.previousVersions.get(0));\n+        byte[] raw = post.serialize();\n+        String completePath = context.username + \"/\" + dir.resolve(uuid).toString();\n+        return context.getByPath(completePath).thenCompose(fopt ->\n+            fopt.get().overwriteFile(AsyncReader.build(raw), raw.length, network, crypto, x -> {})\n+                    .thenApply(f -> new Pair<>(Paths.get(post.author).resolve(dir).resolve(uuid), f))\n+        );\n+    }\n+\n+    @JsMethod\n+    public CompletableFuture<Pair<String, SocialPost.Ref>> uploadMediaForPost(AsyncReader media, int length,\n+                                                                       LocalDateTime postTime, ProgressConsumer<Long> monitor) {\n+        String uuid = UUID.randomUUID().toString();\n+        return getOrMkdirToStoreMedia(\"media\", postTime)\n+                .thenCompose(p -> p.right.uploadAndReturnFile(uuid, media, length, false,\n+                        network, crypto)\n+                        .thenCompose(f -> f.getInputStream(f.version.get(f.writer()).props, network, crypto, monitor)\n+                                .thenCompose(reader -> crypto.hasher.hash(reader, f.getSize()))\n+                                .thenApply(hash -> new Pair<>(f.getFileProperties().getType(), new SocialPost.Ref(p.left.resolve(uuid).toString(), f.readOnlyPointer(), hash)))));\n+    }\n+\n+    private CompletableFuture<Pair<Path, FileWrapper>> getOrMkdirToStoreMedia(String mediaType, LocalDateTime postTime) {\n+        Path dirFromHome = Paths.get(UserContext.POSTS_DIR_NAME,\n+                Integer.toString(postTime.getYear()),\n+                mediaType);\n+        return context.getUserRoot()\n+                .thenCompose(home -> home.getOrMkdirs(dirFromHome, network, true, crypto)\n+                .thenApply(dir -> new Pair<>(Paths.get(\"/\" + context.username).resolve(dirFromHome), dir)));\n+    }\n+\n+    public static Path getDirFromHome(SocialPost post) {\n+        return Paths.get(UserContext.POSTS_DIR_NAME,\n+                Integer.toString(post.postTime.getYear()),\n+                Integer.toString(post.postTime.getMonthValue()));\n     }\n \n     @JsMethod\n     public synchronized boolean hasUnseen() {\n         return lastSeenIndex < feedSizeRecords;\n     }\n \n+    @JsMethod\n+    public synchronized int getFeedSize() {\n+        return feedSizeRecords;\n+    }\n+\n     @JsMethod\n     public synchronized int getLastSeenIndex() {\n         return lastSeenIndex;\n@@ -68,7 +141,7 @@ public synchronized int getLastSeenIndex() {\n      * @return the byte offset and corresponding index of a prior object boundary, which ideally should be in the same chunk\n      */\n     private CompletableFuture<Pair<Long, Integer>> getPriorByteOffset(int index) {\n-        return dataDir.getChild(FEED_INDEX, context.crypto.hasher, context.network)\n+        return dataDir.getChild(FEED_INDEX, crypto.hasher, network)\n                 .thenCompose(fopt -> {\n                     //TODO\n //                    if (fopt.isEmpty())\n@@ -91,10 +164,56 @@ public synchronized int getLastSeenIndex() {\n                                 })).orElse(Futures.of(Collections.emptyList()))));\n     }\n \n+    @JsMethod\n+    public CompletableFuture<List<Pair<SharedItem, FileWrapper>>> getSharedFiles(int from, int to) {\n+        return getShared(from, to, crypto, network)\n+                .thenCompose(context::getFiles);\n+    }\n+\n+    private CompletableFuture<List<Pair<SharedItem, FileWrapper>>> mergeCommentReferences(List<Pair<SharedItem, FileWrapper>> items) {\n+        List<Pair<SharedItem, FileWrapper>> posts = items.stream()\n+                .filter(p -> p.right.getFileProperties().isSocialPost())\n+                .collect(Collectors.toList());\n+\n+        return Futures.combineAllInOrder(posts.stream()\n+                .map(p -> Serialize.parse(p.right, SocialPost::fromCbor, network, crypto)\n+                        .thenApply(sp -> new Triple<>(p.left, p.right, sp)))\n+                .collect(Collectors.toList()))\n+                .thenCompose(retrieved -> {\n+                    Map<String, List<Triple<SharedItem, FileWrapper, SocialPost>>> commentsOnOurs = retrieved.stream()\n+                            .filter(t -> t.right.parent.map(p -> p.path.startsWith(\"/\" + context.username)).orElse(false))\n+                            .collect(Collectors.groupingBy(t -> t.right.parent.get().path));\n+                    return Futures.combineAllInOrder(commentsOnOurs.entrySet().stream()\n+                    .map(e -> mergeCommentsIntoParent(e.getKey(), e.getValue()))\n+                    .collect(Collectors.toList()));\n+                }).thenApply(x -> items);\n+    }\n+\n+    private CompletableFuture<Boolean> mergeCommentsIntoParent(String parentPath,\n+                                                               List<Triple<SharedItem, FileWrapper, SocialPost>> comments) {\n+        return Futures.combineAllInOrder(comments.stream().map(t -> t.middle.getInputStream(network, crypto, x -> {})\n+                .thenCompose(reader -> crypto.hasher.hash(reader, t.middle.getSize())\n+                        .thenApply(h -> new SocialPost.Ref(t.left.path, t.left.cap, h))))\n+                .collect(Collectors.toList())).thenCompose(refs ->\n+                context.getByPath(parentPath).thenCompose(fopt -> {\n+                    if (fopt.isEmpty())\n+                        return Futures.of(false);\n+                    if (! fopt.get().getFileProperties().isSocialPost())\n+                        return Futures.of(true);\n+                    return Serialize.parse(fopt.get(), SocialPost::fromCbor, network, crypto)\n+                            .thenCompose(parent -> {\n+                                SocialPost withComments = parent.addComments(refs);\n+                                byte[] raw = withComments.serialize();\n+                                return fopt.get().overwriteFile(AsyncReader.build(raw), raw.length, network, crypto, x -> {})\n+                                        .thenApply(x -> true);\n+                            });\n+                }));\n+    }\n+\n     private synchronized CompletableFuture<Boolean> commit() {\n         byte[] raw = new FeedState(lastSeenIndex, feedSizeRecords, feedSizeBytes, currentCapBytesProcessed).serialize();\n         return stateFile.overwriteFile(AsyncReader.build(raw), raw.length,\n-                context.network, context.crypto, x -> {})\n+                network, crypto, x -> {})\n                 .thenApply(f -> {\n                     this.stateFile = f;\n                     return true;\n@@ -109,13 +228,13 @@ public synchronized int getLastSeenIndex() {\n     public synchronized CompletableFuture<SocialFeed> update() {\n         return context.getFollowingNodes()\n                 .thenCompose(friends -> Futures.reduceAll(friends, this,\n-                        (s, f) -> s.updateFriend(f, context.network), (a, b) -> b))\n-                .thenCompose(x -> x.commit().thenApply(b -> x));\n+                        (s, f) -> s.updateFriend(f, network), (a, b) -> b));\n     }\n \n     private synchronized CompletableFuture<SocialFeed> updateFriend(FriendSourcedTrieNode friend, NetworkAccess network) {\n         ProcessedCaps current = currentCapBytesProcessed.getOrDefault(friend.ownerName, ProcessedCaps.empty());\n-        return friend.getCaps(current, network)\n+        return friend.updateIncludingGroups(network)\n+                .thenCompose(x -> friend.getCaps(current, network))\n                 .thenCompose(diff -> {\n                     if (diff.isEmpty())\n                         return Futures.of(this);\n@@ -124,6 +243,11 @@ public synchronized int getLastSeenIndex() {\n                 });\n     }\n \n+    private CompletableFuture<List<Pair<SharedItem, FileWrapper>>> mergeInComments(List<SharedItem> shared) {\n+        return context.getFiles(shared)\n+                .thenCompose(this::mergeCommentReferences);\n+    }\n+\n     private static String extractOwner(String path) {\n         int start = path.startsWith(\"/\") ? 1 : 0;\n         int end = path.indexOf(\"/\", start + 1);\n@@ -136,26 +260,33 @@ private static String extractOwner(String path) {\n         ProcessedCaps updated = current.add(diff);\n         currentCapBytesProcessed.put(friendName, updated);\n         List<CapabilityWithPath> newCaps = diff.getNewCaps();\n-        feedSizeRecords += newCaps.size();\n         List<SharedItem> forFeed = newCaps.stream()\n                 .map(c -> new SharedItem(c.cap, extractOwner(c.path), friendName, c.path))\n                 .collect(Collectors.toList());\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        for (SharedItem item : forFeed) {\n-            try {\n-                bout.write(item.serialize());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n+        return addToFeed(forFeed);\n+    }\n+\n+    private synchronized CompletableFuture<SocialFeed> addToFeed(List<SharedItem> newItems) {\n+        return mergeInComments(newItems).thenCompose(b -> {\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            for (SharedItem item : newItems) {\n+                try {\n+                    bout.write(item.serialize());\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n             }\n-        }\n-        byte[] data = bout.toByteArray();\n-        feedSizeBytes += data.length;\n-        return dataDir.appendToChild(FEED_FILE, data, false, context.network, context.crypto, x -> {})\n-                .thenCompose(dir -> {\n-                    this.dataDir = dir;\n-                    return commit();\n-                })\n-                .thenApply(x -> this);\n+            byte[] data = bout.toByteArray();\n+            return dataDir.appendToChild(FEED_FILE, feedSizeBytes, data, false, network, crypto, x -> {\n+            })\n+                    .thenCompose(dir -> {\n+                        feedSizeRecords += newItems.size();\n+                        feedSizeBytes += data.length;\n+                        this.dataDir = dir;\n+                        return commit();\n+                    })\n+                    .thenApply(x -> this);\n+        });\n     }\n \n     public static CompletableFuture<SocialFeed> load(FileWrapper dataDir, UserContext context) {"
  },
  {
    "sha": "ab98795090d6960ca6ddd7370943097fe41fcc85",
    "filename": "src/peergos/shared/social/SocialPost.java",
    "status": "added",
    "additions": 311,
    "deletions": 0,
    "changes": 311,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SocialPost.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/social/SocialPost.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/social/SocialPost.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -0,0 +1,311 @@\n+package peergos.shared.social;\n+\n+import jsinterop.annotations.*;\n+import peergos.shared.cbor.*;\n+import peergos.shared.crypto.hash.*;\n+import peergos.shared.io.ipfs.multihash.*;\n+import peergos.shared.user.fs.*;\n+\n+import java.time.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.*;\n+\n+@JsType\n+public class SocialPost implements Cborable {\n+    @JsType\n+    public enum Type {\n+        Text, // body is just text\n+        Image, // 1 image in references\n+        Video, // 1 video in references\n+        Audio, // 1 audio file in references\n+        Media, // several images/video/audio files in references\n+        Poll // votes are merged in as comments, options are in body\n+    }\n+\n+    /** This enum describes the audience that a post is allowed to be shared with.\n+     *\n+     */\n+    @JsType\n+    public enum Resharing {\n+        Author,\n+        Friends,\n+        Followers,\n+        Public\n+    }\n+\n+    public interface Content extends Cborable {\n+\n+        @JsMethod\n+        String inlineText();\n+\n+        @JsMethod\n+        Optional<Ref> reference();\n+\n+        @JsType\n+        class Text implements Content {\n+            public final String content;\n+\n+            public Text(String content) {\n+                this.content = content;\n+            }\n+\n+            @Override\n+            public String inlineText() {\n+                return content;\n+            }\n+\n+            @Override\n+            public Optional<Ref> reference() {\n+                return Optional.empty();\n+            }\n+\n+            @Override\n+            public CborObject toCbor() {\n+                return new CborObject.CborString(content);\n+            }\n+        }\n+\n+        class Reference implements Content {\n+            public final Ref ref;\n+\n+            public Reference(Ref ref) {\n+                this.ref = ref;\n+            }\n+\n+            @Override\n+            public CborObject toCbor() {\n+                SortedMap<String, Cborable> state = new TreeMap<>();\n+                state.put(\"t\", new CborObject.CborString(\"Ref\"));\n+                state.put(\"r\", ref);\n+                return CborObject.CborMap.build(state);\n+            }\n+\n+            @Override\n+            public String inlineText() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public Optional<Ref> reference() {\n+                return Optional.of(ref);\n+            }\n+        }\n+\n+        static Content fromCbor(Cborable cbor) {\n+            if (cbor instanceof CborObject.CborString)\n+                return new Text(((CborObject.CborString) cbor).value);\n+            if (cbor instanceof CborObject.CborMap) {\n+                CborObject.CborMap m = (CborObject.CborMap) cbor;\n+                String type = m.getString(\"t\");\n+                switch (type) {\n+                    case \"Ref\": return new Reference(m.get(\"r\", Ref::fromCbor));\n+                    default: throw new IllegalStateException(\"Unknown content type in Social Post: \" + type);\n+                }\n+            }\n+            throw new IllegalStateException(\"Unknown Content type in Social Post\");\n+        }\n+    }\n+\n+    public final Type kind;\n+    public final String author;\n+    public final List<? extends Content> body;\n+    public final LocalDateTime postTime;\n+    public final Resharing shareTo;\n+    public final Optional<Ref> parent;\n+    public final List<SocialPost> previousVersions;\n+    // this is excluded from hash calculation when replying\n+    public final List<Ref> comments;\n+\n+    @JsConstructor\n+    public SocialPost(Type kind,\n+                      String author,\n+                      List<? extends Content> body,\n+                      LocalDateTime postTime,\n+                      Resharing shareTo,\n+                      Optional<Ref> parent,\n+                      List<SocialPost> previousVersions,\n+                      List<Ref> comments) {\n+        this.kind = kind;\n+        this.author = author;\n+        this.body = body;\n+        this.postTime = postTime;\n+        this.shareTo = shareTo;\n+        this.parent = parent;\n+        this.previousVersions = previousVersions;\n+        this.comments = comments;\n+    }\n+\n+    @JsMethod\n+    public List<Ref> references() {\n+        return body.stream()\n+                .flatMap(c -> c.reference().stream())\n+                .collect(Collectors.toList());\n+    }\n+\n+    public static SocialPost createInitialPost(Type type, String author, List<? extends Content> body, Resharing resharing) {\n+        return new SocialPost(type, author, body, LocalDateTime.now(), resharing,\n+                Optional.empty(), Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    public static SocialPost createComment(Ref parent, Resharing fromParent, Type type, String author, List<? extends Content> body) {\n+        return new SocialPost(type, author, body, LocalDateTime.now(), fromParent,\n+                Optional.of(parent), Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    public SocialPost edit(List<? extends Content> body,\n+                           LocalDateTime postTime) {\n+        ArrayList<SocialPost> versions = new ArrayList<>(previousVersions);\n+        versions.add(this);\n+        return new SocialPost(kind, author, body, postTime, shareTo, parent, versions, comments);\n+    }\n+\n+    /** adding references to comments does not change the version of this comment (the hash ignores the comment refs)\n+     *\n+     * @param comment\n+     * @return\n+     */\n+    public SocialPost addComment(Ref comment) {\n+        ArrayList<Ref> updatedComments = new ArrayList<>(comments);\n+        if (! comments.contains(comment))\n+            updatedComments.add(comment);\n+        return new SocialPost(kind, author, body, postTime, shareTo, parent, previousVersions, updatedComments);\n+    }\n+\n+    public SocialPost addComments(List<Ref> newComments) {\n+        ArrayList<Ref> updatedComments = new ArrayList<>(comments);\n+        for (Ref comment : newComments) {\n+            if (!updatedComments.contains(comment))\n+                updatedComments.add(comment);\n+        }\n+        return new SocialPost(kind, author, body, postTime, shareTo, parent, previousVersions, updatedComments);\n+    }\n+\n+    private byte[] serializeWithoutComments() {\n+        return new SocialPost(kind, author, body, postTime, shareTo, parent,\n+                previousVersions, Collections.emptyList()).serialize();\n+    }\n+\n+    public CompletableFuture<Multihash> contentHash(Hasher h) {\n+        return h.bareHash(serializeWithoutComments());\n+    }\n+\n+    @Override\n+    public CborObject toCbor() {\n+        SortedMap<String, Cborable> state = new TreeMap<>();\n+        state.put(\"k\", new CborObject.CborString(kind.name()));\n+        state.put(\"a\", new CborObject.CborString(author));\n+        state.put(\"b\", new CborObject.CborList(body));\n+        state.put(\"t\", new CborObject.CborLong(postTime.toEpochSecond(ZoneOffset.UTC)));\n+        state.put(\"s\", new CborObject.CborString(shareTo.name()));\n+        parent.ifPresent(r -> state.put(\"p\", r));\n+        if (! previousVersions.isEmpty())\n+            state.put(\"v\", new CborObject.CborList(previousVersions));\n+        if (! comments.isEmpty())\n+            state.put(\"d\", new CborObject.CborList(comments));\n+\n+        List<CborObject> withMimeType = new ArrayList<>();\n+        withMimeType.add(new CborObject.CborLong(MimeTypes.CBOR_PEERGOS_POST_INT));\n+        withMimeType.add(CborObject.CborMap.build(state));\n+\n+        return new CborObject.CborList(withMimeType);\n+    }\n+\n+    public static SocialPost fromCbor(Cborable cbor) {\n+        if (!(cbor instanceof CborObject.CborList))\n+            throw new IllegalStateException(\"Invalid cbor! \" + cbor);\n+        CborObject.CborList withMimeType = (CborObject.CborList) cbor;\n+        long mimeType = withMimeType.getLong(0);\n+        if (mimeType != MimeTypes.CBOR_PEERGOS_POST_INT)\n+            throw new IllegalStateException(\"Invalid mimetype for SocialPost: \" + mimeType);\n+\n+        CborObject.CborMap m = withMimeType.get(1, c -> (CborObject.CborMap)c);\n+\n+        Type type = Type.valueOf(m.getString(\"k\"));\n+        String author = m.getString(\"a\");\n+        List<Content> body = m.getList(\"b\", Content::fromCbor);\n+        LocalDateTime postTime = m.get(\"t\", c -> LocalDateTime.ofEpochSecond(((CborObject.CborLong)c).value, 0, ZoneOffset.UTC));\n+        Resharing shareTo = Resharing.valueOf(m.getString(\"s\"));\n+        Optional<Ref> parent = m.getOptional(\"p\", Ref::fromCbor);\n+        List<SocialPost> previousVersions = m.getList(\"v\", SocialPost::fromCbor);\n+        List<Ref> comments = m.getList(\"d\", Ref::fromCbor);\n+\n+        return new SocialPost(type, author, body, postTime, shareTo, parent, previousVersions, comments);\n+    }\n+\n+    public static class Ref implements Cborable {\n+        public final String path;\n+        public final AbsoluteCapability cap;\n+        public final Multihash contentHash;\n+\n+        @JsConstructor\n+        public Ref(String path, AbsoluteCapability cap, Multihash contentHash) {\n+            this.path = path;\n+            this.cap = cap;\n+            this.contentHash = contentHash;\n+        }\n+\n+        @Override\n+        public CborObject toCbor() {\n+            SortedMap<String, Cborable> state = new TreeMap<>();\n+            state.put(\"p\", new CborObject.CborString(path));\n+            state.put(\"c\", cap);\n+            state.put(\"h\", new CborObject.CborMerkleLink(contentHash));\n+\n+            return CborObject.CborMap.build(state);\n+        }\n+\n+        public static Ref fromCbor(Cborable cbor) {\n+            if (!(cbor instanceof CborObject.CborMap))\n+                throw new IllegalStateException(\"Invalid cbor! \" + cbor);\n+            CborObject.CborMap m = (CborObject.CborMap) cbor;\n+\n+            String path = m.getString(\"p\");\n+            AbsoluteCapability cap = m.get(\"c\", AbsoluteCapability::fromCbor);\n+            Multihash contentHash = m.getMerkleLink(\"h\");\n+            return new Ref(path, cap, contentHash);\n+        }\n+    }\n+\n+    public static class MutableRef implements Cborable {\n+        public final String path;\n+        public final AbsoluteCapability cap;\n+\n+        @JsConstructor\n+        public MutableRef(String path, AbsoluteCapability cap) {\n+            this.path = path;\n+            this.cap = cap;\n+        }\n+\n+        @Override\n+        public CborObject toCbor() {\n+            SortedMap<String, Cborable> state = new TreeMap<>();\n+            state.put(\"p\", new CborObject.CborString(path));\n+            state.put(\"c\", cap);\n+            return CborObject.CborMap.build(state);\n+        }\n+\n+        public static MutableRef fromCbor(Cborable cbor) {\n+            if (!(cbor instanceof CborObject.CborMap))\n+                throw new IllegalStateException(\"Invalid cbor! \" + cbor);\n+            CborObject.CborMap m = (CborObject.CborMap) cbor;\n+\n+            String path = m.getString(\"p\");\n+            AbsoluteCapability cap = m.get(\"c\", AbsoluteCapability::fromCbor);\n+            return new MutableRef(path, cap);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            MutableRef that = (MutableRef) o;\n+            return path.equals(that.path) && cap.equals(that.cap);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(path, cap);\n+        }\n+    }\n+}"
  },
  {
    "sha": "1fff54427401b298e8c3d4e83403b057126a841b",
    "filename": "src/peergos/shared/user/FriendSourcedTrieNode.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/FriendSourcedTrieNode.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/FriendSourcedTrieNode.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/FriendSourcedTrieNode.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -91,7 +91,7 @@ private FileWrapper convert(FileWrapper file, String path) {\n         return file.withTrieNode(new ExternalTrieNode(path, this));\n     }\n \n-    private CompletableFuture<Boolean> updateIncludingGroups(NetworkAccess network) {\n+    public CompletableFuture<Boolean> updateIncludingGroups(NetworkAccess network) {\n         return ensureUptodate(crypto, network)\n                 .thenCompose(x -> {\n                     List<CapabilityWithPath> newGroups = x.getNewCaps().stream()"
  },
  {
    "sha": "ee0e9736926c9d4b0d4a0683508c3722767fe3cc",
    "filename": "src/peergos/shared/user/FriendsGroups.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/FriendsGroups.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/FriendsGroups.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/FriendsGroups.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -16,7 +16,7 @@ public FriendsGroups(Map<String, EntryPoint> pathToGroup) {\n \n     public Set<EntryPoint> getFriends(String friend) {\n         return pathToGroup.entrySet().stream()\n-                .filter(e -> e.getKey().startsWith(friend))\n+                .filter(e -> e.getKey().startsWith(friend) || e.getKey().startsWith(\"/\" + friend))\n                 .map(e -> e.getValue())\n                 .collect(Collectors.toSet());\n     }"
  },
  {
    "sha": "a145d2e93af197d04b995695af01ef1b1f20a3ef",
    "filename": "src/peergos/shared/user/UserContext.java",
    "status": "modified",
    "additions": 10,
    "deletions": 4,
    "changes": 14,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/UserContext.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/UserContext.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/UserContext.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -39,6 +39,7 @@\n     private static final Logger LOG = Logger.getGlobal();\n \n     public static final String SHARED_DIR_NAME = \"shared\";\n+    public static final String POSTS_DIR_NAME = \".posts\";\n     public static final String GROUPS_FILENAME = \".groups.cbor\"; // no clash possible with usernames possible because of dot\n     public static final String FEED_DIR_NAME = \".feed\";\n     public static final String TRANSACTIONS_DIR_NAME = \".transactions\";\n@@ -1672,7 +1673,7 @@ private static void ensureAllowedToShare(FileWrapper file, String ourname, boole\n         return getByPath(\"/\" + username + \"/shared/\" + usernameToGrantAccess)\n                 .thenCompose(shared -> {\n                     if (!shared.isPresent())\n-                        return CompletableFuture.completedFuture(false);\n+                        return Futures.errored(new IllegalStateException(\"Unknown recipient for sharing: \" + usernameToGrantAccess));\n                     FileWrapper sharedDir = shared.get();\n                     return sharingFunction.apply(sharedDir, file);\n                 });\n@@ -1831,7 +1832,10 @@ private static void ensureAllowedToShare(FileWrapper file, String ourname, boole\n     @JsMethod\n     public CompletableFuture<List<Pair<SharedItem, FileWrapper>>> getFiles(List<SharedItem> pointers) {\n         return Futures.combineAllInOrder(pointers.stream()\n-                .map(s -> network.getFile(s.cap, s.owner)\n+                .map(s -> Futures.asyncExceptionally(() -> network.getFile(s.cap, s.owner)\n+                                .thenCompose(fopt -> fopt.map(f -> Futures.of(Optional.of(f)))\n+                                        .orElseGet(() -> getByPath(s.path))),\n+                        t -> getByPath(s.path))\n                         .thenApply(opt -> opt.map(f -> new Pair<>(s, f))))\n                 .collect(Collectors.toList()))\n                 .thenApply(res -> res.stream()\n@@ -2061,8 +2065,10 @@ private static void ensureAllowedToShare(FileWrapper file, String ourname, boole\n     public CompletableFuture<Boolean> unfollow(String friendName) {\n         LOG.info(\"Unfollowing: \" + friendName);\n         return getUserRoot()\n-                .thenCompose(home -> home.appendToChild(BLOCKED_USERNAMES_FILE, (friendName + \"\\n\").getBytes(), true,\n-                        network, crypto, x -> {}))\n+                .thenCompose(home -> home.getChild(BLOCKED_USERNAMES_FILE, crypto.hasher, network)\n+                        .thenCompose(fopt -> home.appendToChild(BLOCKED_USERNAMES_FILE,\n+                                fopt.map(f -> f.getSize()).orElse(0L), (friendName + \"\\n\").getBytes(), true,\n+                                network, crypto, x -> {})))\n                 .thenApply(b -> {\n                     entrie = entrie.removeEntry(\"/\" + friendName + \"/\");\n                     return true;"
  },
  {
    "sha": "165990e557bb63da3301f75970332b540f49ba9a",
    "filename": "src/peergos/shared/user/fs/AsyncReader.java",
    "status": "modified",
    "additions": 5,
    "deletions": 3,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/AsyncReader.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/AsyncReader.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/fs/AsyncReader.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -106,12 +106,14 @@\n                                                                   int objectsToSkip,\n                                                                   int maxObjectsToRead,\n                                                                   long maxBytesToRead) {\n-        if (maxObjectsToRead == 0)\n+        if (maxObjectsToRead == 0 || maxBytesToRead == 0)\n             return CompletableFuture.completedFuture(0L);\n-        byte[] buf = new byte[Chunk.MAX_SIZE];\n+        int toRead = (int) Math.min(Chunk.MAX_SIZE - prefix.length, maxBytesToRead);\n+        byte[] buf = new byte[prefix.length + toRead];\n         System.arraycopy(prefix, 0, buf, 0, prefix.length);\n         ByteArrayInputStream in = new ByteArrayInputStream(buf);\n-        return readIntoArray(buf, prefix.length, (int) Math.min((long)(buf.length - prefix.length), maxBytesToRead))\n+\n+        return readIntoArray(buf, prefix.length, toRead)\n                 .thenCompose(bytesRead -> {\n                     int toSkip = objectsToSkip;\n                     int objectsToRead = maxObjectsToRead;"
  },
  {
    "sha": "c7b2f3617d58050d24ac0386cc997c46bc38b23d",
    "filename": "src/peergos/shared/user/fs/FileProperties.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/FileProperties.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/FileProperties.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/fs/FileProperties.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -113,6 +113,11 @@ public int getNumberOfChunks() {\n         return FileWrapper.getNumberOfChunks(size);\n     }\n \n+    @JsMethod\n+    public boolean isSocialPost() {\n+        return MimeTypes.PEERGOS_POST.equals(mimeType);\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unusable-by-js\")\n     public CborObject toCbor() {"
  },
  {
    "sha": "1e588c607f1794ba5fbf97ce0a5038e386f320e9",
    "filename": "src/peergos/shared/user/fs/FileWrapper.java",
    "status": "modified",
    "additions": 21,
    "deletions": 14,
    "changes": 35,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/FileWrapper.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/FileWrapper.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/fs/FileWrapper.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -9,6 +9,7 @@\n import peergos.shared.crypto.random.*;\n import peergos.shared.crypto.symmetric.*;\n import peergos.shared.inode.*;\n+import peergos.shared.io.ipfs.multihash.*;\n import peergos.shared.storage.*;\n import peergos.shared.user.*;\n import peergos.shared.user.fs.cryptree.*;\n@@ -178,6 +179,12 @@ public boolean isRoot() {\n         });\n     }\n \n+    @JsMethod\n+    public CompletableFuture<Multihash> getContentHash(NetworkAccess network, Crypto crypto) {\n+        return getInputStream(network, crypto, x -> {})\n+                .thenCompose(reader -> crypto.hasher.hash(reader, getSize()));\n+    }\n+\n     public CompletableFuture<Optional<FileWrapper>> getDescendentByPath(String path,\n                                                                         Hasher hasher,\n                                                                         NetworkAccess network) {\n@@ -1038,6 +1045,7 @@ public static int getNumberOfChunks(long size) {\n \n     @JsMethod\n     public CompletableFuture<FileWrapper> appendToChild(String filename,\n+                                                        long expectedSize,\n                                                         byte[] fileData,\n                                                         boolean isHidden,\n                                                         NetworkAccess network,\n@@ -1050,11 +1058,16 @@ public static int getNumberOfChunks(long size) {\n                                 child.get().getLocation().getMapKey(),\n                                 child.get().getFileProperties().size, crypto.hasher))\n                         .orElseGet(() -> Futures.of(crypto.random.randomBytes(32)))\n-                        .thenCompose(x -> uploadFileSection(filename, AsyncReader.build(fileData), isHidden,\n-                                child.map(f -> f.getSize()).orElse(0L),\n-                                fileData.length + child.map(f -> f.getSize()).orElse(0L),\n-                                child.map(f -> f.getPointer().capability.rBaseKey), true, network, crypto,\n-                                monitor, x)));\n+                        .thenCompose(x -> {\n+                            long size = child.map(f -> f.getSize()).orElse(0L);\n+                            if (size != expectedSize)\n+                                throw new IllegalStateException(\"File has been concurrently modified!\");\n+                            return uploadFileSection(filename, AsyncReader.build(fileData), isHidden,\n+                                    size,\n+                                    fileData.length + size,\n+                                    child.map(f -> f.getPointer().capability.rBaseKey), true, network, crypto,\n+                                    monitor, x);\n+                        }));\n     }\n \n     /**\n@@ -1292,15 +1305,9 @@ static boolean isLegalName(String name) {\n                 .thenApply(fa -> true);\n     }\n \n-    /**\n-     *\n-     * @return A capability based on the parent key\n-     */\n-    public AbsoluteCapability getMinimalReadPointer() {\n-        if (isDirectory()) {\n-            return pointer.capability.withBaseKey(getParentKey());\n-        }\n-        return pointer.capability;\n+    @JsMethod\n+    public AbsoluteCapability readOnlyPointer() {\n+        return pointer.capability.readOnly();\n     }\n \n     public WritableAbsoluteCapability writableFilePointer() {"
  },
  {
    "sha": "443955a4861751372b8cebb0344fd7fdaa7f04e5",
    "filename": "src/peergos/shared/user/fs/MimeTypes.java",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/MimeTypes.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/user/fs/MimeTypes.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/user/fs/MimeTypes.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -44,8 +44,12 @@\n     final static int[] WOFF2 = new int[]{'w','O','F','2'};\n \n     // mimetypes for files that are cbor list(mimetype int, map(data)), mimetypes < 24 use a single byte\n+    public static final String PEERGOS_TODO = \"application/vnd.peergos-todo\";\n     public static final int CBOR_PEERGOS_TODO_INT = 10;\n     final static int[] CBOR_PEERGOS_TODO = new int[]{0x82 /* cbor list with 2 elements*/, CBOR_PEERGOS_TODO_INT};\n+    public static final String PEERGOS_POST = \"application/vnd.peergos-post\";\n+    public static final int CBOR_PEERGOS_POST_INT = 17;\n+    final static int[] CBOR_PEERGOS_POST = new int[]{0x82 /* cbor list with 2 elements*/, CBOR_PEERGOS_POST_INT};\n \n     final static int HEADER_BYTES_TO_IDENTIFY_MIME_TYPE = 40;\n \n@@ -144,7 +148,9 @@ public static final String calculateMimeType(byte[] start, String filename) {\n             return \"font/woff2\";\n \n         if (equalArrays(start, CBOR_PEERGOS_TODO))\n-            return \"application/vnd.peergos-todo\";\n+            return PEERGOS_TODO;\n+        if (equalArrays(start, CBOR_PEERGOS_POST))\n+            return PEERGOS_POST;\n \n         if (allAscii(start)) {\n             if (filename.endsWith(\".ics\") && equalArrays(start, ICS))"
  },
  {
    "sha": "ec60d7df23b7a3992b8d9b3c22e53f7d33fb7899",
    "filename": "src/peergos/shared/util/Serialize.java",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/Peergos/Peergos/blob/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/util/Serialize.java",
    "raw_url": "https://github.com/Peergos/Peergos/raw/42d51ce84b3b65450388371d0d9e8607b212c830/src/peergos/shared/util/Serialize.java",
    "contents_url": "https://api.github.com/repos/Peergos/Peergos/contents/src/peergos/shared/util/Serialize.java?ref=42d51ce84b3b65450388371d0d9e8607b212c830",
    "patch": "@@ -112,6 +112,21 @@ public static String deserializeString(DataInput din, int len) throws IOExceptio\n         return in.readIntoArray(res, 0, (int) size).thenApply(i -> res);\n     }\n \n+    @JsMethod\n+    public static <T> T parse(byte[] in, Function<Cborable, T> parser) {\n+        return Cborable.parser(parser).apply(in);\n+    }\n+\n+    public static <T> CompletableFuture<T> parse(FileWrapper f,\n+                                                 Function<Cborable, T> parser,\n+                                                 NetworkAccess network,\n+                                                 Crypto crypto) {\n+        byte[] res = new byte[(int)f.getSize()];\n+        return f.getInputStream(network, crypto, x -> {})\n+                .thenCompose(reader -> reader.readIntoArray(res, 0, (int) f.getSize()))\n+                .thenApply(i -> Cborable.parser(parser).apply(res));\n+    }\n+\n     public static <T> CompletableFuture<T> parse(AsyncReader in, long size, Function<Cborable, T> parser) {\n         byte[] res = new byte[(int)size];\n         return in.readIntoArray(res, 0, (int) size)"
  }
]
