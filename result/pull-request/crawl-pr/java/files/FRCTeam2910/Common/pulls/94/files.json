[
  {
    "sha": "c756f781ae6d46c13ef72e1cdcfe3d221a016692",
    "filename": "robot/src/main/java/org/frcteam2910/common/robot/drivers/Mk3SwerveModule.java",
    "status": "added",
    "additions": 291,
    "deletions": 0,
    "changes": 291,
    "blob_url": "https://github.com/FRCTeam2910/Common/blob/4f1a8cfff7caa406092dfd3f136e462dff1193dd/robot/src/main/java/org/frcteam2910/common/robot/drivers/Mk3SwerveModule.java",
    "raw_url": "https://github.com/FRCTeam2910/Common/raw/4f1a8cfff7caa406092dfd3f136e462dff1193dd/robot/src/main/java/org/frcteam2910/common/robot/drivers/Mk3SwerveModule.java",
    "contents_url": "https://api.github.com/repos/FRCTeam2910/Common/contents/robot/src/main/java/org/frcteam2910/common/robot/drivers/Mk3SwerveModule.java?ref=4f1a8cfff7caa406092dfd3f136e462dff1193dd",
    "patch": "@@ -0,0 +1,291 @@\n+package org.frcteam2910.common.robot.drivers;\n+\n+import com.ctre.phoenix.motorcontrol.StickyFaults;\n+import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;\n+import com.ctre.phoenix.motorcontrol.TalonFXControlMode;\n+import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;\n+import com.ctre.phoenix.motorcontrol.can.TalonFX;\n+import com.ctre.phoenix.sensors.CANCoder;\n+import edu.wpi.first.wpilibj.Notifier;\n+import org.frcteam2910.common.drivers.SwerveModule;\n+import org.frcteam2910.common.math.Vector2;\n+\n+import java.util.Optional;\n+\n+import org.frcteam2910.common.robot.Constants;\n+\n+public class Mk3SwerveModule extends SwerveModule {\n+    private static final double TALONFX_COUNTS_PER_REVOLUTION = 2048;\n+    private static final double CAN_UPDATE_RATE = 50.0;\n+    private static final int TALONFX_PID_LOOP_NUMBER = 0;\n+    private static final double MAX_STEERING_SPEED = 0.5;\n+    private static final double WHEEL_DIAMETER_INCHES = 4.0;\n+\n+    private final double absoluteEncoderAngleOffset;\n+\n+    private TalonFX steeringMotor;\n+    private CANCoder angleEncoder;\n+    private TalonFX driveMotor;\n+\n+    private boolean driveMotorDefaultInvertState;\n+    private double driveCountsPerInch;\n+    private double steerCountsPerDegree;\n+\n+    private final Object canLock = new Object();\n+    private double driveDistance = 0.0;\n+    private double driveVelocity = 0.0;\n+    private double driveCurrent = 0.0;\n+    private double currentWheelAngle = 0.0;\n+    private double moduleAngleToAdd = 0.0;\n+    private Optional<Double> drivePercentOutput = Optional.empty();\n+    private Optional<Double> angleToResetSteeringTo = Optional.empty();\n+    private Optional<Double> steeringTargetPositionDegrees = Optional.empty();\n+\n+    /**\n+     * All CAN operations are done in a separate thread to reduce latency on the control thread\n+     */\n+    private Notifier canUpdateNotifier = new Notifier(() -> {\n+        double unadjustedDriveCounts = driveMotor.getSelectedSensorPosition(); // TODO Verify\n+        synchronized (canLock) {\n+            this.driveDistance = unadjustedDriveCounts * (1.0 / driveCountsPerInch);\n+        }\n+\n+        double driveCountPerHundredMillis = driveMotor.getSelectedSensorVelocity();\n+        synchronized (canLock) {\n+            this.driveVelocity = (driveCountPerHundredMillis * 10) / driveCountsPerInch;\n+        }\n+\n+        double driveCurrent = driveMotor.getStatorCurrent();\n+        synchronized (canLock) {\n+            this.driveCurrent = driveCurrent;\n+        }\n+\n+        Optional<Double> drivePercentOutput;\n+        synchronized (canLock) {\n+            drivePercentOutput = this.drivePercentOutput;\n+        }\n+        if (drivePercentOutput.isPresent()) {\n+            this.driveMotor.set(TalonFXControlMode.Position.PercentOutput, drivePercentOutput.get());\n+        }\n+\n+        StickyFaults faults = new StickyFaults();\n+        steeringMotor.getStickyFaults(faults);\n+        if (faults.UnderVoltage || faults.ResetDuringEn) {\n+            // We clear faults first for two reasons:\n+            // 1. To reset the angle offset as close as possible to getting the new angle\n+            // 2. To allow the faults to be set as soon as possible (eg if we're directly in the\n+            //    middle of a 5ms brownout, we're more likely to trip this again)\n+            steeringMotor.clearStickyFaults(Constants.CAN_TIMEOUT_MS);\n+            resetAngleOffsetWithAbsoluteEncoder();\n+        }\n+\n+        double unadjustedSteeringAngle = this.steeringMotor.getSelectedSensorPosition() / steerCountsPerDegree;\n+\n+        Optional<Double> angleToResetSteeringTo;\n+        double moduleAngleToAdd;\n+        synchronized (canLock) {\n+            angleToResetSteeringTo = this.angleToResetSteeringTo;\n+        }\n+        if (angleToResetSteeringTo.isPresent()) {\n+            // We're resetting the current angle offset\n+            double baseAngle = getClampedAngle(unadjustedSteeringAngle);\n+            moduleAngleToAdd = angleToResetSteeringTo.get() - baseAngle;\n+            synchronized (canLock) {\n+                this.moduleAngleToAdd = moduleAngleToAdd;\n+                this.angleToResetSteeringTo = Optional.empty();\n+            }\n+        } else {\n+            // Just pull the last angle offset, no need to reset every time\n+            synchronized (canLock) {\n+                moduleAngleToAdd = this.moduleAngleToAdd;\n+            }\n+        }\n+\n+        double currentWheelAngle = unadjustedSteeringAngle + moduleAngleToAdd;\n+        synchronized (canLock) {\n+            this.currentWheelAngle = currentWheelAngle;\n+        }\n+\n+        Optional<Double> targetPosition;\n+        synchronized (canLock) {\n+            targetPosition = this.steeringTargetPositionDegrees;\n+            this.steeringTargetPositionDegrees = Optional.empty();\n+        }\n+        if (targetPosition.isPresent()) {\n+            // We first offset the target angle by the amount calculated\n+            // from the absolute encoder so the calculation is relative\n+            // to the angle the module thinks it's at\n+            double targetAngle = targetPosition.get() - moduleAngleToAdd;\n+\n+            // Then calculate the target angle and drive inversion\n+            SteeringConfiguration steeringConfig = calculateConfiguration(unadjustedSteeringAngle, targetAngle);\n+\n+            // And set the values\n+            double targetPosCalculated = steeringConfig.targetAngle * this.steerCountsPerDegree;\n+            this.steeringMotor.set(TalonFXControlMode.Position, targetPosCalculated);\n+            this.driveMotor.setInverted(steeringConfig.invertMotor ^ this.driveMotorDefaultInvertState);\n+        }\n+    });\n+\n+    /**\n+     * @param modulePosition The module's offset from the center of the robot's center of rotation\n+     * @param angleOffset    An angle in radians that is used to offset the angle encoder\n+     * @param angleMotor     The motor that controls the module's angle\n+     * @param driveMotor     The motor that drives the module's wheel\n+     * @param angleEncoder   The analog input for the angle encoder\n+     */\n+    public Mk3SwerveModule(Vector2 modulePosition, double angleOffset, double angleGearRatio, double driveGearRatio,\n+                           TalonFX angleMotor, TalonFX driveMotor, CANCoder angleEncoder) {\n+        super(modulePosition);\n+        this.absoluteEncoderAngleOffset = Math.toDegrees(angleOffset);\n+        this.steeringMotor = angleMotor;\n+        this.angleEncoder = angleEncoder;\n+        this.driveMotor = driveMotor;\n+        this.driveCountsPerInch = (TALONFX_COUNTS_PER_REVOLUTION * driveGearRatio) / (Math.PI * WHEEL_DIAMETER_INCHES);\n+        this.steerCountsPerDegree = (TALONFX_COUNTS_PER_REVOLUTION * angleGearRatio) / 360;\n+        this.driveMotorDefaultInvertState = driveMotor.getInverted();\n+        this.resetAngleOffsetWithAbsoluteEncoder();\n+\n+        SupplyCurrentLimitConfiguration config = new SupplyCurrentLimitConfiguration();\n+        config.currentLimit = 60;\n+        config.enable = true;\n+\n+        driveMotor.configSupplyCurrentLimit(config);\n+\n+        // Wipe configuration\n+        steeringMotor.configFactoryDefault();\n+        steeringMotor.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, TALONFX_PID_LOOP_NUMBER, Constants.CAN_TIMEOUT_MS);\n+        // Make the integrated encoder count forever (don't wrap), since it doesn't work properly with continuous mode\n+        // We account for this manually (unfortunately)\n+        steeringMotor.configFeedbackNotContinuous(true, Constants.CAN_TIMEOUT_MS);\n+        // Configure PID values\n+        steeringMotor.config_kP(TALONFX_PID_LOOP_NUMBER, 0.3, Constants.CAN_TIMEOUT_MS);\n+        steeringMotor.config_kI(TALONFX_PID_LOOP_NUMBER, 0.0, Constants.CAN_TIMEOUT_MS);\n+        steeringMotor.config_kD(TALONFX_PID_LOOP_NUMBER, 0.0, Constants.CAN_TIMEOUT_MS);\n+        // Limit steering module speed\n+        steeringMotor.configPeakOutputForward(MAX_STEERING_SPEED, Constants.CAN_TIMEOUT_MS);\n+        steeringMotor.configPeakOutputReverse(-MAX_STEERING_SPEED, Constants.CAN_TIMEOUT_MS);\n+\n+        canUpdateNotifier.startPeriodic(1.0 / CAN_UPDATE_RATE);\n+    }\n+\n+    public void resetAngleOffsetWithAbsoluteEncoder() {\n+        // Absolute position is reported in degrees\n+        // Not running this on CAN thread since we only poll this when necessary, so\n+        // losing a few ms of main loop to reduce CAN bas usage is worth it\n+        double offsetInDegrees = angleEncoder.getAbsolutePosition() - absoluteEncoderAngleOffset;\n+        if (offsetInDegrees < 0) {\n+            offsetInDegrees += 360;\n+        }\n+        synchronized (canLock) {\n+            this.angleToResetSteeringTo = Optional.of(offsetInDegrees);\n+        }\n+    }\n+\n+    @Override\n+    protected double readAngle() {\n+        double angle;\n+        synchronized (canLock) {\n+            angle = this.currentWheelAngle;\n+        }\n+        angle = Math.toRadians(angle);\n+        angle %= 2.0 * Math.PI;\n+        if (angle < 0.0) {\n+            angle += 2.0 * Math.PI;\n+        }\n+\n+        return angle;\n+    }\n+\n+    @Override\n+    protected double readDistance() {\n+        synchronized (canLock) {\n+            return driveDistance;\n+        }\n+    }\n+\n+    @Override\n+    public double getCurrentVelocity() {\n+        synchronized (canLock) {\n+            return driveVelocity;\n+        }\n+    }\n+\n+    @Override\n+    public double getDriveCurrent() {\n+        synchronized (canLock) {\n+            return this.driveCurrent;\n+        }\n+    }\n+\n+    @Override\n+    protected void setTargetAngle(double angle) {\n+        angle = Math.toDegrees(angle);\n+        synchronized (canLock) {\n+            this.steeringTargetPositionDegrees = Optional.of(angle);\n+        }\n+    }\n+\n+    @Override\n+    protected void setDriveOutput(double output) {\n+        synchronized (canLock) {\n+            this.drivePercentOutput = Optional.of(output);\n+        }\n+    }\n+\n+    private static final class SteeringConfiguration {\n+        public boolean invertMotor;\n+        public double targetAngle;\n+    }\n+\n+    private static double getClampedAngle(double angle) {\n+        angle %= 360;\n+        if (angle < 0) {\n+            angle += 360;\n+        }\n+        return angle;\n+    }\n+\n+    private static SteeringConfiguration calculateConfiguration(double currentAngle, double targetAngle) {\n+        SteeringConfiguration ret = new SteeringConfiguration();\n+\n+        // First, get the current angle in [0, 360)\n+        double currentAngleClamped = getClampedAngle(currentAngle);\n+\n+        // Limit the target angle to [0, 360)\n+        targetAngle %= 360;\n+        if (targetAngle < 0) {\n+            targetAngle += 360;\n+        }\n+\n+        // Get the difference between the two\n+        double delta = currentAngleClamped - targetAngle;\n+        // And move the targetAngle to +/- 180 of the\n+        // current angle\n+        if (delta > 180) {\n+            targetAngle += 360;\n+        } else if (delta < -180) {\n+            targetAngle -= 360;\n+        }\n+\n+        delta = currentAngleClamped - targetAngle;\n+        // Now, if necessary, we flip the direction of the wheel\n+        // This makes the wheel travel no more than 90* to get\n+        // to the target angle\n+        if (delta > 90 || delta < -90) {\n+            if (delta > 90)\n+                targetAngle += 180;\n+            else if (delta < -90)\n+                targetAngle -= 180;\n+            // And invert the drive motor, since the wheel is facing\n+            // the opposite direction that it \"should\"\n+            ret.invertMotor = true;\n+        } else {\n+            ret.invertMotor = false;\n+        }\n+\n+        targetAngle += currentAngle - currentAngleClamped;\n+        ret.targetAngle = targetAngle;\n+        return ret;\n+    }\n+}"
  },
  {
    "sha": "87174e14fa3bd17888cf8383870079ca349abf63",
    "filename": "robot/src/main/java/org/frcteam2910/common/robot/drivers/Pigeon.java",
    "status": "added",
    "additions": 49,
    "deletions": 0,
    "changes": 49,
    "blob_url": "https://github.com/FRCTeam2910/Common/blob/4f1a8cfff7caa406092dfd3f136e462dff1193dd/robot/src/main/java/org/frcteam2910/common/robot/drivers/Pigeon.java",
    "raw_url": "https://github.com/FRCTeam2910/Common/raw/4f1a8cfff7caa406092dfd3f136e462dff1193dd/robot/src/main/java/org/frcteam2910/common/robot/drivers/Pigeon.java",
    "contents_url": "https://api.github.com/repos/FRCTeam2910/Common/contents/robot/src/main/java/org/frcteam2910/common/robot/drivers/Pigeon.java?ref=4f1a8cfff7caa406092dfd3f136e462dff1193dd",
    "patch": "@@ -0,0 +1,49 @@\n+package org.frcteam2910.common.robot.drivers;\n+\n+import com.ctre.phoenix.sensors.PigeonIMU;\n+import org.frcteam2910.common.drivers.Gyroscope;\n+import org.frcteam2910.common.math.Rotation2;\n+\n+public class Pigeon extends Gyroscope {\n+    private final PigeonIMU pigeon;\n+\n+    public Pigeon(int canId) {\n+        pigeon = new PigeonIMU(canId);\n+    }\n+\n+    @Override\n+    public void calibrate() {\n+        pigeon.setFusedHeading(0);\n+    }\n+\n+    @Override\n+    public Rotation2 getUnadjustedAngle() {\n+        return Rotation2.fromRadians(getAxis(Axis.YAW));\n+    }\n+\n+    @Override\n+    public double getUnadjustedRate() {\n+        return 0; // TODO\n+    }\n+\n+    public double getAxis(Axis axis) {\n+        double[] ypr = new double[3];\n+        pigeon.getYawPitchRoll(ypr);\n+        switch (axis) {\n+            case PITCH:\n+                return Math.toRadians(ypr[1]);\n+            case ROLL:\n+                return Math.toRadians(ypr[2]);\n+            case YAW:\n+                return Math.toRadians(ypr[0]);\n+            default:\n+                return 0.0;\n+        }\n+    }\n+\n+    public enum Axis {\n+        PITCH,\n+        ROLL,\n+        YAW\n+    }\n+}"
  }
]
