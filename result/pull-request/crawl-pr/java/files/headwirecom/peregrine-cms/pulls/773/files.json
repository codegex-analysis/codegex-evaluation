[
  {
    "sha": "6a2edb7db2cbed73a38859fd1f72bfa496a8926f",
    "filename": "admin-base/core/pom.xml",
    "status": "modified",
    "additions": 24,
    "deletions": 6,
    "changes": 30,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/pom.xml",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/pom.xml",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/pom.xml?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -170,12 +170,6 @@\n             <artifactId>commons-io</artifactId>\n         </dependency>\n \n-        <dependency>\n-            <groupId>junit</groupId>\n-            <artifactId>junit</artifactId>\n-            <scope>provided</scope>\n-        </dependency>\n-\n         <dependency>\n             <groupId>javax.inject</groupId>\n             <artifactId>javax.inject</artifactId>\n@@ -227,6 +221,30 @@\n             <groupId>org.apache.sling</groupId>\n             <artifactId>org.apache.sling.event</artifactId>\n         </dependency>\n+\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.mockito</groupId>\n+            <artifactId>mockito-all</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.slf4j</groupId>\n+            <artifactId>slf4j-simple</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>junit-addons</groupId>\n+            <artifactId>junit-addons</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>${project.groupId}</groupId>\n+            <artifactId>commons</artifactId>\n+            <version>${project.version}</version>\n+            <type>test-jar</type>\n+            <scope>test</scope>\n+        </dependency>\n     </dependencies>\n \n     <profiles>"
  },
  {
    "sha": "1c2770cc2e501b1e0d6fae814191640c5c98194f",
    "filename": "admin-base/core/src/main/java/com/peregrine/admin/servlets/NodesServlet.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/NodesServlet.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/NodesServlet.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/main/java/com/peregrine/admin/servlets/NodesServlet.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -55,6 +55,7 @@\n import static com.peregrine.commons.util.PerUtil.PER_VENDOR;\n import static com.peregrine.commons.util.PerUtil.getProperties;\n import static com.peregrine.commons.util.PerUtil.isPrimaryType;\n+import static java.util.Objects.nonNull;\n import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_METHODS;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_RESOURCE_TYPES;\n@@ -273,9 +274,11 @@ private void writeProperties(Resource resource, JsonResponse json) throws IOExce\n         }\n         // TODO refactor code above to use PerReplicable when writing replication properties\n         PerReplicable sourceRepl = resource.adaptTo(PerReplicable.class);\n-        json.writeAttribute(ACTIVATED, sourceRepl.isReplicated());\n-        if (sourceRepl.getLastModified()!=null && sourceRepl.getReplicated()!= null) {\n-            json.writeAttribute(IS_STALE, sourceRepl.isStale());\n+        if (nonNull(sourceRepl)) {\n+            json.writeAttribute(ACTIVATED, sourceRepl.isReplicated());\n+            if (sourceRepl.getLastModified() != null && sourceRepl.getReplicated() != null) {\n+                json.writeAttribute(IS_STALE, sourceRepl.isStale());\n+            }\n         }\n     }\n "
  },
  {
    "sha": "cde6a5ab8c8b7e415574aa794b8e33728c918722",
    "filename": "admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServlet.java",
    "status": "modified",
    "additions": 42,
    "deletions": 58,
    "changes": 100,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServlet.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServlet.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServlet.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -25,14 +25,14 @@\n  * #L%\n  */\n \n-import com.peregrine.replication.PerReplicable;\n import com.peregrine.admin.resource.AdminResourceHandler;\n import com.peregrine.commons.util.PerConstants;\n import com.peregrine.replication.Replication;\n import com.peregrine.replication.Replication.ReplicationException;\n import com.peregrine.replication.ReplicationsContainerWithDefault;\n import org.apache.sling.api.resource.Resource;\n import org.apache.sling.api.resource.ResourceResolver;\n+import org.jetbrains.annotations.NotNull;\n import org.osgi.service.component.annotations.Component;\n import org.osgi.service.component.annotations.Reference;\n \n@@ -43,15 +43,12 @@\n import java.util.stream.Stream;\n \n import static com.peregrine.admin.servlets.AdminPaths.RESOURCE_TYPE_DO_REPLICATION;\n-import static com.peregrine.commons.util.PerConstants.NAME;\n import static com.peregrine.commons.util.PerUtil.EQUALS;\n import static com.peregrine.commons.util.PerUtil.PER_PREFIX;\n import static com.peregrine.commons.util.PerUtil.PER_VENDOR;\n import static com.peregrine.commons.util.PerUtil.POST;\n import static com.peregrine.commons.util.PerUtil.listMissingResources;\n import static java.lang.Boolean.parseBoolean;\n-import static java.util.Objects.isNull;\n-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_METHODS;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_RESOURCE_TYPES;\n import static org.osgi.framework.Constants.SERVICE_DESCRIPTION;\n@@ -80,79 +77,66 @@\n public final class ReplicationServlet extends ReplicationServletBase {\n \n     public static final String DEACTIVATE = \"deactivate\";\n-    public static final String REPLICATION_NOT_FOUND_FOR_NAME = \"Replication not found for name: \";\n-    public static final String REPLICATION_FAILED = \"Replication Failed\";\n-    public static final String REPLICATES = \"replicates\";\n     public static final String RESOURCES = \"resources\";\n-    public static final String SUFFIX_IS_NOT_RESOURCE = \"Suffix: '%s' is not a resource\";\n \n     @Reference\n     private ReplicationsContainerWithDefault replications;\n \n     @Reference\n     private AdminResourceHandler resourceManagement;\n \n+    protected ReplicationsContainerWithDefault getReplications() {\n+        return replications;\n+    }\n+\n     @Override\n     protected Response performReplication(\n+            final Replication replication,\n             final Request request,\n             final Resource resource,\n             final ResourceResolver resourceResolver\n-    ) throws IOException {\n-        final String replicationName = request.getParameter(NAME);\n-        final Replication replication = replications.getOrDefault(replicationName);\n-        if (isNull(replication)) {\n-            return new ErrorResponse()\n-                    .setHttpErrorCode(SC_BAD_REQUEST)\n-                    .setErrorMessage(REPLICATION_NOT_FOUND_FOR_NAME + replicationName);\n+    ) throws IOException, ReplicationException {\n+        if (parseBoolean(request.getParameter(DEACTIVATE))) {\n+            return performDeactivation(replication, resource);\n         }\n \n-        final PerReplicable replicable = resource.adaptTo(PerReplicable.class);\n-        if (isNull(replicable)) {\n-            return prepareResponse(resource, Collections.emptyList());\n+        final boolean deep = parseBoolean(request.getParameter(\"deep\"));\n+        List<Resource> toBeReplicated = listMissingResources(resource, deep, new LinkedList<>());\n+        for (final Resource r : Optional.of(RESOURCES)\n+                .map(request::getParameterValues)\n+                .map(Arrays::stream)\n+                .orElseGet(Stream::empty)\n+                .map(resourceResolver::getResource)\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList())) {\n+            listMissingResources(r, deep, toBeReplicated);\n         }\n \n-        replicable.ensureReplicableMixin();\n-        try {\n-            if (parseBoolean(request.getParameter(DEACTIVATE))) {\n-                replicable.setLastReplicationActionAsDeactivated();\n-                final var replicatedStuff = replication.deactivate(resource);\n-                for (final Resource r : streamReplicableResources(replicatedStuff)\n-                        .collect(Collectors.toList())) {\n-                    resourceManagement.deleteVersionLabel(r, PerConstants.PUBLISHED_LABEL);\n-                }\n-\n-                return prepareResponse(resource, replicatedStuff);\n-            }\n-\n-            replicable.setLastReplicationActionAsActivated();\n-            final boolean deep = parseBoolean(request.getParameter(\"deep\"));\n-            List<Resource> toBeReplicated = listMissingResources(resource, deep);\n-            for (final Resource r : Optional.of(RESOURCES)\n-                    .map(request::getParameterValues)\n-                    .map(Arrays::stream)\n-                    .orElseGet(Stream::empty)\n-                    .map(resourceResolver::getResource)\n-                    .filter(Objects::nonNull)\n-                    .collect(Collectors.toList())){\n-                listMissingResources(r, deep, toBeReplicated);\n-            }\n-\n-            toBeReplicated = replication.prepare(toBeReplicated);\n-            // Replication can be local or remote and so the commit of the changes is done inside the Replication Service\n-            streamReplicableResources(toBeReplicated)\n-                    .map(Resource::getPath)\n-                    .forEach(p -> {\n-                        try {\n-                            resourceManagement.createVersion(resourceResolver, p, PerConstants.PUBLISHED_LABEL);\n-                        } catch (final AdminResourceHandler.ManagementException e) {\n-                            logger.trace(\"Unable to create a version for path: {} \", p, e);\n-                        }\n-                    });\n+        toBeReplicated = replication.prepare(toBeReplicated);\n+        streamReplicableResources(toBeReplicated)\n+                .map(Resource::getPath)\n+                .forEach(p -> {\n+                    try {\n+                        resourceManagement.createVersion(resourceResolver, p, PerConstants.PUBLISHED_LABEL);\n+                    } catch (final AdminResourceHandler.ManagementException e) {\n+                        logger.trace(\"Unable to create a version for path: {} \", p, e);\n+                    }\n+                });\n+        return prepareResponse(resource, replication.replicate(toBeReplicated));\n+    }\n \n-            return prepareResponse(resource, replication.replicate(toBeReplicated));\n-        } catch (final ReplicationException e) {\n-            return badRequestReplicationFailed(e);\n+    @NotNull\n+    private Response performDeactivation(\n+            final Replication replication,\n+            final Resource resource\n+    ) throws ReplicationException, IOException {\n+        final var replicatedStuff = replication.deactivate(resource);\n+        for (final Resource r : streamReplicableResources(replicatedStuff)\n+                .collect(Collectors.toList())) {\n+            resourceManagement.deleteVersionLabel(r, PerConstants.PUBLISHED_LABEL);\n         }\n+\n+        return prepareResponse(resource, replicatedStuff);\n     }\n \n }\n\\ No newline at end of file"
  },
  {
    "sha": "862997a62e67b77a1cd291bc1e13d3c4ea4d285e",
    "filename": "admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServletBase.java",
    "status": "modified",
    "additions": 30,
    "deletions": 10,
    "changes": 40,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServletBase.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServletBase.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/main/java/com/peregrine/admin/servlets/ReplicationServletBase.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -27,6 +27,9 @@\n \n import com.peregrine.replication.PerReplicable;\n import com.peregrine.commons.servlets.AbstractBaseServlet;\n+import com.peregrine.replication.Replication;\n+import com.peregrine.replication.Replication.ReplicationException;\n+import com.peregrine.replication.ReplicationsContainerWithDefault;\n import org.apache.sling.api.resource.Resource;\n import org.apache.sling.api.resource.ResourceResolver;\n \n@@ -36,17 +39,16 @@\n import java.util.Objects;\n import java.util.stream.Stream;\n \n-import static com.peregrine.admin.servlets.ReplicationServlet.REPLICATION_FAILED;\n import static com.peregrine.commons.util.PerConstants.NAME;\n import static com.peregrine.commons.util.PerConstants.PATH;\n-import static com.peregrine.commons.util.PerUtil.AddAllResourceChecker;\n import static java.util.Objects.isNull;\n import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n \n public abstract class ReplicationServletBase extends AbstractBaseServlet {\n \n+    public static final String REPLICATION_NOT_FOUND_FOR_NAME = \"Replication not found for name: \";\n+    public static final String REPLICATION_FAILED = \"Replication Failed\";\n     public static final String REPLICATES = \"replicates\";\n-    public static final AddAllResourceChecker ADD_ALL_RESOURCE_CHECKER = new AddAllResourceChecker();\n \n     @Override\n     protected final Response handleRequest(final Request request) throws IOException {\n@@ -57,34 +59,52 @@ protected final Response handleRequest(final Request request) throws IOException\n \n         final String sourcePath = request.getParameter(PATH);\n         final ResourceResolver resourceResolver = request.getResourceResolver();\n-        final Resource source = resourceResolver.getResource(sourcePath);\n-        if (isNull(source)) {\n+        final Resource resource = resourceResolver.getResource(sourcePath);\n+        if (isNull(resource)) {\n             return new ErrorResponse()\n                     .setHttpErrorCode(SC_BAD_REQUEST)\n                     .setErrorMessage(String.format(\"Suffix: '%s' is not a resource\", sourcePath));\n         }\n \n-        return performReplication(request, source, resourceResolver);\n+        final String replicationName = request.getParameter(NAME);\n+        final Replication replication = getReplications().getOrDefault(replicationName);\n+        if (isNull(replication)) {\n+            return new ErrorResponse()\n+                    .setHttpErrorCode(SC_BAD_REQUEST)\n+                    .setErrorMessage(REPLICATION_NOT_FOUND_FOR_NAME + replicationName);\n+        }\n+\n+        try {\n+            return performReplication(replication, request, resource, resourceResolver);\n+        } catch (final ReplicationException e) {\n+            return badRequestReplicationFailed(e);\n+        }\n     }\n \n+    protected abstract ReplicationsContainerWithDefault getReplications();\n+\n     protected abstract Response performReplication(\n+            Replication replication,\n             Request request,\n             Resource resource,\n             ResourceResolver resourceResolver\n-    ) throws IOException;\n+    ) throws IOException, ReplicationException;\n \n     protected static ErrorResponse badRequestReplicationFailed(final Exception e) throws IOException {\n+        return badRequest(REPLICATION_FAILED).setException(e);\n+    }\n+\n+    protected static ErrorResponse badRequest(final String message) throws IOException {\n         return new ErrorResponse()\n                 .setHttpErrorCode(SC_BAD_REQUEST)\n-                .setErrorMessage(REPLICATION_FAILED)\n-                .setException(e);\n+                .setErrorMessage(message);\n     }\n \n     protected static Stream<Resource> streamReplicableResources(final Collection<Resource> resources) {\n         return resources.stream()\n                 .map(r -> r.adaptTo(PerReplicable.class))\n                 .filter(Objects::nonNull)\n-                .map(PerReplicable::getContentResource)\n+                .map(PerReplicable::getMainResource)\n                 .filter(Objects::nonNull);\n     }\n "
  },
  {
    "sha": "1b8fc8f1e68be62ff6c9181b418c0b4695f4adae",
    "filename": "admin-base/core/src/main/java/com/peregrine/admin/servlets/TenantSetupReplicationServlet.java",
    "status": "modified",
    "additions": 18,
    "deletions": 27,
    "changes": 45,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/TenantSetupReplicationServlet.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/main/java/com/peregrine/admin/servlets/TenantSetupReplicationServlet.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/main/java/com/peregrine/admin/servlets/TenantSetupReplicationServlet.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -25,11 +25,11 @@\n  * #L%\n  */\n \n-import com.peregrine.replication.DefaultReplicationMapper;\n import com.peregrine.admin.resource.AdminResourceHandler;\n import com.peregrine.commons.util.PerConstants;\n-import com.peregrine.replication.PerReplicable;\n+import com.peregrine.replication.Replication;\n import com.peregrine.replication.Replication.ReplicationException;\n+import com.peregrine.replication.ReplicationsContainerWithDefault;\n import com.peregrine.sitemap.SiteMapFilesCache;\n import org.apache.sling.api.resource.Resource;\n import org.apache.sling.api.resource.ResourceResolver;\n@@ -46,16 +46,12 @@\n \n import static com.peregrine.admin.servlets.AdminPaths.RESOURCE_TYPE_TENANT_SETUP_REPLICATION;\n \n-import static com.peregrine.commons.util.PerConstants.FELIBS_ROOT;\n-import static com.peregrine.commons.util.PerConstants.PAGES;\n-import static com.peregrine.commons.util.PerConstants.SITE_PRIMARY_TYPE;\n-import static com.peregrine.commons.util.PerConstants.SLASH;\n+import static com.peregrine.commons.util.PerConstants.*;\n import static com.peregrine.commons.util.PerUtil.EQUALS;\n import static com.peregrine.commons.util.PerUtil.PER_PREFIX;\n import static com.peregrine.commons.util.PerUtil.PER_VENDOR;\n import static com.peregrine.commons.util.PerUtil.POST;\n import static java.util.Objects.nonNull;\n-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_METHODS;\n import static org.apache.sling.api.servlets.ServletResolverConstants.SLING_SERVLET_RESOURCE_TYPES;\n import static org.osgi.framework.Constants.SERVICE_DESCRIPTION;\n@@ -90,49 +86,47 @@\n     private final SimpleDateFormat dateLabelFormat = new SimpleDateFormat(\"yyyy-MM-dd@HH.mm.ss\");\n \n     @Reference\n-    private DefaultReplicationMapper defaultReplicationMapper;\n+    private ReplicationsContainerWithDefault replications;\n \n     @Reference\n     private AdminResourceHandler resourceManagement;\n \n     @Reference\n     private SiteMapFilesCache siteMapFilesCache;\n \n+    protected ReplicationsContainerWithDefault getReplications() {\n+        return replications;\n+    }\n+\n     @Override\n     protected Response performReplication(\n+            final Replication replication,\n             final Request request,\n             final Resource site,\n             final ResourceResolver resourceResolver\n-    ) throws IOException {\n+    ) throws IOException, ReplicationException {\n         final String path = site.getPath();\n         // Make sure that the Resource is a Site\n         if (!SITE_PRIMARY_TYPE.equals(site.getResourceType())) {\n-            return new ErrorResponse()\n-                    .setHttpErrorCode(SC_BAD_REQUEST)\n-                    .setErrorMessage(String.format(\"Suffix: '%s' is not a Peregrine Site\", path));\n+            return badRequest(String.format(\"Suffix: '%s' is not a Peregrine Site\", path));\n         }\n \n         final var toBeReplicatedInitial = extractSiteFeLibs(site, resourceResolver.getResource(FELIBS_ROOT));\n         toBeReplicatedInitial.add(0, site);\n         logger.trace(\"List of Resource to be replicated: '{}'\", toBeReplicatedInitial);\n-        final var toBeReplicated = new LinkedList<>(toBeReplicatedInitial);\n+        List<Resource> toBeReplicated = new LinkedList<>(toBeReplicatedInitial);\n         for (final Resource resource : toBeReplicatedInitial) {\n             try {\n                 logger.trace(\"Replication Resource: '{}'\", resource);\n-                var references = defaultReplicationMapper.findReferences(resource, true);\n-                references = defaultReplicationMapper.prepare(references);\n-                toBeReplicated.addAll(references);\n+                toBeReplicated.addAll(replication.findReferences(resource, true));\n             } catch (final ReplicationException e) {\n                 logger.warn(\"Replication Failed\", e);\n                 return badRequestReplicationFailed(e);\n             }\n         }\n \n         final String dateLabel = site.getName() + \"_\" + dateLabelFormat.format(new Date(System.currentTimeMillis()));\n-        streamReplicableResources(toBeReplicated)\n-                .map(r -> r.adaptTo(PerReplicable.class))\n-                .filter(Objects::nonNull)\n-                .forEach(PerReplicable::ensureReplicableMixin);\n+        toBeReplicated = replication.prepare(toBeReplicated);\n         streamReplicableResources(toBeReplicated)\n                 .map(Resource::getPath)\n                 .forEach(p -> {\n@@ -142,13 +136,9 @@ protected Response performReplication(\n                         logger.trace(\"Unable to create a version for path: {} \", p, e);\n                     }\n                 });\n-        try {\n-            var replicatedStuff = defaultReplicationMapper.replicate(toBeReplicated);\n-            siteMapFilesCache.build(path + SLASH + PAGES);\n-            return prepareResponse(site, replicatedStuff);\n-        } catch (final ReplicationException e) {\n-            return badRequestReplicationFailed(e);\n-        }\n+        final var replicatedStuff = replication.replicate(toBeReplicated);\n+        siteMapFilesCache.build(path + SLASH + PAGES);\n+        return prepareResponse(site, replicatedStuff);\n     }\n \n     /**\n@@ -182,4 +172,5 @@ protected Response performReplication(\n \n         return result;\n     }\n+\n }"
  },
  {
    "sha": "ee5f91eca4cc14c87b12091abdfad2bd5847f4f1",
    "filename": "admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTest.java",
    "status": "added",
    "additions": 27,
    "deletions": 0,
    "changes": 27,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,27 @@\n+package com.peregrine.admin.servlets;\n+\n+import com.peregrine.replication.Replication;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static com.peregrine.admin.servlets.ReplicationServlet.DEACTIVATE;\n+\n+public final class ReplicationServletTest extends ReplicationServletTestBase {\n+\n+    public ReplicationServletTest() throws NoSuchFieldException, Replication.ReplicationException {\n+        super(new ReplicationServlet());\n+    }\n+\n+    @Test\n+    public void performDeactivation() throws IOException {\n+        request.putParameter(DEACTIVATE, true);\n+        performReplicationResponseContains(jcrContent);\n+    }\n+\n+    @Test\n+    public void performActivation() throws IOException {\n+        performReplicationResponseContains(jcrContent);\n+    }\n+\n+}"
  },
  {
    "sha": "3fd72089f1c2ef5ae94993688ee69e416174062d",
    "filename": "admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTestBase.java",
    "status": "added",
    "additions": 80,
    "deletions": 0,
    "changes": 80,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTestBase.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTestBase.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/test/java/com/peregrine/admin/servlets/ReplicationServletTestBase.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,80 @@\n+package com.peregrine.admin.servlets;\n+\n+import com.peregrine.SlingServletTest;\n+import com.peregrine.admin.resource.AdminResourceHandler;\n+import com.peregrine.commons.servlets.AbstractBaseServlet;\n+import com.peregrine.mock.PageMock;\n+import com.peregrine.replication.PerReplicable;\n+import com.peregrine.replication.Replication;\n+import com.peregrine.replication.ReplicationsContainerWithDefault;\n+import junitx.util.PrivateAccessor;\n+import org.apache.sling.api.resource.Resource;\n+import org.junit.Assert;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static com.peregrine.commons.util.PerConstants.PATH;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class ReplicationServletTestBase extends SlingServletTest {\n+\n+    private final ReplicationServletBase servlet;\n+\n+    private final AdminResourceHandler resourceManagement = mock(AdminResourceHandler.class);\n+    private final ReplicationsContainerWithDefault replications = mock(ReplicationsContainerWithDefault.class);\n+\n+    private final Replication replication = mock(Replication.class);\n+    private final PerReplicable replicable = mock(PerReplicable.class);\n+\n+    public ReplicationServletTestBase(final ReplicationServletBase servlet)\n+            throws NoSuchFieldException, Replication.ReplicationException\n+    {\n+        this.servlet = servlet;\n+        setField(\"replications\", replications);\n+        setField(\"resourceManagement\", resourceManagement);\n+\n+        when(replications.getOrDefault(anyString())).thenReturn(replication);\n+\n+        when(replication.prepare(any())).thenAnswer(i -> i.getArguments()[0]);\n+        when(replication.replicate(any())).thenAnswer(i -> i.getArguments()[0]);\n+        when(replication.deactivate(any(PageMock.class))).thenAnswer(\n+                i -> Collections.singletonList(\n+                        ((PageMock)i.getArguments()[0]).getContent()\n+                )\n+        );\n+\n+        page.addAdapter(replicable);\n+        jcrContent.addAdapter(replicable);\n+        when(replicable.getMainResource()).thenReturn(jcrContent);\n+    }\n+\n+    protected void setField(final String name, final Object value) throws NoSuchFieldException {\n+        PrivateAccessor.setField(servlet, name, value);\n+    }\n+\n+    protected void performReplicationResponseContains(final PageMock page, final String... substrings) throws IOException {\n+        request.putParameter(PATH, page.getPath());\n+        final AbstractBaseServlet.Request request = new AbstractBaseServlet.Request(this.request, response);\n+        final String response = servlet.handleRequest(request).getContent();\n+        Arrays.stream(substrings)\n+                .map(response::contains)\n+                .forEach(Assert::assertTrue);\n+    }\n+\n+    protected void performReplicationResponseContains(final String... substrings) throws IOException {\n+        performReplicationResponseContains(page, substrings);\n+    }\n+\n+    protected void performReplicationResponseContains(final Resource... resources) throws IOException {\n+        performReplicationResponseContains(Arrays.stream(resources)\n+                .map(Resource::getPath)\n+                .toArray(String[]::new)\n+        );\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "bcae89ceb3f8b9454fd7a1b5a8a5ad1f8604f5de",
    "filename": "admin-base/core/src/test/java/com/peregrine/admin/servlets/TenantSetupReplicationServletTest.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/TenantSetupReplicationServletTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/admin-base/core/src/test/java/com/peregrine/admin/servlets/TenantSetupReplicationServletTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/admin-base/core/src/test/java/com/peregrine/admin/servlets/TenantSetupReplicationServletTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,32 @@\n+package com.peregrine.admin.servlets;\n+\n+import com.peregrine.mock.SiteMock;\n+import com.peregrine.replication.Replication;\n+import com.peregrine.sitemap.SiteMapFilesCache;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.Mockito.mock;\n+\n+public class TenantSetupReplicationServletTest extends ReplicationServletTestBase {\n+\n+    private final SiteMapFilesCache siteMapFilesCache = mock(SiteMapFilesCache.class);\n+    private final SiteMock site = new SiteMock(repo, \"site\");\n+\n+    public TenantSetupReplicationServletTest() throws NoSuchFieldException, Replication.ReplicationException {\n+        super(new TenantSetupReplicationServlet());\n+        setField(\"siteMapFilesCache\", siteMapFilesCache);\n+    }\n+\n+    @Test\n+    public void notSite() throws IOException {\n+        performReplicationResponseContains(\"message\");\n+    }\n+\n+    @Test\n+    public void site() throws IOException {\n+        performReplicationResponseContains(site,site.getPath());\n+    }\n+\n+}"
  },
  {
    "sha": "7fad6a50934cc77341e773f728c9d85defc6cb64",
    "filename": "platform/base/core/src/main/java/com/peregrine/adaption/impl/PeregrineAdapterFactory.java",
    "status": "modified",
    "additions": 4,
    "deletions": 0,
    "changes": 4,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/adaption/impl/PeregrineAdapterFactory.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/adaption/impl/PeregrineAdapterFactory.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/adaption/impl/PeregrineAdapterFactory.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -131,6 +131,10 @@\n         }\n \n         if(PerReplicable.class.equals(type)) {\n+            if (StringUtils.startsWith(primaryType, \"rep:\")) {\n+                return null;\n+            }\n+\n             return (AdapterType) new PerReplicableImpl(resource);\n         }\n "
  },
  {
    "sha": "f7e5d29762f3a1dd39094b3668736ba479ac1380",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/PerReplicable.java",
    "status": "modified",
    "additions": 3,
    "deletions": 12,
    "changes": 15,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/PerReplicable.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/PerReplicable.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/PerReplicable.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -1,6 +1,7 @@\n package com.peregrine.replication;\n \n import com.peregrine.adaption.PerBase;\n+import org.apache.sling.api.resource.Resource;\n \n import java.util.Calendar;\n \n@@ -16,6 +17,8 @@\n  */\n public interface PerReplicable extends PerBase {\n \n+    Resource getMainResource();\n+\n     /**\n      * @return true if the resource has been replicated\n      */\n@@ -40,16 +43,4 @@\n      * @return A string property describing the last replication action (either activated, deactivated, null)\n      */\n     String getLastReplicationAction();\n-\n-    boolean ensureReplicableMixin();\n-\n-    /**\n-     * Call this method to mark the value of per:ReplicationLastAction as \"activated\"\n-     */\n-    void setLastReplicationActionAsActivated();\n-\n-    /**\n-     * Call this method to mark the value of per:ReplicationLastAction as \"deactivated\"\n-     */\n-    void setLastReplicationActionAsDeactivated();\n }"
  },
  {
    "sha": "5253cf43152bbe0b99f9a0dff27ea68695928546",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/ReplicationUtil.java",
    "status": "modified",
    "additions": 86,
    "deletions": 86,
    "changes": 172,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/ReplicationUtil.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/ReplicationUtil.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/ReplicationUtil.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -12,21 +12,14 @@\n import javax.jcr.nodetype.NodeTypeManager;\n import javax.jcr.query.Query;\n \n-import java.util.ArrayList;\n-import java.util.Calendar;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import static com.peregrine.replication.impl.DistributionReplicationService.DISTRIBUTION_PENDING;\n-import static com.peregrine.commons.util.PerConstants.JCR_CONTENT;\n-import static com.peregrine.commons.util.PerConstants.PER_REPLICATED;\n-import static com.peregrine.commons.util.PerConstants.PER_REPLICATED_BY;\n-import static com.peregrine.commons.util.PerConstants.PER_REPLICATION;\n-import static com.peregrine.commons.util.PerConstants.PER_REPLICATION_REF;\n-import static com.peregrine.commons.util.PerUtil.getModifiableProperties;\n-import static com.peregrine.commons.util.PerUtil.isEmpty;\n-import static com.peregrine.commons.util.PerUtil.isJcrContent;\n+import java.util.*;\n+\n+import static com.peregrine.commons.util.PerConstants.*;\n+import static com.peregrine.commons.util.PerUtil.*;\n+import static java.util.Objects.isNull;\n+import static java.util.Objects.nonNull;\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n \n public class ReplicationUtil {\n \n@@ -88,6 +81,7 @@ public static boolean supportsReplicationProperties(Resource resource) {\n                 // Failed to obtain Replication Node Type -> handle them manually\n             }\n         }\n+\n         return answer;\n     }\n \n@@ -100,72 +94,76 @@ public static boolean supportsReplicationProperties(Resource resource) {\n      * @param target Target Resource to be updated with same date and reference back to the source in the replication ref. If null will be ignored\n      */\n     public static void updateReplicationProperties(Resource source, String targetPath, Resource target) {\n-        if(source != null) {\n-            boolean replicationMixin = ReplicationUtil.supportsReplicationProperties(source);\n-            LOGGER.trace(\"Is Replication Mixin: : {}, Source: '{}'\", replicationMixin, source.getPath());\n-            if (replicationMixin) {\n-                ensureMixin(source);\n-                ModifiableValueMap sourceProperties = getModifiableProperties(source, false);\n-                if (sourceProperties != null) {\n-                    Calendar replicated = Calendar.getInstance();\n-                    final ResourceResolver resourceResolver = source.getResourceResolver();\n-                    if (DISTRIBUTION_PENDING.equals(targetPath)) {\n-                        // Note for remote replication use-case\n-                        // updateReplicationProperties will be called twice. The first time will include a resource\n-                        //   obtained from the user initiating resource publishing. In this case targetPath will be \"distribution pending\"\n-                        // TODO: CR add replication status to the per:Replication mixin such that these inferences are not needed.\n-                        sourceProperties.put(PER_REPLICATED_BY, resourceResolver.getUserID());\n-                    }\n-                    sourceProperties.put(PER_REPLICATED, replicated);\n-                    LOGGER.trace(\"Updated Source Replication Properties\");\n-                    if (target == null) {\n-                        if (isEmpty(targetPath)) {\n-                            // If Target Path is empty remove the replication ref property\n-                            sourceProperties.remove(PER_REPLICATION_REF);\n-                        } else {\n-                            sourceProperties.put(PER_REPLICATION_REF, targetPath);\n-                        }\n-                    } else {\n-                        ensureMixin(target);\n-                        try {\n-                            ModifiableValueMap targetProperties = getModifiableProperties(target, false);\n-                            String userId = resourceResolver.getUserID();\n-                            LOGGER.trace(\"Replication User Id: '{}' for target: '{}'\", userId, target.getPath());\n-                            // TODO: Refactor duplicated code\n-                            if (DISTRIBUTION_PENDING.equals(targetPath)) {\n-                                targetProperties.put(PER_REPLICATED_BY, userId);\n-                            }\n-                            targetProperties.put(PER_REPLICATED, replicated);\n-                            if (JCR_CONTENT.equals(source.getName())) {\n-                                // For jcr:content nodes set the replication ref to its parent\n-                                sourceProperties.put(PER_REPLICATION_REF, target.getParent().getPath());\n-                                targetProperties.put(PER_REPLICATION_REF, source.getParent().getPath());\n-                            } else {\n-                                sourceProperties.put(PER_REPLICATION_REF, target.getPath());\n-                                targetProperties.put(PER_REPLICATION_REF, source.getPath());\n-                            }\n-                            LOGGER.trace(\"Updated Target: '{}' Replication Properties\", target.getPath());\n-                        } catch (IllegalArgumentException e) {\n-                            LOGGER.error(\"Failed to add replication properties\", e);\n-                            throw e;\n-                        }\n-                    }\n-\n-                    refreshAndCommit(resourceResolver);\n-                } else {\n-                    LOGGER.debug(\"Source: '{}' is not writable -> ignored\", source);\n-                }\n+        if (isNull(source)) {\n+            return;\n+        }\n+\n+        if (nonNull(target)) {\n+            markAsActivated(source, target);\n+        } else if (isNotBlank(targetPath)) {\n+            markAsActivated(source, targetPath);\n+        } else {\n+            markAsDeactivated(source);\n+        }\n+    }\n+\n+    public static void markAsActivated(final Resource source, final String targetPath) {\n+        if (isNotEmpty(targetPath)) {\n+            addReplicationProps(source, targetPath);\n+        }\n+    }\n+\n+    public static void markAsActivated(final Resource source, final Resource target) {\n+        if (nonNull(target) && ensureMixin(target)) {\n+            if (isJcrContent(source)) {\n+                addReplicationProps(source, target.getParent().getPath());\n+                addReplicationProps(target, source.getParent().getPath());\n+            } else {\n+                addReplicationProps(source, target.getPath());\n+                addReplicationProps(target, source.getPath());\n             }\n         }\n     }\n \n-    private static void refreshAndCommit(final ResourceResolver resourceResolver) {\n+    public static void markAsDeactivated(final Resource resource) {\n+        addReplicationProps(resource, null);\n+    }\n+\n+    private static void addReplicationProps(final Resource resource, final String replicationRef) {\n+        addReplicationProps(resource, Calendar.getInstance(), replicationRef);\n+    }\n+\n+    private static void addReplicationProps(final Resource resource, final Calendar replicated, final String replicationRef) {\n+        if (isNull(resource) || !supportsReplicationProperties(resource) || !ensureMixin(resource)) {\n+            return;\n+        }\n+\n+        final ModifiableValueMap properties = getModifiableProperties(resource, false);\n+        if (isNull(properties)) {\n+            return;\n+        }\n+\n+        final ResourceResolver resolver = resource.getResourceResolver();\n+        properties.put(PER_REPLICATED_BY, resolver.getUserID());\n+        properties.put(PER_REPLICATED, replicated);\n+        if (isBlank(replicationRef)) {\n+            properties.put(PER_REPLICATION_LAST_ACTION, DEACTIVATED);\n+            properties.remove(PER_REPLICATION_REF);\n+        } else {\n+            properties.put(PER_REPLICATION_LAST_ACTION, ACTIVATED);\n+            properties.put(PER_REPLICATION_REF, replicationRef);\n+        }\n+\n+        refreshAndCommit(resolver);\n+    }\n+\n+    public static void refreshAndCommit(final ResourceResolver resourceResolver) {\n         resourceResolver.refresh();\n         try {\n             resourceResolver.commit();\n         } catch (final PersistenceException e) {\n             resourceResolver.revert();\n-            LOGGER.error(\"could not commit replication property changes\", e);\n+            LOGGER.error(\"Could not commit changes\", e);\n         }\n     }\n \n@@ -186,22 +184,24 @@ private static void refreshAndCommit(final ResourceResolver resourceResolver) {\n      * @return True if the mixin was added, false if node could not be adapted, mixin could not\n      *         be added or if adding failed\n      */\n-    private static boolean ensureMixin(Resource resource) {\n-        boolean answer = false;\n-        Node node = resource.adaptTo(Node.class);\n-        if(node != null) {\n-            try {\n-                if(node.canAddMixin(PER_REPLICATION)) {\n-                    node.addMixin(PER_REPLICATION);\n-                    answer = true;\n-                } else {\n-                    LOGGER.warn(\"Could not set Replication Mixin on resource: '{}'\", resource);\n-                }\n-            } catch(RepositoryException e) {\n-                LOGGER.warn(\"Could not add Replication Mixin to node: '{}'\", node);\n+    private static boolean ensureMixin(final Resource resource) {\n+        final Node node = resource.adaptTo(Node.class);\n+        if (isNull(node)) {\n+            return false;\n+        }\n+\n+        try {\n+            if (node.canAddMixin(PER_REPLICATION)) {\n+                node.addMixin(PER_REPLICATION);\n+                return true;\n+            } else {\n+                LOGGER.warn(\"Could not set Replication Mixin on resource: '{}'\", resource);\n             }\n+        } catch (final RepositoryException e) {\n+            LOGGER.warn(\"Could not add Replication Mixin to node: '{}'\", node);\n         }\n-        return answer;\n+\n+        return false;\n     }\n \n     public static boolean isReplicated(final Resource resource) {"
  },
  {
    "sha": "0e205ab3cdc32999d116700275be34421f54a689",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/impl/FileReplicationServiceBase.java",
    "status": "modified",
    "additions": 88,
    "deletions": 80,
    "changes": 168,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/FileReplicationServiceBase.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/FileReplicationServiceBase.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/impl/FileReplicationServiceBase.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -13,9 +13,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@@ -46,7 +46,8 @@\n import java.util.stream.Stream;\n import java.util.stream.StreamSupport;\n \n-import static com.peregrine.replication.ReplicationUtil.updateReplicationProperties;\n+import static com.peregrine.commons.util.PerUtil.*;\n+import static com.peregrine.replication.ReplicationUtil.markAsActivated;\n import static com.peregrine.commons.Chars.DOT;\n import static com.peregrine.commons.util.PerConstants.PUBLISHED_LABEL;\n import static com.peregrine.commons.util.PerConstants.RENDITION_ACTION;\n@@ -57,9 +58,8 @@\n import static com.peregrine.commons.util.PerConstants.SLASH;\n import static com.peregrine.commons.util.PerConstants.SLING_FOLDER;\n import static com.peregrine.commons.util.PerConstants.SLING_ORDERED_FOLDER;\n-import static com.peregrine.commons.util.PerUtil.RENDITIONS;\n-import static com.peregrine.commons.util.PerUtil.isNotEmpty;\n import static java.util.Objects.isNull;\n+import static java.util.Objects.requireNonNullElse;\n import static org.apache.commons.lang3.StringUtils.EMPTY;\n import static org.apache.commons.lang3.StringUtils.isBlank;\n import static org.apache.commons.lang3.StringUtils.isNotBlank;\n@@ -71,9 +71,7 @@\n  */\n public abstract class FileReplicationServiceBase extends ReplicationServiceBase {\n \n-    private static final List<Pattern> NAME_PATTERNS = Collections.singletonList(\n-            Pattern.compile(\".*(\\\\.data\\\\.json|\\\\.html)\")\n-    );\n+    private static final Pattern NAME_PATTERN = Pattern.compile(\".*((\\\\.data|\\\\.infinity)\\\\.json|\\\\.html)\");\n     private static final ResourceChecker EXCLUDED_RESOURCES_RESOURCE_CHECKER = new ResourceChecker() {\n \n         // List of all resources that are excluded from handling\n@@ -93,24 +91,26 @@ public boolean doAddChildren(final Resource resource) {\n \n     private static final String EXTENSION_NAME_MUST_BE_PROVIDED = \"Extension Name must be provided\";\n     private static final String EXTENSION_TYPES_MUST_BE_PROVIDED = \"Extension Types must be provided\";\n-    public static final String RENDERING_OF_ASSET_FAILED = \"Rendering of Asset failed\";\n+    private static final String RENDERING_OF_ASSET_FAILED = \"Rendering of Asset failed\";\n \n     private final RenditionConsumer assetRenditionCreator = (resource, renditionName) -> {\n         if (isNotBlank(renditionName)) {\n             getRenderService().renderRawInternally(resource, RENDITION_ACTION + SLASH + renditionName);\n         }\n+\n+        return null;\n     };\n     private final RenditionConsumer assetRenditionReplicator = (resource, renditionName) -> {\n         final var initialResolver = resource.getResourceResolver();\n         final var targetResolver = new VersioningResourceResolver(initialResolver, PUBLISHED_LABEL);\n         final var wrappedResource = targetResolver.wrap(resource);\n         if (isNull(wrappedResource)) {\n-            return;\n+            return null;\n         }\n \n         final String extension = isBlank(renditionName) ? EMPTY : RENDITION_ACTION + SLASH + renditionName;\n         final byte[] content = getRenderService().renderRawInternally(wrappedResource, extension);\n-        storeRendering(resource, renditionName, content);\n+        return storeRendering(resource, renditionName, content);\n     };\n \n     @Override\n@@ -124,7 +124,7 @@ public boolean doAddChildren(final Resource resource) {\n         // Also make sure we ignore nodes like jcr:content\n         return resources.stream()\n                 .filter(Objects::nonNull)\n-                .filter(item -> !item.getPath().contains(JCR_CONTENT))\n+                .filter(item -> !PerUtil.isJcrContentOrDescendant(item))\n                 .collect(Collectors.toList());\n     }\n \n@@ -155,7 +155,7 @@ public boolean doAddChildren(final Resource resource) {\n             removeReplica(startingResource, null, false);\n             answer.add(startingResource);\n         } else if(primaryType.startsWith(\"per:\")) {\n-            removeReplica(startingResource, NAME_PATTERNS, false);\n+            removeReplica(startingResource, NAME_PATTERN, false);\n             answer.add(startingResource);\n         } else if(primaryType.equals(NT_FOLDER) || primaryType.equals(SLING_FOLDER) || primaryType.equals(SLING_ORDERED_FOLDER)) {\n             removeReplica(startingResource, null, true);\n@@ -180,31 +180,36 @@ public boolean doAddChildren(final Resource resource) {\n \n     @Override\n     public List<Resource> replicate(Collection<Resource> resourceList) throws ReplicationException {\n-        List<Resource> answer = new ArrayList<>();\n         log.trace(\"Replicate Resource List: '{}'\", resourceList);\n         // Replicate the resources\n         final ResourceResolver resourceResolver = ResourceUtils.findResolver(resourceList);\n         if (isNull(resourceResolver)) {\n             return Collections.emptyList();\n         }\n \n+        final List<Resource> answer = new LinkedList<>();\n         Session session = resourceResolver.adaptTo(Session.class);\n-        for (Resource item : filterReferences(resourceList)) {\n+        for(Resource item: filterReferences(resourceList)) {\n             handleParents(item.getParent());\n             // Need to figure out the type and replicate accordingly\n             String primaryType = PerUtil.getPrimaryType(item);\n-            if (ASSET_PRIMARY_TYPE.equals(primaryType)) {\n-                processAssetRenditions(item, assetRenditionReplicator);\n+            final String path;\n+            if(ASSET_PRIMARY_TYPE.equals(primaryType)) {\n+                path = processAssetRenditions(item, assetRenditionReplicator);\n             } else {\n-                replicatePerResource(item, false);\n+                path = replicatePerResource(item);\n             }\n \n             answer.add(item);\n+            if (isNotBlank(path)) {\n+                final Resource contentResource = item.getChild(JCR_CONTENT);\n+                markAsActivated(requireNonNullElse(contentResource, item), path);\n+            }\n         }\n \n         try {\n             session.save();\n-        } catch (RepositoryException e) {\n+        } catch(RepositoryException e) {\n             log.warn(\"Failed to save changes replicate parents\", e);\n         }\n \n@@ -235,21 +240,27 @@ private void handleParents(Resource resource) throws ReplicationException {\n \n     /** @return Map listing all extensions and the primary types of all nodes that are exported with that extension **/\n     abstract List<ExportExtension> getExportExtensions();\n+    private List<ExportExtension> getExportExtensions(final Resource resource) {\n+        return getExportExtensions().stream()\n+                .filter(e -> e.supportsResource(resource))\n+                .collect(Collectors.toList());\n+    }\n+\n     /** @return A list of all mandatory renditions which are created during the replication if not already there **/\n     abstract List<String> getMandatoryRenditions();\n \n     protected String renderingName(final Resource resource, final String extension) {\n         return resource.getName() + (isNotEmpty(extension) ? DOT + extension : EMPTY);\n     }\n \n-    private void processAssetRenditions(Resource resource, RenditionConsumer consumer) throws ReplicationException {\n+    private String processAssetRenditions(Resource resource, RenditionConsumer consumer) throws ReplicationException {\n         if (isNull(resource)) {\n-            return;\n+            return null;\n         }\n \n         try {\n             // Get the image data of the resource and write to the target\n-            consumer.consume(resource, EMPTY);\n+            final String answer = consumer.consume(resource, EMPTY);\n             // Loop over all existing renditions and write the image data to the target\n             final List<String> checkRenditions = new ArrayList<>(getMandatoryRenditions());\n             final Resource renditions = ResourceUtils.tryToCreateChildOrGetNull(resource, RENDITIONS, SLING_FOLDER);\n@@ -278,22 +289,13 @@ private void processAssetRenditions(Resource resource, RenditionConsumer consume\n                     log.warn(\"Rendition Failure\", e);\n                 }\n             }\n+\n+            return answer;\n         } catch(final RenderException e) {\n             throw new ReplicationException(RENDERING_OF_ASSET_FAILED, e);\n         }\n     }\n \n-    /**\n-     * Store the given Content Rendering on the target\n-     * @param resource Resource that is exported\n-     * @param extension File Extension (without a leading dot)\n-     * @param content String content of the rendering\n-     * @return Path to the Stored Rendition used for the Rendition Ref property\n-     * @throws ReplicationException if the writing of the content failed\n-     */\n-    String storeRendering(Resource resource, String extension, String content) throws ReplicationException {\n-        return storeFile(resource.getParent(), renderingName(resource, extension), content);\n-    }\n     /**\n      * Store the given Asset Rendering on the target\n      * @param resource Resource that is exported\n@@ -313,58 +315,46 @@ String storeRendering(Resource resource, String extension, byte[] content) throw\n      * @param isFolder If true this is a folder to be removed\n      * @throws ReplicationException If the removal fails\n      */\n-    abstract void removeReplica(Resource resource, final List<Pattern> namePattern, boolean isFolder) throws ReplicationException;\n-\n-    private void replicatePerResource(Resource resource, boolean post) throws ReplicationException {\n-        log.trace(\"Replicate Resource: '{}', Post: '{}'\", resource.getPath(), post);\n-        for(ExportExtension exportExtension: getExportExtensions()) {\n-            String extension = exportExtension.getName();\n-            log.trace(\"Handle Extension: '{}'\", extension);\n-            boolean raw = extension.endsWith(\"~raw\");\n-            if(raw) {\n-                extension = extension.substring(0, extension.length() - \"~raw\".length());\n-            }\n-            if(\"*\".equals(extension)) {\n-                extension = \"\";\n-            }\n-            if(exportExtension.supportsResource(resource)) {\n-                Object renderingContent = null;\n-                try {\n-                    final RenderService renderService = getRenderService();\n-                    if(raw) {\n-                        log.trace(\"Before Rendering Raw Resource With Extension: '{}'\", extension);\n-                        renderingContent = renderService.renderRawInternally(resource, extension);\n-                    } else {\n-                        log.trace(\"Before Rendering String Resource With Extension: '{}'\", extension);\n-                        renderingContent = renderService.renderInternally(resource, extension);\n-                    }\n-                } catch(RenderException e) {\n-                    log.warn(\"Rendering of '{}' failed -> ignore it\", resource.getPath());\n-                }\n-                if(renderingContent != null) {\n-                    log.trace(\"Rendered Resource: {}\", renderingContent);\n-                    String path;\n-                    if(raw) {\n-                        path = storeRendering(resource, extension, (byte[]) renderingContent);\n-                    } else {\n-                        path = storeRendering(resource, extension, (String) renderingContent);\n-                    }\n-                    Resource contentResource = resource.getChild(JCR_CONTENT);\n-                    updateReplicationProperties(Objects.requireNonNullElse(contentResource, resource), path, null);\n+    abstract void removeReplica(Resource resource, final Pattern namePattern, boolean isFolder) throws ReplicationException;\n+\n+    private String replicatePerResource(Resource resource) throws ReplicationException {\n+        String result = null;\n+        log.trace(\"Replicate Resource: '{}'\", resource.getPath());\n+        final RenderService renderService = getRenderService();\n+        for (final ExportExtension exportExtension : getExportExtensions(resource)) {\n+            final String extension = exportExtension.getFileExtension();\n+            try {\n+                final String path;\n+                if (exportExtension.isRaw()) {\n+                    log.trace(\"Before Rendering Raw Resource With Extension: '{}'\", extension);\n+                    final byte[] content = renderService.renderRawInternally(resource, extension);\n+                    path = storeRendering(resource, extension, content);\n+                } else {\n+                    log.trace(\"Before Rendering String Resource With Extension: '{}'\", extension);\n+                    final String content = renderService.renderInternally(resource, extension);\n+                    path = storeFile(resource.getParent(), renderingName(resource, extension), content);\n                 }\n+\n+                result = StringUtils.defaultIfBlank(result, path);\n+            } catch (RenderException e) {\n+                log.warn(\"Rendering of '{}' failed -> ignore it\", resource.getPath());\n             }\n         }\n+\n+        return result;\n     }\n \n-    public static class ExportExtension {\n+    protected static class ExportExtension {\n+\n         private final String name;\n         private final List<String> types;\n \n         public ExportExtension(String name, List<String> types) {\n-            if(StringUtils.isEmpty(name)) {\n+            if (StringUtils.isEmpty(name)) {\n                 throw new IllegalArgumentException(EXTENSION_NAME_MUST_BE_PROVIDED);\n             }\n-            if(types == null || types.isEmpty()) {\n+\n+            if (isNull(types) || types.isEmpty()) {\n                 throw new IllegalArgumentException(EXTENSION_TYPES_MUST_BE_PROVIDED);\n             }\n             this.name = name;\n@@ -375,17 +365,35 @@ public String getName() {\n             return name;\n         }\n \n-        public boolean supportsResource(Resource resource) {\n-            String primaryType = PerUtil.getPrimaryType(resource);\n-            if(types.contains(primaryType)) { return true; }\n-            String slingResourceType = PerUtil.getResourceType(resource);\n-            return types.contains(slingResourceType);\n+        public boolean supportsResource(final Resource resource) {\n+            if (types.contains(getPrimaryType(resource))) {\n+                return true;\n+            }\n+\n+            return types.contains(getResourceType(resource));\n+        }\n+\n+        public boolean isRaw() {\n+            return StringUtils.endsWith(name, \"~raw\");\n+        }\n+\n+        public String getFileExtension() {\n+            String result = name;\n+            if (isRaw()) {\n+                result = StringUtils.substringAfterLast(result, \"~raw\");\n+            }\n+\n+            if (\"*\".equals(result)) {\n+                return EMPTY;\n+            }\n+\n+            return result;\n         }\n \n     }\n \n     private interface RenditionConsumer {\n-        void consume(Resource resource, String renditionName) throws RenderException, ReplicationException;\n+        String consume(Resource resource, String renditionName) throws RenderException, ReplicationException;\n     }\n \n }"
  },
  {
    "sha": "edb0ce2d99d76ac68ab93dbf6395b2168f105e4e",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/impl/LocalFileSystemReplicationService.java",
    "status": "modified",
    "additions": 22,
    "deletions": 60,
    "changes": 82,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalFileSystemReplicationService.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalFileSystemReplicationService.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalFileSystemReplicationService.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -13,9 +13,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@@ -30,7 +30,6 @@\n import com.peregrine.replication.Replication;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.sling.api.resource.Resource;\n-import org.apache.sling.api.resource.ResourceResolverFactory;\n import org.osgi.framework.BundleContext;\n import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n@@ -52,18 +51,16 @@\n import java.util.function.Function;\n import java.util.regex.Pattern;\n \n+import static com.peregrine.commons.IOUtils.*;\n import static com.peregrine.commons.TextUtils.replacePlaceholders;\n-import static com.peregrine.replication.ReplicationUtil.updateReplicationProperties;\n import static com.peregrine.commons.Chars._SCORE;\n import static com.peregrine.commons.ResourceUtils.jcrNameToFileName;\n import static com.peregrine.commons.util.PerConstants.SLASH;\n-import static com.peregrine.commons.util.PerUtil.getJcrContent;\n-import static com.peregrine.commons.util.PerUtil.intoList;\n-import static com.peregrine.commons.util.PerUtil.isNotEmpty;\n-import static com.peregrine.commons.util.PerUtil.splitIntoMap;\n+import static com.peregrine.commons.util.PerUtil.*;\n+import static com.peregrine.replication.ReplicationUtil.markAsActivated;\n+import static com.peregrine.replication.ReplicationUtil.markAsDeactivated;\n import static java.util.Objects.isNull;\n import static java.util.Objects.nonNull;\n-import static org.apache.commons.lang3.StringUtils.EMPTY;\n \n /**\n  * This class replicates resources to a local file system folder\n@@ -81,14 +78,12 @@\n     public static final int CREATE_LEAF_STRATEGY = 1;\n     public static final int CREATE_ALL_STRATEGY = 2;\n     public static final String LOCAL_FILE_SYSTEM = \"local-file-system://\";\n-    public static final String FAILED_TO_CREATED_FOLDER = \"Failed to create folder: '%s'\";\n-    public static final String FAILED_TO_DELETE_FILE = \"Failed to delete file: '%s'\";\n+    public static final String FAILED_TO_CREATE_FOLDER = \"Failed to create folder '%s' under '%s'\";\n     public static final String FAILED_STORE_RENDERING_MISSING_PARENT_FOLDER = \"Failed to Store Rendering as Parent Folder does not exist or is not a directory: '%s'\";\n     public static final String FAILED_STORE_RENDERING_FILE_IS_DIRECTORY = \"Failed to Store Rendering as target file is a directory:: '%s'\";\n     public static final String FAILED_TO_STORE_RENDERING = \"Failed to write raw rending content to file: '%s'\";\n     public static final String SUPPORTED_TYPES_EMPTY = \"Supported Types is empty for Extension: '%s'\";\n     public static final String COULD_NOT_CREATE_LEAF_FOLDER = \"Could not create leaf folder: '%s'\";\n-    public static final String EXPORT_FOLDER = \"exportFolder\";\n     public static final String REPLICATION_TARGET_FOLDER_CANNOT_BE_EMPTY = \"Replication Target Folder cannot be empty\";\n     public static final String COULD_NOT_CREATE_ALL_FOLDERS = \"Could not create all folders: '%s'\";\n     public static final String REPLICATION_FOLDER_NOT_CREATED = \"Replication Target Folder: '%s' does not exist and will not be created\";\n@@ -137,17 +132,17 @@\n         String[] mandatoryRenditions();\n     }\n \n+    private File targetFolder;\n+    private final List<ExportExtension> exportExtensions = new ArrayList<>();\n+    private List<String> mandatoryRenditions = new ArrayList<>();\n+\n     @Activate\n     @SuppressWarnings(\"unused\")\n     void activate(BundleContext context, Configuration configuration) { setup(context, configuration); }\n     @Modified\n     @SuppressWarnings(\"unused\")\n     void modified(BundleContext context, Configuration configuration) { setup(context, configuration); }\n \n-    private File targetFolder;\n-    private final List<ExportExtension> exportExtensions = new ArrayList<>();\n-    private List<String> mandatoryRenditions = new ArrayList<>();\n-\n     private void setup(BundleContext context, Configuration configuration) {\n         log.trace(\"Create Local FS Replication Service Name: '{}'\", configuration.name());\n         init(configuration.name(), configuration.description());\n@@ -208,9 +203,6 @@ private void setup(BundleContext context, Configuration configuration) {\n     @Reference\n     @SuppressWarnings(\"unused\")\n     private RenderService renderService;\n-    @Reference\n-    @SuppressWarnings(\"unused\")\n-    ResourceResolverFactory resourceResolverFactory;\n \n     @Override\n     RenderService getRenderService() {\n@@ -232,26 +224,17 @@ boolean isFolderOnTarget(String path) {\n     File createTargetFolder(final String path) throws ReplicationException {\n         File answer = targetFolder;\n         for (final String name: path.split(SLASH)) {\n-            if (StringUtils.isNotEmpty(name)) {\n-                answer = createTargetFolder(answer, jcrNameToFileName(name));\n+            if (nonNull(answer) && StringUtils.isNotEmpty(name)) {\n+                final String fileName = jcrNameToFileName(name);\n+                answer = createChildDirectory(answer, fileName, fileName + _SCORE);\n             }\n         }\n \n-        return answer;\n-    }\n-\n-    private File createTargetFolder(final File parent, final String name) throws ReplicationException {\n-        File answer = new File(parent, name);\n-        if (answer.exists() && !answer.isDirectory()) {\n-            // File exists but is not a folder (like an image or so) -> create a folder with '_' at the end\n-            answer = new File(parent, name + _SCORE);\n-        }\n-\n-        if ((answer.exists() && answer.isDirectory()) || answer.mkdir()) {\n-            return answer;\n+        if (isNull(answer)) {\n+            throw new ReplicationException(String.format(FAILED_TO_CREATE_FOLDER, path, targetFolder.getAbsolutePath()));\n         }\n \n-        throw new ReplicationException(String.format(FAILED_TO_CREATED_FOLDER, answer.getAbsolutePath()));\n+        return answer;\n     }\n \n     @Override\n@@ -306,12 +289,12 @@ private String storeFile(final Resource parent, final String name, final Functio\n         }\n \n         final String localFileSystemPath = LOCAL_FILE_SYSTEM + file.getAbsolutePath();\n-        updateReplicationProperties(getJcrContent(parent), localFileSystemPath, null);\n+        markAsActivated(getJcrContent(parent), localFileSystemPath);\n         return localFileSystemPath;\n     }\n \n     @Override\n-    void removeReplica(Resource resource, final List<Pattern> namePattern, final boolean isFolder) throws ReplicationException {\n+    void removeReplica(Resource resource, final Pattern namePattern, final boolean isFolder) throws ReplicationException {\n         final String resourceName = resource.getName();\n         final File directory = new File(targetFolder, resource.getParent().getPath());\n         if(!directory.exists() || !directory.isDirectory()) {\n@@ -324,15 +307,7 @@ void removeReplica(Resource resource, final List<Pattern> namePattern, final boo\n                         return true;\n                     }\n \n-                    if (isNull(namePattern)) {\n-                        return name.startsWith(resourceName);\n-                    }\n-\n-                    for (final Pattern pattern : namePattern) {\n-                        return pattern.matcher(name).matches() && file.getName().startsWith(resourceName);\n-                    }\n-\n-                    return false;\n+                    return name.startsWith(resourceName) && (isNull(namePattern) || namePattern.matcher(name).matches());\n                 }\n         );\n         if (isNull(filesToBeDeletedFiles)) {\n@@ -341,27 +316,14 @@ void removeReplica(Resource resource, final List<Pattern> namePattern, final boo\n \n         for (final File toBeDeleted : filesToBeDeletedFiles) {\n             log.trace(\"Delete File: '{}'\", toBeDeleted.getAbsolutePath());\n-            if (!deleteFile(toBeDeleted)) {\n+            if (!deleteFileOrDirectory(toBeDeleted)) {\n                 throw new ReplicationException(String.format(FAILED_TO_DELETE_FILE, toBeDeleted.getAbsolutePath()));\n             }\n \n-            updateReplicationProperties(getJcrContent(resource), EMPTY, null);\n+            markAsDeactivated(getJcrContentOrSelf(resource));\n         }\n     }\n \n-    private boolean deleteFile(File file) {\n-        if(file.isDirectory()) {\n-            for(File child: file.listFiles()) {\n-                if(!deleteFile(child)) {\n-                    log.warn(String.format(FAILED_TO_DELETE_FILE, file.getAbsolutePath()));\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        return file.delete();\n-    }\n-\n     private File createFileWithParentAndName(final Resource parent, final String name) throws ReplicationException {\n         final File directory = createTargetFolder(parent.getPath());\n         if (!(directory.exists() && directory.isDirectory())) {"
  },
  {
    "sha": "7d3d588eb3a240e9cd591213d7303a02c67f3c78",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/impl/LocalReplicationService.java",
    "status": "modified",
    "additions": 181,
    "deletions": 266,
    "changes": 447,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalReplicationService.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalReplicationService.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/impl/LocalReplicationService.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -13,9 +13,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- * \n+ *\n  * http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing,\n  * software distributed under the License is distributed on an\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n@@ -25,42 +25,28 @@\n  * #L%\n  */\n \n-import com.peregrine.replication.ReplicationServiceBase;\n+import com.google.common.collect.Iterables;\n+import com.peregrine.commons.ResourceUtils;\n+import com.peregrine.commons.util.PerUtil.*;\n import com.peregrine.replication.ReferenceLister;\n import com.peregrine.replication.Replication;\n-import com.peregrine.commons.util.PerUtil.MatchingResourceChecker;\n-import com.peregrine.commons.util.PerUtil.MissingOrOutdatedResourceChecker;\n-import com.peregrine.commons.util.PerUtil.ResourceChecker;\n-import org.apache.sling.api.resource.ModifiableValueMap;\n-import org.apache.sling.api.resource.PersistenceException;\n-import org.apache.sling.api.resource.Resource;\n-import org.apache.sling.api.resource.ResourceResolver;\n-import org.apache.sling.api.resource.ResourceResolverFactory;\n-import org.apache.sling.api.resource.ValueMap;\n-import org.osgi.service.component.annotations.Activate;\n-import org.osgi.service.component.annotations.Component;\n-import org.osgi.service.component.annotations.ConfigurationPolicy;\n-import org.osgi.service.component.annotations.Modified;\n-import org.osgi.service.component.annotations.Reference;\n+import com.peregrine.replication.ReplicationServiceBase;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.sling.api.resource.*;\n+import org.osgi.service.component.annotations.*;\n import org.osgi.service.metatype.annotations.AttributeDefinition;\n import org.osgi.service.metatype.annotations.Designate;\n import org.osgi.service.metatype.annotations.ObjectClassDefinition;\n \n-import javax.jcr.RepositoryException;\n-import javax.jcr.Session;\n import java.util.*;\n \n-import static com.peregrine.replication.ReplicationUtil.updateReplicationProperties;\n-import static com.peregrine.commons.util.PerConstants.JCR_UUID;\n-import static com.peregrine.commons.util.PerUtil.EQUALS;\n-import static com.peregrine.commons.util.PerUtil.containsResource;\n-import static com.peregrine.commons.util.PerUtil.getModifiableProperties;\n-import static com.peregrine.commons.util.PerUtil.getParent;\n-import static com.peregrine.commons.util.PerUtil.getProperties;\n-import static com.peregrine.commons.util.PerUtil.getResource;\n-import static com.peregrine.commons.util.PerUtil.listMissingParents;\n-import static com.peregrine.commons.util.PerUtil.listMissingResources;\n-import static com.peregrine.commons.util.PerUtil.relativePath;\n+import static com.peregrine.commons.ResourceUtils.performFlatSafeCopy;\n+import static com.peregrine.commons.util.PerConstants.SLASH;\n+import static com.peregrine.commons.util.PerUtil.*;\n+import static com.peregrine.replication.ReplicationUtil.*;\n+import static java.util.Objects.isNull;\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n \n /**\n  * This service replicates resources within the same Peregrine\n@@ -85,6 +71,10 @@\n     public static final String LOCAL_TARGET_NOT_FOUND = \"Local Target: '%s' not found. Please fix the local mapping or create the local target.\";\n     public static final String FAILED_TO_DELETE_A_TARGET_RESOURCE = \"Failed to delete a target resource: '%s'\";\n \n+    private String localSource;\n+    private String localTarget;\n+    private String localSourceWithSlash;\n+\n     @ObjectClassDefinition(\n         name = \"Peregrine: Local Replication Service\",\n         description = \"Each instance provides the configuration for a Local Replication\"\n@@ -113,32 +103,26 @@\n     @SuppressWarnings(\"unused\")\n     void modified(Configuration configuration) { setup(configuration); }\n \n-    private String localSource;\n-    private String localTarget;\n-\n     private void setup(Configuration configuration) {\n         init(configuration.name(), configuration.description());\n-        localSource = localTarget = null;\n-        String mapping = configuration.localMapping();\n-        String[] tokens = mapping.split(EQUALS);\n-        if(tokens.length == 2) {\n-            localSource = tokens[0];\n-            localTarget = tokens[1];\n-        } else {\n+        localSource = localTarget = localSourceWithSlash = null;\n+        final String mapping = configuration.localMapping();\n+        final String[] tokens = mapping.split(EQUALS);\n+        if(tokens.length < 2) {\n             throw new IllegalArgumentException(String.format(LOCAL_MAPPING_HAS_THE_WRONG_FORMAT, mapping));\n         }\n-        if(localSource == null || localSource.isEmpty() || !localSource.startsWith(\"/\")) {\n+\n+        localSource = StringUtils.stripEnd(tokens[0], SLASH);\n+        localSourceWithSlash = localSource + SLASH;\n+        localTarget = StringUtils.stripEnd(tokens[1], SLASH);\n+        if(!StringUtils.startsWith(localSource, SLASH)) {\n             throw new IllegalArgumentException(String.format(LOCAL_MAPPING_SOURCE_MUST_BE_ABSOLUTE, mapping));\n         }\n-        if(localTarget == null || localTarget.isEmpty() || !localTarget.startsWith(\"/\")) {\n+\n+        if(!StringUtils.startsWith(localTarget, SLASH)) {\n             throw new IllegalArgumentException(String.format(LOCAL_MAPPING_TARGET_MUST_BE_ABSOLUTE, mapping));\n         }\n-        if(localSource.endsWith(\"/\")) {\n-            localSource = localSource.substring(0, localSource.length() - 1);\n-        }\n-        if(localTarget.endsWith(\"/\")) {\n-            localTarget = localTarget.substring(0, localTarget.length() - 1);\n-        }\n+\n         log.trace(\"Local Replication Service Name: '{}' created\", getName());\n         log.trace(\"Local Source: '{}', Target: '{}'\", localSource, localTarget);\n     }\n@@ -151,113 +135,54 @@ private void setup(Configuration configuration) {\n     private ReferenceLister referenceLister;\n \n     @Override\n-    public List<Resource> findReferences(Resource startingResource, boolean deep) throws ReplicationException {\n+    public List<Resource> findReferences(final Resource startingResource, final boolean deep) throws ReplicationException {\n         ResourceResolver resourceResolver = startingResource.getResourceResolver();\n-        Resource source = resourceResolver.getResource(localSource);\n-        if(source == null) {\n-            throw new ReplicationException(String.format(LOCAL_SOURCE_NOT_FOUND, localSource));\n-        }\n-        Resource target = resourceResolver.getResource(localTarget);\n-        if(target == null) {\n-            throw new ReplicationException(String.format(LOCAL_TARGET_NOT_FOUND, localTarget));\n-        }\n-        List<Resource> referenceList = referenceLister.getReferenceList(true, startingResource, true, source, target);\n-        List<Resource> replicationList = new ArrayList<>();\n-        ResourceChecker resourceChecker = new MissingOrOutdatedResourceChecker(source, target);\n+        final Resource source = resolveLocalSource(resourceResolver);\n+        final Resource target = resolveLocalTarget(resourceResolver);\n+        final List<Resource> referenceList = referenceLister.getReferenceList(true, startingResource, deep, source, target);\n+        final List<Resource> replicationList = new ArrayList<>();\n+        final ResourceChecker resourceChecker = new MissingOrOutdatedResourceChecker(source, target);\n         // Need to check this list of they need to be replicated first\n-        for(Resource resource: referenceList) {\n+        for(final Resource resource: referenceList) {\n             if(resourceChecker.doAdd(resource) && !containsResource(replicationList, resource)) {\n                 replicationList.add(resource);\n             }\n         }\n+\n         // This only returns the referenced resources. Now we need to check if there are any JCR Content nodes to be added as well\n-        for(Resource reference: new ArrayList<>(replicationList)) {\n+        for(final Resource reference: new LinkedList<>(replicationList)) {\n             listMissingResources(reference, resourceChecker, false, replicationList);\n         }\n+\n         listMissingParents(startingResource, replicationList, source, resourceChecker);\n         return listMissingResources(startingResource, resourceChecker, deep, replicationList);\n     }\n \n+    private Resource resolveLocalSource(final ResourceResolver resolver) throws ReplicationException {\n+        return Optional.ofNullable(localSource)\n+                .map(resolver::getResource)\n+                .orElseThrow(() -> new ReplicationException(String.format(LOCAL_SOURCE_NOT_FOUND, localSource)));\n+    }\n+\n+    private Resource resolveLocalTarget(final ResourceResolver resolver) throws ReplicationException {\n+        return Optional.ofNullable(localTarget)\n+                .map(resolver::getResource)\n+                .orElseThrow(() -> new ReplicationException(String.format(LOCAL_TARGET_NOT_FOUND, localTarget)));\n+    }\n+\n     @Override\n     public List<Resource> deactivate(Resource startingResource)\n         throws ReplicationException\n     {\n-        ResourceResolver resourceResolver = startingResource.getResourceResolver();\n-        Resource source = resourceResolver.getResource(localSource);\n-        if(source == null) {\n-            throw new ReplicationException(String.format(LOCAL_SOURCE_NOT_FOUND, localSource));\n-        }\n-        Resource target = resourceResolver.getResource(localTarget);\n-        if(target == null) {\n-            throw new ReplicationException(String.format(LOCAL_TARGET_NOT_FOUND, localTarget));\n-        }\n-\n-        List<Resource> replicationList = new ArrayList<>(Collections.singletonList(startingResource));\n-        ResourceChecker resourceChecker = new MatchingResourceChecker(source, target);\n+        final ResourceResolver resourceResolver = startingResource.getResourceResolver();\n+        final Resource source = resolveLocalSource(resourceResolver);\n+        final Resource target = resolveLocalTarget(resourceResolver);\n+        final List<Resource> replicationList = new ArrayList<>(Collections.singletonList(startingResource));\n+        final ResourceChecker resourceChecker = new MatchingResourceChecker(source, target);\n         listMissingResources(startingResource, resourceChecker, true, replicationList);\n         return deactivate(startingResource, replicationList);\n     }\n \n-    @Override\n-    public List<Resource> replicate(Collection<Resource> resourceList) throws ReplicationException {\n-        List<Resource> handledSources = new ArrayList<>();\n-        List<Resource> answer = new ArrayList<>();\n-        // Replicate the resources\n-        ResourceResolver resourceResolver = null;\n-        for(Resource item: resourceList) {\n-            if(item != null) {\n-                resourceResolver = item.getResourceResolver();\n-                break;\n-            }\n-        }\n-        if(resourceResolver != null) {\n-            Resource source = resourceResolver.getResource(localSource);\n-            if(source == null) {\n-                throw new ReplicationException(String.format(LOCAL_SOURCE_NOT_FOUND, localSource));\n-            }\n-            Resource target = resourceResolver.getResource(localTarget);\n-            if(target == null) {\n-                throw new ReplicationException(String.format(LOCAL_TARGET_NOT_FOUND, localTarget));\n-            }\n-            // Prepare the Mappings for the Properties mapping\n-            Map<String, String> pathMapping = new HashMap<>();\n-            for(Resource item: resourceList) {\n-                if(item != null) {\n-                    String relativePath = relativePath(source, item);\n-                    if(relativePath != null) {\n-                        String targetPath = localTarget + '/' + relativePath;\n-                        log.trace(\"Add to Path mappings Source Path: '{}', Target Path: '{}'\", item.getPath(), targetPath);\n-                        pathMapping.put(item.getPath(), targetPath);\n-                        // References need to be updated through the Path Mappings therefore we revisit them here\n-                        List<Resource> referenceList = referenceLister.getReferenceList(true, item, true, source, target);\n-                        for(Resource reference: referenceList) {\n-                            relativePath = relativePath(source, reference);\n-                            if(relativePath != null) {\n-                                targetPath = localTarget + '/' + relativePath;\n-                                log.trace(\"Add to Path mappings Reference Source Path: '{}', Target Path: '{}'\", reference.getPath(), targetPath);\n-                                pathMapping.put(reference.getPath(), targetPath);\n-                            }\n-                        }\n-                    } else {\n-                        log.warn(\"Given Resource: '{}' path does not start with local source path: '{}' -> ignore\", item, localSource);\n-                    }\n-                }\n-            }\n-            Session session = resourceResolver.adaptTo(Session.class);\n-            for(Resource item: resourceList) {\n-                if(item != null) {\n-                    handleParents(handledSources, item, answer, pathMapping, resourceResolver);\n-                }\n-            }\n-            try {\n-                session.save();\n-            } catch(RepositoryException e) {\n-                log.warn(\"Failed to save changes replicate parents\", e);\n-            }\n-        }\n-        return answer;\n-    }\n-\n     /**\n      * This method deactivates the given resource to deactivate it and then updates\n      * the given list of source resources with the replication properties\n@@ -267,157 +192,147 @@ private void setup(Configuration configuration) {\n      * @return List of all updated source dependencies\n      * @throws ReplicationException\n      */\n-    public List<Resource> deactivate(Resource toBeDeleted, List<Resource> resourceList) throws ReplicationException {\n+    private List<Resource> deactivate(Resource toBeDeleted, List<Resource> resourceList) throws ReplicationException {\n+        final ResourceResolver resourceResolver = ResourceUtils.findResolver(resourceList);\n+        if (isNull(resourceResolver)) {\n+            return Collections.emptyList();\n+        }\n+\n         List<Resource> answer = new ArrayList<>();\n         // Replicate the resources\n-        ResourceResolver resourceResolver = null;\n-        for(Resource item: resourceList) {\n-            if(item != null) {\n-                resourceResolver = item.getResourceResolver();\n-                break;\n-            }\n+        Resource source = resolveLocalSource(resourceResolver);\n+        resolveLocalTarget(resourceResolver);\n+        // Update all replication targets by setting the new Replication Date, User and remove the Ref to indicate the deactivation\n+        for (Resource item : resourceList) {\n+            markAsDeactivated(item);\n         }\n-        if(resourceResolver != null) {\n-            Resource source = resourceResolver.getResource(localSource);\n-            if(source == null) {\n-                throw new ReplicationException(String.format(LOCAL_SOURCE_NOT_FOUND, localSource));\n-            }\n-            Resource target = resourceResolver.getResource(localTarget);\n-            if(target == null) {\n-                throw new ReplicationException(String.format(LOCAL_TARGET_NOT_FOUND, localTarget));\n-            }\n-            // Update all replication targets by setting the new Replication Date, User and remove the Ref to indicate the deactivation\n-            for(Resource item: resourceList) {\n-                updateReplicationProperties(item, \"\", null);\n+        // Delete the replicated target resource\n+        String relativePath = relativePath(source, toBeDeleted);\n+        if (relativePath != null) {\n+            String targetPath = localTarget + '/' + relativePath;\n+            Resource targetResource = getResource(resourceResolver, targetPath);\n+            if (targetResource != null) {\n+                try {\n+                    resourceResolver.delete(targetResource);\n+                } catch (PersistenceException e) {\n+                    throw new ReplicationException(String.format(FAILED_TO_DELETE_A_TARGET_RESOURCE, targetPath), e);\n+                }\n             }\n-            // Delete the replicated target resource\n-            String relativePath = relativePath(source, toBeDeleted);\n-            if(relativePath != null) {\n+        } else {\n+            log.warn(\"Given Resource: '{}' path does not start with local source path: '{}' -> ignore\", toBeDeleted, localSource);\n+        }\n+\n+        refreshAndCommit(resourceResolver);\n+        return answer;\n+    }\n+\n+    @Override\n+    public List<Resource> replicate(final Collection<Resource> resourceList) throws ReplicationException {\n+        final ResourceResolver resourceResolver = ResourceUtils.findResolver(resourceList);\n+        if (isNull(resourceResolver)) {\n+            return Collections.emptyList();\n+        }\n+\n+        final Collection<Resource> safeResourceList = new LinkedList<>(resourceList);\n+        Iterables.removeIf(safeResourceList, Objects::isNull);\n+        final Resource source = resolveLocalSource(resourceResolver);\n+        final Resource target = resolveLocalTarget(resourceResolver);\n+        // Prepare the Mappings for the Properties mapping\n+        final Map<String, String> pathMapping = new HashMap<>();\n+        for (final Resource item : safeResourceList) {\n+            String relativePath = relativePath(source, item);\n+            if (isNotBlank(relativePath)) {\n                 String targetPath = localTarget + '/' + relativePath;\n-                Resource targetResource = getResource(resourceResolver, targetPath);\n-                if(targetResource != null) {\n-                    try {\n-                        resourceResolver.delete(targetResource);\n-                    } catch(PersistenceException e) {\n-                        throw new ReplicationException(String.format(FAILED_TO_DELETE_A_TARGET_RESOURCE, targetPath), e);\n+                log.trace(\"Add to Path mappings Source Path: '{}', Target Path: '{}'\", item.getPath(), targetPath);\n+                pathMapping.put(item.getPath(), targetPath);\n+                // References need to be updated through the Path Mappings therefore we revisit them here\n+                List<Resource> referenceList = referenceLister.getReferenceList(true, item, true, source, target);\n+                for (Resource reference : referenceList) {\n+                    relativePath = relativePath(source, reference);\n+                    if (isNotBlank(relativePath)) {\n+                        targetPath = localTarget + '/' + relativePath;\n+                        log.trace(\"Add to Path mappings Reference Source Path: '{}', Target Path: '{}'\", reference.getPath(), targetPath);\n+                        pathMapping.put(reference.getPath(), targetPath);\n                     }\n                 }\n             } else {\n-                log.warn(\"Given Resource: '{}' path does not start with local source path: '{}' -> ignore\", toBeDeleted, localSource);\n-            }\n-            Session session = resourceResolver.adaptTo(Session.class);\n-            try {\n-                session.save();\n-            } catch(RepositoryException e) {\n-                log.warn(\"Failed to save changes replicate parents\", e);\n+                log.warn(\"Given Resource: '{}' path does not start with local source path: '{}' -> ignore\", item, localSource);\n             }\n         }\n+\n+        final List<Resource> handledSources = new LinkedList<>();\n+        final List<Resource> answer = new LinkedList<>();\n+        for (final Resource item : safeResourceList) {\n+            handleParents(handledSources, item, answer, pathMapping, resourceResolver);\n+        }\n+\n+        refreshAndCommit(resourceResolver);\n         return answer;\n     }\n \n     private boolean handleParents(List<Resource> handledSources, Resource resource, List<Resource> resourceList, Map<String, String> pathMapping, ResourceResolver resourceResolver) {\n-        if(!containsResource(handledSources, resource)) {\n-            String targetPath = pathMapping.get(resource.getPath());\n-            log.trace(\"Handle Parents, Resource: '{}', Target Path: '{}'\", resource.getPath(), targetPath);\n-            if(targetPath != null) {\n-                try {\n-                    //AS TODO: If the parent is not found because the are intermediate missing parents\n-                    //AS TODO: we need to recursively go up the parents until we either find an existing parent and then create all its children on the way out\n-                    //AS TODO: or we fail and ignore it\n-                    String targetParent = getParent(targetPath);\n-                    log.trace(\"Target Parent: '{}'\", targetParent);\n-                    if(targetParent == null) {\n-                        // No more parent -> handling parents failed\n-                        return false;\n-                    }\n-                    Resource targetParentResource = resourceResolver.getResource(targetParent);\n-                    log.trace(\"Target Parent Resource: '{}'\", targetParentResource == null ? \"null\" : targetParentResource.getPath());\n-                    if(targetParentResource == null) {\n-                        // Parent does not exist so try with its parent\n-                        Resource parent = resource.getParent();\n-                        log.trace(\"Source Parent: '{}'\", parent == null ? \"null\" : parent.getPath());\n-                        if(parent == null) {\n-                            // No more parent -> handling parents failed\n-                            return false;\n-                        }\n-                        log.trace(\"Recursive Handle Parents: '{}'\", resource.getParent().getPath());\n-                        boolean ok = handleParents(handledSources, resource.getParent(), resourceList, pathMapping, resourceResolver);\n-                        if(!ok) {\n-                            // Handling of parent failed -> leaving as failure\n-                            return false;\n-                        } else {\n-                            targetParentResource = resourceResolver.getResource(targetParent);\n-                            log.trace(\"Target Parent Resource(2): '{}'\", targetParentResource == null ? \"null\" : targetParentResource.getPath());\n-                            if(targetParentResource == null) {\n-                                log.error(\"Target Parent:'\" + targetParent + \"' is still not found even after all parents were handled\");\n-                            }\n-                        }\n-                    }\n-                    log.trace(\"Copy Resource: '{}' to Target: '{}'\", resource.getPath(), targetParentResource.getPath());\n-                    Resource copy = copy(resource, targetParentResource, pathMapping);\n-                    resourceList.add(copy);\n-                    handledSources.add(resource);\n-                } catch(PersistenceException e) {\n-                    log.error(\"Failed to replicate resource: '{}' -> ignored\", resource, e);\n-                }\n-            }\n+        if (containsResource(handledSources, resource)) {\n+            return true;\n         }\n-        return true;\n-    }\n \n-    /**\n-     * Copy of a Single Resource rather than the ResourceResolver's copy which copies the entire sub tree\n-     *\n-     * @param source Source to be copied\n-     * @param targetParent Parent Resource which the copy will be added to\n-     * @param pathMapping Path Mappings used to check and rewrite references\n-     * @return The newly created (copied) resource\n-     *\n-     * @throws PersistenceException If the resource could not be created like it already exists or parent missing\n-     */\n-    private Resource copy(Resource source, Resource targetParent, Map<String, String> pathMapping)\n-        throws PersistenceException\n-    {\n-        log.trace(\"Copy Resource: '{}', Target Parent Resource: '{}', Path Mappings: '{}'\", source.getPath(), targetParent, pathMapping);\n-        Resource answer;\n-        Map<String, Object> newProperties = new HashMap<>();\n-        ModifiableValueMap properties = getModifiableProperties(source, false);\n-        for(String key : properties.keySet()) {\n-            if(JCR_UUID.equals(key)) {\n-                // UUIDs cannot be copied over -> ignore them\n-                continue;\n+        final String targetPath = getTargetPath(resource);\n+        log.trace(\"Handle Parents, Resource: '{}', Target Path: '{}'\", resource.getPath(), targetPath);\n+        if (isBlank(targetPath)) {\n+            return true;\n+        }\n+\n+        final String targetParentPath = getParent(targetPath);\n+        log.trace(\"Target Parent: '{}'\", targetParentPath);\n+        if (isBlank(targetParentPath)) {\n+            // No more parent -> handling parents failed\n+            return false;\n+        }\n+\n+        Resource targetParent = resourceResolver.getResource(targetParentPath);\n+        if (isNull(targetParent)) {\n+            // Parent does not exist so try with its parent\n+            final Resource parent = resource.getParent();\n+            if (isNull(parent)) {\n+                // No more parent -> handling parents failed\n+                return false;\n             }\n-            Object value = properties.get(key);\n-            if(value instanceof String) {\n-                String stringValue = (String) value;\n-                String targetValue = pathMapping.get(value);\n-                log.trace(\"Is Property to be adjusted, name: '{}', value: '{}', mapped: '{}'\", key, stringValue, targetValue);\n-                if(targetValue != null) {\n-                    log.trace(\"Adjusted Property. Key: '{}', Old Value: '{}', New Value: '{}'\", new String[]{key, stringValue, targetValue});\n-                    value = targetValue;\n-                }\n+\n+            log.trace(\"Recursive Handle Parents: '{}'\", parent.getPath());\n+            if (!handleParents(handledSources, parent, resourceList, pathMapping, resourceResolver)) {\n+                // Handling of parent failed -> leaving as failure\n+                return false;\n             }\n-            newProperties.put(key, value);\n-        }\n-        answer = targetParent.getChild(source.getName());\n-        if(answer == null) {\n-            ValueMap sourceProperties = getProperties(source, false);\n-            Map<String, Object> targetProperties = new HashMap<>();\n-            for(String key: sourceProperties.keySet()) {\n-                if(JCR_UUID.equals(key)) {\n-                    // UUIDs cannot be copied over -> ignore them\n-                    continue;\n-                }\n-                try {\n-                    targetProperties.put(key, newProperties.get(key));\n-                } catch(Exception e) {\n-                    // Ignore\n-                }\n+\n+            targetParent = resourceResolver.getResource(targetParentPath);\n+            if (isNull(targetParent)) {\n+                log.error(\"Target Parent:'\" + targetParentPath + \"' is still not found even after all parents were handled\");\n+                return false;\n             }\n-            log.trace(\"Create Resource: '{}' on Parent: '{}', Properties: '{}'\", source.getName(), targetParent.getPath(), targetProperties);\n-            answer = source.getResourceResolver().create(targetParent, source.getName(), targetProperties);\n         }\n-        updateReplicationProperties(source, null, answer);\n-        return answer;\n+\n+        try {\n+            log.trace(\"Copy Resource: '{}' to Target: '{}'\", resource.getPath(), targetParent.getPath());\n+            final Resource copy = performFlatSafeCopy(resourceResolver, resource, targetParent, pathMapping::get);\n+            markAsActivated(resource, copy);\n+            resourceList.add(copy);\n+        } catch (final PersistenceException e) {\n+            log.error(\"Failed to replicate resource: '{}' -> ignored\", resource, e);\n+        }\n+\n+        handledSources.add(resource);\n+        return true;\n+    }\n+\n+    private String getTargetPath(final Resource resource) {\n+        return getTargetPath(resource.getPath());\n+    }\n+\n+    private String getTargetPath(final String path) {\n+        if (StringUtils.startsWith(path, localSourceWithSlash)) {\n+            return StringUtils.replaceFirst(path, localSource, localTarget);\n+        }\n+\n+        return null;\n     }\n+\n }"
  },
  {
    "sha": "2da71daf1363e4bf0d356485b2b840a522b12b4f",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/impl/PerReplicableImpl.java",
    "status": "modified",
    "additions": 11,
    "deletions": 63,
    "changes": 74,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/PerReplicableImpl.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/PerReplicableImpl.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/impl/PerReplicableImpl.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -2,35 +2,23 @@\n \n import com.peregrine.adaption.impl.PerBaseImpl;\n import com.peregrine.replication.PerReplicable;\n-import com.peregrine.commons.util.PerUtil;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.sling.api.resource.ModifiableValueMap;\n-import org.apache.sling.api.resource.PersistenceException;\n import org.apache.sling.api.resource.Resource;\n import org.apache.sling.api.resource.ValueMap;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import javax.jcr.Node;\n-import javax.jcr.RepositoryException;\n-import javax.jcr.nodetype.NodeType;\n-import java.util.*;\n+import java.util.Calendar;\n+import java.util.Optional;\n \n import static com.peregrine.commons.util.PerConstants.*;\n \n public class PerReplicableImpl extends PerBaseImpl implements PerReplicable {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(PerReplicableImpl.class);\n+    private final ValueMap vm;\n \n-    private ValueMap vm;\n-    private ModifiableValueMap modifiableValueMap;\n-\n-    public PerReplicableImpl(Resource resource) {\n+    public PerReplicableImpl(final Resource resource) {\n         super(resource);\n         vm = Optional.ofNullable(getProperties())\n                 .orElseGet(resource::getValueMap);\n-        modifiableValueMap = Optional.ofNullable(getModifiableProperties())\n-                .orElseGet(() -> resource.adaptTo(ModifiableValueMap.class));\n     }\n \n     private <T> T getProperty(final String name, final Class<T> type) {\n@@ -41,8 +29,13 @@ private String getStringProperty(final String name) {\n         return getProperty(name, String.class);\n     }\n \n-    private Calendar getCalendarProperty(String jcrLastModified) {\n-        return getProperty(jcrLastModified, Calendar.class);\n+    private Calendar getCalendarProperty(String name) {\n+        return getProperty(name, Calendar.class);\n+    }\n+\n+    @Override\n+    public Resource getMainResource() {\n+        return Optional.ofNullable(getContentResource()).orElseGet(this::getResource);\n     }\n \n     /**\n@@ -90,49 +83,4 @@ public String getLastReplicationAction(){\n         return getStringProperty(PER_REPLICATION_LAST_ACTION);\n     }\n \n-    @Override\n-    public boolean ensureReplicableMixin() {\n-        final Resource resource = hasContent() ? getContentResource() : getResource();\n-        if (PerUtil.isPrimaryType(resource, NT_UNSTRUCTURED,\n-                ASSET_CONTENT_TYPE,\n-                \"per:NpmPackageConfig\",\n-                OBJECT_PRIMARY_TYPE,\n-                OBJECT_DEFINITION_PRIMARY_TYPE,\n-                PAGE_PRIMARY_TYPE,\n-                PAGE_CONTENT_TYPE)) {\n-            return true;\n-        }\n-        final Node node = resource.adaptTo(Node.class);\n-        try {\n-            if (!Arrays.stream(node.getMixinNodeTypes())\n-                    .map(NodeType::getName)\n-                    .anyMatch(PER_REPLICATION::equals)) {\n-                node.addMixin(PER_REPLICATION);\n-                node.getSession().save();\n-            }\n-\n-            return true;\n-        } catch (final RepositoryException e) {\n-            return false;\n-        }\n-    }\n-\n-    @Override\n-    public void setLastReplicationActionAsActivated() {\n-        setLastAction(ACTIVATED);\n-    }\n-\n-    @Override\n-    public void setLastReplicationActionAsDeactivated(){\n-        setLastAction(DEACTIVATED);\n-    }\n-\n-    private void setLastAction(String value){\n-        this.modifiableValueMap.put(PER_REPLICATION_LAST_ACTION, value);\n-        try {\n-            this.getResource().getResourceResolver().commit();\n-        } catch (PersistenceException e) {\n-            LOG.error(\"Could not set replication status to pending\", e);\n-        }\n-    }\n }"
  },
  {
    "sha": "cfffd843cf7f2269502352d895976c9c5f15977d",
    "filename": "platform/base/core/src/main/java/com/peregrine/replication/impl/ReplicationsContainerWithDefaultImpl.java",
    "status": "modified",
    "additions": 1,
    "deletions": 4,
    "changes": 5,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/ReplicationsContainerWithDefaultImpl.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/main/java/com/peregrine/replication/impl/ReplicationsContainerWithDefaultImpl.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/main/java/com/peregrine/replication/impl/ReplicationsContainerWithDefaultImpl.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -48,8 +48,6 @@\n )\n public final class ReplicationsContainerWithDefaultImpl implements ReplicationsContainerWithDefault {\n \n-    public static final String DEFAULT_REPL = \"defaultRepl\";\n-\n     @Reference\n     private ReplicationsContainer replications;\n \n@@ -67,8 +65,7 @@ public Replication get(final String name) {\n \n     @Override\n     public Replication getDefault() {\n-        return Optional.of(DEFAULT_REPL)\n-                .map(this::get)\n+        return Optional.ofNullable(get(\"defaultRepl\"))\n                 .orElse(defaultReplicationMapper);\n     }\n "
  },
  {
    "sha": "02abbd0ce79b786efa4dac5b1141a204dcfb3343",
    "filename": "platform/base/core/src/test/java/com/peregrine/replication/ReplicationUtilTest.java",
    "status": "added",
    "additions": 108,
    "deletions": 0,
    "changes": 108,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/ReplicationUtilTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/ReplicationUtilTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/replication/ReplicationUtilTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,108 @@\n+package com.peregrine.replication;\n+\n+import com.peregrine.SlingResourcesTest;\n+import com.peregrine.mock.PageContentMock;\n+import com.peregrine.mock.PageMock;\n+import com.peregrine.replication.impl.PerReplicableImpl;\n+import org.apache.sling.api.resource.Resource;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+\n+import static com.peregrine.commons.util.PerConstants.*;\n+import static com.peregrine.mock.MockTools.setParentChildRelationships;\n+import static org.apache.commons.lang3.StringUtils.EMPTY;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.when;\n+\n+public final class ReplicationUtilTest extends SlingResourcesTest {\n+\n+    private static final String ADMIN = \"admin\";\n+    private static final String TARGET_PATH = \"/live/page\";\n+\n+    private final PageMock target = new PageMock();\n+    private final PageContentMock targetContent = target.getContent();\n+\n+    @Before\n+    public void setUp() {\n+        ReplicationUtil.setReplicationPrimaryNodeTypes(Arrays.asList(\n+                PAGE_PRIMARY_TYPE,\n+                PAGE_CONTENT_TYPE\n+        ));\n+        when(resourceResolver.getUserID()).thenReturn(ADMIN);\n+        target.setPath(TARGET_PATH);\n+        setParentChildRelationships(repo.getLive(), target);\n+    }\n+\n+    private void assertNoProps() {\n+        assertNull(jcrContent.getProperty(PER_REPLICATED_BY));\n+        final PerReplicable replicable = new PerReplicableImpl(page);\n+        assertNull(replicable.getReplicated());\n+        assertNull(replicable.getLastReplicationAction());\n+        assertNull(replicable.getReplicationRef());\n+    }\n+\n+    private void assertActivated() {\n+        assertEquals(ADMIN, jcrContent.getProperty(PER_REPLICATED_BY));\n+        final PerReplicable replicable = new PerReplicableImpl(page);\n+        assertNotNull(replicable.getReplicated());\n+        assertEquals(ACTIVATED, replicable.getLastReplicationAction());\n+        assertEquals(TARGET_PATH, replicable.getReplicationRef());\n+    }\n+\n+    private void assertDeactivated() {\n+        assertEquals(ADMIN, jcrContent.getProperty(PER_REPLICATED_BY));\n+        final PerReplicable replicable = new PerReplicableImpl(page);\n+        assertNotNull(replicable.getReplicated());\n+        assertEquals(DEACTIVATED, replicable.getLastReplicationAction());\n+        assertNull(replicable.getReplicationRef());\n+    }\n+\n+    @Test\n+    public void markAsActivated_path() {\n+        ReplicationUtil.markAsActivated(jcrContent, EMPTY);\n+        assertNoProps();\n+        ReplicationUtil.markAsActivated(jcrContent, TARGET_PATH);\n+        assertActivated();\n+    }\n+\n+    @Test\n+    public void markAsActivated_page() {\n+        ReplicationUtil.markAsActivated(jcrContent, (Resource) null);\n+        assertNoProps();\n+        ReplicationUtil.markAsActivated(jcrContent, targetContent);\n+        assertActivated();\n+    }\n+\n+    @Test\n+    public void markAsDeactivated() {\n+        ReplicationUtil.markAsDeactivated(jcrContent);\n+        assertDeactivated();\n+    }\n+\n+    @Test\n+    public void updateReplicationProperties_deactivate() {\n+        ReplicationUtil.updateReplicationProperties(null, null, null);\n+        assertNoProps();\n+        ReplicationUtil.updateReplicationProperties(jcrContent, null, null);\n+        assertDeactivated();\n+        ReplicationUtil.updateReplicationProperties(jcrContent, TARGET_PATH, null);\n+        assertActivated();\n+        ReplicationUtil.updateReplicationProperties(jcrContent, null, targetContent);\n+        assertActivated();\n+    }\n+\n+    @Test\n+    public void updateReplicationProperties_path() {\n+        ReplicationUtil.updateReplicationProperties(jcrContent, TARGET_PATH, null);\n+        assertActivated();\n+    }\n+\n+    @Test\n+    public void updateReplicationProperties_page() {\n+        ReplicationUtil.updateReplicationProperties(jcrContent, null, targetContent);\n+        assertActivated();\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "bd2aeaf3dbca3baf2eae15563c402ffe2eeea635",
    "filename": "platform/base/core/src/test/java/com/peregrine/replication/impl/LocalFileSystemReplicationServiceTest.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/impl/LocalFileSystemReplicationServiceTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/impl/LocalFileSystemReplicationServiceTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/replication/impl/LocalFileSystemReplicationServiceTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,63 @@\n+package com.peregrine.replication.impl;\n+\n+import com.peregrine.SlingResourcesTest;\n+import com.peregrine.render.RenderService;\n+import com.peregrine.replication.Replication;\n+import com.peregrine.replication.impl.LocalFileSystemReplicationService.Configuration;\n+import junitx.util.PrivateAccessor;\n+import org.apache.sling.api.resource.Resource;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.osgi.framework.BundleContext;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public final class LocalFileSystemReplicationServiceTest extends SlingResourcesTest {\n+\n+    private final BundleContext context = mock(BundleContext.class);\n+    private final Configuration config = mock(Configuration.class);\n+    private final RenderService renderService = mock(RenderService.class);\n+\n+    private final LocalFileSystemReplicationService model = new LocalFileSystemReplicationService();\n+\n+    @Rule\n+    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+    @Before\n+    public void setUp() throws IOException, NoSuchFieldException {\n+        final File root = temporaryFolder.newFolder(\"staticreplication\");\n+        when(config.name()).thenReturn(root.getName());\n+        when(config.targetFolder()).thenReturn(root.getPath());\n+        when(config.exportExtensions()).thenReturn(new String[]{\n+                \"data.json=per:Page|per:Template\",\n+                \"infinity.json=per:Object\",\n+                \"html=per:Page|per:Template\",\n+                \"*~raw=nt:file\",\n+                \"css=per:Site|per:FeLib\",\n+                \"js=per:Site|per:FeLib\"\n+        });\n+        PrivateAccessor.setField(model, \"renderService\", renderService);\n+        model.activate(context, config);\n+    }\n+\n+    @Test\n+    public void replicate() throws Replication.ReplicationException {\n+        final var result = model.replicate(\n+                resources.stream()\n+                .map(m -> (Resource)m)\n+                .collect(Collectors.toList())\n+        );\n+        assertTrue(result.contains(repo.getContent()));\n+        assertTrue(result.contains(parent));\n+        assertTrue(result.contains(page));\n+    }\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "2b4443c88483997fc8091233c1c4b71bcfda6169",
    "filename": "platform/base/core/src/test/java/com/peregrine/replication/impl/PerReplicableImplTest.java",
    "status": "added",
    "additions": 59,
    "deletions": 0,
    "changes": 59,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/impl/PerReplicableImplTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/replication/impl/PerReplicableImplTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/replication/impl/PerReplicableImplTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,59 @@\n+package com.peregrine.replication.impl;\n+\n+import com.peregrine.SlingResourcesTest;\n+import org.junit.Test;\n+\n+import java.util.Calendar;\n+\n+import static com.peregrine.commons.util.PerConstants.*;\n+import static org.junit.Assert.*;\n+\n+public final class PerReplicableImplTest extends SlingResourcesTest {\n+\n+    private final PerReplicableImpl model = new PerReplicableImpl(page);\n+\n+    @Test\n+    public void getMainResource() {\n+        assertEquals(jcrContent, model.getMainResource());\n+    }\n+\n+    @Test\n+    public void isReplicated() {\n+        assertFalse(model.isReplicated());\n+        jcrContent.putProperty(PER_REPLICATION_REF, \"ref\");\n+        assertTrue(model.isReplicated());\n+    }\n+\n+    @Test\n+    public void getReplicated() {\n+        assertNull(model.getReplicated());\n+        final Calendar time = Calendar.getInstance();\n+        jcrContent.putProperty(PER_REPLICATED, time);\n+        assertEquals(time, model.getReplicated());\n+    }\n+\n+    @Test\n+    public void isStale() {\n+        assertFalse(model.isStale());\n+        final Calendar replicated = Calendar.getInstance();\n+        jcrContent.putProperty(PER_REPLICATED, replicated);\n+        final Calendar modified = Calendar.getInstance();\n+        modified.setTimeInMillis(replicated.getTimeInMillis() + 1);\n+        jcrContent.putProperty(JCR_LAST_MODIFIED, modified);\n+        assertTrue(model.isStale());\n+    }\n+\n+    @Test\n+    public void getReplicationRef() {\n+        assertNull(model.getReplicationRef());\n+        jcrContent.putProperty(PER_REPLICATION_REF, \"ref\");\n+        assertNotNull(model.getReplicationRef());\n+    }\n+\n+    @Test\n+    public void getLastReplicationAction() {\n+        assertNull(model.getLastReplicationAction());\n+        jcrContent.putProperty(PER_REPLICATION_LAST_ACTION, \"activate\");\n+        assertNotNull(model.getLastReplicationAction());\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "4c8297e27b79635a2a05aaffb2dfff3c194ef367",
    "filename": "platform/base/core/src/test/java/com/peregrine/sitemap/PageRecognizerBaseTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/PageRecognizerBaseTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/PageRecognizerBaseTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/sitemap/PageRecognizerBaseTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -7,7 +7,6 @@\n import org.mockito.runners.MockitoJUnitRunner;\r\n \r\n import static com.peregrine.commons.util.PerConstants.EXCLUDE_TREE_FROM_SITEMAP;\r\n-import static com.peregrine.commons.util.PerConstants.JCR_PRIMARY_TYPE;\r\n import static com.peregrine.commons.util.PerConstants.SLING_RESOURCE_TYPE;\r\n import static org.junit.Assert.assertFalse;\r\n import static org.junit.Assert.assertTrue;\r\n@@ -24,6 +23,8 @@\n \r\n     protected PageRecognizerBaseTest(final PageRecognizerBase model) {\r\n         this.model = model;\r\n+        page.removeProperty(SLING_RESOURCE_TYPE);\r\n+        page.getContent().removeProperty(SLING_RESOURCE_TYPE);\r\n     }\r\n \r\n     public PageRecognizerBaseTest() {\r\n@@ -38,13 +39,13 @@ protected boolean isPageImpl(final Page candidate) {\n     @Test\r\n     public void isPage() {\r\n         assertFalse(model.isPage(candidate));\r\n-        parent.putProperty(JCR_PRIMARY_TYPE, model.getPagePrimaryType());\r\n+        parent.setPrimaryType(model.getPagePrimaryType());\r\n         assertFalse(model.isPage(new Page(parent)));\r\n-        page.putProperty(JCR_PRIMARY_TYPE, model.getPagePrimaryType());\r\n+        page.setPrimaryType(model.getPagePrimaryType());\r\n         assertFalse(model.isPage(candidate));\r\n         jcrContent.setPrimaryType(model.getPageContentPrimaryType());\r\n         assertFalse(model.isPage(candidate));\r\n-        page.putProperty(SLING_RESOURCE_TYPE, RESOURCE_TYPE);\r\n+        page.setResourceType(RESOURCE_TYPE);\r\n         assertTrue(model.isPage(candidate));\r\n         page.putProperty(model.getExcludeFromSiteMapPropertyName(), true);\r\n         assertFalse(model.isPage(candidate));\r"
  },
  {
    "sha": "418c9d614389060be97534098b6ee9c5fc5022e3",
    "filename": "platform/base/core/src/test/java/com/peregrine/sitemap/impl/NonEmptyPerPageRecognizerTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/impl/NonEmptyPerPageRecognizerTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/impl/NonEmptyPerPageRecognizerTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/sitemap/impl/NonEmptyPerPageRecognizerTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -20,8 +20,8 @@ public NonEmptyPerPageRecognizerTest() {\n     @Test\r\n     public void isPage() {\r\n         super.isPage();\r\n-        parent.putProperty(JCR_PRIMARY_TYPE, model.getPagePrimaryType());\r\n-        parent.putProperty(SLING_RESOURCE_TYPE, RESOURCE_TYPE);\r\n+        parent.setPrimaryType(model.getPagePrimaryType());\r\n+        parent.setResourceType(RESOURCE_TYPE);\r\n         assertFalse(model.isPage(new Page(parent)));\r\n     }\r\n \r"
  },
  {
    "sha": "dff3c01827c88c879edd2aab80476bea665d8e46",
    "filename": "platform/base/core/src/test/java/com/peregrine/sitemap/impl/SiteMapUrlBuilderImplTest.java",
    "status": "modified",
    "additions": 7,
    "deletions": 8,
    "changes": 15,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/impl/SiteMapUrlBuilderImplTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/base/core/src/test/java/com/peregrine/sitemap/impl/SiteMapUrlBuilderImplTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/base/core/src/test/java/com/peregrine/sitemap/impl/SiteMapUrlBuilderImplTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -7,7 +7,6 @@\n import org.mockito.runners.MockitoJUnitRunner;\r\n \r\n import static org.junit.Assert.assertEquals;\r\n-import static org.mockito.Mockito.when;\r\n \r\n @RunWith(MockitoJUnitRunner.class)\r\n public final class SiteMapUrlBuilderImplTest extends SlingResourcesTest {\r\n@@ -22,18 +21,18 @@ public void buildSiteMapUrl() {\n \r\n     @Test\r\n     public void getIndex() {\r\n-        when(requestPathInfo.getExtension()).thenReturn(SiteMapConstants.XML);\r\n-        setSelectors((String[])null);\r\n+        request.setExtension(SiteMapConstants.XML);\r\n+        request.setSelectors((String[])null);\r\n         assertEquals(0, model.getIndex(request));\r\n-        setSelectorsString(\"sitemap\");\r\n+        request.setSelectorsString(\"sitemap\");\r\n         assertEquals(0, model.getIndex(request));\r\n-        setSelectorsString(\"sitemap.0\");\r\n+        request.setSelectorsString(\"sitemap.0\");\r\n         assertEquals(0, model.getIndex(request));\r\n-        setSelectorsString(\"sitemap.1\");\r\n+        request.setSelectorsString(\"sitemap.1\");\r\n         assertEquals(1, model.getIndex(request));\r\n-        setSelectorsString(\"sitemap.x\");\r\n+        request.setSelectorsString(\"sitemap.x\");\r\n         assertEquals(-1, model.getIndex(request));\r\n-        setSelectorsString(\"sitemap..x\");\r\n+        request.setSelectorsString(\"sitemap..x\");\r\n         assertEquals(0, model.getIndex(request));\r\n     }\r\n \r"
  },
  {
    "sha": "ecb754d800c5f39f814deea3f85d7e18c2bf6fe7",
    "filename": "platform/commons/src/main/java/com/peregrine/commons/IOUtils.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/IOUtils.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/IOUtils.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/main/java/com/peregrine/commons/IOUtils.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,47 @@\n+package com.peregrine.commons;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+\n+import static java.util.Objects.isNull;\n+\n+public final class IOUtils {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(IOUtils.class);\n+\n+    public static final String FAILED_TO_DELETE_FILE = \"Failed to delete file: '%s'\";\n+\n+    public static File createChildDirectory(final File parent, final String... namesToChooseFrom) {\n+        if (isNull(namesToChooseFrom) || namesToChooseFrom.length == 0) {\n+            return null;\n+        }\n+\n+        int i = 0;\n+        File result = new File(parent, namesToChooseFrom[i]);\n+        while (result.exists() && !result.isDirectory() && ++i < namesToChooseFrom.length) {\n+            result = new File(parent, namesToChooseFrom[i]);\n+        }\n+\n+        if ((result.exists() && result.isDirectory()) || result.mkdir()) {\n+            return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    public static boolean deleteFileOrDirectory(final File file) {\n+        if (file.isDirectory()) {\n+            for (final File child: file.listFiles()) {\n+                if(!deleteFileOrDirectory(child)) {\n+                    LOGGER.warn(String.format(FAILED_TO_DELETE_FILE, file.getAbsolutePath()));\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return file.delete();\n+    }\n+\n+}"
  },
  {
    "sha": "b43f05da18d1a9cedca1846da62afe34c1836646",
    "filename": "platform/commons/src/main/java/com/peregrine/commons/ResourceUtils.java",
    "status": "modified",
    "additions": 39,
    "deletions": 2,
    "changes": 41,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/ResourceUtils.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/ResourceUtils.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/main/java/com/peregrine/commons/ResourceUtils.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -6,13 +6,14 @@\n import org.apache.sling.api.resource.*;\n \n import java.util.*;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static com.peregrine.commons.Strings.COLON;\n import static com.peregrine.commons.Strings._SCORE;\n-import static com.peregrine.commons.util.PerConstants.JCR_PRIMARY_TYPE;\n-import static com.peregrine.commons.util.PerConstants.SLASH;\n+import static com.peregrine.commons.util.PerConstants.*;\n import static java.util.Objects.isNull;\n+import static java.util.Objects.nonNull;\n import static org.apache.commons.lang3.StringUtils.contains;\n import static org.apache.commons.lang3.StringUtils.isBlank;\n import static org.apache.commons.lang3.StringUtils.isNotBlank;\n@@ -196,6 +197,42 @@ public static Resource performFlatSafeCopy(\n         return resourceResolver.create(targetParent, name, getCopyableProperties(resource));\n     }\n \n+    /**\n+     * Copy of a Single Resource rather than the ResourceResolver's copy which copies the entire sub tree\n+     *\n+     * @param resource Source to be copied\n+     * @param targetParent Parent Resource which the copy will be added to\n+     * @param pathMapping Path Mappings used to check and rewrite references\n+     * @return The newly created (copied) resource\n+     *\n+     * @throws PersistenceException If the resource could not be created like it already exists or parent missing\n+     */\n+    public static Resource performFlatSafeCopy(\n+            final ResourceResolver resourceResolver,\n+            final Resource resource,\n+            final Resource targetParent,\n+            final Function<Object, String> pathMapping\n+    ) throws PersistenceException {\n+        final String name = resource.getName();\n+        final Resource answer = targetParent.getChild(name);\n+        if (nonNull(answer)) {\n+            return answer;\n+        }\n+\n+        final Map<String, Object> properties = Optional.ofNullable(resource)\n+                .map(ResourceUtils::getCopyableProperties)\n+                .orElseGet(Collections::emptyMap);\n+        for (final Map.Entry<String, Object> e : properties.entrySet()) {\n+            Optional.ofNullable(e.getValue())\n+                    .filter(v -> v instanceof String)\n+                    .map(String.class::cast)\n+                    .map(pathMapping)\n+                    .ifPresent(e::setValue);\n+        }\n+\n+        return resourceResolver.create(targetParent, name, properties);\n+    }\n+\n     public static Resource performDeepSafeCopy(\n             final ResourceResolver resourceResolver,\n             final Resource resource,"
  },
  {
    "sha": "f818947a04e31339353ca2b2b9c8b0b1714d7a6b",
    "filename": "platform/commons/src/main/java/com/peregrine/commons/util/PerUtil.java",
    "status": "modified",
    "additions": 15,
    "deletions": 8,
    "changes": 23,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/util/PerUtil.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/main/java/com/peregrine/commons/util/PerUtil.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/main/java/com/peregrine/commons/util/PerUtil.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -348,6 +348,21 @@ public static boolean isJcrContent(final Resource resource) {\n         return PerConstants.JCR_CONTENT.equals(resource.getName());\n     }\n \n+    private static boolean isDescendantOfJcrContent(final String path) {\n+        return StringUtils.contains(path, SLASH + JCR_CONTENT + SLASH);\n+    }\n+\n+    public static boolean isJcrContentOrDescendant(final String path) {\n+        return isJcrContent(path) || isDescendantOfJcrContent(path);\n+    }\n+\n+    public static boolean isJcrContentOrDescendant(final Resource resource) {\n+        return Optional.ofNullable(resource)\n+                .map(Resource::getPath)\n+                .map(PerUtil::isJcrContentOrDescendant)\n+                .orElse(false);\n+    }\n+\n     public static Resource getJcrContent(final Resource resource) {\n         if (isJcrContent(resource)) {\n             return resource;\n@@ -356,14 +371,6 @@ public static Resource getJcrContent(final Resource resource) {\n         return getProperJcrContent(resource);\n     }\n \n-    public static String getJcrContent(final String path) {\n-        if (isJcrContent(path)) {\n-            return path;\n-        }\n-\n-        return path + SLASH + PerConstants.JCR_CONTENT;\n-    }\n-\n     public static Resource getProperJcrContent(final Resource resource) {\n         return resource.getChild(PerConstants.JCR_CONTENT);\n     }"
  },
  {
    "sha": "1782a591b11028057debf2a94b37986e17a9a61f",
    "filename": "platform/commons/src/test/java/com/peregrine/SlingResourcesTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 35,
    "changes": 40,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/SlingResourcesTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/SlingResourcesTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/test/java/com/peregrine/SlingResourcesTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -1,26 +1,16 @@\n package com.peregrine;\n \n-import com.peregrine.mock.PageMock;\n-import com.peregrine.mock.RepoMock;\n-import com.peregrine.mock.ResourceMock;\n+import com.peregrine.mock.*;\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.sling.api.SlingHttpServletRequest;\n-import org.apache.sling.api.request.RequestPathInfo;\n import org.apache.sling.api.resource.ResourceResolver;\n-import org.mockito.Mockito;\n \n import java.util.Arrays;\n import java.util.List;\n import java.util.stream.Collectors;\n \n-import static com.peregrine.commons.Chars.DOT;\n import static com.peregrine.commons.util.PerConstants.*;\n import static com.peregrine.mock.MockTools.*;\n-import static org.apache.commons.lang3.StringUtils.EMPTY;\n-import static org.apache.commons.lang3.StringUtils.isNotBlank;\n-import static org.apache.commons.lang3.StringUtils.substringAfter;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n+import static org.apache.commons.lang3.StringUtils.*;\n \n public class SlingResourcesTest {\n \n@@ -33,13 +23,12 @@\n \n     protected final ResourceMock parent = new ResourceMock(\"Parent\");\n     protected final PageMock page = new PageMock(\"Page\");\n-    protected final ResourceMock jcrContent = page.getContent();\n+    protected final PageContentMock jcrContent = page.getContent();\n     protected final ResourceMock resource = new ResourceMock(\"Resource\");\n \n     protected final PageMock component = new PageMock(\"Per Component\");\n \n-    protected final SlingHttpServletRequest request = mock(SlingHttpServletRequest.class, fullName(this, \"Request\"));\n-    protected final RequestPathInfo requestPathInfo = Mockito.mock(RequestPathInfo.class);\n+    protected final SlingHttpServletRequestMock request = new SlingHttpServletRequestMock(fullName(this, \"Request\"));\n \n     protected final RepoMock repo;\n     protected final ResourceMock contentRoot;\n@@ -76,7 +65,7 @@ public SlingResourcesTest(final RepoMock repo, final String rootPath) {\n         component.setPath(SLASH_APPS_SLASH + RESOURCE_TYPE);\n         resource.setResourceType(RESOURCE_TYPE);\n         init(component);\n-        bindRequest();\n+        request.bind(resource);\n     }\n \n     public SlingResourcesTest(final String rootPath) {\n@@ -87,15 +76,6 @@ public SlingResourcesTest() {\n         this(CONTENT_ROOT);\n     }\n \n-    private void bindRequest() {\n-        when(request.getResource()).thenReturn(resource);\n-        when(request.getResourceResolver()).thenReturn(resourceResolver);\n-        when(request.getRequestPathInfo()).thenReturn(requestPathInfo);\n-        final String path = resource.getPath();\n-        when(requestPathInfo.getResourcePath()).thenReturn(path);\n-        when(requestPathInfo.getExtension()).thenReturn(HTML);\n-    }\n-\n     protected <Mock extends ResourceMock> Mock init(final Mock mock) {\n         return repo.init(mock);\n     }\n@@ -104,14 +84,4 @@ protected PageMock init(final PageMock mock) {\n         return repo.init(mock);\n     }\n \n-    protected void setSelectors(final String... selectors) {\n-        when(requestPathInfo.getSelectors()).thenReturn(selectors);\n-        when(requestPathInfo.getSelectorString()).thenReturn(StringUtils.join(selectors, DOT));\n-    }\n-\n-    protected void setSelectorsString(final String selectorsString) {\n-        when(requestPathInfo.getSelectors()).thenReturn(selectorsString.split(\"\\\\.\"));\n-        when(requestPathInfo.getSelectorString()).thenReturn(selectorsString);\n-    }\n-\n }"
  },
  {
    "sha": "0737da1c14edd805a7e12873a91139e21465283e",
    "filename": "platform/commons/src/test/java/com/peregrine/commons/IOUtilsTest.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/commons/IOUtilsTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/commons/IOUtilsTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/test/java/com/peregrine/commons/IOUtilsTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,44 @@\n+package com.peregrine.commons;\r\n+\r\n+import org.junit.Before;\r\n+import org.junit.Rule;\r\n+import org.junit.Test;\r\n+import org.junit.rules.TemporaryFolder;\r\n+import org.junit.runner.RunWith;\r\n+import org.mockito.runners.MockitoJUnitRunner;\r\n+\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+\r\n+import static org.junit.Assert.*;\r\n+\r\n+@RunWith(MockitoJUnitRunner.class)\r\n+public final class IOUtilsTest {\r\n+\r\n+    @Rule\r\n+    public final TemporaryFolder temporaryFolder = new TemporaryFolder();\r\n+\r\n+    private File dir;\r\n+\r\n+    @Before\r\n+    public void setUp() throws IOException {\r\n+        dir = temporaryFolder.newFolder(\"dir\");\r\n+        temporaryFolder.newFile(\"dir/file.txt\");\r\n+    }\r\n+\r\n+    @Test\r\n+    public void createChildDirectory() {\r\n+        assertNull(IOUtils.createChildDirectory(dir));\r\n+        assertNull(IOUtils.createChildDirectory(dir, (String[]) null));\r\n+        assertNull(IOUtils.createChildDirectory(dir, \"file.txt\"));\r\n+        final File child = IOUtils.createChildDirectory(this.dir, \"file.txt\", \"child\");\r\n+        assertNotNull(child);\r\n+        assertEquals(\"child\", child.getName());\r\n+    }\r\n+\r\n+    @Test\r\n+    public void deleteFileOrDirectory() {\r\n+        assertTrue(IOUtils.deleteFileOrDirectory(dir));\r\n+    }\r\n+\r\n+}\r"
  },
  {
    "sha": "bc69069c5dd036675743db139979fc08778c1de4",
    "filename": "platform/commons/src/test/java/com/peregrine/commons/ResourceUtilsTest.java",
    "status": "modified",
    "additions": 14,
    "deletions": 2,
    "changes": 16,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/commons/ResourceUtilsTest.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/commons/ResourceUtilsTest.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/test/java/com/peregrine/commons/ResourceUtilsTest.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -9,8 +9,7 @@\n import org.mockito.runners.MockitoJUnitRunner;\r\n \r\n import static org.junit.Assert.assertEquals;\r\n-import static org.mockito.Matchers.any;\r\n-import static org.mockito.Matchers.eq;\r\n+import static org.junit.Assert.assertNotNull;\r\n import static org.mockito.Mockito.when;\r\n \r\n @RunWith(MockitoJUnitRunner.class)\r\n@@ -56,4 +55,17 @@ public void getOrCreateResource_resourceGetsCreated() throws PersistenceExceptio\n         assertEquals(this.resource, resource);\r\n     }\r\n \r\n+    @Test\r\n+    public void performFlatSafeCopy_targetExists() throws PersistenceException {\r\n+        final Resource copy = ResourceUtils.performFlatSafeCopy(resourceResolver, resource, jcrContent, Object::toString);\r\n+        assertEquals(resource, copy);\r\n+    }\r\n+\r\n+    @Test\r\n+    public void performFlatSafeCopy_newTarget() throws PersistenceException {\r\n+        repo.mockResourceResolverCreate();\r\n+        final Resource copy = ResourceUtils.performFlatSafeCopy(resourceResolver, resource, parent, Object::toString);\r\n+        assertNotNull(copy);\r\n+    }\r\n+\r\n }\r"
  },
  {
    "sha": "5d1c350721eab31cb79a9096dc26f2e53cefbb36",
    "filename": "platform/commons/src/test/java/com/peregrine/mock/PageContentMock.java",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/mock/PageContentMock.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/mock/PageContentMock.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/test/java/com/peregrine/mock/PageContentMock.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -0,0 +1,20 @@\n+package com.peregrine.mock;\r\n+\r\n+import javax.jcr.RepositoryException;\r\n+\r\n+import static com.peregrine.commons.util.PerConstants.PAGE_CONTENT_TYPE;\r\n+import static com.peregrine.commons.util.PerConstants.PER_REPLICATION;\r\n+import static org.mockito.Mockito.when;\r\n+\r\n+public class PageContentMock extends ResourceMock {\r\n+\r\n+    public PageContentMock(final String name) {\r\n+        super(name);\r\n+        setPrimaryType(PAGE_CONTENT_TYPE);\r\n+        setResourceType(PAGE_CONTENT_TYPE);\r\n+        try {\r\n+            when(node.canAddMixin(PER_REPLICATION)).thenReturn(true);\r\n+        } catch (final RepositoryException e) { }\r\n+    }\r\n+\r\n+}\r"
  },
  {
    "sha": "511a2e729d5f90c72162566c4d2ef21eb1d323af",
    "filename": "platform/commons/src/test/java/com/peregrine/mock/PageMock.java",
    "status": "modified",
    "additions": 11,
    "deletions": 9,
    "changes": 20,
    "blob_url": "https://github.com/headwirecom/peregrine-cms/blob/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/mock/PageMock.java",
    "raw_url": "https://github.com/headwirecom/peregrine-cms/raw/146adc8ed308a1dda56ad18bbe865703b77a4fe7/platform/commons/src/test/java/com/peregrine/mock/PageMock.java",
    "contents_url": "https://api.github.com/repos/headwirecom/peregrine-cms/contents/platform/commons/src/test/java/com/peregrine/mock/PageMock.java?ref=146adc8ed308a1dda56ad18bbe865703b77a4fe7",
    "patch": "@@ -1,22 +1,24 @@\n package com.peregrine.mock;\r\n \r\n-import static com.peregrine.commons.util.PerConstants.JCR_CONTENT;\r\n-import static com.peregrine.commons.util.PerConstants.PAGE_PRIMARY_TYPE;\r\n-import static com.peregrine.commons.util.PerConstants.SLASH;\r\n+import javax.jcr.RepositoryException;\r\n+\r\n+import static com.peregrine.commons.util.PerConstants.*;\r\n import static org.mockito.Mockito.when;\r\n \r\n public class PageMock extends ResourceMock {\r\n \r\n-    private final ResourceMock content;\r\n+    private final PageContentMock content;\r\n \r\n     public PageMock(final String name) {\r\n         super(name);\r\n-        content = new ResourceMock(concatenateToDerivedName(name, \"'s \", JCR_CONTENT));\r\n-        when(mock.getResourceType()).thenReturn(PAGE_PRIMARY_TYPE);\r\n-        when(mock.isResourceType(PAGE_PRIMARY_TYPE)).thenReturn(true);\r\n-\r\n+        content = new PageContentMock(concatenateToDerivedName(name, \"'s \", JCR_CONTENT));\r\n+        setPrimaryType(PAGE_PRIMARY_TYPE);\r\n+        setResourceType(PAGE_PRIMARY_TYPE);\r\n         addChild(JCR_CONTENT, content);\r\n         content.setParent(this);\r\n+        try {\r\n+            when(node.canAddMixin(PER_REPLICATION)).thenReturn(true);\r\n+        } catch (final RepositoryException e) { }\r\n     }\r\n \r\n     public PageMock() {\r\n@@ -28,7 +30,7 @@ protected void setPathImpl(final String path) {\n         content.setPath(path + SLASH + JCR_CONTENT);\r\n     }\r\n \r\n-    public ResourceMock getContent() {\r\n+    public PageContentMock getContent() {\r\n         return content;\r\n     }\r\n }\r"
  }
]
