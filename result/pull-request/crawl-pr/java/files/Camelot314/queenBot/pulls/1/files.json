[
  {
    "sha": "fbcc1e516d7d12df3b916b6e510f48429c1f90ca",
    "filename": "discordBot/src/main/java/discordBot/DefaultResponse.java",
    "status": "modified",
    "additions": 30,
    "deletions": 76,
    "changes": 106,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/DefaultResponse.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/DefaultResponse.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/DefaultResponse.java?ref=727ae09665af9c79ca860f0a8800fc3171608ba1",
    "patch": "@@ -1,6 +1,5 @@\n package discordBot;\r\n \r\n-import java.util.Random;\r\n \r\n import org.javacord.api.DiscordApi;\r\n import org.javacord.api.event.message.MessageCreateEvent;\r\n@@ -12,11 +11,9 @@\n  *\r\n  */\r\n public class DefaultResponse implements Response {\r\n-\tprivate String command, response, response2;\r\n-\tprivate boolean contains, isProb;\r\n-\tprivate int odd;\r\n+\tprivate String command, response;\r\n+\tprivate boolean contains;\r\n \tprivate Executable lambda;\r\n-\tprivate static Random random;\r\n \tprivate static String helpMessage;\r\n \tprivate static String helpCommand;\r\n \tprivate static int responseCount; \r\n@@ -31,28 +28,16 @@\n \t * @param command\r\n \t * @param response\r\n \t * @param contains\r\n-\t * @param isProb\r\n-\t * @param odd\r\n+\t * @param lambda\r\n \t */\r\n-\tpublic DefaultResponse (String command, String response, String response2,\r\n-\t\t\tboolean contains, boolean isProb, int odd, Executable lambda) {\r\n-\t\t\r\n+\tpublic DefaultResponse (String command, String response, boolean contains, Executable lambda) {\r\n \t\tthis.command = command;\r\n \t\tthis.response = response;\r\n-\t\tthis.response2 = response2;\r\n \t\tthis.contains = contains;\r\n-\r\n-\t\tthis.odd = odd >= 0 ? odd : 0;\r\n-\t\tif (odd == 0) {\r\n-\t\t\tthis.isProb = false;\r\n-\t\t} else {\r\n-\t\t\tthis.isProb = true;\r\n-\t\t}\r\n \t\t\r\n \t\tif (responseCount == 0) {\r\n \t\t\thelpMessage = response;\r\n \t\t\thelpCommand = command;\r\n-\t\t\trandom = new Random();\r\n \t\t}\r\n \t\tresponseCount ++;\r\n \t\t\r\n@@ -67,20 +52,7 @@ public DefaultResponse (String command, String response, String response2,\n \t */\r\n \tpublic DefaultResponse (String command, String response,\r\n \t\t\tboolean contains) {\r\n-\t\tthis (command, response, null, contains, false, 0, null);\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Constructor\r\n-\t * @param command\r\n-\t * @param response\r\n-\t * @param contains\r\n-\t * @param function\r\n-\t */\r\n-\tpublic DefaultResponse (String command, String response, boolean contains, \r\n-\t\t\tExecutable function) {\r\n-\t\t\r\n-\t\tthis (command, response, null, contains, false, 0, function);\r\n+\t\tthis (command, response, contains, null);\r\n \t}\r\n \t\r\n \t/**\r\n@@ -93,23 +65,8 @@ public DefaultResponse (String command, String response, boolean contains,\n \t */\r\n \tpublic DefaultResponse (String command, String response, String response2,\r\n \t\t\tboolean contains, int odd) {\r\n-\t\t\r\n-\t\tthis (command, response, response2, contains, true, odd, null);\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Constructor\r\n-\t * @param command\r\n-\t * @param response\r\n-\t * @param response2\r\n-\t * @param contains\r\n-\t * @param odd\r\n-\t * @param function\r\n-\t */\r\n-\tpublic DefaultResponse (String command, String response, String response2,\r\n-\t\t\tboolean contains, int odd, Executable function) {\r\n-\t\t\r\n-\t\tthis (command, response, response2, contains, true, odd, function);\r\n+\t\tthis (command, response, contains, null);\r\n+\r\n \t}\r\n \t\r\n \t\r\n@@ -144,17 +101,21 @@ public static String getHelpStr () {\n \t\treturn helpMessage;\r\n \t}\r\n \t\r\n+\t/**\r\n+\t * Getter for the contains.\r\n+\t * @return\r\n+\t */\r\n+\tpublic boolean getContains() {\r\n+\t\treturn contains;\r\n+\t}\r\n+\t\r\n \t/**\r\n \t * Executes the lambda expression\r\n \t * @param input\r\n \t */\r\n \t@Override\r\n \tpublic String exec (DiscordApi api, MessageCreateEvent event) {\r\n-\t\tif (lambda != null) {\r\n-\t\t\treturn lambda.exec(api, event);\r\n-\t\t} else {\r\n-\t\t\treturn isCommand(event.getMessageContent(), null);\r\n-\t\t}\r\n+\t\treturn exec(api, event, null);\r\n \t}\r\n \t\r\n \t/**\r\n@@ -167,11 +128,15 @@ public String exec (DiscordApi api, MessageCreateEvent event) {\n \t */\r\n \t@Override\r\n \tpublic String exec (DiscordApi api, MessageCreateEvent event, String additonal) {\r\n-\t\tif (lambda != null) {\r\n-\t\t\treturn lambda.exec(api, event);\r\n-\t\t} else {\r\n-\t\t\treturn isCommand(event.getMessageContent(), additonal);\r\n+\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\tif ((contains && input.contains(command)) || input.equals(command)) {\r\n+\t\t\tif (lambda != null) {\r\n+\t\t\t\treturn lambda.exec(api, event);\r\n+\t\t\t} else {\r\n+\t\t\t\treturn isCommand(event.getMessageContent(), additonal);\r\n+\t\t\t}\r\n \t\t}\r\n+\t\treturn null;\r\n \t}\r\n \t\r\n \t\r\n@@ -225,27 +190,16 @@ public String toString() {\n \t * @return\r\n \t */\r\n \tprivate String isCommand(String input, String additional) {\r\n-\t\tboolean send;\r\n \t\tString toReturn = null;\r\n+\t\t\r\n+\t\tadditional = additional == null ? \"\" : additional;\r\n \t\tinput = input.toLowerCase();\r\n \t\tif (input != null) {\r\n-\t\t\tsend = contains && !input.contains(helpMessage) && input.contains(command) \r\n-\t\t\t\t\t|| input.equals(command);\r\n-\t\t\tif (input.contains(\"yes peasant\") || input.contains(\"do you want a 14th\")) {\r\n-\t\t\t\tsend = false;\r\n-\t\t\t} else if (send && !isProb) {\r\n+\t\t\tif (command.equals(helpCommand)) {\r\n+\t\t\t\ttoReturn = helpMessage;\r\n+\t\t\t\ttoReturn += additional == null ? \"\" : additional;\r\n+\t\t\t} else {\r\n \t\t\t\ttoReturn = response;\r\n-\t\t\t} else if (send && isProb) {\r\n-\t\t\t\tif (random.nextInt(odd) == 0) {\r\n-\t\t\t\t\ttoReturn =  response2;\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tif (command.equals(helpCommand)) {\r\n-\t\t\t\t\t\ttoReturn = helpMessage;\r\n-\t\t\t\t\t\ttoReturn += additional == null ? \"\" : additional;\r\n-\t\t\t\t\t} else {\r\n-\t\t\t\t\t\ttoReturn = response;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\treturn toReturn;\r"
  },
  {
    "sha": "d4ce679852cc5049a0ea3421348f86f03eff8376",
    "filename": "discordBot/src/main/java/discordBot/Queen.java",
    "status": "modified",
    "additions": 25,
    "deletions": 648,
    "changes": 673,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/Queen.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/Queen.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/Queen.java?ref=727ae09665af9c79ca860f0a8800fc3171608ba1",
    "patch": "@@ -1,31 +1,14 @@\n package discordBot;\r\n \r\n import java.awt.Color;\r\n-import java.io.FileInputStream;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n import java.util.ArrayList;\r\n import java.util.Collections;\r\n+import java.util.Random;\r\n \r\n import org.javacord.api.DiscordApi;\r\n import org.javacord.api.DiscordApiBuilder;\r\n-import org.javacord.api.entity.channel.ServerChannel;\r\n-import org.javacord.api.entity.channel.ServerVoiceChannel;\r\n-import org.javacord.api.entity.channel.ServerVoiceChannelBuilder;\r\n-import org.javacord.api.entity.channel.TextChannel;\r\n import org.javacord.api.entity.message.MessageBuilder;\r\n import org.javacord.api.entity.message.embed.EmbedBuilder;\r\n-import org.javacord.api.entity.server.Server;\r\n-import org.javacord.api.event.message.MessageCreateEvent;\r\n-\r\n-import java.util.NoSuchElementException;\r\n-import java.util.concurrent.TimeUnit;\r\n-\r\n-interface ExecServer {\r\n-\tpublic void executable(Server server);\r\n-}\r\n \r\n /**\r\n  * This is QueenBot\r\n@@ -41,152 +24,32 @@\n public class Queen {\r\n \tprivate static final String USERNAME_OF_AUTH_TERMINATOR = /* discord UserID of the person you want to have control */ null;\r\n \tprivate static final String TOKEN = /* Bot token provided by discord */ null;\r\n-\tprivate static final String SAVED_DATA_FILE = \"savedCustoms/savedData\";\r\n+\tprivate static final String HELP_COMMAND = \"!help\";\r\n \tprivate String help;\r\n \tprivate DiscordApi api;\r\n-\tprivate boolean hasActiveVoiceChannels, isRunning;\r\n-\tprivate ArrayList<VoiceChannelServer> activeVoiceServers;\r\n-\t\r\n+\tprivate boolean isRunning;\t\r\n \tprivate ArrayList<Response> responses;\r\n \tprivate ArrayList<Response> responseRelyContains;\r\n-\tprivate ArrayList<ServerCustomCommands> customs;\r\n+\tprivate static final Random RANDOM = new Random();\r\n \t\r\n \tpublic Queen() {     \r\n         \r\n-        // commands list\r\n-        String[] commands =  {\r\n-        \t\t \"!help\", \".\", \"sorry\",\r\n-                 \"i'm sorry\", \"what\", \"how u\",\r\n-                 \"i see no problem\", \"feel\", \"i'm in\",\r\n-                 \"?\", \"i\\u2014\", \"i--\",\r\n-                 \"stop\", \"*\", \"this is my 13th reason\",\r\n-                 \"my queen\", \"queenbot\"\r\n-        };\r\n-        \r\n-        // responses list\r\n-        String[] responsesStr =  {\r\n-        \t\t\"\", \"PERIODT!\", \"As you should be\",\r\n-                \"As you should be\", \"It's a secret\", \"I am in pain\",\r\n-                \"Neither do I\", \"MOOD\", \"MOOD\",\r\n-                \"Yes\", \"\\u2014I\", \"\\u2014I\",\r\n-                \"No\", null, \"Do you want a 14th?\",\r\n-                \"Yes Peasant?\", \"Yes Peasant?\"\r\n-        };\r\n-        \r\n-        /*\r\n-         * For the cases I do want the response to be random\r\n-         * I am specifying the other message that will be sent\r\n-         * as determined above. \r\n-         */\r\n-        String[] responses2Str = {\r\n-        \t\t\"I refuse\", null, null,\r\n-        \t\tnull, null, null,\r\n-        \t\tnull, null, null,\r\n-        \t\t\"No\", null, null,\r\n-        \t\tnull, \"Learn to type lol\", null,\r\n-        \t\tnull, null\r\n-        };\r\n-        \r\n-        help = \"Hello I am QueenBot\\n\"\r\n-              + \"I have a list of commands or phrases u may want to use:\\n\"\r\n-              + \"!help\" + Utilities.addSpaces(\"!help\") + \": brings up my commandments\";\r\n-        \r\n-        responsesStr[0] = help;\r\n-        \r\n-        /*\r\n-         * this specifies whether it will use the .contains() \r\n-         * string method or the .equals string method\r\n-         * basically look throughout the message or just the\r\n-         * exact equality.\r\n-         */\r\n-        boolean[] contains = {\r\n-                false, true, false,\r\n-                false, false, false,\r\n-                false, true, true,\r\n-                true, true, true,\r\n-                false, true, false,\r\n-                true, true\r\n-        };\r\n-        \r\n-        /*\r\n-         * this is needed by the responses constructor.\r\n-         * Basically this is for cases where I wanted the response\r\n-         * given back to be random. The number represents the likelihood\r\n-         * it will occur (using Random.nextInt()). 5 means next int\r\n-         * will use 5 as the max and it will happen 1 in 5. 0 means always\r\n-         * happens. \r\n-         */\r\n-        int[] odds = {\r\n-                5, 0, 0,\r\n-                0, 0, 0,\r\n-                0, 0, 0,\r\n-                2, 0, 0,\r\n-                0, 7, 0,\r\n-                0, 0\r\n-        };\r\n-        \r\n+\t\thelp = \"Hello I am QueenBot\\n\"\r\n+\t              + \"I have a list of commands or phrases u may want to use:\\n\"\r\n+\t              + \"!help\" + Utilities.addSpaces(\"!help\") + \": brings up my commandments\";        \r\n         \r\n         \r\n         // creates the arraylists.\r\n         responses = new ArrayList<>();\r\n-        activeVoiceServers = new ArrayList<>();\r\n         responseRelyContains = new ArrayList<>();\r\n         \r\n-        \r\n-        /*\r\n-         * Loops through all the arrays above and\r\n-         * creates the responses objects and adds it to the \r\n-         * responses array lists.\r\n-         */\r\n-        for (int i = 0; i < commands.length; i ++) {\r\n-        \tString displayMess = responsesStr[i];\r\n-        \tboolean admin = false;\r\n-        \tif (odds[i] != 0) {\r\n-        \t\tdisplayMess = responsesStr[i] + \" / \" + responses2Str[i];\r\n-        \t}\r\n-        \t\r\n-        \tif (displayMess == null || displayMess.contains(\"null\")) {\r\n-        \t\tdisplayMess = responses2Str[i];\r\n-        \t}\r\n-        \t\r\n-        \tif (i == 0) {\r\n-        \t\tadmin = true;\r\n-        \t}\r\n-        \taddResponse(commands[i], responsesStr[i], responses2Str[i],\r\n-        \t\t\tdisplayMess, contains[i], odds[i], admin, null);\r\n-        }\r\n-        \r\n+        addResponse(HELP_COMMAND, help, help, false, false, null);\r\n+        addResponse(\"?\", null, \"yes / no\", true, false, (api, event) -> {\r\n+\t\t\tString message = RANDOM.nextBoolean() ? \"yes\" : \"no\";\t\t\t\r\n+\t\t\tevent.getChannel().sendMessage(message);\t\t\t\r\n+\t\t\treturn null;\r\n+\t\t});\r\n         addTerminatorCommand();\r\n-        \r\n-        /*\r\n-         * Adding a custom response that executes a bit of code (that makes\r\n-         * a voice channel server when allowed and specified).\r\n-         */\r\n-        addResponse(\"fight me\", null, null, \"*Special*\", false, 0, false, \r\n-        \t\t(api, event) -> {\r\n-        \t\t\t\r\n-        \tString input = event.getMessageContent().toLowerCase();\r\n-        \tif (input.equals(\"fight me\")) {\r\n-        \t\tServer server = getServer(event);\r\n-    \t\t\tif (server != null) {\r\n-    \t\t\t\tif (server.canYouCreateChannels()) {\r\n-    \t\t\t\t\tevent.getChannel().sendMessage(\"Join the rig then\");\r\n-        \t\t\t\taddVoice(api, server.getId(), event.getChannel().getId());\r\n-    \t\t\t\t} else {\r\n-    \t\t\t\t\tevent.getChannel().sendMessage(\"I am not allowed to\");\r\n-    \t\t\t\t}\r\n-    \t\t\t}\r\n-        \t}\r\n-\t\t\t\r\n-        \treturn null;\r\n-        });\r\n-        \r\n-        addCustomCommands();\r\n-        addCustomHelperCommands();\r\n-        \r\n-        \r\n-\t\tcustoms = new ArrayList<>();\r\n-\t\tloadCustoms();\r\n \t}\r\n \r\n \t\r\n@@ -208,21 +71,22 @@ public Queen() {\n \t * @throws IllegalArgumentException if command is null or both responses and\r\n \t * lambda are null.\r\n \t */\r\n-\tpublic void addResponse(String command, String response, String response2, \r\n-\t\t\tString displayMes, boolean contains, int odd, boolean adminOnly, \r\n-\t\t\tExecutable lambda) {\r\n+\t\t\r\n+\tpublic void addResponse(String command, String response, \r\n+\t\t\t\tString displayMes, boolean contains, boolean adminOnly, \r\n+\t\t\t\tExecutable lambda) {\r\n \t\t\r\n \t\tif (command == null) {\r\n \t\t\tthrow new IllegalArgumentException(\"You must have an agrument for command\");\r\n \t\t}\r\n \t\t\r\n-\t\tif (response == null && response2 == null && lambda == null) {\r\n+\t\tif (response == null && lambda == null) {\r\n \t\t\tthrow new IllegalArgumentException(\r\n \t\t\t\t\t\"If you have no responses then the executable must not be null\"\r\n \t\t\t);\r\n \t\t}\r\n-\t\t\r\n-\t\tResponse temp = new DefaultResponse(command, response, response2, contains, odd, lambda);\r\n+\t\tResponse temp = new DefaultResponse(command, response, contains, lambda);\r\n+\r\n \t\tif (!adminOnly) {\r\n \t\t\tString helpMessage = DefaultResponse.getHelpStr();\r\n \t\t\thelpMessage = helpMessage == null ? \"\" : helpMessage;\r\n@@ -250,59 +114,39 @@ public void run () {\n \t\t\tapi.addMessageCreateListener(event -> {\r\n \t\t\t\tCollections.sort(responses);\r\n \t        \tString toSend = null;\r\n-\t        \tString helpAddition;\r\n \t        \tString input;\r\n         \t\tDefaultResponse toFind;\r\n         \t\tResponse response;\r\n-        \t\tServerCustomCommands custom = findCustom(event);\r\n-\t        \tboolean hasCustoms = custom != null, sent = false;\r\n \t        \t\r\n \t        \tlong messageSender = event.getMessageAuthor().getId();\r\n \t        \tboolean senderIsYou = messageSender == api.getYourself().getId();\r\n \t        \t\r\n \t        \tif (!senderIsYou) {\r\n-\t        \t\t\r\n-\t        \t\thelpAddition = custom == null ? \"\" : \"\\n\" + custom.getCustomHelpAddition();\r\n \t        \t\tinput = event.getMessageContent().toLowerCase();\r\n \t        \t\ttoFind = new DefaultResponse(input);\r\n \t        \t\t\r\n \t        \t\tint index = Collections.binarySearch(responses, toFind);\r\n \t        \t\tresponse = index > -1 ? responses.get(index) : null;\r\n \t        \t\t\r\n \t        \t\tif (response != null) {\r\n-\t\t\t\t\t\tif (hasCustoms) {\r\n-\t\t\t\t\t\t\ttoSend = response.exec(api, event, helpAddition);\r\n-\t\t\t\t\t\t} else {\r\n-\t\t\t\t\t\t\ttoSend = response.exec(api, event);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\tif (toSend != null && toSend.equals(help + helpAddition)) {\r\n+\t\t\t\t\t\ttoSend = response.exec(api, event);\r\n+\t\t\t\t\t\tif (toSend != null && toSend.equals(help)) {\r\n \t\t\t\t\t\t\tnew MessageBuilder().setEmbed(new EmbedBuilder().setTitle(\"Commandments\")\r\n-\t\t\t\t\t\t\t\t\t.setColor(Color.yellow).setDescription(help + helpAddition))\r\n+\t\t\t\t\t\t\t\t\t.setColor(Color.yellow).setDescription(help))\r\n \t\t\t\t\t\t\t\t\t.send(event.getChannel());\r\n-\t\t\t\t\t\t\tsent = true;\r\n \t\t\t\t\t\t} else if (toSend != null) {\r\n \t\t\t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n-\t\t\t\t\t\t\tsent = true;\r\n \t\t\t\t\t\t} \r\n \t        \t\t} else {\r\n \t        \t\t\t// where the binary search didn't work but there still\r\n \t        \t\t\t// may be a chance that it is in rely contains.\r\n \t        \t\t\t\r\n \t        \t\t\tfor (Response responseCont : responseRelyContains) {\r\n-\t        \t\t\t\ttoSend = responseCont.exec(api, event, helpAddition);\r\n+\t        \t\t\t\ttoSend = responseCont.exec(api, event);\r\n \t        \t\t\t\tif (toSend != null) {\r\n \t        \t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n-\t        \t\t\t\t\tsent = true;\r\n \t        \t\t\t\t}\t\r\n \t        \t\t\t}\r\n-\t        \t\t\tif (!sent && hasCustoms) {\r\n-\t        \t\t\t\t// was not in responses or rely contains. but is a\r\n-\t        \t\t\t\t// custom\r\n-\t        \t\t\t\ttoSend = custom.returnCustomResponse(api, event);\r\n-\t        \t\t\t\tif (toSend != null) {\r\n-\t        \t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n-\t        \t\t\t\t}\r\n-\t        \t\t\t}\r\n \t        \t\t}\r\n \t        \t}\r\n \t        \t\r\n@@ -344,7 +188,7 @@ public boolean hasResponse(Response toCheck) {\n \t * ends the bot.\r\n \t */\r\n \tprivate void addTerminatorCommand() {\r\n-        addResponse(\"!terminate\", null, null, \"terminates\", true, 0, true, (api, event) -> {\r\n+\t\taddResponse(\"!terminate\", null, \"terminates\", true, true, (api, event) -> {\r\n         \tString input = event.getMessageContent().toLowerCase();\r\n         \tboolean terminateMessage = false;\r\n         \tboolean willListen = false;\r\n@@ -355,14 +199,6 @@ private void addTerminatorCommand() {\n         \t\t\t.equals(USERNAME_OF_AUTH_TERMINATOR);\r\n         \t\r\n         \tif (terminateMessage && willListen) {\r\n-            \tif (hasActiveVoiceChannels) {\r\n-            \t\tevent.getChannel().sendMessage(\"Deleting Voice Channels\");\r\n-            \t\tdeleteAllVoiceChannels();\r\n-            \t}\r\n-            \tif (customs.size() > 0) {\r\n-            \t\tevent.getChannel().sendMessage(\"Saving customs\");\r\n-            \t\tsaveCustoms();\r\n-            \t}\r\n             \tevent.getChannel().sendMessage(\"Terminating\");\r\n             \tSystem.out.println(\"input: \" + input );\r\n             \tSystem.out.println(\"User: \" + event.getMessageAuthor().getDiscriminatedName());\r\n@@ -374,464 +210,5 @@ private void addTerminatorCommand() {\n         \t\r\n         });\r\n \t}\r\n-\t\r\n-\t/**\r\n-\t * Saved the customs to a file.\r\n-\t */\r\n-\tprivate void saveCustoms() {\r\n-\t\t\r\n-\t\ttry {\r\n-\t\t\tFileOutputStream fileOutput = new FileOutputStream(SAVED_DATA_FILE);\r\n-\t\t\tObjectOutputStream objectOut = new ObjectOutputStream(fileOutput);\r\n-\t\t\tobjectOut.writeObject(customs);\r\n-\t\t\tobjectOut.flush();\r\n-\t\t\tobjectOut.close();\r\n-\t\t\tfileOutput.close();\r\n-\t\t} catch (IOException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t}\r\n-\t\t\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Reads the customs file if there is one and then adds customs to the queen\r\n-\t * object accordingly.\r\n-\t */\r\n-\t@SuppressWarnings(\"unchecked\")\r\n-\tprivate void loadCustoms() {\r\n-\t\t\r\n-\t\ttry {\r\n-\t\t\tFileInputStream fileIn = new FileInputStream(SAVED_DATA_FILE);\r\n-\t\t\tObjectInputStream objectIn = new ObjectInputStream(fileIn);\r\n-\t\t\tcustoms = (ArrayList<ServerCustomCommands>) objectIn.readObject();\r\n-\t\t\tobjectIn.close();\r\n-\t\t\tfileIn.close();\r\n-\t\t} catch (IOException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t} catch (ClassNotFoundException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t} catch (ClassCastException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * The method that adds the customs commands trigger. This method is called\r\n-\t * in the constructor. \r\n-\t */\r\n-\tprivate void addCustomCommands() {\r\n-\t\taddResponse(\"!customs\", null, null, \"check custom commands\", false, 0, false, \r\n-\t\t\t\t(api, event) -> {\r\n-\t\t\t\t\tif (event.getMessageContent().toLowerCase().equals(\"!customs\")) {\r\n-\t\t\t\t\t\tServer server = getServer(event);\r\n-\t\t\t\t\t\tif (server != null) {\r\n-\t\t\t\t\t\t\tString customCommands[] = {\r\n-\t\t\t\t\t\t\t\t\t\"!customs-on/off\" + Utilities.addSpaces(\"!customs on/off\") +\r\n-\t\t\t\t\t\t\t\t\t\": enables or disables customs\",\r\n-\t\t\t\t\t\t\t\t\t\"!customs-clear\" + Utilities.addSpaces(\"!customs clear\") \r\n-\t\t\t\t\t\t\t\t\t+ \": clears all customs\",\r\n-\t\t\t\t\t\t\t\t\t\"!customs-add\" + Utilities.addSpaces(\"!customs add\") + \r\n-\t\t\t\t\t\t\t\t\t\": adds custom (input and output need to be separated by a \\\":\\\"\",\r\n-\t\t\t\t\t\t\t\t\t\"!customs-remove\" + Utilities.addSpaces(\"!customs remove\") +\r\n-\t\t\t\t\t\t\t\t\t\": removes the specified custom by input\"\r\n-\t\t\t\t\t\t\t};\r\n-\t\t\t\t\t\t\t\r\n-\t\t\t\t\t\t\tString commandStr = customCommands[0];\r\n-\t\t\t\t\t\t\tfor (int i = 1; i < customCommands.length; i ++) {\r\n-\t\t\t\t\t\t\t\tcommandStr += \"\\n\" + customCommands[i];\r\n-\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\tnew MessageBuilder().setEmbed(new EmbedBuilder()\r\n-\t\t        \t\t\t\t\t.setTitle(\"Customs Settings\")\r\n-\t\t        \t\t\t\t\t.setColor(Color.yellow)\r\n-\t\t        \t\t\t\t\t.setDescription(commandStr)\r\n-\t\t        \t\t\t\t).send(event.getChannel());\r\n-\t\t\t\t\t\t\t\r\n-\t\t\t\t\t\t} else {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\"No customs outside of servers\");\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\treturn null;\t\r\n-\t\t});\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Adds all the necessary helper commands that are associated with customs. \r\n-\t */\r\n-\tprivate void addCustomHelperCommands() {\r\n-\t\taddCustomsOn();\r\n-\t\taddCustomsClear();\r\n-\t\taddCustomsAdd();\r\n-\t\taddCustomsRemove();\r\n-\t\t\r\n-\t\t\r\n-\t\t\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Adds the remove command. It first checks to see if customs are on in the\r\n-\t * chat. If true then it calls the ServerCustomCommands remove method with the\r\n-\t * string after the command call. If it successfully found the response to\r\n-\t * remove it will say removed. Otherwise it will say not found.\r\n-\t */\r\n-\tprivate void addCustomsRemove() {\r\n-\t\tResponse remove = new DefaultResponse(\"!customs-remove\", null, false, \r\n-\t\t\t\t(api, event) -> {\r\n-\t\t\t\t\t\r\n-\t\t\tString input = event.getMessageContent().toLowerCase();\r\n-\t\t\tif (input.contains(\"!customs-remove\")\r\n-\t\t\t\t\t&& input.charAt(0) == '!') {\r\n-\t\t\t\t\r\n-\t\t\t\tServerCustomCommands custom = findCustom(event);\r\n-\t\t\t\t\r\n-\t\t\t\tif (custom != null) {\r\n-\t\t\t\t\tString[] args = Utilities.interpreter(event.getMessageContent(), 1, true);\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tif (args == null) {\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\"I could not understand\\n\" +\r\n-\t\t\t\t\t\t\t\t\"Make sure your text reads the command then \"\r\n-\t\t\t\t\t\t\t\t+ \"\\\"input of custom\\\"\"\r\n-\t\t\t\t\t\t\t);\r\n-\t\t\t\t\t} else {\r\n-\t\t\t\t\t\targs[0] = args[0].toLowerCase();\r\n-\t\t\t\t\t\tif (custom.remove(args[0])) {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\t\"Removed the \" +\r\n-\t\t\t\t\t\t\t\t\t\"\\\"\" + args[0] + \"\\\" trigger\"\r\n-\t\t\t\t\t\t\t);\r\n-\t\t\t\t\t\t} else {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\"Could not find command\");\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tevent.getChannel().sendMessage(\"you have to enable customs first\");\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\t\r\n-\t\t\treturn null;\r\n-\t\t});\r\n-\t\tresponses.add(remove);\r\n-\t\tresponseRelyContains.add(remove);\r\n-\t}\r\n-\r\n-\r\n-\r\n-\t/**\r\n-\t * This adds the customs add command. This will first check if the customs are\r\n-\t * on for the selected chat. If they are on then it will take the string after\r\n-\t * the command call and process it and then add a custom response to the\r\n-\t * ServerCustomCommands object associated with the server.\r\n-\t */\r\n-\tprivate void addCustomsAdd() {\r\n-\t\tResponse add = new DefaultResponse(\"!customs-add\", null, false, (api, event) -> {\r\n-\t\t\tString input = event.getMessageContent().toLowerCase();\r\n-\t\t\tif (input.contains(\"!customs-add\")\r\n-\t\t\t\t\t&& input.charAt(0) == '!') {\r\n-\r\n-\t\t\t\tServerCustomCommands custom = findCustom(event);\r\n-\t\t\t\t\r\n-\t\t\t\tif (custom != null) {\r\n-\t\t\t\t\tString[] args = Utilities.interpreter(event.getMessageContent(), 2, true);\r\n-\t\t\t\t\tif (args == null) {\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\"I could not understand\\n\" +\r\n-\t\t\t\t\t\t\t\t\"Make sure your text reads the command then \"\r\n-\t\t\t\t\t\t\t\t+ \"\\\"input : output\\\"\"\r\n-\t\t\t\t\t\t\t);\r\n-\t\t\t\t\t} else {\r\n-\t\t\t\t\t\targs[0] = args[0].toLowerCase();\r\n-\t\t\t\t\t\tboolean sendError = false;\r\n-\t\t\t\t\t\tfor (Response response : responseRelyContains) {\r\n-\t\t\t\t\t\t\tif (args[0].contains(response.getCommand())) {\r\n-\t\t\t\t\t\t\t\tsendError = true;\r\n-\t\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\tif (sendError) {\r\n-\t\t\t\t\t\t\t\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\t\"Sorry but I can't let\"\r\n-\t\t\t\t\t\t\t\t\t+ \"you add this response it may already be used\"\r\n-\t\t\t\t\t\t\t\t\t+ \" for reasons\");\r\n-\t\t\t\t\t\t} else if (custom.addResponse(args[0], args[1], this)) {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\t\"\\\"\" + args[0] + \"\\\" triggers\" \r\n-\t\t\t\t\t\t\t\t\t+ \"\\\"\" + args[1] + \"\\\"\"\r\n-\t\t\t\t\t\t\t);\r\n-\t\t\t\t\t\t} else {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\t\"Error :\\\\\"\r\n-\t\t\t\t\t\t\t\t\t+ \" Already added or is already command\"\r\n-\t\t\t\t\t\t\t\t\t);\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t\t\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tevent.getChannel().sendMessage(\"you have to enable customs first\");\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn null;\r\n-\t\t});\r\n-\t\tresponses.add(add);\r\n-\t\tresponseRelyContains.add(add);\r\n-\t}\r\n-\r\n-\r\n-\r\n-\t/**\r\n-\t * This will remove or clear all the customs on the server. First it checks if\r\n-\t * the current chat is on a server. (Will do nothing if not on a server.) It\r\n-\t * then checks to see if there is a customs object associated with the server in\r\n-\t * the arrayList customs. If both are true then it will check if the sender is\r\n-\t * the admin of the server. After all that it will then remove the\r\n-\t * ServerCustomCommands object from the customs arrayList.\r\n-\t */\r\n-\tprivate void addCustomsClear() {\r\n-\t\tresponses.add(new DefaultResponse(\"!customs-off\", null, false, (api, event) -> {\r\n-\t\t\treturn customsClearExecutable(event);\r\n-\t\t\t}));\r\n-\t\tresponses.add(new DefaultResponse(\"!customs-clear\", null, false, (api, event) -> {\r\n-\t\t\treturn customsClearExecutable(event);\r\n-\t\t}));\r\n-\t}\r\n-\r\n-\r\n-\r\n-\t/**\r\n-\t * This is the lambda expression used by both of the clear responses.\r\n-\t * @param event\r\n-\t * @return\r\n-\t */\r\n-\tprivate String customsClearExecutable(MessageCreateEvent event) {\r\n-\t\tString input = event.getMessageContent().toLowerCase();\r\n-\t\tServer server = getServer(event);\r\n-\t\t\r\n-\t\tif (input.equals(\"!customs-off\") || input.equals(\"!customs-clear\")) {\r\n-\t\t\t\r\n-\t\t\tServerCustomCommands custom = findCustom(event);\r\n-\t\t\tif (custom != null) {\r\n-\t\t\t\tif (event.getMessageAuthor().isServerAdmin()) {\r\n-\r\n-\t\t\t\t\tint index = Collections.binarySearch(customs, custom);\r\n-\t\t\t\t\tif (index >= 0) {\r\n-\t\t\t\t\t\tcustoms.remove(index);\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\"Removed all customs\");\r\n-\t\t\t\t\t} else {\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\"No customs to remove\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\r\n-\t\t\t\t\t\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\"You must be and admin to access customs duh\"\r\n-\t\t\t\t\t);\r\n-\t\t\t\t}\r\n-\t\t\t} else if (server != null) {\r\n-\t\t\t\tevent.getChannel().sendMessage(\"No customs to remove\");\r\n-\t\t\t\t\r\n-\t\t\t\t\r\n-\t\t\t} else {\r\n-\t\t\t\tevent.getChannel().sendMessage(\"I can only remove customs on servers dummy\");\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This adds the customs on command. This command checks if the current chat is\r\n-\t * in a server (will not add if on). Then it checks if the given server already\r\n-\t * has a ServerCustomCommands object associated with it in the arrayList\r\n-\t * customs. (Will not add 2 customs for 1 server.) Then it checks to see if the\r\n-\t * message sender is the admin of the serer (will not allow anyone who is not\r\n-\t * admin from turning on customs.) Finally if it meets all the above criteria it\r\n-\t * creates a ServerCustomCommands object and puts in the server id.\r\n-\t */\r\n-\tprivate void addCustomsOn() {\r\n-\t\tresponses.add(new DefaultResponse(\"!customs-on\", null, false, (api, event) -> {\r\n-\t\t\tString input = event.getMessageContent().toLowerCase();\r\n-\t\t\tServer server = getServer(event);\r\n-\t\t\t\r\n-\t\t\tif (input.equals(\"!customs-on\")) {\r\n-\t\t\t\t\r\n-\t\t\t\tif (findCustom(event) != null) {\r\n-\t\t\t\t\tevent.getChannel().sendMessage(\"Customs are already on\");\r\n-\t\t\t\t} else if (server != null) {\r\n-\t\t\t\t\tlong serverId = server.getId();\r\n-\t\t\t\t\t\r\n-\t\t\t\t\tif (event.getMessageAuthor().isServerAdmin()) {\r\n-\t\t\t\t\t\tcustoms.add(new ServerCustomCommands(serverId));\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\"Enabled them customs\");\r\n-\t\t\t\t\t} else {\r\n-\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n-\t\t\t\t\t\t\t\t\"You must be and admin to access customs duh\"\r\n-\t\t\t\t\t\t);\r\n-\t\t\t\t\t}\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tevent.getChannel().sendMessage(\"I can only add customs on servers dummy\");\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\treturn null;\r\n-\t\t}));\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Given an event it will return a server reference if there is one.\r\n-\t * @param event\r\n-\t * @return reference to a server.\r\n-\t */\r\n-\tprivate Server getServer(MessageCreateEvent event) {\r\n-\t\tServer server;\r\n-\t\ttry {\r\n-\t\t\tserver = event.getServer().get();\r\n-\t\t} catch (NoSuchElementException e) {\r\n-\t\t\tserver = null;\r\n-\t\t}\r\n-\t\treturn server;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Takes in an event and checks to see if there is a ServerCustom command \r\n-\t * associated with the server.\r\n-\t * @param event\r\n-\t * @return\r\n-\t */\r\n-\tprivate ServerCustomCommands findCustom (MessageCreateEvent event) {\r\n-\t\tServer server = getServer(event);\r\n-\t\tint index = -1;\r\n-\t\tif (server != null) {\r\n-\t\t\tServerCustomCommands key = new ServerCustomCommands(server.getId());\r\n-\t\t\tindex = Collections.binarySearch(customs, key);\r\n-\t\t\t\r\n-\t\t}\r\n-\t\tif (index > - 1 ) {\r\n-\t\t\treturn customs.get(index);\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t\t\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This is the method used to create a new temporary voice channel. \r\n-\t * It adds a VoiceChannelServer object to the arrayList once the channel\r\n-\t * is created so that QueenBot can keep track of all the open channels.\r\n-\t * It will then remove it from the list when the channel is being deleted.\r\n-\t * @param api\r\n-\t * @param serverId\r\n-\t * @param textChannelID\r\n-\t */\r\n-\tprivate void addVoice(DiscordApi api, long serverId, long textChannelID) {\r\n-\r\n-\t\tServer server = api.getServerById(serverId).get();\r\n-\t\tif (server != null) {\r\n-\t\t\t// only makes if it is in a server\r\n-\t\t\tTextChannel originalChannel = server.getTextChannelById(textChannelID).get();\r\n-\t\t\tCollections.sort(activeVoiceServers);\r\n-\t\t\tVoiceChannelServer toFind = new VoiceChannelServer(server.getId(), -1);\r\n-\t\t\tint index = Collections.binarySearch(activeVoiceServers, toFind);\r\n-\t\t\tif (index < 0) {\r\n-\t\t\t\t// only adds if one has not been already added\r\n-\t\t\t\t\r\n-\t\t    \t// Creating voice channel\r\n-\t\t\t\tServerVoiceChannel channel = new ServerVoiceChannelBuilder(server)\r\n-\t\t    \t\t\t.setName(\"The Ring\")\r\n-\t\t    \t\t\t.create()\r\n-\t\t    \t\t\t.join();\r\n-\t\t\t\t\r\n-\t\t\t\tlong voiceId = channel.getId();\r\n-\t\t\t\thasActiveVoiceChannels = true;\r\n-\t\t\t\tVoiceChannelServer voiceServer = new VoiceChannelServer(server.getId(), voiceId);\r\n-\t\t\t\tactiveVoiceServers.add(voiceServer);\r\n-\t\t    \t\r\n-\t\t    \t// Delete the channel if the last user leaves\r\n-\t\t    \tchannel.addServerVoiceChannelMemberLeaveListener(event -> {\r\n-\t\t    \t    if (event.getChannel().getConnectedUserIds().isEmpty()) {\r\n-\t\t    \t        \r\n-\t\t    \t    \tevent.getChannel().delete();\r\n-\t\t    \t        adjustActiveVoiceIds(voiceServer);\r\n-\t\t    \t        \r\n-\t\t\t\t\t\tif (originalChannel != null) {\r\n-\t\t\t\t\t\t\toriginalChannel.sendMessage(\"Good Fight\");\r\n-\t\t\t\t\t\t}\r\n-\t\t    \t    }\r\n-\t\t    \t});\r\n-\r\n-\t\t    \t// Delete the channel if no user joined in the first 30 seconds \r\n-\t\t    \tapi.getThreadPool().getScheduler().schedule(() -> {\r\n-\t\t    \t    if (channel.getConnectedUserIds().isEmpty()) {\r\n-\t\t    \t        \r\n-\t\t    \t    \tchannel.delete();\r\n-\t\t    \t    \tadjustActiveVoiceIds(voiceServer);\r\n-\t\t    \t        \r\n-\t\t    \t        if (originalChannel != null) {\r\n-\t\t    \t        \toriginalChannel.sendMessage(\"cowards\");\r\n-\t\t    \t        }\r\n-\t\t    \t    }\r\n-\t\t    \t}, 30, TimeUnit.SECONDS);\r\n-\t\t\t}\r\n-\t\t\t\r\n-\r\n-\t\t}\t\t\r\n-    \t\r\n-    }\r\n-\r\n-\t/**\r\n-\t * This does the removing to the voiceChannelServers arrayList.\r\n-\t * @param voiceObj\r\n-\t */\r\n-\tprivate void adjustActiveVoiceIds(VoiceChannelServer voiceObj) {\r\n-\t\tactiveVoiceServers.remove(voiceObj);\r\n-\t\tif (activeVoiceServers.size() == 0) {\r\n-\t\t\thasActiveVoiceChannels = false;\r\n-\t\t} else {\r\n-\t\t\thasActiveVoiceChannels = true;\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This method is called when the terminate sequence is called\r\n-\t * This will remove any of the open temporary channels. \r\n-\t */\r\n-\tprivate void deleteAllVoiceChannels() {\r\n-\t\tif (hasActiveVoiceChannels) {\r\n-\t\t\tfor (int i = 0; i < activeVoiceServers.size(); i ++) {\r\n-\t\t\t\tVoiceChannelServer current = activeVoiceServers.get(i);\r\n-\t\t\t\t\r\n-\t\t\t\tserverMethod(current.getServerId(), (server) -> {\r\n-\t\t\t\t\tServerChannel channel;\r\n-\t\t\t\t\ttry {\r\n-\t\t\t\t\t\tchannel = server.getVoiceChannelById(\r\n-\t\t\t\t\t\t\t\tcurrent.getVoiceChannelId()\r\n-\t\t\t\t\t\t\t\t).get();\r\n-\t\t\t\t\t} catch (NoSuchElementException e) {\r\n-\t\t\t\t\t\tchannel = null;\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tif (channel != null) {\r\n-\t\t\t\t\t\tchannel.delete();\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\t\t\t\r\n-\t\t\t\t});\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This is to some annoying code writing. The reason I am using\r\n-\t * server ids and then getting the server is because there is a \r\n-\t * chance that the references or cache becomes out dated\r\n-\t * either from a server disconnect or just over time.\r\n-\t * By using the ids (which don't change) this shouldn't be a problem.\r\n-\t * @param serverId\r\n-\t * @param exec\r\n-\t */\r\n-\tprivate void serverMethod(long serverId, ExecServer exec) {\r\n-\t\tServer server = api.getServerById(serverId).get();\r\n-\t\tif (server != null) {\r\n-\t\t\texec.executable(server);\r\n-\t\t}\r\n-\t}\r\n \r\n }\r"
  },
  {
    "sha": "f68774282fb17919c38fec6227296a2568427c5b",
    "filename": "discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "status": "removed",
    "additions": 0,
    "deletions": 178,
    "changes": 178,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/ServerCustomCommands.java?ref=3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5",
    "patch": "@@ -1,178 +0,0 @@\n-package discordBot;\r\n-\r\n-import java.io.Serializable;\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-\r\n-import org.javacord.api.DiscordApi;\r\n-import org.javacord.api.event.message.MessageCreateEvent;\r\n-\r\n-/**\r\n- * This is an object associated with a server that keeps track of all the \r\n- * custom responses.\r\n- * @author kjara\r\n- *\r\n- */\r\n-public class ServerCustomCommands implements Comparable <ServerCustomCommands>, Serializable {\r\n-\t/**\r\n-\t * \r\n-\t */\r\n-\tprivate static final long serialVersionUID = -2453323497723493301L;\r\n-\tprivate ArrayList<SimpleResponse> customResponses;\r\n-\tprivate long serverId;\r\n-\tprivate String customHelpAddition;\r\n-\t\r\n-\t/**\r\n-\t * Constructor.\r\n-\t * @param serverId\r\n-\t * @param queen\r\n-\t */\r\n-\tpublic ServerCustomCommands(long serverId) {\r\n-\t\tcustomResponses = new ArrayList<> ();\r\n-\t\tcustomHelpAddition = \"\";\r\n-\t\tthis.serverId = serverId;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Will take in two strings and add a response to the list. It will return \r\n-\t * true if both input and output are not null and response is added. Will not add\r\n-\t * any commands that are duplicates or default to queen.\r\n-\t * @param input\r\n-\t * @param output\r\n-\t * @return boolean true if added.\r\n-\t */\r\n-\tpublic boolean addResponse(String input, String output, Queen queen) {\r\n-\t\tif (input != null && output != null && queen != null) {\r\n-\t\t\tboolean noAdd = false;\r\n-\t\t\tSimpleResponse toAdd = new SimpleResponse(input, output);\r\n-\t\t\tnoAdd = queen.hasResponse(toAdd);\r\n-\t\t\t\r\n-\t\t\tif (!noAdd) {\r\n-\t\t\t\tint index = Collections.binarySearch(customResponses, toAdd);\r\n-\t\t\t\tnoAdd = index > -1;\r\n-\t\t\t}\r\n-\t\t\tif (!noAdd) {\r\n-\t\t\t\tcustomResponses.add(toAdd);\r\n-\t\t\t\tif (customHelpAddition.isEmpty()) {\r\n-\t\t\t\t\tcustomHelpAddition += \"\\nCustoms\";\r\n-\t\t\t\t\t\r\n-\t\t\t\t}\r\n-\t\t\t\tcustomHelpAddition += \"\\n\" + input + \r\n-\t\t\t\t\t\tUtilities.addSpaces(input) + \": \" + output;\r\n-\t\t\t\treturn true;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This will return the custom help addition which is just the list of custom\r\n-\t * commands with their responses.\r\n-\t * @return\r\n-\t */\r\n-\tpublic String getCustomHelpAddition() {\r\n-\t\treturn customHelpAddition;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Returns the serverId of the custom.\r\n-\t * @return\r\n-\t */\r\n-\tpublic long getServerId() {\r\n-\t\treturn serverId;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Gets the number of custom commands in the object.\r\n-\t * @return\r\n-\t */\r\n-\tpublic int getNumberCustoms() {\r\n-\t\treturn customResponses.size();\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This is the remove command. It will remove a response corresponding to the\r\n-\t * given input command. It will also edit the help message string. \r\n-\t * This will return true if the command was found and removed. \r\n-\t * @param command\r\n-\t * @return boolean true if successful.\r\n-\t */\r\n-\tpublic boolean remove(String command) {\r\n-\t\tSimpleResponse toFind = new SimpleResponse (command);\r\n-\t\t\r\n-\t\tint index = Collections.binarySearch(customResponses, toFind);\r\n-\t\t\r\n-\t\tif (index > -1) {\r\n-\t\t\tcustomResponses.remove(index);\r\n-\t\t\tString tempHelpAddition = customHelpAddition;\r\n-\t\t\tint commandStart = tempHelpAddition.indexOf(command);\r\n-\t\t\tif (commandStart > 1) {\r\n-\t\t\t\t// because of the new line character\r\n-\t\t\t\ttempHelpAddition = customHelpAddition.substring(0, commandStart - 1);\r\n-\t\t\t\t// starts at character after \\n\r\n-\t\t\t\tString lineToRemove = customHelpAddition.substring(commandStart);\r\n-\t\t\t\tint nextNewLine = lineToRemove.indexOf('\\n');\r\n-\t\t\t\tString remaining = \"\";\r\n-\t\t\t\tif (nextNewLine >= 0 && (nextNewLine + commandStart + 1) \r\n-\t\t\t\t\t\t< customHelpAddition.length()) {\r\n-\t\t\t\t\tremaining = customHelpAddition.substring(\r\n-\t\t\t\t\t\t\tnextNewLine + commandStart + 1\r\n-\t\t\t\t\t); \r\n-\t\t\t\t}\r\n-\t\t\t\t\r\n-\t\t\t\ttempHelpAddition += remaining;\r\n-\t\t\t\tcustomHelpAddition = tempHelpAddition;\r\n-\t\t\t\t\r\n-\t\t\t}\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * This will loop through all the responses and return a string that is a response\r\n-\t * to the message if there is one. Otherwise returns null.\r\n-\t * @param api\r\n-\t * @param event\r\n-\t * @return String response if it finds one to return\r\n-\t */\r\n-\tpublic String returnCustomResponse(DiscordApi api, MessageCreateEvent event) {\r\n-\t\tString toSend = null;\r\n-\t\tString command = event.getMessageContent().toLowerCase();\r\n-\t\tCollections.sort(customResponses);\r\n-\t\tResponse toFind = new SimpleResponse(command);\r\n-\t\tint index = Collections.binarySearch(customResponses, toFind);\r\n-\t\tif (index > -1) {\r\n-\t\t\treturn customResponses.get(index).exec(api, event);\r\n-\t\t}\r\n-\t\treturn toSend;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Overrides the equals method. Objects are compared by the serveriD.\r\n-\t */\r\n-\t@Override\r\n-\tpublic boolean equals(Object obj) {\r\n-\t\tif (obj == this) \r\n-\t\t\treturn true;\r\n-\t\tif (!(obj instanceof ServerCustomCommands))\r\n-\t\t\treturn false;\r\n-\t\t\r\n-\t\tServerCustomCommands other = (ServerCustomCommands) obj;\r\n-\t\treturn other.serverId == serverId;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Method needed to implement comparable. Objects are compared by their \r\n-\t * serverIds.\r\n-\t */\r\n-\t@Override\r\n-\tpublic int compareTo(ServerCustomCommands other) {\r\n-\t\treturn Long.compare(serverId, other.serverId);\r\n-\t}\r\n-\t\r\n-\t@Override\r\n-\tpublic String toString() {\r\n-\t\treturn \"\" + serverId + getCustomHelpAddition().substring(8);\r\n-\t}\r\n-}\r"
  },
  {
    "sha": "712432a57f3a6649a6f6afed3cd131ef347c1089",
    "filename": "discordBot/src/main/java/discordBot/SimpleResponse.java",
    "status": "removed",
    "additions": 0,
    "deletions": 89,
    "changes": 89,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/SimpleResponse.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/SimpleResponse.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/SimpleResponse.java?ref=3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5",
    "patch": "@@ -1,89 +0,0 @@\n-package discordBot;\r\n-\r\n-import java.io.Serializable;\r\n-\r\n-import org.javacord.api.DiscordApi;\r\n-import org.javacord.api.event.message.MessageCreateEvent;\r\n-\r\n-public final class SimpleResponse implements Serializable, Response {\r\n-\t/**\r\n-\t * \r\n-\t */\r\n-\tprivate static final long serialVersionUID = -4192087201373479648L;\r\n-\tprivate String command, response;\r\n-\t\r\n-\t/**\r\n-\t * Constructor\r\n-\t * @param command\r\n-\t * @param response\r\n-\t */\r\n-\tpublic SimpleResponse(String command, String response) {\r\n-\t\tthis.command = command;\r\n-\t\tthis.response = response;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Constructor that is used for the Collections binary search method.\r\n-\t * The object is initialized with nothing other than the command. Do not\r\n-\t * use the object initialized with this constructor for anything else.\r\n-\t * @param command\r\n-\t */\r\n-\tpublic SimpleResponse(String command) {\r\n-\t\tthis.command = command;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * The executes. Basically gets the response. \r\n-\t */\r\n-\t@Override\r\n-\tpublic String exec(DiscordApi api, MessageCreateEvent event) {\r\n-\t\treturn getDefaultResponse();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * The same thing but with an additional param. This is needed to satisfy the\r\n-\t * interface.\r\n-\t */\r\n-\t@Override\r\n-\tpublic String exec(DiscordApi api, MessageCreateEvent event, String add) {\r\n-\t\treturn getDefaultResponse();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the command.\r\n-\t */\r\n-\t@Override\r\n-\tpublic String getCommand() {\r\n-\t\treturn command;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Gets the response.\r\n-\t */\r\n-\t@Override\r\n-\tpublic String getDefaultResponse() {\r\n-\t\treturn response;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Equals method. It compares by the command.\r\n-\t */\r\n-\t@Override\r\n-\tpublic boolean equals(Object obj) {\r\n-\t\tif (obj == this) \r\n-\t\t\treturn true;\r\n-\t\tif (!(obj instanceof Response)) \r\n-\t\t\treturn false;\r\n-\t\t\r\n-\t\tResponse other = (Response) obj;\r\n-\t\treturn command.equals(other.getCommand());\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * toString() method.\r\n-\t */\r\n-\t@Override\r\n-\tpublic String toString() {\r\n-\t\treturn getCommand() + \" : \" + getDefaultResponse();\r\n-\t}\r\n-}\r"
  },
  {
    "sha": "cf3b81550a61ef135dea1829d07d1d5725fddf4d",
    "filename": "discordBot/src/main/java/discordBot/Utilities.java",
    "status": "modified",
    "additions": 0,
    "deletions": 52,
    "changes": 52,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/Utilities.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/727ae09665af9c79ca860f0a8800fc3171608ba1/discordBot/src/main/java/discordBot/Utilities.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/Utilities.java?ref=727ae09665af9c79ca860f0a8800fc3171608ba1",
    "patch": "@@ -18,56 +18,4 @@ public static String addSpaces(String initial) {\n \t\t}\r\n \t\treturn spaces.toString();\r\n \t}\r\n-\t\r\n-\t/**\r\n-\t * This takes in a string and processes it. The first thing it does is make \r\n-\t * a substring after the space. It then trims and processes it. So that\r\n-\t * !ada heh hi : hello. returns a string array of [\"heh hi\", \"hello\"].\r\n-\t * if the size of the array does not match the argument number then it returns\r\n-\t * null.\r\n-\t * @param input\r\n-\t * @param argumentNumber\r\n-\t * @return\r\n-\t */\r\n-\tpublic static String[] interpreter(String input, int argumentNumber, boolean skipFirstWord) {\r\n-\t\tString[] toReturn = null;\r\n-\t\tif (input == null || (skipFirstWord && input.indexOf(' ') < 0)) {\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\tString afterCommandCall;\r\n-\t\tif (skipFirstWord) {\r\n-\t\t\tafterCommandCall = input.substring(input.indexOf(' '));\r\n-\t\t} else {\r\n-\t\t\tafterCommandCall = input;\r\n-\t\t}\r\n-\t\tafterCommandCall = afterCommandCall.trim();\r\n-\t\tif (afterCommandCall.isEmpty()) {\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\tint colonIndex = afterCommandCall.indexOf(':');\r\n-\t\tString firstArg = null;\r\n-\t\tString secondArg = null;\r\n-\t\tif (argumentNumber > 1) {\r\n-\t\t\tif (colonIndex < 1 || colonIndex == afterCommandCall.length() - 1) {\r\n-\t\t\t\treturn null;\r\n-\t\t\t} else {\r\n-\t\t\t\tfirstArg = afterCommandCall.substring(0, colonIndex);\r\n-\t\t\t\tfirstArg = firstArg.trim();\r\n-\t\t\t\tsecondArg = afterCommandCall.substring(colonIndex + 1, afterCommandCall.length());\r\n-\t\t\t\tsecondArg = secondArg.trim();\r\n-\t\t\t\t\r\n-\t\t\t\tif (firstArg.isEmpty() || secondArg.isEmpty()) {\r\n-\t\t\t\t\treturn null;\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\ttoReturn = new String[] {\r\n-\t\t\t\t\t\t\tfirstArg, secondArg\r\n-\t\t\t\t\t};\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} else if (argumentNumber == 1) {\r\n-\t\t\ttoReturn = new String[] {afterCommandCall};\r\n-\t\t}\r\n-\t\treturn toReturn;\t\t\r\n-\t\t\r\n-\t}\r\n }\r"
  },
  {
    "sha": "014b83706ec1d210c5b8347893a97a4424ee5823",
    "filename": "discordBot/src/main/java/discordBot/VoiceChSrvVoiceIdComp.java",
    "status": "removed",
    "additions": 0,
    "deletions": 20,
    "changes": 20,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/VoiceChSrvVoiceIdComp.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/VoiceChSrvVoiceIdComp.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/VoiceChSrvVoiceIdComp.java?ref=3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5",
    "patch": "@@ -1,20 +0,0 @@\n-package discordBot;\r\n-\r\n-import java.util.Comparator;\r\n-\r\n-/**\r\n- * This is a comparator for the VoiceChannelServer that compares by \r\n- * The voiceChannelId.\r\n- * @author kjara\r\n- *\r\n- */\r\n-public class VoiceChSrvVoiceIdComp implements Comparator<VoiceChannelServer>{\r\n-\t\r\n-\t/**\r\n-\t * Ordering given by this comparator compares by the voiceChannelId numbers.\r\n-\t */\r\n-\t@Override\r\n-\tpublic int compare(VoiceChannelServer a, VoiceChannelServer b) {\r\n-\t\treturn Long.compare(a.getVoiceChannelId(), b.getVoiceChannelId());\r\n-\t}\r\n-}\r"
  },
  {
    "sha": "1e8bc7aa9ea4fd3d9076a3dfee0118f8337dd5a5",
    "filename": "discordBot/src/main/java/discordBot/VoiceChannelServer.java",
    "status": "removed",
    "additions": 0,
    "deletions": 68,
    "changes": 68,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/VoiceChannelServer.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/main/java/discordBot/VoiceChannelServer.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/VoiceChannelServer.java?ref=3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5",
    "patch": "@@ -1,68 +0,0 @@\n-package discordBot;\r\n-\r\n-import java.util.Comparator;\r\n-\r\n-/**\r\n- * This is a final class that basically\r\n- * just houses the id for the server and voice channel\r\n- * that it is provided.\r\n- * @author kjara\r\n- *\r\n- */\r\n-public final class VoiceChannelServer implements Comparable<VoiceChannelServer>{\r\n-\tprivate long serverId, voiceChannelId;\r\n-\tpublic static final Comparator<VoiceChannelServer> VOICE_CHANNEL_ORDER \r\n-\t\t\t\t\t\t\t\t\t\t\t\t= new VoiceChSrvVoiceIdComp();\r\n-\t\r\n-\t/**\r\n-\t * Constructor\r\n-\t * @param serverId\r\n-\t * @param voiceChannelId\r\n-\t */\r\n-\tpublic VoiceChannelServer(long serverId, long voiceChannelId) {\r\n-\t\tthis.serverId = serverId;\r\n-\t\tthis.voiceChannelId = voiceChannelId;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the server id\r\n-\t * @return long\r\n-\t */\r\n-\tpublic long getServerId() {\r\n-\t\treturn serverId;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * returns the voice channel id\r\n-\t * @return long.\r\n-\t */\r\n-\tpublic long getVoiceChannelId() {\r\n-\t\treturn voiceChannelId;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * overrides the equals method. Objects are compared by the serverId and \r\n-\t * voiceChannelId.\r\n-\t */\r\n-\t@Override\r\n-\tpublic boolean equals(Object obj) {\r\n-\t\tif (obj == this) \r\n-\t\t\treturn true;\r\n-\t\tif (!(obj instanceof VoiceChannelServer)) \r\n-\t\t\treturn false;\r\n-\t\tVoiceChannelServer other = (VoiceChannelServer) obj;\r\n-\t\t\r\n-\t\treturn other.serverId == serverId || other.voiceChannelId == voiceChannelId;\r\n-\t\t\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Compares objects by the ServerId. There is a comparator that sorts by\r\n-\t * voiceChannelId.\r\n-\t */\r\n-\t@Override\r\n-\tpublic int compareTo(VoiceChannelServer other) {\r\n-\t\treturn Long.compare(serverId, other.serverId);\r\n-\t}\r\n-\r\n-}\r"
  },
  {
    "sha": "60c1ba2234ffc79f38cf754aa1ca1b11f31dc130",
    "filename": "discordBot/src/test/java/tests/Tests.java",
    "status": "removed",
    "additions": 0,
    "deletions": 122,
    "changes": 122,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/test/java/tests/Tests.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5/discordBot/src/test/java/tests/Tests.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/test/java/tests/Tests.java?ref=3adc6fdcaa14116a2bbed8f85a9ab23a18b979d5",
    "patch": "@@ -1,122 +0,0 @@\n-package tests;\r\n-\r\n-import static org.junit.jupiter.api.Assertions.*;\r\n-\r\n-import java.io.FileInputStream;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.util.ArrayList;\r\n-\r\n-import org.junit.jupiter.api.Test;\r\n-\r\n-import discordBot.Queen;\r\n-import discordBot.ServerCustomCommands;\r\n-\r\n-\r\n-class Tests {\r\n-\r\n-\t@Test\r\n-\tvoid test() {\r\n-\t\tchar test = '\\u2014';\r\n-\t\tassertTrue( test == '�');\r\n-\t\tassertTrue(\"i\\u2014\".equals(\"i�\"));\r\n-\t}\r\n-\t\r\n-\t@Test\r\n-\tvoid longTest() {\r\n-\t\tArrayList<Long> test = new ArrayList<>();\r\n-\t\ttest.add(0L);\r\n-\t\ttest.add(5L);\r\n-\t\tassertTrue(test.size() == 2);\r\n-\t\ttest.remove((Long) 0L);\r\n-\t\tassertTrue(test.size() == 1);\r\n-\t\t\r\n-\t\tassertTrue((long) test.get(0) == 5L);\r\n-\t}\r\n-\t\r\n-\t@Test\r\n-\tvoid serializingCustoms() {\r\n-\t\tQueen queen = new Queen();\r\n-\t\tServerCustomCommands custom1 = new ServerCustomCommands(0L);\r\n-\t\tServerCustomCommands custom2 = new ServerCustomCommands(1L);\r\n-\t\t\r\n-\t\tassertTrue(custom1.addResponse(\"hi\", \"there\", queen));\r\n-\t\tassertTrue(custom1.addResponse(\"hello there\", \"general Kenobi\", queen));\r\n-\t\tassertTrue(custom2.addResponse(\"test\", \"test\", queen));\r\n-\t\tassertTrue(custom2.addResponse(\"hi\", \"there\", queen));\r\n-\t\t\r\n-\t\tArrayList<ServerCustomCommands> list = new ArrayList<>();\r\n-\t\t\r\n-\t\tlist.add(custom1);\r\n-\t\tlist.add(custom2);\r\n-\t\t\r\n-//\t\tServerCustomsPacker packer = new ServerCustomsPacker(list);\r\n-\t\t\r\n-\t\ttry {\r\n-\t\t\tFileOutputStream fileOutput = new FileOutputStream(\"savedCustoms/testData\");\r\n-\t\t\tObjectOutputStream objectOut = new ObjectOutputStream(fileOutput);\r\n-\t\t\tobjectOut.writeObject(list);\r\n-\t\t\tobjectOut.flush();\r\n-\t\t\tobjectOut.close();\r\n-\t\t\tfileOutput.close();\r\n-\t\t} catch (IOException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\tfail(\"could not write\");\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\t\r\n-\t@SuppressWarnings(\"unchecked\")\r\n-\t@Test\r\n-\tvoid deSerialziationCustoms() {\r\n-\t\tArrayList<ServerCustomCommands> list = new ArrayList<>();\r\n-\t\t\r\n-\t\ttry {\r\n-\t\t\tFileInputStream fileIn = new FileInputStream(\"savedCustoms/testData\");\r\n-\t\t\tObjectInputStream objectIn = new ObjectInputStream(fileIn);\r\n-\t\t\tlist = (ArrayList<ServerCustomCommands>) objectIn.readObject();\r\n-\t\t\tobjectIn.close();\r\n-\t\t\tfileIn.close();\r\n-\t\t} catch (IOException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\tfail(\"could not make object\");\r\n-\t\t} catch (ClassNotFoundException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\tfail(\"could not find class\");\r\n-\t\t} catch (ClassCastException e) {\r\n-\t\t\te.printStackTrace();\r\n-\t\t\tfail(\"the class type was different\");\r\n-\t\t}\r\n-\t\tfor (ServerCustomCommands customs : list) {\r\n-\t\t\tSystem.out.println(customs);\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-//\t@Test\r\n-//\tvoid search() {\r\n-//\t\tQueen queen = new Queen();\r\n-//\t\tResponse custom = new Response(\".\");\r\n-//\t\tint index = Collections.binarySearch(queen.responses, custom);\r\n-//\t\tfor (Response response : queen.responses) {\r\n-//\t\t\tSystem.out.println(response.getCommand());\r\n-//\t\t}\r\n-//\t\tassertTrue(index >= 0);\r\n-//\t\t\r\n-//\t\tResponse custom2 = new Response(\"!customs\");\r\n-//\t\tboolean isTrue = queen.responses.get(queen.responses.size() - 5).equals(custom2);\r\n-//\t\tSystem.out.println(\"-------\");\r\n-//\t\tSystem.out.println( queen.responses.get(queen.responses.size() - 5).getCommand());\r\n-//\t\tSystem.out.println(custom2.getCommand());\r\n-//\t\tSystem.out.println(isTrue);\r\n-//\t\t\r\n-//\t\tCollections.sort(queen.responses);\r\n-//\t\tindex = Collections.binarySearch(queen.responses, custom2);\r\n-//\t\tSystem.out.println(index);\r\n-//\t\tassertTrue(index >= 0);\r\n-//\t}\r\n-\t\r\n-\t\r\n-\r\n-}\r"
  }
]
