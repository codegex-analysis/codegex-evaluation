[
  {
    "sha": "fbcc1e516d7d12df3b916b6e510f48429c1f90ca",
    "filename": "discordBot/src/main/java/discordBot/DefaultResponse.java",
    "status": "modified",
    "additions": 22,
    "deletions": 11,
    "changes": 33,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/DefaultResponse.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/DefaultResponse.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/DefaultResponse.java?ref=c74da6b51d6bb09c3eed03bcb729099db808b740",
    "patch": "@@ -1,5 +1,6 @@\n package discordBot;\r\n \r\n+\r\n import org.javacord.api.DiscordApi;\r\n import org.javacord.api.event.message.MessageCreateEvent;\r\n \r\n@@ -19,7 +20,16 @@\n \t\r\n \t\r\n \t\r\n-\t\r\n+\t/**\r\n+\t * Constructor. \r\n+\t * Initializes the static help message as the very first response\r\n+\t * that is put into the constructor. It also initializes a static\r\n+\t * random object that all the responses will use. \r\n+\t * @param command\r\n+\t * @param response\r\n+\t * @param contains\r\n+\t * @param lambda\r\n+\t */\r\n \tpublic DefaultResponse (String command, String response, boolean contains, Executable lambda) {\r\n \t\tthis.command = command;\r\n \t\tthis.response = response;\r\n@@ -55,7 +65,6 @@ public DefaultResponse (String command, String response,\n \t */\r\n \tpublic DefaultResponse (String command, String response, String response2,\r\n \t\t\tboolean contains, int odd) {\r\n-\t\t\r\n \t\tthis (command, response, contains, null);\r\n \r\n \t}\r\n@@ -106,11 +115,7 @@ public boolean getContains() {\n \t */\r\n \t@Override\r\n \tpublic String exec (DiscordApi api, MessageCreateEvent event) {\r\n-\t\tif (lambda != null) {\r\n-\t\t\treturn lambda.exec(api, event);\r\n-\t\t} else {\r\n-\t\t\treturn isCommand(event.getMessageContent(), null);\r\n-\t\t}\r\n+\t\treturn exec(api, event, null);\r\n \t}\r\n \t\r\n \t/**\r\n@@ -123,11 +128,15 @@ public String exec (DiscordApi api, MessageCreateEvent event) {\n \t */\r\n \t@Override\r\n \tpublic String exec (DiscordApi api, MessageCreateEvent event, String additonal) {\r\n-\t\tif (lambda != null) {\r\n-\t\t\treturn lambda.exec(api, event);\r\n-\t\t} else {\r\n-\t\t\treturn isCommand(event.getMessageContent(), additonal);\r\n+\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\tif ((contains && input.contains(command)) || input.equals(command)) {\r\n+\t\t\tif (lambda != null) {\r\n+\t\t\t\treturn lambda.exec(api, event);\r\n+\t\t\t} else {\r\n+\t\t\t\treturn isCommand(event.getMessageContent(), additonal);\r\n+\t\t\t}\r\n \t\t}\r\n+\t\treturn null;\r\n \t}\r\n \t\r\n \t\r\n@@ -182,6 +191,8 @@ public String toString() {\n \t */\r\n \tprivate String isCommand(String input, String additional) {\r\n \t\tString toReturn = null;\r\n+\t\t\r\n+\t\tadditional = additional == null ? \"\" : additional;\r\n \t\tinput = input.toLowerCase();\r\n \t\tif (input != null) {\r\n \t\t\tif (command.equals(helpCommand)) {\r"
  },
  {
    "sha": "99667cbf335bef24a7d121d84dc89c0da699c362",
    "filename": "discordBot/src/main/java/discordBot/Queen.java",
    "status": "modified",
    "additions": 420,
    "deletions": 65,
    "changes": 485,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/Queen.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/Queen.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/Queen.java?ref=c74da6b51d6bb09c3eed03bcb729099db808b740",
    "patch": "@@ -1,14 +1,22 @@\n package discordBot;\r\n \r\n import java.awt.Color;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n import java.util.ArrayList;\r\n import java.util.Collections;\r\n+import java.util.NoSuchElementException;\r\n import java.util.Random;\r\n \r\n import org.javacord.api.DiscordApi;\r\n import org.javacord.api.DiscordApiBuilder;\r\n import org.javacord.api.entity.message.MessageBuilder;\r\n import org.javacord.api.entity.message.embed.EmbedBuilder;\r\n+import org.javacord.api.entity.server.Server;\r\n+import org.javacord.api.event.message.MessageCreateEvent;\r\n \r\n /**\r\n  * This is QueenBot\r\n@@ -24,32 +32,39 @@\n public class Queen {\r\n \tprivate static final String USERNAME_OF_AUTH_TERMINATOR = /* discord UserID of the person you want to have control */ null;\r\n \tprivate static final String TOKEN = /* Bot token provided by discord */ null;\r\n+\tprivate static final String SAVED_DATA_FILE = \"savedCustoms/savedData\";\r\n \tprivate static final String HELP_COMMAND = \"!help\";\r\n \tprivate String help;\r\n \tprivate DiscordApi api;\r\n-\tprivate boolean isRunning;\t\r\n+\tprivate boolean isRunning;\r\n+\t\r\n \tprivate ArrayList<Response> responses;\r\n \tprivate ArrayList<Response> responseRelyContains;\r\n+\tprivate ArrayList<ServerCustomCommands> customs;\r\n \tprivate static final Random RANDOM = new Random();\r\n \t\r\n \tpublic Queen() {     \r\n         \r\n \t\thelp = \"Hello I am QueenBot\\n\"\r\n \t              + \"I have a list of commands or phrases u may want to use:\\n\"\r\n-\t              + \"!help\" + Utilities.addSpaces(\"!help\") + \": brings up my commandments\";        \r\n-        \r\n-        \r\n-        // creates the arraylists.\r\n-        responses = new ArrayList<>();\r\n-        responseRelyContains = new ArrayList<>();\r\n+\t              + \"!help\" + Utilities.addSpaces(\"!help\") + \": brings up my commandments\";     \r\n         \r\n-        addResponse(HELP_COMMAND, help, help, false, false, null);\r\n-        addResponse(\"?\", null, \"yes / no\", true, false, (api, event) -> {\r\n+        \t// creates the arraylists.\r\n+        \tresponses = new ArrayList<>();\r\n+\t\tcustoms = new ArrayList<>();\r\n+\t\t\r\n+\t\t// adds commands\r\n+        \tresponseRelyContains = new ArrayList<>();\r\n+        \taddResponse(HELP_COMMAND, help, help, false, false, null);\r\n+\t\taddResponse(\"?\", null, \"yes / no\", true, false, (api, event) -> {\r\n \t\t\tString message = RANDOM.nextBoolean() ? \"yes\" : \"no\";\t\t\t\r\n \t\t\tevent.getChannel().sendMessage(message);\t\t\t\r\n \t\t\treturn null;\r\n \t\t});\r\n-        addTerminatorCommand();\r\n+        \taddTerminatorCommand();\r\n+        \taddCustomCommands();\r\n+        \taddCustomHelperCommands();\r\n+\t\tloadCustoms();\r\n \t}\r\n \r\n \t\r\n@@ -71,7 +86,6 @@ public Queen() {\n \t * @throws IllegalArgumentException if command is null or both responses and\r\n \t * lambda are null.\r\n \t */\r\n-\t\t\r\n \tpublic void addResponse(String command, String response, \r\n \t\t\t\tString displayMes, boolean contains, boolean adminOnly, \r\n \t\t\t\tExecutable lambda) {\r\n@@ -113,46 +127,44 @@ public void run () {\n \t\t\tapi = new DiscordApiBuilder().setToken(TOKEN).login().join();\r\n \t\t\tapi.addMessageCreateListener(event -> {\r\n \t\t\t\tCollections.sort(responses);\r\n-\t        \tString toSend = null;\r\n-\t        \tString input;\r\n-        \t\tDefaultResponse toFind;\r\n-        \t\tResponse response;\r\n+\t        \t\tString toSend = null;\r\n+\t        \t\tString input;\r\n+        \t\t\tDefaultResponse toFind;\r\n+        \t\t\tResponse response;\r\n \t        \t\r\n-\t        \tlong messageSender = event.getMessageAuthor().getId();\r\n-\t        \tboolean senderIsYou = messageSender == api.getYourself().getId();\r\n+\t        \t\tlong messageSender = event.getMessageAuthor().getId();\r\n+\t        \t\tboolean senderIsYou = messageSender == api.getYourself().getId();\r\n \t        \t\r\n-\t        \tif (!senderIsYou) {\r\n-\t        \t\tinput = event.getMessageContent().toLowerCase();\r\n-\t        \t\ttoFind = new DefaultResponse(input);\r\n+\t        \t\tif (!senderIsYou) {\r\n+\t        \t\t\tinput = event.getMessageContent().toLowerCase();\r\n+\t        \t\t\ttoFind = new DefaultResponse(input);\r\n \t        \t\t\r\n-\t        \t\tint index = Collections.binarySearch(responses, toFind);\r\n-\t        \t\tresponse = index > -1 ? responses.get(index) : null;\r\n+\t        \t\t\tint index = Collections.binarySearch(responses, toFind);\r\n+\t        \t\t\tresponse = index > -1 ? responses.get(index) : null;\r\n \t        \t\t\r\n-\t        \t\tif (response != null) {\r\n-\t\t\t\t\t\ttoSend = response.exec(api, event);\r\n-\t\t\t\t\t\tif (toSend != null && toSend.equals(help)) {\r\n-\t\t\t\t\t\t\tnew MessageBuilder().setEmbed(new EmbedBuilder().setTitle(\"Commandments\")\r\n-\t\t\t\t\t\t\t\t\t.setColor(Color.yellow).setDescription(help))\r\n-\t\t\t\t\t\t\t\t\t.send(event.getChannel());\r\n-\t\t\t\t\t\t} else if (toSend != null) {\r\n-\t\t\t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n-\t\t\t\t\t\t} \r\n-\t        \t\t} else {\r\n-\t        \t\t\t// where the binary search didn't work but there still\r\n-\t        \t\t\t// may be a chance that it is in rely contains.\r\n+\t        \t\t\tif (response != null) {\r\n+\t\t\t\t\t\t\ttoSend = response.exec(api, event);\r\n+\t\t\t\t\t\t\tif (toSend != null && toSend.equals(help)) {\r\n+\t\t\t\t\t\t\t\tnew MessageBuilder().setEmbed(new EmbedBuilder().setTitle(\"Commandments\")\r\n+\t\t\t\t\t\t\t\t\t\t.setColor(Color.yellow).setDescription(help))\r\n+\t\t\t\t\t\t\t\t\t\t.send(event.getChannel());\r\n+\t\t\t\t\t\t\t} else if (toSend != null) {\r\n+\t\t\t\t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n+\t\t\t\t\t\t\t} \r\n+\t        \t\t\t} else {\r\n+\t        \t\t\t\t// where the binary search didn't work but there still\r\n+\t        \t\t\t\t// may be a chance that it is in rely contains.\r\n \t        \t\t\t\r\n-\t        \t\t\tfor (Response responseCont : responseRelyContains) {\r\n-\t        \t\t\t\ttoSend = responseCont.exec(api, event);\r\n-\t        \t\t\t\tif (toSend != null) {\r\n-\t        \t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n-\t        \t\t\t\t}\t\r\n+\t        \t\t\t\tfor (Response responseCont : responseRelyContains) {\r\n+\t        \t\t\t\t\ttoSend = responseCont.exec(api, event);\r\n+\t        \t\t\t\t\tif (toSend != null) {\r\n+\t        \t\t\t\t\t\tevent.getChannel().sendMessage(toSend);\r\n+\t        \t\t\t\t\t}\t\r\n+\t        \t\t\t\t}\r\n \t        \t\t\t}\r\n \t        \t\t}\r\n-\t        \t}\r\n-\t        \t\r\n-\t        \t\r\n-\t        \t\r\n-\t        });\r\n+\r\n+\t        \t});\r\n \t\t}\r\n \t}\r\n \t\r\n@@ -188,27 +200,370 @@ public boolean hasResponse(Response toCheck) {\n \t * ends the bot.\r\n \t */\r\n \tprivate void addTerminatorCommand() {\r\n-\t\taddResponse(\"!terminate\", null, \"terminates\", true, true, (api, event) -> {\r\n-        \tString input = event.getMessageContent().toLowerCase();\r\n-        \tboolean terminateMessage = false;\r\n-        \tboolean willListen = false;\r\n-        \tif (input.contains(\"\" + api.getYourself().getId())) {\r\n-        \t\tterminateMessage = input.contains(\"!\") && input.contains(\"terminate\");\r\n-        \t}\r\n-        \twillListen = event.getMessageAuthor().getDiscriminatedName()\r\n-        \t\t\t.equals(USERNAME_OF_AUTH_TERMINATOR);\r\n-        \t\r\n-        \tif (terminateMessage && willListen) {\r\n-            \tevent.getChannel().sendMessage(\"Terminating\");\r\n-            \tSystem.out.println(\"input: \" + input );\r\n-            \tSystem.out.println(\"User: \" + event.getMessageAuthor().getDiscriminatedName());\r\n-            \tSystem.out.println(\"User id: \" + event.getMessageAuthor().getId());\r\n-            \tSystem.out.println(\"QueenBot user id:\" + api.getYourself().getId());\r\n-            \tSystem.exit(0);\r\n-        \t}\r\n-        \treturn null;\r\n-        \t\r\n-        });\r\n+      \t\taddResponse(\"!terminate\", null, \"terminates\", true, true, (api, event) -> {\r\n+    \t\t\tString input = event.getMessageContent().toLowerCase();\r\n+    \t\t\tboolean terminateMessage = false;\r\n+    \t\t\tboolean willListen = false;\r\n+    \t\t\tif (input.contains(\"\" + api.getYourself().getId())) {\r\n+    \t\t\t\tterminateMessage = input.contains(\"!\") && input.contains(\"terminate\");\r\n+    \t\t\t}\r\n+    \t\t\twillListen = event.getMessageAuthor().getDiscriminatedName()\r\n+    \t\t\t\t\t.equals(USERNAME_OF_AUTH_TERMINATOR);\r\n+    \t\r\n+    \t\t\tif (terminateMessage && willListen) {\r\n+     \t\t\t   \tif (customs.size() > 0) {\r\n+        \t\t\t\tevent.getChannel().sendMessage(\"Saving customs\");\r\n+        \t\t\t\tsaveCustoms();\r\n+        \t\t\t}\r\n+        \t\t\tevent.getChannel().sendMessage(\"Terminating\");\r\n+        \t\t\tSystem.out.println(\"input: \" + input );\r\n+        \t\t\tSystem.out.println(\"User: \" + event.getMessageAuthor().getDiscriminatedName());\r\n+        \t\t\tSystem.out.println(\"User id: \" + event.getMessageAuthor().getId());\r\n+        \t\t\tSystem.out.println(\"QueenBot user id:\" + api.getYourself().getId());\r\n+        \t\t\tSystem.exit(0);\r\n+    \t\t\t}\r\n+    \t\t\treturn null;\r\n+    \t\r\n+    \t\t});\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Saved the customs to a file.\r\n+\t */\r\n+\tprivate void saveCustoms() {\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tFileOutputStream fileOutput = new FileOutputStream(SAVED_DATA_FILE);\r\n+\t\t\tObjectOutputStream objectOut = new ObjectOutputStream(fileOutput);\r\n+\t\t\tobjectOut.writeObject(customs);\r\n+\t\t\tobjectOut.flush();\r\n+\t\t\tobjectOut.close();\r\n+\t\t\tfileOutput.close();\r\n+\t\t} catch (IOException e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t}\r\n+\t\t\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Reads the customs file if there is one and then adds customs to the queen\r\n+\t * object accordingly.\r\n+\t */\r\n+\t@SuppressWarnings(\"unchecked\")\r\n+\tprivate void loadCustoms() {\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tFileInputStream fileIn = new FileInputStream(SAVED_DATA_FILE);\r\n+\t\t\tObjectInputStream objectIn = new ObjectInputStream(fileIn);\r\n+\t\t\tcustoms = (ArrayList<ServerCustomCommands>) objectIn.readObject();\r\n+\t\t\tobjectIn.close();\r\n+\t\t\tfileIn.close();\r\n+\t\t} catch (IOException e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t} catch (ClassNotFoundException e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t} catch (ClassCastException e) {\r\n+\t\t\te.printStackTrace();\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * The method that adds the customs commands trigger. This method is called\r\n+\t * in the constructor. \r\n+\t */\r\n+\tprivate void addCustomCommands() {\r\n+\t\taddResponse(\"!customs\", null, \"check custom commands\", false, false, \r\n+\t\t\t\t(api, event) -> {\r\n+\t\t\t\t\tif (event.getMessageContent().toLowerCase().equals(\"!customs\")) {\r\n+\t\t\t\t\t\tServer server = getServer(event);\r\n+\t\t\t\t\t\tif (server != null) {\r\n+\t\t\t\t\t\t\tString customCommands[] = {\r\n+\t\t\t\t\t\t\t\t\t\"!customs-on/off\" + Utilities.addSpaces(\"!customs on/off\") +\r\n+\t\t\t\t\t\t\t\t\t\": enables or disables customs\",\r\n+\t\t\t\t\t\t\t\t\t\"!customs-clear\" + Utilities.addSpaces(\"!customs clear\") \r\n+\t\t\t\t\t\t\t\t\t+ \": clears all customs\",\r\n+\t\t\t\t\t\t\t\t\t\"!customs-add\" + Utilities.addSpaces(\"!customs add\") + \r\n+\t\t\t\t\t\t\t\t\t\": adds custom (input and output need to be separated by a \\\":\\\"\",\r\n+\t\t\t\t\t\t\t\t\t\"!customs-remove\" + Utilities.addSpaces(\"!customs remove\") +\r\n+\t\t\t\t\t\t\t\t\t\": removes the specified custom by input\"\r\n+\t\t\t\t\t\t\t};\r\n+\t\t\t\t\t\t\t\r\n+\t\t\t\t\t\t\tString commandStr = customCommands[0];\r\n+\t\t\t\t\t\t\tfor (int i = 1; i < customCommands.length; i ++) {\r\n+\t\t\t\t\t\t\t\tcommandStr += \"\\n\" + customCommands[i];\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\tnew MessageBuilder().setEmbed(new EmbedBuilder()\r\n+\t\t        \t\t\t\t\t.setTitle(\"Customs Settings\")\r\n+\t\t        \t\t\t\t\t.setColor(Color.yellow)\r\n+\t\t        \t\t\t\t\t.setDescription(commandStr)\r\n+\t\t        \t\t\t\t).send(event.getChannel());\r\n+\t\t\t\t\t\t\t\r\n+\t\t\t\t\t\t} else {\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\"No customs outside of servers\");\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\treturn null;\t\r\n+\t\t});\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Adds all the necessary helper commands that are associated with customs. \r\n+\t */\r\n+\tprivate void addCustomHelperCommands() {\r\n+\t\taddCustomsOn();\r\n+\t\taddCustomsClear();\r\n+\t\taddCustomsAdd();\r\n+\t\taddCustomsRemove();\r\n+\t\t\r\n+\t\t\r\n+\t\t\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Adds the remove command. It first checks to see if customs are on in the\r\n+\t * chat. If true then it calls the ServerCustomCommands remove method with the\r\n+\t * string after the command call. If it successfully found the response to\r\n+\t * remove it will say removed. Otherwise it will say not found.\r\n+\t */\r\n+\tprivate void addCustomsRemove() {\r\n+\t\tResponse remove = new DefaultResponse(\"!customs-remove\", null, true, \r\n+\t\t\t\t(api, event) -> {\r\n+\t\t\t\t\t\r\n+\t\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\t\tif (input.contains(\"!customs-remove\")\r\n+\t\t\t\t\t&& input.charAt(0) == '!') {\r\n+\t\t\t\t\r\n+\t\t\t\tServerCustomCommands custom = findCustom(event);\r\n+\t\t\t\t\r\n+\t\t\t\tif (custom != null) {\r\n+\t\t\t\t\tString[] args = Utilities.interpreter(event.getMessageContent(), 1, true);\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (args == null) {\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\"I could not understand\\n\" +\r\n+\t\t\t\t\t\t\t\t\"Make sure your text reads the command then \"\r\n+\t\t\t\t\t\t\t\t+ \"\\\"input of custom\\\"\"\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\targs[0] = args[0].toLowerCase();\r\n+\t\t\t\t\t\tif (custom.remove(args[0])) {\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\t\"Removed the \" +\r\n+\t\t\t\t\t\t\t\t\t\"\\\"\" + args[0] + \"\\\" trigger\"\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t\t} else {\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\"Could not find command\");\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tevent.getChannel().sendMessage(\"you have to enable customs first\");\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\treturn null;\r\n+\t\t});\r\n+\t\tresponses.add(remove);\r\n+\t\tresponseRelyContains.add(remove);\r\n+\t}\r\n+\r\n+\r\n+\r\n+\t/**\r\n+\t * This adds the customs add command. This will first check if the customs are\r\n+\t * on for the selected chat. If they are on then it will take the string after\r\n+\t * the command call and process it and then add a custom response to the\r\n+\t * ServerCustomCommands object associated with the server.\r\n+\t */\r\n+\tprivate void addCustomsAdd() {\r\n+\t\tResponse add = new DefaultResponse(\"!customs-add\", null, true, (api, event) -> {\r\n+\t\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\t\tif (input.contains(\"!customs-add\")\r\n+\t\t\t\t\t&& input.charAt(0) == '!') {\r\n+\r\n+\t\t\t\tServerCustomCommands custom = findCustom(event);\r\n+\t\t\t\t\r\n+\t\t\t\tif (custom != null) {\r\n+\t\t\t\t\tString[] args = Utilities.interpreter(event.getMessageContent(), 2, true);\r\n+\t\t\t\t\tif (args == null) {\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\"I could not understand\\n\" +\r\n+\t\t\t\t\t\t\t\t\"Make sure your text reads the command then \"\r\n+\t\t\t\t\t\t\t\t+ \"\\\"input : output\\\"\"\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\targs[0] = args[0].toLowerCase();\r\n+\t\t\t\t\t\tboolean sendError = false;\r\n+\t\t\t\t\t\tfor (Response response : responseRelyContains) {\r\n+\t\t\t\t\t\t\tif (args[0].contains(response.getCommand())) {\r\n+\t\t\t\t\t\t\t\tsendError = true;\r\n+\t\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (sendError) {\r\n+\t\t\t\t\t\t\t\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\t\"Sorry but I can't let\"\r\n+\t\t\t\t\t\t\t\t\t+ \"you add this response it may already be used\"\r\n+\t\t\t\t\t\t\t\t\t+ \" for reasons\");\r\n+\t\t\t\t\t\t} else if (custom.addResponse(args[0], args[1], this)) {\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\t\"\\\"\" + args[0] + \"\\\" triggers\" \r\n+\t\t\t\t\t\t\t\t\t+ \"\\\"\" + args[1] + \"\\\"\"\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t\t} else {\r\n+\t\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\t\"Error :\\\\\"\r\n+\t\t\t\t\t\t\t\t\t+ \" Already added or is already command\"\r\n+\t\t\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\t\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tevent.getChannel().sendMessage(\"you have to enable customs first\");\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn null;\r\n+\t\t});\r\n+\t\tresponses.add(add);\r\n+\t\tresponseRelyContains.add(add);\r\n+\t}\r\n+\r\n+\r\n+\r\n+\t/**\r\n+\t * This will remove or clear all the customs on the server. First it checks if\r\n+\t * the current chat is on a server. (Will do nothing if not on a server.) It\r\n+\t * then checks to see if there is a customs object associated with the server in\r\n+\t * the arrayList customs. If both are true then it will check if the sender is\r\n+\t * the admin of the server. After all that it will then remove the\r\n+\t * ServerCustomCommands object from the customs arrayList.\r\n+\t */\r\n+\tprivate void addCustomsClear() {\r\n+\t\tresponses.add(new DefaultResponse(\"!customs-off\", null, false, (api, event) -> {\r\n+\t\t\treturn customsClearExecutable(event);\r\n+\t\t\t}));\r\n+\t\tresponses.add(new DefaultResponse(\"!customs-clear\", null, false, (api, event) -> {\r\n+\t\t\treturn customsClearExecutable(event);\r\n+\t\t}));\r\n+\t}\r\n+\r\n+\r\n+\r\n+\t/**\r\n+\t * This is the lambda expression used by both of the clear responses.\r\n+\t * @param event\r\n+\t * @return\r\n+\t */\r\n+\tprivate String customsClearExecutable(MessageCreateEvent event) {\r\n+\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\tServer server = getServer(event);\r\n+\t\t\r\n+\t\tif (input.equals(\"!customs-off\") || input.equals(\"!customs-clear\")) {\r\n+\t\t\t\r\n+\t\t\tServerCustomCommands custom = findCustom(event);\r\n+\t\t\tif (custom != null) {\r\n+\t\t\t\tif (event.getMessageAuthor().isServerAdmin()) {\r\n+\r\n+\t\t\t\t\tint index = Collections.binarySearch(customs, custom);\r\n+\t\t\t\t\tif (index >= 0) {\r\n+\t\t\t\t\t\tcustoms.remove(index);\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\"Removed all customs\");\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\"No customs to remove\");\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\t\r\n+\t\t\t\t\t\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\"You must be and admin to access customs duh\"\r\n+\t\t\t\t\t);\r\n+\t\t\t\t}\r\n+\t\t\t} else if (server != null) {\r\n+\t\t\t\tevent.getChannel().sendMessage(\"No customs to remove\");\r\n+\t\t\t\t\r\n+\t\t\t\t\r\n+\t\t\t} else {\r\n+\t\t\t\tevent.getChannel().sendMessage(\"I can only remove customs on servers dummy\");\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn null;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * This adds the customs on command. This command checks if the current chat is\r\n+\t * in a server (will not add if on). Then it checks if the given server already\r\n+\t * has a ServerCustomCommands object associated with it in the arrayList\r\n+\t * customs. (Will not add 2 customs for 1 server.) Then it checks to see if the\r\n+\t * message sender is the admin of the serer (will not allow anyone who is not\r\n+\t * admin from turning on customs.) Finally if it meets all the above criteria it\r\n+\t * creates a ServerCustomCommands object and puts in the server id.\r\n+\t */\r\n+\tprivate void addCustomsOn() {\r\n+\t\tresponses.add(new DefaultResponse(\"!customs-on\", null, false, (api, event) -> {\r\n+\t\t\tString input = event.getMessageContent().toLowerCase();\r\n+\t\t\tServer server = getServer(event);\r\n+\t\t\t\r\n+\t\t\tif (input.equals(\"!customs-on\")) {\r\n+\t\t\t\t\r\n+\t\t\t\tif (findCustom(event) != null) {\r\n+\t\t\t\t\tevent.getChannel().sendMessage(\"Customs are already on\");\r\n+\t\t\t\t} else if (server != null) {\r\n+\t\t\t\t\tlong serverId = server.getId();\r\n+\t\t\t\t\t\r\n+\t\t\t\t\tif (event.getMessageAuthor().isServerAdmin()) {\r\n+\t\t\t\t\t\tcustoms.add(new ServerCustomCommands(serverId));\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\"Enabled them customs\");\r\n+\t\t\t\t\t} else {\r\n+\t\t\t\t\t\tevent.getChannel().sendMessage(\r\n+\t\t\t\t\t\t\t\t\"You must be and admin to access customs duh\"\r\n+\t\t\t\t\t\t);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tevent.getChannel().sendMessage(\"I can only add customs on servers dummy\");\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\treturn null;\r\n+\t\t}));\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Given an event it will return a server reference if there is one.\r\n+\t * @param event\r\n+\t * @return reference to a server.\r\n+\t */\r\n+\tprivate Server getServer(MessageCreateEvent event) {\r\n+\t\tServer server;\r\n+\t\ttry {\r\n+\t\t\tserver = event.getServer().get();\r\n+\t\t} catch (NoSuchElementException e) {\r\n+\t\t\tserver = null;\r\n+\t\t}\r\n+\t\treturn server;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Takes in an event and checks to see if there is a ServerCustom command \r\n+\t * associated with the server.\r\n+\t * @param event\r\n+\t * @return\r\n+\t */\r\n+\tprivate ServerCustomCommands findCustom (MessageCreateEvent event) {\r\n+\t\tServer server = getServer(event);\r\n+\t\tint index = -1;\r\n+\t\tif (server != null) {\r\n+\t\t\tServerCustomCommands key = new ServerCustomCommands(server.getId());\r\n+\t\t\tindex = Collections.binarySearch(customs, key);\r\n+\t\t\t\r\n+\t\t}\r\n+\t\tif (index > - 1 ) {\r\n+\t\t\treturn customs.get(index);\r\n+\t\t}\r\n+\t\treturn null;\r\n+\t\t\r\n \t}\r\n \r\n }\r"
  },
  {
    "sha": "f68774282fb17919c38fec6227296a2568427c5b",
    "filename": "discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "status": "added",
    "additions": 178,
    "deletions": 0,
    "changes": 178,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/ServerCustomCommands.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/ServerCustomCommands.java?ref=c74da6b51d6bb09c3eed03bcb729099db808b740",
    "patch": "@@ -0,0 +1,178 @@\n+package discordBot;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+\r\n+import org.javacord.api.DiscordApi;\r\n+import org.javacord.api.event.message.MessageCreateEvent;\r\n+\r\n+/**\r\n+ * This is an object associated with a server that keeps track of all the \r\n+ * custom responses.\r\n+ * @author kjara\r\n+ *\r\n+ */\r\n+public class ServerCustomCommands implements Comparable <ServerCustomCommands>, Serializable {\r\n+\t/**\r\n+\t * \r\n+\t */\r\n+\tprivate static final long serialVersionUID = -2453323497723493301L;\r\n+\tprivate ArrayList<SimpleResponse> customResponses;\r\n+\tprivate long serverId;\r\n+\tprivate String customHelpAddition;\r\n+\t\r\n+\t/**\r\n+\t * Constructor.\r\n+\t * @param serverId\r\n+\t * @param queen\r\n+\t */\r\n+\tpublic ServerCustomCommands(long serverId) {\r\n+\t\tcustomResponses = new ArrayList<> ();\r\n+\t\tcustomHelpAddition = \"\";\r\n+\t\tthis.serverId = serverId;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Will take in two strings and add a response to the list. It will return \r\n+\t * true if both input and output are not null and response is added. Will not add\r\n+\t * any commands that are duplicates or default to queen.\r\n+\t * @param input\r\n+\t * @param output\r\n+\t * @return boolean true if added.\r\n+\t */\r\n+\tpublic boolean addResponse(String input, String output, Queen queen) {\r\n+\t\tif (input != null && output != null && queen != null) {\r\n+\t\t\tboolean noAdd = false;\r\n+\t\t\tSimpleResponse toAdd = new SimpleResponse(input, output);\r\n+\t\t\tnoAdd = queen.hasResponse(toAdd);\r\n+\t\t\t\r\n+\t\t\tif (!noAdd) {\r\n+\t\t\t\tint index = Collections.binarySearch(customResponses, toAdd);\r\n+\t\t\t\tnoAdd = index > -1;\r\n+\t\t\t}\r\n+\t\t\tif (!noAdd) {\r\n+\t\t\t\tcustomResponses.add(toAdd);\r\n+\t\t\t\tif (customHelpAddition.isEmpty()) {\r\n+\t\t\t\t\tcustomHelpAddition += \"\\nCustoms\";\r\n+\t\t\t\t\t\r\n+\t\t\t\t}\r\n+\t\t\t\tcustomHelpAddition += \"\\n\" + input + \r\n+\t\t\t\t\t\tUtilities.addSpaces(input) + \": \" + output;\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * This will return the custom help addition which is just the list of custom\r\n+\t * commands with their responses.\r\n+\t * @return\r\n+\t */\r\n+\tpublic String getCustomHelpAddition() {\r\n+\t\treturn customHelpAddition;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Returns the serverId of the custom.\r\n+\t * @return\r\n+\t */\r\n+\tpublic long getServerId() {\r\n+\t\treturn serverId;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Gets the number of custom commands in the object.\r\n+\t * @return\r\n+\t */\r\n+\tpublic int getNumberCustoms() {\r\n+\t\treturn customResponses.size();\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * This is the remove command. It will remove a response corresponding to the\r\n+\t * given input command. It will also edit the help message string. \r\n+\t * This will return true if the command was found and removed. \r\n+\t * @param command\r\n+\t * @return boolean true if successful.\r\n+\t */\r\n+\tpublic boolean remove(String command) {\r\n+\t\tSimpleResponse toFind = new SimpleResponse (command);\r\n+\t\t\r\n+\t\tint index = Collections.binarySearch(customResponses, toFind);\r\n+\t\t\r\n+\t\tif (index > -1) {\r\n+\t\t\tcustomResponses.remove(index);\r\n+\t\t\tString tempHelpAddition = customHelpAddition;\r\n+\t\t\tint commandStart = tempHelpAddition.indexOf(command);\r\n+\t\t\tif (commandStart > 1) {\r\n+\t\t\t\t// because of the new line character\r\n+\t\t\t\ttempHelpAddition = customHelpAddition.substring(0, commandStart - 1);\r\n+\t\t\t\t// starts at character after \\n\r\n+\t\t\t\tString lineToRemove = customHelpAddition.substring(commandStart);\r\n+\t\t\t\tint nextNewLine = lineToRemove.indexOf('\\n');\r\n+\t\t\t\tString remaining = \"\";\r\n+\t\t\t\tif (nextNewLine >= 0 && (nextNewLine + commandStart + 1) \r\n+\t\t\t\t\t\t< customHelpAddition.length()) {\r\n+\t\t\t\t\tremaining = customHelpAddition.substring(\r\n+\t\t\t\t\t\t\tnextNewLine + commandStart + 1\r\n+\t\t\t\t\t); \r\n+\t\t\t\t}\r\n+\t\t\t\t\r\n+\t\t\t\ttempHelpAddition += remaining;\r\n+\t\t\t\tcustomHelpAddition = tempHelpAddition;\r\n+\t\t\t\t\r\n+\t\t\t}\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * This will loop through all the responses and return a string that is a response\r\n+\t * to the message if there is one. Otherwise returns null.\r\n+\t * @param api\r\n+\t * @param event\r\n+\t * @return String response if it finds one to return\r\n+\t */\r\n+\tpublic String returnCustomResponse(DiscordApi api, MessageCreateEvent event) {\r\n+\t\tString toSend = null;\r\n+\t\tString command = event.getMessageContent().toLowerCase();\r\n+\t\tCollections.sort(customResponses);\r\n+\t\tResponse toFind = new SimpleResponse(command);\r\n+\t\tint index = Collections.binarySearch(customResponses, toFind);\r\n+\t\tif (index > -1) {\r\n+\t\t\treturn customResponses.get(index).exec(api, event);\r\n+\t\t}\r\n+\t\treturn toSend;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Overrides the equals method. Objects are compared by the serveriD.\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean equals(Object obj) {\r\n+\t\tif (obj == this) \r\n+\t\t\treturn true;\r\n+\t\tif (!(obj instanceof ServerCustomCommands))\r\n+\t\t\treturn false;\r\n+\t\t\r\n+\t\tServerCustomCommands other = (ServerCustomCommands) obj;\r\n+\t\treturn other.serverId == serverId;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Method needed to implement comparable. Objects are compared by their \r\n+\t * serverIds.\r\n+\t */\r\n+\t@Override\r\n+\tpublic int compareTo(ServerCustomCommands other) {\r\n+\t\treturn Long.compare(serverId, other.serverId);\r\n+\t}\r\n+\t\r\n+\t@Override\r\n+\tpublic String toString() {\r\n+\t\treturn \"\" + serverId + getCustomHelpAddition().substring(8);\r\n+\t}\r\n+}\r"
  },
  {
    "sha": "712432a57f3a6649a6f6afed3cd131ef347c1089",
    "filename": "discordBot/src/main/java/discordBot/SimpleResponse.java",
    "status": "added",
    "additions": 89,
    "deletions": 0,
    "changes": 89,
    "blob_url": "https://github.com/Camelot314/queenBot/blob/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/SimpleResponse.java",
    "raw_url": "https://github.com/Camelot314/queenBot/raw/c74da6b51d6bb09c3eed03bcb729099db808b740/discordBot/src/main/java/discordBot/SimpleResponse.java",
    "contents_url": "https://api.github.com/repos/Camelot314/queenBot/contents/discordBot/src/main/java/discordBot/SimpleResponse.java?ref=c74da6b51d6bb09c3eed03bcb729099db808b740",
    "patch": "@@ -0,0 +1,89 @@\n+package discordBot;\r\n+\r\n+import java.io.Serializable;\r\n+\r\n+import org.javacord.api.DiscordApi;\r\n+import org.javacord.api.event.message.MessageCreateEvent;\r\n+\r\n+public final class SimpleResponse implements Serializable, Response {\r\n+\t/**\r\n+\t * \r\n+\t */\r\n+\tprivate static final long serialVersionUID = -4192087201373479648L;\r\n+\tprivate String command, response;\r\n+\t\r\n+\t/**\r\n+\t * Constructor\r\n+\t * @param command\r\n+\t * @param response\r\n+\t */\r\n+\tpublic SimpleResponse(String command, String response) {\r\n+\t\tthis.command = command;\r\n+\t\tthis.response = response;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Constructor that is used for the Collections binary search method.\r\n+\t * The object is initialized with nothing other than the command. Do not\r\n+\t * use the object initialized with this constructor for anything else.\r\n+\t * @param command\r\n+\t */\r\n+\tpublic SimpleResponse(String command) {\r\n+\t\tthis.command = command;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * The executes. Basically gets the response. \r\n+\t */\r\n+\t@Override\r\n+\tpublic String exec(DiscordApi api, MessageCreateEvent event) {\r\n+\t\treturn getDefaultResponse();\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * The same thing but with an additional param. This is needed to satisfy the\r\n+\t * interface.\r\n+\t */\r\n+\t@Override\r\n+\tpublic String exec(DiscordApi api, MessageCreateEvent event, String add) {\r\n+\t\treturn getDefaultResponse();\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Returns the command.\r\n+\t */\r\n+\t@Override\r\n+\tpublic String getCommand() {\r\n+\t\treturn command;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Gets the response.\r\n+\t */\r\n+\t@Override\r\n+\tpublic String getDefaultResponse() {\r\n+\t\treturn response;\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Equals method. It compares by the command.\r\n+\t */\r\n+\t@Override\r\n+\tpublic boolean equals(Object obj) {\r\n+\t\tif (obj == this) \r\n+\t\t\treturn true;\r\n+\t\tif (!(obj instanceof Response)) \r\n+\t\t\treturn false;\r\n+\t\t\r\n+\t\tResponse other = (Response) obj;\r\n+\t\treturn command.equals(other.getCommand());\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * toString() method.\r\n+\t */\r\n+\t@Override\r\n+\tpublic String toString() {\r\n+\t\treturn getCommand() + \" : \" + getDefaultResponse();\r\n+\t}\r\n+}\r"
  }
]
