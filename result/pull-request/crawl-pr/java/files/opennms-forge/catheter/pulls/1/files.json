[
  {
    "sha": "6366013304bdb825f959123177b0b3b8e0e7327a",
    "filename": "README.md",
    "status": "modified",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/02e448f6565b6ce21a39dd7f6e410f823044335d/README.md",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/02e448f6565b6ce21a39dd7f6e410f823044335d/README.md",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/README.md?ref=02e448f6565b6ce21a39dd7f6e410f823044335d",
    "patch": "@@ -24,9 +24,7 @@ So, the byte rate can be combined of more or less flows. The following example s\n This will result in a pretty random stream of flows that total up to the requested byte rate. The following example code will create a realtime simulation with three exporters. The third exporter has an skewed clock with a five minutes offset:\n \n \n-    final Simulation simulation = Simulation.builder()\n-                .withBootstrapServers(KAFKA_BOOTSTRAP_SERVERS)\n-                .withFlowTopic(KAFKA_FLOW_TOPIC)\n+    final Simulation simulation = Simulation.builder(handler)\n                 .withTickMs(Duration.ofMillis(100))\n                 .withRealtime(true)\n                 .withExporters(Exporter.builder()"
  },
  {
    "sha": "8e86b75794c73c0b64e9af5038b3bd576b589f1d",
    "filename": "pom.xml",
    "status": "modified",
    "additions": 0,
    "deletions": 17,
    "changes": 17,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/02e448f6565b6ce21a39dd7f6e410f823044335d/pom.xml",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/02e448f6565b6ce21a39dd7f6e410f823044335d/pom.xml",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/pom.xml?ref=02e448f6565b6ce21a39dd7f6e410f823044335d",
    "patch": "@@ -44,13 +44,11 @@\n     </build>\n \n     <properties>\n-        <kafka.version>2.4.1</kafka.version>\n         <log4j.version>2.13.3</log4j.version>\n         <slf4j.version>1.7.28</slf4j.version>\n         <testcontainers.version>1.15.0</testcontainers.version>\n         <junit.version>4.13.1</junit.version>\n         <args4j.version>2.33</args4j.version>\n-\t<moxy.version>2.5.1</moxy.version>\n         <jaxb.api.version>2.3.0</jaxb.api.version>\n     </properties>\n \n@@ -60,21 +58,6 @@\n             <artifactId>guava</artifactId>\n             <version>26.0-jre</version>\n         </dependency>\n-        <dependency>\n-            <groupId>org.apache.kafka</groupId>\n-            <artifactId>kafka-clients</artifactId>\n-            <version>${kafka.version}</version>\n-        </dependency>\n-        <dependency>\n-            <groupId>org.opennms.nephron</groupId>\n-            <artifactId>nephron-proto</artifactId>\n-            <version>LATEST</version>\n-        </dependency>\n-        <dependency>\n-            <groupId>org.eclipse.persistence</groupId>\n-            <artifactId>org.eclipse.persistence.moxy</artifactId>\n-            <version>${moxy.version}</version>\n-        </dependency>\n         <dependency>\n             <groupId>args4j</groupId>\n             <artifactId>args4j</artifactId>"
  },
  {
    "sha": "a15482e22b0827c504733b7287e1773567b35f8c",
    "filename": "src/main/java/org/opennms/nephron/catheter/Catheter.java",
    "status": "removed",
    "additions": 0,
    "deletions": 72,
    "changes": 72,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/875dd862385acfd439c9533198685b2ebfae5da2/src/main/java/org/opennms/nephron/catheter/Catheter.java",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/875dd862385acfd439c9533198685b2ebfae5da2/src/main/java/org/opennms/nephron/catheter/Catheter.java",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/src/main/java/org/opennms/nephron/catheter/Catheter.java?ref=875dd862385acfd439c9533198685b2ebfae5da2",
    "patch": "@@ -1,72 +0,0 @@\n-/*******************************************************************************\n- * This file is part of OpenNMS(R).\n- *\n- * Copyright (C) 2020 The OpenNMS Group, Inc.\n- * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n- *\n- * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n- *\n- * OpenNMS(R) is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Affero General Public License as published\n- * by the Free Software Foundation, either version 3 of the License,\n- * or (at your option) any later version.\n- *\n- * OpenNMS(R) is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU Affero General Public License for more details.\n- *\n- * You should have received a copy of the GNU Affero General Public License\n- * along with OpenNMS(R).  If not, see:\n- *      http://www.gnu.org/licenses/\n- *\n- * For more information contact:\n- *     OpenNMS(R) Licensing <license@opennms.org>\n- *     http://www.opennms.org/\n- *     http://www.opennms.com/\n- *******************************************************************************/\n-\n-package org.opennms.nephron.catheter;\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import javax.xml.bind.JAXBException;\n-\n-import org.kohsuke.args4j.Argument;\n-import org.kohsuke.args4j.CmdLineException;\n-import org.kohsuke.args4j.CmdLineParser;\n-\n-\n-public class Catheter {\n-\n-    @Argument\n-    private File jsonConfigFile;\n-\n-    public static void main(final String... args) throws IOException, JAXBException {\n-        new Catheter().run(args);\n-    }\n-\n-    private void run(final String... args) throws IOException, JAXBException {\n-        final CmdLineParser parser = new CmdLineParser(this);\n-\n-        try {\n-            parser.parseArgument(args);\n-\n-            if (jsonConfigFile == null) {\n-                throw new CmdLineException(parser, \"No argument is given\");\n-            }\n-        } catch (CmdLineException e) {\n-            System.err.println(e.getMessage());\n-            System.err.println(\"java -jar catheter-1.0-SNAPSHOT-jar-with-dependencies.jar JSON-file\");\n-            parser.printUsage(System.err);\n-            System.err.println();\n-\n-            return;\n-        }\n-\n-        final Simulation simulation = Simulation.fromFile(jsonConfigFile);\n-\n-        simulation.start();\n-    }\n-}"
  },
  {
    "sha": "c20691ddd928b8caef1b5d1b3b3ebda85a8e935b",
    "filename": "src/main/java/org/opennms/nephron/catheter/Exporter.java",
    "status": "modified",
    "additions": 25,
    "deletions": 92,
    "changes": 117,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/02e448f6565b6ce21a39dd7f6e410f823044335d/src/main/java/org/opennms/nephron/catheter/Exporter.java",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/02e448f6565b6ce21a39dd7f6e410f823044335d/src/main/java/org/opennms/nephron/catheter/Exporter.java",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/src/main/java/org/opennms/nephron/catheter/Exporter.java?ref=02e448f6565b6ce21a39dd7f6e410f823044335d",
    "patch": "@@ -28,32 +28,13 @@\n \n package org.opennms.nephron.catheter;\n \n-import java.net.Inet4Address;\n-import java.net.InetAddress;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Arrays;\n import java.util.Collection;\n-import java.util.List;\n import java.util.Objects;\n import java.util.Random;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-import org.opennms.netmgt.flows.persistence.model.FlowDocument;\n-import org.opennms.netmgt.flows.persistence.model.Locality;\n-import org.opennms.netmgt.flows.persistence.model.NodeInfo;\n-\n-import com.google.common.net.InetAddresses;\n-import com.google.protobuf.UInt32Value;\n-import com.google.protobuf.UInt64Value;\n \n public class Exporter {\n-    private final List<Integer> protocols;\n-    private final List<String> applications;\n-    private final List<String> hosts;\n-    private final List<AddrHost> addresses;\n     private final int nodeId;\n     private final String foreignSource;\n     private final String foreignId;\n@@ -76,10 +57,6 @@ private Exporter(final Builder builder,\n         this.random = random;\n         this.generator = builder.generator.build(now, random);\n \n-        this.protocols = Arrays.asList(6, 17);\n-        this.applications = generate(200, generateString(15));\n-        this.hosts = generate(5, generateString(10));\n-        this.addresses = generate(100, () -> new AddrHost(generateInetAddr().get(), generateString(10).get()));\n         this.inputSnmp = builder.inputSnmp;\n         this.outputSnmp = builder.outputSnmp;\n     }\n@@ -88,53 +65,12 @@ public static Builder builder() {\n         return new Builder();\n     }\n \n-    public Collection<FlowDocument> tick(final Instant now) {\n-        return this.generator.tick(now).stream().map(this::createFlowDocument).collect(Collectors.toList());\n-    }\n-\n-    public Collection<FlowDocument> shutdown(final Instant now) {\n-        return this.generator.shutdown(now).stream().map(this::createFlowDocument).collect(Collectors.toList());\n+    public Collection<FlowReport> tick(final Instant now) {\n+        return this.generator.tick(now);\n     }\n \n-    private FlowDocument createFlowDocument(final FlowReport report) {\n-        final int protocol = choose(this.protocols);\n-        final String application = choose(this.applications);\n-\n-        final AddrHost srcAddr = choose(this.addresses);\n-        final AddrHost dstAddr = choose(this.addresses);\n-\n-        final InetAddress[] convo = InetAddresses.coerceToInteger(srcAddr.address) < InetAddresses.coerceToInteger(dstAddr.address)\n-                ? new InetAddress[]{srcAddr.address, dstAddr.address}\n-                : new InetAddress[]{dstAddr.address, srcAddr.address};\n-\n-        final String convoKey = \"[\\\"\" + this.location + \"\\\",\\\"\" + protocol + \",\\\"\" + InetAddresses.toAddrString(convo[0]) + \"\\\",\\\"\" + InetAddresses.toAddrString(convo[1]) + \"\\\",\\\"\" + application + \"\\\"]\";\n-\n-        final FlowDocument.Builder flow = FlowDocument.newBuilder();\n-        flow.setApplication(application);\n-        flow.setHost(choose(this.hosts));\n-        flow.setLocation(this.location);\n-        flow.setDstLocality(Locality.PUBLIC);\n-        flow.setSrcLocality(Locality.PUBLIC);\n-        flow.setFlowLocality(Locality.PUBLIC);\n-        flow.setSrcAddress(InetAddresses.toAddrString(srcAddr.address));\n-        flow.setDstAddress(InetAddresses.toAddrString(dstAddr.address));\n-        flow.setSrcHostname(srcAddr.hostname);\n-        flow.setDstHostname(dstAddr.hostname);\n-        flow.setFirstSwitched(UInt64Value.of(report.getStart().plus(this.clockOffset).toEpochMilli()));\n-        flow.setDeltaSwitched(UInt64Value.of(report.getStart().plus(this.clockOffset).toEpochMilli()));\n-        flow.setLastSwitched(UInt64Value.of(report.getEnd().plus(this.clockOffset).toEpochMilli()));\n-        flow.setNumBytes(UInt64Value.of(report.getBytes()));\n-        flow.setConvoKey(convoKey);\n-        flow.setInputSnmpIfindex(UInt32Value.of(this.inputSnmp));\n-        flow.setOutputSnmpIfindex(UInt32Value.of(this.outputSnmp));\n-\n-        final NodeInfo.Builder exporter = NodeInfo.newBuilder();\n-        exporter.setNodeId(this.nodeId);\n-        exporter.setForeignSource(this.foreignSource);\n-        exporter.setForeginId(this.foreignId);\n-        flow.setExporterNode(exporter);\n-\n-        return flow.build();\n+    public Collection<FlowReport> shutdown(final Instant now) {\n+        return this.generator.shutdown(now);\n     }\n \n     @Override\n@@ -168,28 +104,35 @@ public String toString() {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(this.protocols, this.applications, this.hosts, this.addresses, this.nodeId, this.foreignSource, this.foreignId, this.location, this.generator, this.clockOffset, this.random, this.inputSnmp, this.outputSnmp);\n+        return Objects.hash(this.nodeId, this.foreignSource, this.foreignId, this.location, this.generator, this.clockOffset, this.random, this.inputSnmp, this.outputSnmp);\n+    }\n+\n+    public int getNodeId() {\n+        return this.nodeId;\n+    }\n+\n+    public String getForeignSource() {\n+        return this.foreignSource;\n+    }\n+\n+    public int getInputSnmp() {\n+        return this.inputSnmp;\n     }\n \n-    private Supplier<String> generateString(final int length) {\n-        return () -> random.ints(97, 123)\n-                .limit(length)\n-                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)\n-                .toString();\n+    public Duration getClockOffset() {\n+        return this.clockOffset;\n     }\n \n-    private <T> List<T> generate(final int count, final Supplier<T> f) {\n-        return IntStream.range(0, count)\n-                .mapToObj(i -> f.get())\n-                .collect(Collectors.toList());\n+    public int getOutputSnmp() {\n+        return this.outputSnmp;\n     }\n \n-    private Supplier<Inet4Address> generateInetAddr() {\n-        return () -> InetAddresses.fromInteger(random.nextInt());\n+    public String getForeignId() {\n+        return this.foreignId;\n     }\n \n-    private <T> T choose(final List<T> options) {\n-        return options.get(random.nextInt(options.size()));\n+    public String getLocation() {\n+        return this.location;\n     }\n \n     public static class Builder {\n@@ -274,14 +217,4 @@ public Exporter build(final Instant now, final Random random) {\n             return new Exporter(this, now, random);\n         }\n     }\n-\n-    private static class AddrHost {\n-        public final InetAddress address;\n-        public final String hostname;\n-\n-        private AddrHost(final InetAddress address, final String hostname) {\n-            this.address = Objects.requireNonNull(address);\n-            this.hostname = Objects.requireNonNull(hostname);\n-        }\n-    }\n }"
  },
  {
    "sha": "8a1a9e6b22d132c05252453b358c0483e0f861d9",
    "filename": "src/main/java/org/opennms/nephron/catheter/Simulation.java",
    "status": "modified",
    "additions": 31,
    "deletions": 109,
    "changes": 140,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/02e448f6565b6ce21a39dd7f6e410f823044335d/src/main/java/org/opennms/nephron/catheter/Simulation.java",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/02e448f6565b6ce21a39dd7f6e410f823044335d/src/main/java/org/opennms/nephron/catheter/Simulation.java",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/src/main/java/org/opennms/nephron/catheter/Simulation.java?ref=02e448f6565b6ce21a39dd7f6e410f823044335d",
    "patch": "@@ -28,45 +28,26 @@\n \n package org.opennms.nephron.catheter;\n \n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.StringReader;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Objects;\n import java.util.Random;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n import java.util.stream.Collectors;\n \n-import javax.xml.bind.JAXBContext;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.bind.Unmarshaller;\n-import javax.xml.transform.Source;\n-import javax.xml.transform.stream.StreamSource;\n-\n-import org.apache.kafka.clients.producer.KafkaProducer;\n-import org.apache.kafka.clients.producer.ProducerConfig;\n-import org.apache.kafka.clients.producer.ProducerRecord;\n-import org.apache.kafka.common.serialization.ByteArraySerializer;\n-import org.apache.kafka.common.serialization.StringSerializer;\n-import org.eclipse.persistence.jaxb.MarshallerProperties;\n-import org.opennms.nephron.catheter.json.ExporterJson;\n-import org.opennms.nephron.catheter.json.SimulationJson;\n-import org.opennms.netmgt.flows.persistence.model.FlowDocument;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class Simulation {\n     private static final Logger LOG = LoggerFactory.getLogger(Simulation.class);\n-    private final String bootstrapServers;\n-    private final String flowTopic;\n+\n+    private final BiConsumer<Exporter, FlowReport> handler;\n     private final Duration tickMs;\n     private final boolean realtime;\n     private final Instant startTime;\n@@ -80,68 +61,20 @@\n     private long maxIterations = 0;\n \n     private Simulation(final Builder builder) {\n-        this.bootstrapServers = Objects.requireNonNull(builder.bootstrapServers);\n-        this.flowTopic = Objects.requireNonNull(builder.flowTopic);\n+        this.handler = builder.handler;\n         this.tickMs = Objects.requireNonNull(builder.tickMs);\n         this.realtime = builder.realtime;\n         this.startTime = Instant.ofEpochMilli(builder.startTime != null ? builder.startTime.toEpochMilli() : Instant.now().toEpochMilli() / builder.tickMs.toMillis() * builder.tickMs.toMillis());\n         this.random.setSeed(builder.seed);\n         this.exporters = builder.exporters.stream().map(e -> e.build(this.startTime, random)).collect(Collectors.toList());\n     }\n \n-    public static Simulation fromFile(final File file) throws JAXBException, FileNotFoundException {\n-        return fromSource(new StreamSource(new FileReader(file)));\n-\n-    }\n-\n-    public static Simulation fromJson(final String json) throws JAXBException {\n-        return fromSource(new StreamSource(new StringReader(json)));\n-    }\n-\n-    private static Simulation fromSource(final Source source) throws JAXBException {\n-        final Unmarshaller unmarshaller = JAXBContext.newInstance(SimulationJson.class).createUnmarshaller();\n-        unmarshaller.setProperty(MarshallerProperties.MEDIA_TYPE, \"application/json\");\n-        final SimulationJson simulationJson = unmarshaller.unmarshal(source, SimulationJson.class).getValue();\n-\n-        final List<Exporter.Builder> exporterBuilders = new ArrayList<>();\n-\n-        for(final ExporterJson exporterJson : simulationJson.getExporters()) {\n-            final FlowGenerator.Builder flowGeneratorBuilder = FlowGenerator.builder()\n-                    .withMaxFlowCount(exporterJson.getFlowGenerator().getMaxFlowCount())\n-                    .withMinFlowDuration(Duration.ofMillis(exporterJson.getFlowGenerator().getMinFlowDurationMs()))\n-                    .withMaxFlowDuration(Duration.ofMillis(exporterJson.getFlowGenerator().getMaxFlowDurationMs()))\n-                    .withActiveTimeout(Duration.ofMillis(exporterJson.getFlowGenerator().getActiveTimeoutMs()))\n-                    .withBytesPerSecond(exporterJson.getFlowGenerator().getBytesPerSecond());\n-\n-            exporterBuilders.add(Exporter.builder()\n-                                    .withForeignId(exporterJson.getForeignId())\n-                                    .withForeignSource(exporterJson.getForeignSource())\n-                                    .withNodeId(exporterJson.getNodeId())\n-                                    .withLocation(exporterJson.getLocation())\n-                                    .withInputSnmp(exporterJson.getInputSnmp())\n-                                    .withOutputSnmp(exporterJson.getOutputSnmp())\n-                                    .withGenerator(flowGeneratorBuilder)\n-                                    .withClockOffset(Duration.ofMillis(exporterJson.getClockOffsetMs())));\n-        }\n-\n-        return Simulation.builder()\n-            .withStartTime(simulationJson.getStartTime())\n-            .withSeed(simulationJson.getSeed())\n-            .withBootstrapServers(simulationJson.getBootstrapServers())\n-            .withTickMs(Duration.ofMillis(simulationJson.getTickMs()))\n-            .withFlowTopic(simulationJson.getFlowTopic())\n-            .withRealtime(simulationJson.getRealtime())\n-            .withExporters(exporterBuilders).build();\n-    }\n-\n     @Override\n     public boolean equals(final Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n         final Simulation that = (Simulation) o;\n         return this.realtime == that.realtime &&\n-                Objects.equals(this.bootstrapServers, that.bootstrapServers) &&\n-                Objects.equals(this.flowTopic, that.flowTopic) &&\n                 Objects.equals(this.tickMs, that.tickMs) &&\n                 Objects.equals(this.startTime, that.startTime) &&\n                 Objects.equals(this.exporters, that.exporters);\n@@ -150,8 +83,6 @@ public boolean equals(final Object o) {\n     @Override\n     public String toString() {\n         return \"Simulation{\" +\n-                \"bootstrapServers='\" + this.bootstrapServers + '\\'' +\n-                \", flowTopic='\" + this.flowTopic + '\\'' +\n                 \", tickMs=\" + this.tickMs +\n                 \", realtime=\" + this.realtime +\n                 \", startTime=\" + this.startTime +\n@@ -161,11 +92,11 @@ public String toString() {\n \n     @Override\n     public int hashCode() {\n-        return Objects.hash(this.bootstrapServers, this.flowTopic, this.tickMs, this.realtime, this.startTime, this.exporters, this.thread, this.running, this.elapsedTime, this.flowsSent, this.bytesSent, this.random, this.maxIterations);\n+        return Objects.hash(this.tickMs, this.realtime, this.startTime, this.exporters, this.thread, this.running, this.elapsedTime, this.flowsSent, this.bytesSent, this.random, this.maxIterations);\n     }\n \n-    public static Builder builder() {\n-        return new Builder();\n+    public static Builder builder(final BiConsumer<Exporter, FlowReport> handler) {\n+        return new Builder(handler);\n     }\n \n     public void start() {\n@@ -186,12 +117,6 @@ private void run() {\n         this.flowsSent = 0;\n         this.bytesSent = 0;\n \n-        final Map<String, Object> producerProps = new HashMap<>();\n-        producerProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServers);\n-        producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n-        producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n-        KafkaProducer<String, byte[]> kafkaProducer = new KafkaProducer<>(producerProps);\n-\n         Instant now = this.startTime;\n \n         while (this.running.get()) {\n@@ -219,31 +144,23 @@ private void run() {\n \n \n             for (final Exporter exporter : this.exporters) {\n-                sendFlowDocuments(kafkaProducer, exporter.tick(now));\n+                dispatch(exporter, exporter.tick(now));\n             }\n         }\n \n         LOG.debug(\"Simulation: shutting down {} exporters\", this.exporters.size());\n \n         for (final Exporter exporter : this.exporters) {\n-            sendFlowDocuments(kafkaProducer, exporter.shutdown(now));\n+            dispatch(exporter, exporter.shutdown(now));\n         }\n-\n-        kafkaProducer.close();\n     }\n \n-    private void sendFlowDocuments(final KafkaProducer<String, byte[]> kafkaProducer, final Collection<FlowDocument> flowDocuments) {\n-        this.flowsSent += flowDocuments.size();\n-        for (final FlowDocument flowDocument : flowDocuments) {\n-            this.bytesSent += flowDocument.getNumBytes().getValue();\n-            kafkaProducer.send(new ProducerRecord<>(this.flowTopic, flowDocument.toByteArray()), (metadata, exception) -> {\n-                if (exception != null) {\n-                    LOG.warn(\"Simulation: error sending flow document to Kafka topic\", exception);\n-                }\n-            });\n-        }\n-        if (!flowDocuments.isEmpty()) {\n-            LOG.debug(\"Simulation: sent {} flow documents to Kafka topic '{}'\", flowDocuments.size(), this.flowTopic);\n+    private void dispatch(final Exporter exporter, final Collection<FlowReport> flowReports) {\n+        this.flowsSent += flowReports.size();\n+        for (final FlowReport flowReport : flowReports) {\n+            this.bytesSent += flowReport.getBytes();\n+\n+            this.handler.accept(exporter, flowReport);\n         }\n     }\n \n@@ -271,25 +188,30 @@ public long getBytesSent() {\n         return this.bytesSent;\n     }\n \n+    public Random getRandom() {\n+        return this.random;\n+    }\n+\n+    public BiConsumer<Exporter, FlowReport> getHandler() {\n+        return this.handler;\n+    }\n+\n     public static class Builder {\n-        public String flowTopic;\n         public long seed = new Random().nextLong();\n-        private String bootstrapServers;\n+\n+        private BiConsumer<Exporter, FlowReport> handler;\n+\n         private Duration tickMs = Duration.ofMillis(250);\n         private boolean realtime;\n         private Instant startTime;\n         private final List<Exporter.Builder> exporters = new ArrayList<>();\n \n-        private Builder() {\n-        }\n-\n-        public Builder withBootstrapServers(final String bootstrapServers) {\n-            this.bootstrapServers = Objects.requireNonNull(bootstrapServers);\n-            return this;\n+        private Builder(final BiConsumer<Exporter, FlowReport> handler) {\n+            this.handler = Objects.requireNonNull(handler);\n         }\n \n-        public Builder withFlowTopic(final String flowTopic) {\n-            this.flowTopic = flowTopic;\n+        public Builder withHandler(final BiConsumer<Exporter, FlowReport> handler) {\n+            this.handler = Objects.requireNonNull(handler);\n             return this;\n         }\n "
  },
  {
    "sha": "1e6cf8cc29ad77f8ad4c07f596caf4be55a14e2e",
    "filename": "src/test/java/org/opennms/nephron/catheter/CatheterIT.java",
    "status": "modified",
    "additions": 127,
    "deletions": 369,
    "changes": 496,
    "blob_url": "https://github.com/opennms-forge/catheter/blob/02e448f6565b6ce21a39dd7f6e410f823044335d/src/test/java/org/opennms/nephron/catheter/CatheterIT.java",
    "raw_url": "https://github.com/opennms-forge/catheter/raw/02e448f6565b6ce21a39dd7f6e410f823044335d/src/test/java/org/opennms/nephron/catheter/CatheterIT.java",
    "contents_url": "https://api.github.com/repos/opennms-forge/catheter/contents/src/test/java/org/opennms/nephron/catheter/CatheterIT.java?ref=02e448f6565b6ce21a39dd7f6e410f823044335d",
    "patch": "@@ -31,114 +31,64 @@\n import static org.awaitility.Awaitility.await;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import java.io.File;\n import java.time.Duration;\n import java.time.Instant;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.Random;\n-import java.util.UUID;\n import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n-\n-import javax.xml.bind.JAXBContext;\n-import javax.xml.bind.Marshaller;\n-\n-import org.apache.kafka.clients.admin.AdminClient;\n-import org.apache.kafka.clients.admin.NewTopic;\n-import org.apache.kafka.clients.consumer.ConsumerConfig;\n-import org.apache.kafka.clients.consumer.ConsumerRecord;\n-import org.apache.kafka.clients.consumer.ConsumerRecords;\n-import org.apache.kafka.clients.consumer.KafkaConsumer;\n-import org.apache.kafka.common.serialization.Deserializer;\n-import org.apache.kafka.common.serialization.StringDeserializer;\n-import org.eclipse.persistence.jaxb.MarshallerProperties;\n-import org.junit.Assert;\n-import org.junit.Before;\n-import org.junit.Rule;\n+import java.util.function.BiConsumer;\n+\n import org.junit.Test;\n-import org.opennms.nephron.catheter.json.ExporterJson;\n-import org.opennms.nephron.catheter.json.FlowGeneratorJson;\n-import org.opennms.nephron.catheter.json.SimulationJson;\n-import org.opennms.netmgt.flows.persistence.model.FlowDocument;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.testcontainers.containers.KafkaContainer;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.google.protobuf.InvalidProtocolBufferException;\n \n public class CatheterIT {\n     private static final Logger LOG = LoggerFactory.getLogger(CatheterIT.class);\n-    public static final String FLOW_TOPIC = \"flows\";\n \n-    @Rule\n-    public KafkaContainer kafka = new KafkaContainer();\n+    public static class TrackingHandler implements BiConsumer<Exporter, FlowReport> {\n \n-    @Before\n-    public void before() {\n-            createTopics(FLOW_TOPIC);\n-    }\n+        private final AtomicLong count = new AtomicLong();\n+        private final AtomicLong bytes = new AtomicLong();\n+        private final List<FlowReport> flows = new ArrayList<>();\n \n-    @Test\n-    public void testMainMethod() throws Exception {\n-        final SimulationJson simulationJson = new SimulationJson();\n-        simulationJson.setBootstrapServers(kafka.getBootstrapServers());\n-        simulationJson.setFlowTopic(FLOW_TOPIC);\n-        simulationJson.setRealtime(true);\n-        simulationJson.setStartTime(Instant.now());\n-        simulationJson.setTickMs(250);\n-\n-        final FlowGeneratorJson flowGeneratorJson1 = new FlowGeneratorJson();\n-        flowGeneratorJson1.setActiveTimeoutMs(1000);\n-        flowGeneratorJson1.setBytesPerSecond(1000_000);\n-        flowGeneratorJson1.setMaxFlowCount(10);\n-        flowGeneratorJson1.setMinFlowDurationMs(1000);\n-        flowGeneratorJson1.setMaxFlowDurationMs(20000);\n-\n-        final ExporterJson exporterJson1 = new ExporterJson();\n-        exporterJson1.setForeignSource(\"foreignSource1\");\n-        exporterJson1.setForeignId(\"foreignId1\");\n-        exporterJson1.setNodeId(1);\n-        exporterJson1.setClockOffsetMs(10);\n-        exporterJson1.setFlowGenerator(flowGeneratorJson1);\n-        exporterJson1.setLocation(\"Default\");\n-\n-        simulationJson.setExporters(Arrays.asList(exporterJson1));\n-\n-        final Marshaller marshaller = JAXBContext.newInstance(SimulationJson.class).createMarshaller();\n-        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n-        marshaller.setProperty(MarshallerProperties.MEDIA_TYPE, \"application/json\");\n-        marshaller.setProperty(MarshallerProperties.JSON_INCLUDE_ROOT, true);\n-\n-        final File tempFile = File.createTempFile(\"test-\", \".json\");\n-        tempFile.deleteOnExit();\n-\n-        // write JSON file\n-        marshaller.marshal(simulationJson, tempFile);\n-        // run main with JSON file argument\n-        Catheter.main(tempFile.getAbsolutePath());\n-        // setup consumer\n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-        // check whether data arrive...\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> kafkaConsumer.poll(250).count() > 0);\n-        // close the consumer\n-        kafkaConsumer.close();\n+        @Override\n+        public void accept(final Exporter exporter, final FlowReport report) {\n+            this.count.incrementAndGet();\n+            this.bytes.addAndGet(report.getBytes());\n+            this.flows.add(report);\n+        }\n+\n+        public long getReceivedCount() {\n+            return this.count.get();\n+        }\n+\n+        public long getReceivedBytes() {\n+            return this.bytes.get();\n+        }\n+\n+        public List<FlowReport> getReceivedFlows() {\n+            return Collections.unmodifiableList(this.flows);\n+        }\n+\n+        public void awaitRecords(final long count) {\n+            await().pollDelay(Duration.ofSeconds(1))\n+                   .atMost(Duration.ofMinutes(1))\n+                   .until(() -> this.getReceivedCount() >= count);\n+        }\n     }\n \n     @Test\n     public void testTimestampsNonRealtime() throws Exception {\n         final Instant now = Instant.ofEpochMilli(1_500_000_000_000L);\n \n-        final Simulation simulation = Simulation.builder()\n-                .withBootstrapServers(kafka.getBootstrapServers())\n-                .withFlowTopic(FLOW_TOPIC)\n+        final TrackingHandler handler = new TrackingHandler();\n+\n+        final Simulation simulation = Simulation.builder(handler)\n                 .withRealtime(false)\n                 .withStartTime(now)\n                 .withTickMs(Duration.ofMillis(50))\n@@ -157,56 +107,37 @@ public void testTimestampsNonRealtime() throws Exception {\n                                         .withMaxFlowDuration(Duration.ofSeconds(20)))\n                 ).build();\n \n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-\n         // run first simulation with seed\n         simulation.start(20);\n         simulation.join();\n \n-        final AtomicLong received = new AtomicLong();\n-        final List<FlowDocument> flows = new ArrayList<>();\n-\n         // wait till all data arrived\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> {\n-            final ConsumerRecords<String, FlowDocument> records = kafkaConsumer.poll(1000);\n-            received.addAndGet(records.count());\n-\n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                flows.add(record.value());\n-            }\n-\n-            return received.get() >= simulation.getFlowsSent();\n-        });\n+        handler.awaitRecords(simulation.getFlowsSent());\n \n         final Instant future = now.plus(simulation.getElapsedTime()).plus(Duration.ofMillis(1));\n \n         LOG.debug(\"Now: \" + now + \" Future: \" + future);\n \n-        for (final FlowDocument flowDocument : flows) {\n-            final Instant first = Instant.ofEpochMilli(flowDocument.getFirstSwitched().getValue());\n-            final Instant last = Instant.ofEpochMilli(flowDocument.getLastSwitched().getValue());\n-            final Instant delta = Instant.ofEpochMilli(flowDocument.getDeltaSwitched().getValue());\n+        for (final FlowReport flow : handler.getReceivedFlows()) {\n+            final Instant start = flow.getStart();\n+            final Instant end = flow.getEnd();\n \n-            LOG.debug(\"First: \" + first + \" Last: \" + last);\n+            LOG.debug(\"Start: \" + start + \" End: \" + end);\n \n-            assertTrue(first.equals(delta));\n-            assertTrue(first.isBefore(last));\n-            assertTrue(first.isAfter(now));\n-            assertTrue(last.isAfter(now));\n-            assertTrue(last.isBefore(future));\n+            assertTrue(start.isBefore(end));\n+            assertTrue(start.isAfter(now));\n+            assertTrue(end.isAfter(now));\n+            assertTrue(end.isBefore(future));\n         }\n-\n-        // close the consumer\n-        kafkaConsumer.close();\n     }\n \n     @Test\n     public void testTimestampsRealtime() throws Exception {\n         final Instant now = Instant.now();\n \n-        final Simulation simulation = Simulation.builder()\n-                .withBootstrapServers(kafka.getBootstrapServers())\n-                .withFlowTopic(FLOW_TOPIC)\n+        final TrackingHandler handler = new TrackingHandler();\n+\n+        final Simulation simulation = Simulation.builder(handler)\n                 .withRealtime(true)\n                 .withStartTime(now)\n                 .withTickMs(Duration.ofMillis(50))\n@@ -225,8 +156,6 @@ public void testTimestampsRealtime() throws Exception {\n                                         .withMaxFlowDuration(Duration.ofSeconds(20)))\n                 ).build();\n \n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-\n         // run first simulation with seed\n         simulation.start();\n \n@@ -235,95 +164,38 @@ public void testTimestampsRealtime() throws Exception {\n         simulation.stop();\n         simulation.join();\n \n-        final AtomicLong received = new AtomicLong();\n-        final List<FlowDocument> flows = new ArrayList<>();\n-\n         // wait till all data arrived\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> {\n-            final ConsumerRecords<String, FlowDocument> records = kafkaConsumer.poll(1000);\n-            received.addAndGet(records.count());\n-\n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                flows.add(record.value());\n-            }\n-\n-            return received.get() >= simulation.getFlowsSent();\n-        });\n+        handler.awaitRecords(simulation.getFlowsSent());\n \n         final Instant future = Instant.now();\n \n         LOG.debug(\"Now: \" + now + \" Future: \" + future);\n \n-        for (final FlowDocument flowDocument : flows) {\n-            final Instant first = Instant.ofEpochMilli(flowDocument.getFirstSwitched().getValue());\n-            final Instant last = Instant.ofEpochMilli(flowDocument.getLastSwitched().getValue());\n-            final Instant delta = Instant.ofEpochMilli(flowDocument.getDeltaSwitched().getValue());\n+        for (final FlowReport flow : handler.getReceivedFlows()) {\n+            final Instant start = flow.getStart();\n+            final Instant end = flow.getEnd();\n \n-            LOG.debug(\"First: \" + first + \" Last: \" + last);\n+            LOG.debug(\"Start: \" + start + \" End: \" + end);\n \n-            assertTrue(first.equals(delta));\n-            assertTrue(!first.isAfter(last));\n-            assertTrue(first.isAfter(now));\n-            assertTrue(last.isAfter(now));\n-            assertTrue(last.isBefore(future));\n+            assertTrue(!start.isAfter(end));\n+            assertTrue(start.isAfter(now));\n+            assertTrue(end.isAfter(now));\n+            assertTrue(end.isBefore(future));\n         }\n-\n-        // close the consumer\n-        kafkaConsumer.close();\n-    }\n-\n-    @Test\n-    public void testJsonHandling() throws Exception {\n-        final Simulation expected = Simulation.builder()\n-                .withBootstrapServers(\"bootstrapServers\")\n-                .withFlowTopic(\"flowTopic\")\n-                .withRealtime(true)\n-                .withStartTime(Instant.parse(\"2020-11-27T09:16:31.122Z\"))\n-                .withTickMs(Duration.ofMillis(250))\n-                .withExporters(\n-                        Exporter.builder()\n-                                .withInputSnmp(98)\n-                                .withOutputSnmp(99)\n-                                .withNodeId(1)\n-                                .withForeignSource(\"foreignSource1\")\n-                                .withForeignId(\"foreignId1\")\n-                                .withClockOffset(Duration.ofSeconds(10))\n-                                .withLocation(\"Default\")\n-                                .withGenerator(FlowGenerator.builder()\n-                                        .withBytesPerSecond(1000_000L)\n-                                        .withMaxFlowCount(10)\n-                                        .withActiveTimeout(Duration.ofSeconds(1))\n-                                        .withMinFlowDuration(Duration.ofSeconds(1))\n-                                        .withMaxFlowDuration(Duration.ofSeconds(20))),\n-                        Exporter.builder()\n-                                .withInputSnmp(11)\n-                                .withOutputSnmp(12)\n-                                .withNodeId(2)\n-                                .withForeignSource(\"foreignSource2\")\n-                                .withForeignId(\"foreignId2\")\n-                                .withClockOffset(Duration.ofSeconds(-10))\n-                                .withLocation(\"Minion\")\n-                                .withGenerator(FlowGenerator.builder()\n-                                        .withBytesPerSecond(1000_000L)\n-                                        .withMaxFlowCount(10)\n-                                        .withActiveTimeout(Duration.ofSeconds(1))\n-                                        .withMinFlowDuration(Duration.ofSeconds(2))\n-                                        .withMaxFlowDuration(Duration.ofSeconds(15)))\n-                )\n-                .withSeed(1606468048782L)\n-                .build();\n-\n-        // check whether loaded file and expected simulation instance is equal\n-        assertThat(Simulation.fromFile(new File(\"src/test/resources/simulation.json\")), is(expected));\n     }\n \n     @Test\n     public void testInputAndOutput() throws Exception {\n         final Instant now = Instant.ofEpochMilli(1_500_000_000_000L);\n \n-        final Simulation simulation = Simulation.builder()\n-                .withBootstrapServers(kafka.getBootstrapServers())\n-                .withFlowTopic(FLOW_TOPIC)\n+        final TrackingHandler handler = new TrackingHandler();\n+\n+        final BiConsumer<Exporter, FlowReport> checkingHandler = handler.andThen((exporter, report) -> {\n+            assertThat(exporter.getInputSnmp(), is(98));\n+            assertThat(exporter.getOutputSnmp(), is(99));\n+        });\n+\n+        final Simulation simulation = Simulation.builder(checkingHandler)\n                 .withRealtime(false)\n                 .withStartTime(now)\n                 .withTickMs(Duration.ofMillis(50))\n@@ -343,163 +215,98 @@ public void testInputAndOutput() throws Exception {\n                                         .withMaxFlowDuration(Duration.ofSeconds(20)))\n                 ).build();\n \n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-\n         // run simulation\n         simulation.start(20);\n         simulation.join();\n \n-        final AtomicLong received = new AtomicLong();\n-        final List<FlowDocument> flows = new ArrayList<>();\n-\n         // wait till all data arrived\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> {\n-            final ConsumerRecords<String, FlowDocument> records = kafkaConsumer.poll(1000);\n-            received.addAndGet(records.count());\n-\n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                flows.add(record.value());\n-            }\n-\n-            return received.get() >= simulation.getFlowsSent();\n-        });\n-\n-        for (FlowDocument flowDocument : flows) {\n-            assertThat(flowDocument.getInputSnmpIfindex().getValue(), is(98));\n-            assertThat(flowDocument.getOutputSnmpIfindex().getValue(), is(99));\n-        }\n-\n-        // close the consumer\n-        kafkaConsumer.close();\n+        handler.awaitRecords(simulation.getFlowsSent());\n     }\n \n     @Test\n     public void testSeed() throws Exception {\n         // create random seed\n         long seed = new Random().nextLong();\n \n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-\n-        final Simulation s1 = createSimulation(false, false, seed);\n-\n-        // run first simulation with seed\n-        s1.start(20);\n-        s1.join();\n-\n-        final AtomicLong received1 = new AtomicLong();\n-        final List<FlowDocument> flows1 = new ArrayList<>();\n-\n-        // wait till all data arrived\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> {\n-            final ConsumerRecords<String, FlowDocument> records = kafkaConsumer.poll(1000);\n-            received1.addAndGet(records.count());\n-\n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                flows1.add(record.value());\n-            }\n+        // run simulation with same seed twice\n+        final TrackingHandler handler1 = runSimulation( false, false, seed, null, 100_000L);\n+        final TrackingHandler handler2 = runSimulation( false, false, seed, null, 100_000L);\n \n-            return received1.get() >= s1.getFlowsSent();\n-        });\n-\n-        final Simulation s2 = createSimulation(false, false, seed);\n-\n-        // run second simulation with same seed\n-        s2.start(20);\n-        s2.join();\n-\n-        final AtomicLong received2 = new AtomicLong();\n-        final List<FlowDocument> flows2 = new ArrayList<>();\n-\n-        // wait till all data arrived\n-        await().pollDelay(Duration.ofSeconds(1)).atMost(Duration.ofMinutes(1)).until(() -> {\n-            final ConsumerRecords<String, FlowDocument> records = kafkaConsumer.poll(1000);\n-            received2.addAndGet(records.count());\n-\n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                flows2.add(record.value());\n-            }\n-\n-            return received2.get() >= s2.getFlowsSent();\n-        });\n-\n-        // check whether the results ot the two simulation runs are ther same\n-        assertThat(s1.getBytesSent(), is(s2.getBytesSent()));\n-        assertThat(s1.getElapsedTime(), is(s2.getElapsedTime()));\n-        assertThat(s1.getFlowsSent(), is(s2.getFlowsSent()));\n-        Assert.assertEquals(flows1, flows2);\n-        // close the consumer\n-        kafkaConsumer.close();\n-    }\n-\n-    public Simulation createSimulation(final boolean realtime, final boolean clockSkew, final Long seed) {\n-        final Simulation simulation = Simulation.builder()\n-                                                .withBootstrapServers(kafka.getBootstrapServers())\n-                                                .withFlowTopic(FLOW_TOPIC)\n-                                                .withRealtime(realtime)\n-                                                .withStartTime(realtime ? Instant.now() : Instant.ofEpochMilli(1_500_000_000_000L))\n-                                                .withTickMs(Duration.ofMillis(250))\n-                                                .withExporters(\n-                        Exporter.builder()\n-                                .withNodeId(1)\n-                                .withForeignSource(\"exporters\")\n-                                .withForeignId(\"test1\")\n-                                .withClockOffset(clockSkew ? Duration.ofSeconds(-10) : Duration.ZERO)\n-                                .withGenerator(FlowGenerator.builder()\n-                                        .withBytesPerSecond(750_000L)\n-                                        .withMaxFlowCount(10)\n-                                        .withActiveTimeout(Duration.ofSeconds(2))\n-                                        .withMinFlowDuration(Duration.ofSeconds(1))\n-                                        .withMaxFlowDuration(Duration.ofSeconds(20))),\n-                        Exporter.builder()\n-                                .withNodeId(2)\n-                                .withForeignSource(\"exporters\")\n-                                .withForeignId(\"test2\")\n-                                .withClockOffset(clockSkew ? Duration.ofSeconds(10) : Duration.ZERO)\n-                                .withGenerator(FlowGenerator.builder()\n-                                        .withBytesPerSecond(250_000L)\n-                                        .withMaxFlowCount(10)\n-                                        .withActiveTimeout(Duration.ofSeconds(1))\n-                                        .withMinFlowDuration(Duration.ofSeconds(2))\n-                                        .withMaxFlowDuration(Duration.ofSeconds(15)))\n-                )\n-                                                .withSeed(seed != null ? seed : System.currentTimeMillis())\n-                                                .build();\n-\n-        return simulation;\n+        // check whether the results ot the two simulation runs are the same\n+        assertEquals(handler1.getReceivedBytes(), handler2.getReceivedBytes());\n+        assertEquals(handler1.getReceivedCount(), handler2.getReceivedCount());\n+        assertEquals(handler1.getReceivedFlows(), handler2.getReceivedFlows());\n     }\n \n     @Test\n     public void testRealtime() {\n-        runSimulation(createSimulation(true, false, null), Duration.ofSeconds(5));\n+        runSimulation(true, false, null, Duration.ofSeconds(5), null);\n     }\n \n     @Test\n     public void testRealtimeWithClockSkew() {\n-        runSimulation(createSimulation(true, true, 123456L), Duration.ofSeconds(5));\n+        runSimulation(true, true, 123456L, Duration.ofSeconds(5), null);\n     }\n \n     @Test\n     public void testNonRealtime() {\n-        runSimulation(createSimulation(false, false, null), Duration.ofSeconds(5));\n+        runSimulation(false, false, null, Duration.ofSeconds(5), null);\n     }\n \n     @Test\n     public void testNonRealtimeWithClockSkew() {\n-        runSimulation(createSimulation(false, true, 123456L), Duration.ofSeconds(5));\n+        runSimulation(false, true, 123456L, Duration.ofSeconds(5), null);\n     }\n \n-    public void runSimulation(final Simulation simulation, final Duration duration) {\n-        createTopics(FLOW_TOPIC);\n+    public TrackingHandler runSimulation(final boolean realtime, final boolean clockSkew, final Long seed, final Duration duration, final Long iterations) {\n+        final TrackingHandler handler = new TrackingHandler();\n \n-        simulation.start();\n+        final Simulation simulation = Simulation.builder(handler)\n+                                                .withRealtime(realtime)\n+                                                .withStartTime(realtime ? Instant.now() : Instant.ofEpochMilli(1_500_000_000_000L))\n+                                                .withTickMs(Duration.ofMillis(250))\n+                                                .withExporters(\n+                                                        Exporter.builder()\n+                                                                .withNodeId(1)\n+                                                                .withForeignSource(\"exporters\")\n+                                                                .withForeignId(\"test1\")\n+                                                                .withClockOffset(clockSkew ? Duration.ofSeconds(-10) : Duration.ZERO)\n+                                                                .withGenerator(FlowGenerator.builder()\n+                                                                                            .withBytesPerSecond(750_000L)\n+                                                                                            .withMaxFlowCount(10)\n+                                                                                            .withActiveTimeout(Duration.ofSeconds(2))\n+                                                                                            .withMinFlowDuration(Duration.ofSeconds(1))\n+                                                                                            .withMaxFlowDuration(Duration.ofSeconds(20))),\n+                                                        Exporter.builder()\n+                                                                .withNodeId(2)\n+                                                                .withForeignSource(\"exporters\")\n+                                                                .withForeignId(\"test2\")\n+                                                                .withClockOffset(clockSkew ? Duration.ofSeconds(10) : Duration.ZERO)\n+                                                                .withGenerator(FlowGenerator.builder()\n+                                                                                            .withBytesPerSecond(250_000L)\n+                                                                                            .withMaxFlowCount(10)\n+                                                                                            .withActiveTimeout(Duration.ofSeconds(1))\n+                                                                                            .withMinFlowDuration(Duration.ofSeconds(2))\n+                                                                                            .withMaxFlowDuration(Duration.ofSeconds(15)))\n+                                                              )\n+                                                .withSeed(seed != null ? seed : System.currentTimeMillis())\n+                                                .build();\n \n-        try {\n-            Thread.sleep(duration.toMillis());\n-        } catch (InterruptedException e) {\n-            e.printStackTrace();\n+        if (iterations != null) {\n+            simulation.start(iterations);\n+        } else {\n+            simulation.start();\n         }\n \n-        simulation.stop();\n+        if (duration != null) {\n+            try {\n+                Thread.sleep(duration.toMillis());\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+\n+            simulation.stop();\n+        }\n \n         try {\n             simulation.join();\n@@ -521,66 +328,17 @@ public void runSimulation(final Simulation simulation, final Duration duration)\n \n         assertThat(rateSent, is(1000000L));\n \n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = createConsumer();\n-\n-        long flowsReceived = 0;\n-        long bytesReceived = 0;\n+        handler.awaitRecords(simulation.getFlowsSent());\n \n-        ConsumerRecords<String, FlowDocument> records;\n-        while (!(records = kafkaConsumer.poll(Duration.ofMillis(10000))).isEmpty()) {\n-            flowsReceived += records.count();\n+        final long rateReceived = (long) ((double) handler.getReceivedBytes() / (double) simulation.getElapsedTime().toMillis() * 1000.0);\n \n-            for (final ConsumerRecord<String, FlowDocument> record : records) {\n-                bytesReceived += record.value().getNumBytes().getValue();\n-            }\n-        }\n-\n-        assertThat(flowsReceived, is(simulation.getFlowsSent()));\n-\n-        final long rateReceived = (long) ((double) bytesReceived / (double) simulation.getElapsedTime().toMillis() * 1000.0);\n+        LOG.debug(\"Received {} flows\", handler.getReceivedCount());\n+        LOG.debug(\"Received {} bytes in total\", handler.getReceivedBytes());\n+        LOG.debug(\"Rate is {} byte/sec\", rateReceived);\n \n-        LOG.debug(\"Kafka received {} flows\", flowsReceived);\n-        LOG.debug(\"Kafka received {} bytes in total\", bytesReceived);\n-        LOG.debug(\"Kafka rate is {} byte/sec\", rateReceived);\n-\n-        assertThat(bytesReceived, is(simulation.getBytesSent()));\n+        assertThat(handler.getReceivedBytes(), is(simulation.getBytesSent()));\n         assertThat(rateReceived, is(1000000L));\n \n-        kafkaConsumer.close();\n-    }\n-\n-    private void createTopics(String... topics) {\n-        final List<NewTopic> newTopics =\n-                Arrays.stream(topics)\n-                        .map(topic -> new NewTopic(topic, 1, (short) 1))\n-                        .collect(Collectors.toList());\n-        try (final AdminClient admin = AdminClient.create(ImmutableMap.<String, Object>builder()\n-                .put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers())\n-                .build())) {\n-            admin.createTopics(newTopics);\n-        }\n-    }\n-\n-    private KafkaConsumer<String, FlowDocument> createConsumer() {\n-        final Map<String, Object> consumerProps = new HashMap<>();\n-        consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers());\n-        consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, \"test-\" + UUID.randomUUID().toString());\n-        consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n-        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n-        consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, KafkaInputFlowDeserializer.class);\n-        final KafkaConsumer<String, FlowDocument> kafkaConsumer = new KafkaConsumer<>(consumerProps);\n-        kafkaConsumer.subscribe(Collections.singletonList(FLOW_TOPIC));\n-        return kafkaConsumer;\n-    }\n-\n-    public static class KafkaInputFlowDeserializer implements Deserializer<FlowDocument> {\n-        @Override\n-        public FlowDocument deserialize(String topic, byte[] data) {\n-            try {\n-                return FlowDocument.parseFrom(data);\n-            } catch (InvalidProtocolBufferException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n+        return handler;\n     }\n }"
  }
]
