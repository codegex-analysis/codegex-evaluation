[
  {
    "sha": "fb5431e40c59cdfe1c460e4ea996b288acaa02c2",
    "filename": "cnf/pom.xml",
    "status": "modified",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/cnf/pom.xml",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/cnf/pom.xml",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/cnf/pom.xml?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -255,5 +255,20 @@\n \t\t\t<artifactId>slf4j-simple</artifactId>\n \t\t\t<version>1.7.30</version>\n \t\t</dependency>\n+\t\t<!-- Joda Time and MQTT Library for MQTTBridge and other components -->\n+\t\t<!-- MQTT  -->\n+\t\t<!-- https://mvnrepository.com/artifact/org.eclipse.paho/org.eclipse.paho.client.mqttv3 -->\n+\t\t<dependency>\n+\t\t\t<groupId>org.eclipse.paho</groupId>\n+\t\t\t<artifactId>org.eclipse.paho.client.mqttv3</artifactId>\n+\t\t\t<version>1.2.5</version>\n+\t\t</dependency>\n+\t\t<!-- https://mvnrepository.com/artifact/joda-time/joda-time -->\n+\t\t<dependency>\n+\t\t\t<groupId>joda-time</groupId>\n+\t\t\t<artifactId>joda-time</artifactId>\n+\t\t\t<version>2.10.8</version>\n+\t\t</dependency>\n+\n \t</dependencies>\n </project>"
  },
  {
    "sha": "b6faf88a5552ba1d7cda30e9561ad4f759d817cf",
    "filename": "io.openems.edge.application/EdgeApp.bndrun",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.application/EdgeApp.bndrun",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.application/EdgeApp.bndrun",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.application/EdgeApp.bndrun?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -37,6 +37,7 @@\n \tbnd.identity;id='io.openems.edge.battery.soltaro',\\\n \tbnd.identity;id='io.openems.edge.bridge.mbus',\\\n \tbnd.identity;id='io.openems.edge.bridge.modbus',\\\n+\tbnd.identity;id='io.openems.edge.bridge.mqtt',\\\n \tbnd.identity;id='io.openems.edge.bridge.onewire',\\\n \tbnd.identity;id='io.openems.edge.common',\\\n \tbnd.identity;id='io.openems.edge.controller.api.backend',\\\n@@ -164,6 +165,7 @@\n \tio.openems.edge.batteryinverter.sunspec;version=snapshot,\\\n \tio.openems.edge.bridge.mbus;version=snapshot,\\\n \tio.openems.edge.bridge.modbus;version=snapshot,\\\n+\tio.openems.edge.bridge.mqtt;version=snapshot,\\\n \tio.openems.edge.bridge.onewire;version=snapshot,\\\n \tio.openems.edge.common;version=snapshot,\\\n \tio.openems.edge.controller.api;version=snapshot,\\"
  },
  {
    "sha": "7a6fc254361ffde2cd78b7ff38c3205cb76799b7",
    "filename": "io.openems.edge.bridge.mqtt/.classpath",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/.classpath",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/.classpath",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/.classpath?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry kind=\"con\" path=\"aQute.bnd.classpath.container\"/>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8\"/>\n+\t<classpathentry kind=\"src\" output=\"bin\" path=\"src\"/>\n+\t<classpathentry kind=\"src\" output=\"bin_test\" path=\"test\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"/>\n+\t\t</attributes>\n+\t</classpathentry>\n+\t<classpathentry kind=\"output\" path=\"bin\"/>\n+</classpath>"
  },
  {
    "sha": "2186887fec05eb0ba0baffb21be66213ed00d751",
    "filename": "io.openems.edge.bridge.mqtt/.project",
    "status": "added",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/.project",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/.project",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/.project?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+\t<name>io.openems.edge.bridge.mqtt</name>\n+\t<comment></comment>\n+\t<projects>\n+\t</projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.jdt.core.javabuilder</name>\n+\t\t\t<arguments>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n+\t\t<buildCommand>\n+\t\t\t<name>bndtools.core.bndbuilder</name>\n+\t\t\t<arguments>\n+\t\t\t</arguments>\n+\t\t</buildCommand>\n+\t</buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.jdt.core.javanature</nature>\n+\t\t<nature>bndtools.core.bndnature</nature>\n+\t</natures>\n+</projectDescription>"
  },
  {
    "sha": "824c4df57250a311b56ea5019ef8b7e045afabfd",
    "filename": "io.openems.edge.bridge.mqtt/bnd.bnd",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/bnd.bnd",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/bnd.bnd",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/bnd.bnd?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,34 @@\n+Bundle-Name: OpenEMS Edge Mqtt\n+Bundle-Vendor: Consolinno Energy GmbH\n+Bundle-License: https://opensource.org/licenses/EPL-2.0\n+Bundle-Version: 1.0.0.${tstamp}\n+Bundle-Description: \\\n+    This Bundle provides the functionality of communicating with a MQTT Broker with Publish and Subscribe Tasks.\\\n+    As well as providing a configurable class for telemetry and commands.\n+\n+\n+Export-Package:  \\\n+\tio.openems.edge.bridge.mqtt.api,\\\n+\tio.openems.edge.bridge.mqtt.component,\\\n+\n+Private-Package:  \\\n+\tio.openems.edge.bridge.mqtt,\\\n+\tio.openems.edge.bridge.mqtt.connection,\\\n+\tio.openems.edge.bridge.mqtt.manager,\\\n+\tio.openems.edge.bridge.mqtt.handler,\\\n+\n+-includeresource: {readme.md}\n+\n+-buildpath:  \\\n+    ${buildpath},\\\n+\tio.openems.edge.common;version=latest,\\\n+\tio.openems.common;version=latest,\\\n+    org.eclipse.paho.client.mqttv3,\\\n+\tcom.google.guava,\\\n+\tcom.google.gson,\\\n+\tjoda-time;version=2.10.8,\\\n+\n+-testpath: \\\n+\tosgi.enroute.junit.wrapper;version=4.12, \\\n+\tosgi.enroute.hamcrest.wrapper;version=1.3\n+"
  },
  {
    "sha": "d583fbdc1c090dc5356cd3846a5c4d4ea2f62b0b",
    "filename": "io.openems.edge.bridge.mqtt/exampleConfig.json",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/exampleConfig.json",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/exampleConfig.json",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/exampleConfig.json?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,44 @@\n+{\n+  \"payloadStyle\": \"Standard\",\n+  \"mqttID\": \"Example-Component\",\n+  \"subscription\": [\n+    {\n+      \"mqttType\": \"Telemetry\",\n+      \"priority\": \"Low\",\n+      \"topic\": \"Test/OpenEms/JsonConfig/Testing\",\n+      \"qos\": 0,\n+      \"retain\": true,\n+      \"useTime\": false,\n+      \"timeToWait\": 10,\n+      \"payload\": {\n+        \"dummy\": \"DummyTwo\",\n+        \"Power\": \"Power\",\n+        \"Temperatur\": \"Temperature\"\n+      }\n+    },{\n+      \"mqttType\": \"Command\",\n+      \"priority\": \"Low\",\n+      \"topic\":\"control/chp-1/setPower\",\n+      \"qos\": 0,\n+      \"retain\": true,\n+      \"useTime\":false,\n+      \"timeToWait\": 10\n+    }\n+  ],\n+  \"publish\": [\n+    {\n+      \"mqttType\": \"Telemetry\",\n+      \"priority\": \"Low\",\n+      \"topic\": \"Test/OpenEms/JsonConfig/Testing\",\n+      \"qos\": 0,\n+      \"retain\": true,\n+      \"useTime\": true,\n+      \"timeToWait\": 10,\n+      \"payload\": {\n+        \"dummy\": \"DummyTwo\",\n+        \"Power\": \"Power\",\n+        \"Temperatur\": \"Temperature\"\n+      }\n+    }\n+  ]\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "b33b06f58da79105c5e0f5ae7ca3b55c7e4a6360",
    "filename": "io.openems.edge.bridge.mqtt/generated/buildfiles",
    "status": "added",
    "additions": 1,
    "deletions": 0,
    "changes": 1,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/generated/buildfiles",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/generated/buildfiles",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/generated/buildfiles?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1 @@\n+/home/felix/Repository/openems/io.openems.edge.bridge.mqtt/generated/io.openems.edge.bridge.mqtt.jar"
  },
  {
    "sha": "bbea621378e66fcf2c11101b64c36c0413752b27",
    "filename": "io.openems.edge.bridge.mqtt/readme.md",
    "status": "added",
    "additions": 12,
    "deletions": 0,
    "changes": 12,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/readme.md",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/readme.md",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/readme.md?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,12 @@\n+# io.openems.edge.bridge.mqtt Provider\n+\n+This Bundle Provides the MQTT Bridge. It Communicates with a Broker, Handles the subscribe- and publishtasks.\n+\n+Persistent or Clean Session will be configured automatically.\n+\n+AutoReconnect is also handled automatically.\n+\n+This Bridge only works atm with MQTT version 3_1_1.\n+\n+The Bridge gets all the Tasks and asks the MqttComponent if their MQTT config changed.\n+"
  },
  {
    "sha": "57b341172a1b577972f9796697990130da4b6f42",
    "filename": "io.openems.edge.bridge.mqtt/src/.gitignore",
    "status": "added",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/.gitignore",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/.gitignore",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/.gitignore?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,2 @@\n+/bin/\n+/generated/"
  },
  {
    "sha": "8082e8645e2161d4883c392a7704ec8b6ed11988",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/Config.java",
    "status": "added",
    "additions": 88,
    "deletions": 0,
    "changes": 88,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/Config.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/Config.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/Config.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,88 @@\n+package io.openems.edge.bridge.mqtt;\n+\n+import org.osgi.service.metatype.annotations.AttributeDefinition;\n+import org.osgi.service.metatype.annotations.ObjectClassDefinition;\n+import org.osgi.service.metatype.annotations.Option;\n+\n+\n+@ObjectClassDefinition(\n+        name = \"Bridge Mqtt\",\n+        description = \"Mqtt Bridge to communicate with a specific broker.\")\n+@interface Config {\n+\n+    String service_pid();\n+\n+    @AttributeDefinition(name = \"MqttBridge - ID\", description = \"Id of Mqtt Bridge.\")\n+    String id() default \"MqttBridge\";\n+\n+    @AttributeDefinition(name = \"Alias\", description = \"Human readable name for this Component.\")\n+    String alias() default \"\";\n+\n+    @AttributeDefinition(name = \"Broker URL\", description = \"URL of the Broker (if any given)..if you set a URL, you do NOT need to enter IP+ Port+ basepath + connection\")\n+    String brokerUrl() default \"\";\n+\n+    @AttributeDefinition(name = \"Broker IP\", description = \"IP of the broker\")\n+    String ipBroker() default \"localhost\";\n+\n+    @AttributeDefinition(name = \"Port\", description = \"The Port the broker opened for communication(1883 or 8883 are common)\")\n+    int portBroker() default 1883;\n+\n+    @AttributeDefinition(name = \"Basepath\", description = \"The Basepath of the MQTT Connection.\")\n+    String basepath() default \"/ws\";\n+\n+    @AttributeDefinition(name = \"Connection Type\", description = \"Tcp or TLS\",\n+            options = {\n+                    @Option(label = \"Tcp\", value = \"Tcp\"),\n+                    @Option(label = \"TLS\", value = \"TLS\"),\n+                    @Option(label = \"Websocket\", value = \"Wss\")\n+            })\n+    String connection() default \"Tcp\";\n+\n+    @AttributeDefinition(name = \"Username\", description = \"Username for the Broker\")\n+    String username() default \"user\";\n+\n+    @AttributeDefinition(name = \"Password\", description = \"Password\")\n+    String password() default \"user\";\n+\n+\n+    @AttributeDefinition(name = \"ClientName\", description = \"ClientId used for brokerConnection\")\n+    String clientId() default \"OpenEMS-1\";\n+\n+    @AttributeDefinition(name = \"Keep Alive\", description = \"Keep Alive in Seconds\")\n+    int keepAlive() default 60;\n+\n+    @AttributeDefinition(name = \"LastWillSet\", description = \"Do you want a Last Will / Testament to be enabled\")\n+    boolean lastWillSet() default true;\n+\n+    @AttributeDefinition(name = \"Topic Last Will\", description = \"Topic for Last Will\")\n+    String topicLastWill() default \"OpenEMS/Leaflet_0/Status/\";\n+\n+\n+    @AttributeDefinition(name = \"LastWill Payload\", description = \"Payload for the last Will\")\n+    String payloadLastWill() default \"Status : Connected\";\n+\n+    @AttributeDefinition(name = \"QoS of Last Will\", description = \"Quality of Service of last Will Msg\")\n+    int qosLastWill() default 0;\n+\n+    @AttributeDefinition(name = \"Clean Session Flag\", description = \"If set to false --> Persistent Session\")\n+    boolean cleanSessionFlag() default true;\n+\n+    @AttributeDefinition(name = \"Retaines Message for Last Will?\", description = \"Retained Flag of Mqtt Last Will Message.\")\n+    boolean retainedFlag() default true;\n+\n+    @AttributeDefinition(name = \"Use Time for Last Will\", description = \"Send a timestamp?\")\n+    boolean timeStampEnabled() default true;\n+\n+    @AttributeDefinition(name = \"Region\", description = \"Set Region of your Device e.g. Europe/Berlin (look up Joda TimeZones) empty String = UTC\")\n+    String locale() default \"Europe/Berlin\";\n+\n+    @AttributeDefinition(name = \"Mqtt Types\", description = \"Possible MqttTypes, will be filled after activation\")\n+    String[] mqttTypes() default {\"\"};\n+\n+    @AttributeDefinition(name = \"Mqtt Priorities\", description = \"MqttPriorities, will be filled automatically after activation\")\n+    String[] mqttPriorities() default {\"\"};\n+\n+    boolean enabled() default true;\n+\n+    String webconsole_configurationFactory_nameHint() default \"Mqtt Bridge [{id}]\";\n+}"
  },
  {
    "sha": "eba8d426f53dc31a051e7311dcfd72956a93c32f",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/MqttBridgeImpl.java",
    "status": "added",
    "additions": 323,
    "deletions": 0,
    "changes": 323,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/MqttBridgeImpl.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/MqttBridgeImpl.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/MqttBridgeImpl.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,323 @@\n+package io.openems.edge.bridge.mqtt;\n+\n+import io.openems.common.exceptions.OpenemsException;\n+import io.openems.edge.bridge.mqtt.api.MqttBridge;\n+import io.openems.edge.bridge.mqtt.api.MqttComponent;\n+import io.openems.edge.bridge.mqtt.api.MqttPriority;\n+import io.openems.edge.bridge.mqtt.api.MqttPublishTask;\n+import io.openems.edge.bridge.mqtt.api.MqttSubscribeTask;\n+import io.openems.edge.bridge.mqtt.api.MqttTask;\n+import io.openems.edge.bridge.mqtt.api.MqttType;\n+import io.openems.edge.bridge.mqtt.connection.MqttConnectionPublishImpl;\n+import io.openems.edge.bridge.mqtt.manager.MqttPublishManager;\n+import io.openems.edge.bridge.mqtt.manager.MqttSubscribeManager;\n+import io.openems.edge.common.component.AbstractOpenemsComponent;\n+import io.openems.edge.common.component.OpenemsComponent;\n+import io.openems.edge.common.event.EdgeEventConstants;\n+\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.event.Event;\n+import org.osgi.service.event.EventConstants;\n+import org.osgi.service.event.EventHandler;\n+import org.osgi.service.metatype.annotations.Designate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Dictionary;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\n+/**\n+ * The Mqtt Bridge.\n+ * <p> The MQTT Bridge builds up a Connection with the broker, esp. for last will settings.\n+ * The User configures Broker settings username and password. as well as last will settings and their timezone. (Defaults to UTC)\n+ * The Bridge creates 2 Manager. The Publish and subscribe manager, those Manager will create each multiple mqtt connections.\n+ * The Publish manager 3 ; Each for a QoS. and the SubscribeManager n connections depending on the mqttTypes (telemetry/commands/events)\n+ * </p>\n+ */\n+\n+\n+@Designate(ocd = Config.class, factory = true)\n+@Component(name = \"Bridge.Mqtt\",\n+        immediate = true,\n+        configurationPolicy = ConfigurationPolicy.REQUIRE,\n+        property = {EventConstants.EVENT_TOPIC + \"=\" + EdgeEventConstants.TOPIC_CYCLE_BEFORE_PROCESS_IMAGE}\n+)\n+public class MqttBridgeImpl extends AbstractOpenemsComponent implements OpenemsComponent, MqttBridge, EventHandler {\n+\n+    @Reference\n+    ConfigurationAdmin ca;\n+\n+    private final Logger log = LoggerFactory.getLogger(MqttBridgeImpl.class);\n+\n+\n+    //Add to Manager\n+    //MAP OF ALL TASKS <-- ID and values in list\n+    private final Map<String, List<MqttTask>> publishTasks = new ConcurrentHashMap<>();\n+    private final Map<String, List<MqttTask>> subscribeTasks = new ConcurrentHashMap<>();\n+\n+    //MqttComponentMap\n+    private final Map<String, MqttComponent> components = new ConcurrentHashMap<>();\n+\n+    //Manager, handling the mqtt tasks and when to do what task\n+    private MqttPublishManager publishManager;\n+    private MqttSubscribeManager subscribeManager;\n+    //Configs\n+    private String mqttUsername;\n+    private String mqttPassword;\n+    private String mqttBroker;\n+    private String mqttClientId;\n+\n+    //FOR LAST WILL\n+    private MqttConnectionPublishImpl bridgePublisher;\n+\n+    //TimeZone Available for all classes\n+    private DateTimeZone timeZone = DateTimeZone.UTC;\n+\n+    public MqttBridgeImpl() {\n+        super(OpenemsComponent.ChannelId.values(),\n+                MqttBridge.ChannelId.values());\n+    }\n+\n+\n+    @Activate\n+    public void activate(ComponentContext context, Config config) throws OpenemsException, MqttException {\n+\n+        super.activate(context, config.id(), config.alias(), config.enabled());\n+        if (config.mqttPriorities().length != MqttPriority.values().length || config.mqttTypes().length != MqttPriority.values().length) {\n+            updateConfig();\n+            return;\n+        }\n+        this.timeZone = config.locale().equals(\"\") ? DateTimeZone.UTC : DateTimeZone.forID(config.locale());\n+        //Important for last will.\n+        this.bridgePublisher = new MqttConnectionPublishImpl();\n+        try {\n+            this.createMqttSession(config);\n+        } catch (MqttException e) {\n+            log.warn(e.getMessage());\n+            throw new OpenemsException(e.getMessage());\n+        }\n+\n+        publishManager = new MqttPublishManager(publishTasks, this.mqttBroker, this.mqttUsername,\n+                this.mqttPassword, config.keepAlive(), this.mqttClientId, timeZone);\n+        //ClientId --> + CLIENT_SUB_0\n+        subscribeManager = new MqttSubscribeManager(subscribeTasks, this.mqttBroker, this.mqttUsername,\n+                this.mqttPassword, this.mqttClientId, config.keepAlive(), timeZone);\n+\n+        publishManager.activate(super.id() + \"_publish\");\n+        subscribeManager.activate(super.id() + \"_subscribe\");\n+    }\n+\n+    /**\n+     * Updates Config --> MqttTypes and Priorities.\n+     */\n+    private void updateConfig() {\n+        Configuration c;\n+\n+        try {\n+            c = ca.getConfiguration(this.servicePid(), \"?\");\n+            Dictionary<String, Object> properties = c.getProperties();\n+            String types = Arrays.toString(MqttType.values());\n+\n+            properties.put(\"mqttTypes\", propertyInput(types));\n+            this.setMqttTypes().setNextValue(MqttType.values());\n+            types = Arrays.toString(MqttPriority.values());\n+            properties.put(\"mqttPriorities\", propertyInput(types));\n+            c.update(properties);\n+\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Due to the fact that the inputs are arrays this needs to be done...it's weird but it's working.\n+     *\n+     * @param types either mqttTypes or Priorities\n+     * @return the String[] for update in OSGi\n+     */\n+    private String[] propertyInput(String types) {\n+        types = types.replaceAll(\"\\\\[\", \"\");\n+        types = types.replaceAll(\"]\", \"\");\n+        types = types.replaceAll(\" \", \"\");\n+        return types.split(\",\");\n+    }\n+\n+    /**\n+     * Creates the MQTT Session and connects to broker.\n+     *\n+     * @param config config of this mqttBridge\n+     * @throws MqttException if somethings wrong like pw wrong or user etc.\n+     */\n+    private void createMqttSession(Config config) throws MqttException {\n+        //Create Broker URL/IP etc\n+        //TCP SSL OR WSS\n+        if (config.brokerUrl().equals(\"\")) {\n+            String basepath = config.basepath();\n+            if (basepath.equals(\"\") || !basepath.startsWith(\"/\")) {\n+                basepath = \"/\" + basepath;\n+            }\n+            String broker = config.connection().toLowerCase();\n+            broker += \"://\" + config.ipBroker() + \":\" + config.portBroker() + basepath;\n+            this.mqttBroker = broker;\n+        } else {\n+            this.mqttBroker = config.brokerUrl();\n+        }\n+        this.mqttUsername = config.username();\n+\n+        this.mqttPassword = config.password();\n+        //ClientID will be automatically altered by Managers depending on what they're doing\n+        this.mqttClientId = config.clientId();\n+        //BridgePublish set LastWill if configured\n+        this.bridgePublisher.createMqttPublishSession(this.mqttBroker, this.mqttClientId, config.keepAlive(),\n+                this.mqttUsername, this.mqttPassword, config.cleanSessionFlag());\n+        if (config.lastWillSet()) {\n+            this.bridgePublisher.addLastWill(config.topicLastWill(),\n+                    config.payloadLastWill(), config.qosLastWill(), config.timeStampEnabled(), config.retainedFlag(),\n+                    DateTime.now(this.timeZone).toString(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZ\"));\n+        }\n+        //External Call bc Last will can be set\n+        this.bridgePublisher.connect();\n+\n+    }\n+\n+    @Deactivate\n+    public void deactivate() {\n+        try {\n+            //Disconnect every connection\n+            this.bridgePublisher.disconnect();\n+            this.publishManager.deactivate();\n+            this.subscribeManager.deactivate();\n+        } catch (MqttException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    @Override\n+    public DateTimeZone getTimeZone() {\n+        return this.timeZone;\n+    }\n+\n+    /**\n+     * Adds Mqtt Task to this Bridge. Usually called by AbstractMqttComponent.\n+     *\n+     * @param id       usually from MqttComponent / Same as component id\n+     * @param mqttTask usually created by MqttComponent\n+     * @throws MqttException if somethings wrong\n+     */\n+\n+    @Override\n+    public void addMqttTask(String id, MqttTask mqttTask) throws MqttException {\n+\n+        if (mqttTask instanceof MqttPublishTask) {\n+            if (this.publishTasks.containsKey(id)) {\n+                this.publishTasks.get(id).add(mqttTask);\n+            } else {\n+                List<MqttTask> task = new ArrayList<>();\n+                task.add(mqttTask);\n+                this.publishTasks.put(id, task);\n+            }\n+        }\n+\n+        if (mqttTask instanceof MqttSubscribeTask) {\n+            if (this.subscribeTasks.containsKey(id)) {\n+                this.subscribeTasks.get(id).add(mqttTask);\n+            } else {\n+                List<MqttTask> task = new ArrayList<>();\n+                task.add(mqttTask);\n+\n+                this.subscribeTasks.put(id, task);\n+            }\n+            this.subscribeManager.subscribeToTopic(mqttTask, id);\n+        }\n+    }\n+\n+    /**\n+     * Removes the MqttTask by id. Usually Called by AbstractMqttComponent\n+     *\n+     * @param id usually from AbstractMqttComponent\n+     */\n+    @Override\n+    public void removeMqttTasks(String id) {\n+        if (this.subscribeTasks.containsKey(id)) {\n+            this.subscribeTasks.get(id).forEach(task -> {\n+                try {\n+                    this.subscribeManager.unsubscribeFromTopic(task);\n+                } catch (MqttException e) {\n+                    log.warn(\"Couldn't unsubscribe from Topic: \" + task.getTopic() + \"reason \" + e.getMessage());\n+                }\n+            });\n+            this.subscribeTasks.remove(id);\n+        }\n+        this.publishTasks.remove(id);\n+    }\n+\n+    @Override\n+    public List<MqttTask> getSubscribeTasks(String id) {\n+        return this.subscribeTasks.get(id);\n+    }\n+\n+    /**\n+     * Adds The MqttComponent to the Bridge. Important for Updating JSON Config and Reacting to Commands and Events\n+     *\n+     * @param id        id of the MqttComponent usually from config of the Component\n+     * @param component the Component itself.\n+     */\n+    @Override\n+    public void addMqttComponent(String id, MqttComponent component) {\n+        if (!this.components.containsKey(id)) {\n+            this.components.put(id, component);\n+        }\n+    }\n+\n+    @Override\n+    public void removeMqttComponent(String id) {\n+        if (this.components.containsKey(id)) {\n+            this.components.remove(id);\n+            this.removeMqttTasks(id);\n+        }\n+    }\n+\n+    @Override\n+    public void handleEvent(Event event) {\n+\n+        if (event.getTopic().equals(EdgeEventConstants.TOPIC_CYCLE_BEFORE_PROCESS_IMAGE)) {\n+            //handle all Tasks\n+            this.subscribeManager.triggerNextRun();\n+            this.publishManager.triggerNextRun();\n+            //Update the components Config if available\n+            this.components.forEach((key, value) -> {\n+                if (value.getConfiguration().value().isDefined() && !value.getConfiguration().value().get().equals(\"\")) {\n+                    try {\n+                        value.updateJsonConfig();\n+                    } catch (MqttException | ConfigurationException e) {\n+                        log.warn(\"Couldn't refresh the config of component \" + value.id() + \" Please check your\"\n+                                + \" configuration or MqttConnection\");\n+                    }\n+                }\n+                //React to Events and Commands\n+                if (value.isConfigured()) {\n+                    value.reactToEvent();\n+                    value.reactToCommand();\n+                }\n+            });\n+        }\n+    }\n+}"
  },
  {
    "sha": "f149592adb2228c6d121e1eced1ff0357940b425",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/AbstractMqttTask.java",
    "status": "added",
    "additions": 101,
    "deletions": 0,
    "changes": 101,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/AbstractMqttTask.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/AbstractMqttTask.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/AbstractMqttTask.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,101 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import io.openems.edge.common.channel.Channel;\n+\n+import java.util.Map;\n+\n+/**\n+ * The Abstract MqttTask.\n+ * This Class contains most Data that a Task need. Specific Impl. Is found in the MqttSubscribeTaskImpl/MqttPublishTaskImpl\n+ */\n+public abstract class AbstractMqttTask implements MqttTask {\n+    private final String topic;\n+    //Either the configured payload that will be published OR the payload from the broker this is how the subscriber gets the message\n+    String payloadToOrFromBroker = \"\";\n+    //COMMAND/EVENT/TELEMETRY/etc\n+    private final MqttType mqttType;\n+    private final boolean retainFlag;\n+    private final boolean addTime;\n+    private final int qos;\n+    private final MqttPriority mqttPriority;\n+    //Map of Names Channels: ChannelID is key.\n+    Map<String, Channel<?>> channels;\n+    private long timeStamp = -1;\n+    private final int timeToWait;\n+    //Payload either for the Pub task that needs to be changed for broker OR the handled sub task payload.\n+    String configuredPayload;\n+    PayloadStyle style;\n+    String id;\n+    String mqttId;\n+\n+    AbstractMqttTask(String topic, MqttType mqttType,\n+                     boolean retainFlag, boolean addTime, int qos, MqttPriority priority, Map<String, Channel<?>> channels,\n+                     String payloadForTask, int timeToWait, PayloadStyle style, String id, String mqttId) {\n+\n+        this.topic = topic;\n+        this.channels = channels;\n+        this.mqttType = mqttType;\n+        this.retainFlag = retainFlag;\n+        this.addTime = addTime;\n+        this.qos = qos;\n+        this.mqttPriority = priority;\n+        this.timeToWait = timeToWait;\n+        this.configuredPayload = payloadForTask;\n+        this.style = style;\n+        this.id = id;\n+        this.mqttId = mqttId;\n+\n+    }\n+\n+    @Override\n+    public int getQos() {\n+        return this.qos;\n+    }\n+\n+    @Override\n+    public String getTopic() {\n+        return this.topic;\n+    }\n+\n+    @Override\n+    public String getPayload() {\n+        return this.payloadToOrFromBroker;\n+    }\n+\n+    @Override\n+    public boolean getRetainFlag() {\n+        return this.retainFlag;\n+    }\n+\n+    @Override\n+    public boolean getAddTime() {\n+        return this.addTime;\n+    }\n+\n+    @Override\n+    public MqttPriority getPriority() {\n+        return this.mqttPriority;\n+    }\n+\n+    @Override\n+    public MqttType getMqttType() {\n+        return this.mqttType;\n+    }\n+\n+    /**\n+     * Checks if the task is ready --> Time is up.\n+     *\n+     * @param currentTime the currentTime, calculated each cycle by abstractManager\n+     * @return aBoolean.\n+     */\n+    @Override\n+    public boolean isReady(long currentTime) {\n+        boolean isReady = false;\n+        if ((currentTime - timeStamp) / 1000 >= timeToWait) {\n+            timeStamp = currentTime;\n+            isReady = true;\n+        }\n+        return isReady;\n+    }\n+\n+}"
  },
  {
    "sha": "c13529aaa58543bfc4a6bb1af870481ac0c853f2",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/CommandWrapper.java",
    "status": "added",
    "additions": 44,
    "deletions": 0,
    "changes": 44,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/CommandWrapper.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/CommandWrapper.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/CommandWrapper.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,44 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * This Wrapper Class is needed by the SubscribeTask. It holds the Value and Expiration Time for a specific Method.\n+ */\n+public class CommandWrapper {\n+\n+    private String value;\n+    private String expiration;\n+    private boolean infinite;\n+\n+    public CommandWrapper(String value, String expiration) {\n+        this.value = value;\n+        this.expiration = expiration;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public void setValue(String value) {\n+        this.value = value;\n+    }\n+\n+    public String getExpiration() {\n+        return expiration;\n+    }\n+\n+    public boolean isInfinite() {\n+        return infinite;\n+    }\n+\n+    /**\n+     * Sets the Expiration. If The Expiration should be infinite. The Infinite Boolean will be set and called later in\n+     * MqttConfigurationComponent.\n+     *\n+     * @param expiration expirationTime usually set by MqttSubscribeTaskImpl.\n+     */\n+    void setExpiration(String expiration) {\n+        this.infinite = expiration.toUpperCase().trim().equals(\"INFINITE\");\n+\n+        this.expiration = expiration;\n+    }\n+}"
  },
  {
    "sha": "50fc16f815417568c03d3d70c6953461dbce7bab",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttBridge.java",
    "status": "added",
    "additions": 82,
    "deletions": 0,
    "changes": 82,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttBridge.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttBridge.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttBridge.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,82 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import java.util.List;\n+\n+import io.openems.common.channel.Debounce;\n+import io.openems.common.channel.Level;\n+import io.openems.common.types.OpenemsType;\n+import io.openems.edge.common.channel.Channel;\n+import io.openems.edge.common.channel.Doc;\n+import io.openems.edge.common.component.OpenemsComponent;\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+import org.joda.time.DateTimeZone;\n+\n+\n+\n+\n+public interface MqttBridge extends OpenemsComponent {\n+\n+    DateTimeZone getTimeZone();\n+\n+    enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+        SLAVE_COMMUNICATION_FAILED(Doc.of(Level.FAULT) //\n+                .debounce(10, Debounce.TRUE_VALUES_IN_A_ROW_TO_SET_TRUE)), //\n+        CYCLE_TIME_IS_TOO_SHORT(Doc.of(Level.WARNING) //\n+                .debounce(10, Debounce.TRUE_VALUES_IN_A_ROW_TO_SET_TRUE)), //\n+        EXECUTION_DURATION(Doc.of(OpenemsType.LONG)),\n+        MQTT_TYPES(Doc.of(OpenemsType.STRING));\n+\n+        private final Doc doc;\n+\n+        ChannelId(Doc doc) {\n+            this.doc = doc;\n+        }\n+\n+        @Override\n+        public Doc doc() {\n+            return this.doc;\n+        }\n+    }\n+\n+\n+    /**\n+     * Adds Task to the Bridge.\n+     *\n+     * @param id       usually from Config of a concrete MqttComponent, called by abstractMqttComponent.\n+     * @param mqttTask MqttTask created by the AbstractMqttComponent.\n+     * @throws MqttException if subscription fails.\n+     */\n+    void addMqttTask(String id, MqttTask mqttTask) throws MqttException;\n+\n+    /**\n+     * Remove the MqttTask by their ID. Removes all Tasks with the same ID --> Usually called on deactivation\n+     * of the Component or when Config is updated\n+     *\n+     * @param id ID of the Tasks usually from AbstractMqttComponent.\n+     */\n+\n+    void removeMqttTasks(String id);\n+\n+    default Channel<String> setMqttTypes() {\n+        return this.channel(ChannelId.MQTT_TYPES);\n+    }\n+\n+    List<MqttTask> getSubscribeTasks(String id);\n+\n+    /**\n+     * Adds the MqttComponent to the Bridge; Used for Update ; React to Events/ Controls / etc.\n+     *\n+     * @param id        id of the MqttComponent usually from config of the Component\n+     * @param component the Component itself.\n+     */\n+    void addMqttComponent(String id, MqttComponent component);\n+\n+    /**\n+     * Removes the Mqtt  Component and their Tasks. Usually called on deactivation of the MqttComponent\n+     *\n+     * @param id id of the Component you want to remove.\n+     */\n+    void removeMqttComponent(String id);\n+}\n+\n+"
  },
  {
    "sha": "4300686db57ba8f7a001311bfcdc3d10943f88db",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommandType.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommandType.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommandType.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommandType.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,11 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * CommandTypes supported by OpenEMS, if you want to handle more commands, just put them here.\n+ * The SubscribeTask will add them automatically to their Map.\n+ * After adding it here, go to your component and edit the implementation of your reactToCommand() method.\n+ */\n+public enum MqttCommandType {\n+    SETTEMPERATURE, SETSCHEDULE, SETPERFORMANCE, SETPOWER\n+\n+}"
  },
  {
    "sha": "2fd0246966a2fde73bb01bc7370d060f5eb44a3d",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommands.java",
    "status": "added",
    "additions": 58,
    "deletions": 0,
    "changes": 58,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommands.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommands.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttCommands.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,58 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import io.openems.common.channel.AccessMode;\n+import io.openems.common.types.OpenemsType;\n+import io.openems.edge.common.channel.Doc;\n+import io.openems.edge.common.channel.StringWriteChannel;\n+import io.openems.edge.common.channel.WriteChannel;\n+import io.openems.edge.common.component.OpenemsComponent;\n+\n+/**\n+ * This Nature needs to be implemented by Components, that want to react to MQTT Commands.\n+ */\n+\n+public interface MqttCommands extends OpenemsComponent {\n+\n+    enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+        /**\n+         * EXAMPLE COMMANDS\n+         */\n+        SET_TEMPERATURE(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue))),\n+        SET_SCHEDULE(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue))),\n+        SET_PERFORMANCE(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue))),\n+        SET_POWER(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue)));\n+\n+\n+        private final Doc doc;\n+\n+        ChannelId(Doc doc) {\n+            this.doc = doc;\n+        }\n+\n+        @Override\n+        public Doc doc() {\n+            return this.doc;\n+        }\n+    }\n+\n+    default WriteChannel<String> getSetTemperatureChannel() {\n+        return this.channel(ChannelId.SET_TEMPERATURE);\n+    }\n+\n+    default WriteChannel<String> getSetScheduleChannel() {\n+        return this.channel(ChannelId.SET_SCHEDULE);\n+    }\n+\n+    default WriteChannel<String> getSetPerformanceChannel() {\n+        return this.channel(ChannelId.SET_PERFORMANCE);\n+    }\n+\n+    default WriteChannel<String> getSetPowerChannel() {\n+        return this.channel(ChannelId.SET_POWER);\n+    }\n+\n+}"
  },
  {
    "sha": "273168258c87c3a47b6d8eed8cdb381f06825e42",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttComponent.java",
    "status": "added",
    "additions": 71,
    "deletions": 0,
    "changes": 71,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttComponent.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttComponent.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttComponent.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,71 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import io.openems.common.channel.AccessMode;\n+import io.openems.common.types.OpenemsType;\n+import io.openems.edge.common.channel.Doc;\n+import io.openems.edge.common.channel.StringWriteChannel;\n+import io.openems.edge.common.channel.WriteChannel;\n+import io.openems.edge.common.component.OpenemsComponent;\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+import org.osgi.service.cm.ConfigurationException;\n+\n+public interface MqttComponent extends OpenemsComponent {\n+\n+    enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+\n+        /**\n+         * The ConfigurationChannel. If you want to Edit/Init your component via REST/JSON, write to this channel.\n+         */\n+        CONFIGURATION(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue)\n+        ));\n+\n+\n+        private final Doc doc;\n+\n+        ChannelId(Doc doc) {\n+            this.doc = doc;\n+        }\n+\n+        @Override\n+        public Doc doc() {\n+            return this.doc;\n+        }\n+    }\n+\n+    /**\n+     * Get the Configuration Channel, if configured by REST/ or json file.\n+     *\n+     * @return the channel\n+     */\n+    default WriteChannel<String> getConfiguration() {\n+        return this.channel(ChannelId.CONFIGURATION);\n+    }\n+\n+    /**\n+     * Called By Mqtt Bridge. Component has to implement what to do with Events (Either a event happened internally and\n+     * tells the broker or vice versa).\n+     */\n+    void reactToEvent();\n+\n+    /**\n+     * Called By Mqtt Bridge. Component has to implement what to do on commands set by mqtt bridge.\n+     */\n+    void reactToCommand();\n+\n+    /**\n+     * Updates the JSON Config. Called by MqttBridge.\n+     *\n+     * @throws MqttException          If a problem occurred with the mqtt connection.\n+     * @throws ConfigurationException if the configuration is wrong.\n+     */\n+    void updateJsonConfig() throws MqttException, ConfigurationException;\n+\n+\n+    /**\n+     * Is Configuration done? --> either JSON Configuration done OR OSGi important for Bridge.\n+     *\n+     * @return aboolean;\n+     */\n+    boolean isConfigured();\n+}"
  },
  {
    "sha": "509fffbcfe41d8967a2a40cee30db40b204e664a",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnection.java",
    "status": "added",
    "additions": 57,
    "deletions": 0,
    "changes": 57,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnection.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnection.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnection.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,57 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+\n+public interface MqttConnection {\n+    /**\n+     * Creates the MqttSubscribe session. HERE: AutoConnect\n+     *\n+     * @param mqttBroker   URL of Broker usually from manager/bridge.\n+     * @param mqttClientId ClientID of the Connection.\n+     * @param username     username.\n+     * @param mqttPassword password.\n+     * @param keepAlive    keepalive.\n+     * @throws MqttException if connection fails or other problems occured with mqtt.\n+     */\n+    void createMqttSubscribeSession(String mqttBroker, String mqttClientId, String username, String mqttPassword, int keepAlive) throws MqttException;\n+\n+    /**\n+     * Creates the publish connection. Connection not already occurs bc a last will flag could be set.\n+     * HERE: NO Auto connect (Bc. of optional Last Will messages)\n+     *\n+     * @param broker       URL of Broker usually from manager/bridge.\n+     * @param clientId     ClientID of the Connection.\n+     * @param keepAlive    keepalive flag.\n+     * @param username     username.\n+     * @param password     password.\n+     * @param cleanSession clean session flag.\n+     * @throws MqttException if connection fails or other problems occurred with mqtt.\n+     */\n+    void createMqttPublishSession(String broker, String clientId, int keepAlive, String username,\n+                                  String password, boolean cleanSession) throws MqttException, NoSuchAlgorithmException, KeyStoreException, KeyManagementException;\n+\n+    /**\n+     * Adds last will to the    Connection.\n+     *\n+     * @param topicLastWill   topic of the last will.\n+     * @param payloadLastWill payload.\n+     * @param qosLastWill     Quality of service.\n+     * @param shouldAddTime   add Time to payload\n+     * @param retainedFlag    retained flag.\n+     * @param time            time as string.\n+     */\n+    void addLastWill(String topicLastWill, String payloadLastWill, int qosLastWill, boolean shouldAddTime, boolean retainedFlag, String time);\n+\n+    /**\n+     * Connects with it's mqttConnectOptions to the broker.\n+     *\n+     * @throws MqttException will be thrown if configs are wrong or connection not available.\n+     */\n+    void connect() throws MqttException;\n+\n+    void disconnect() throws MqttException;\n+}"
  },
  {
    "sha": "cf2d6c50da754a3c76f508e86a7ae7a9b5866a52",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionPublish.java",
    "status": "added",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionPublish.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionPublish.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionPublish.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,18 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+\n+public interface MqttConnectionPublish {\n+\n+    /**\n+     * Sends the Message to the Broker. Usually called by the PublishManager.\n+     *\n+     * @param topic      Topic of the payload.\n+     * @param message    Payload of the message.\n+     * @param qos        Quality of Service of this Message.\n+     * @param retainFlag Should the message be retained.\n+     * @throws MqttException if an error occurred.\n+     */\n+\n+    void sendMessage(String topic, String message, int qos, boolean retainFlag) throws MqttException;\n+}"
  },
  {
    "sha": "6a6285e6d7a7549d9dcb8a23a22f2e2829ec7dc9",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionSubscribe.java",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "changes": 32,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionSubscribe.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionSubscribe.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttConnectionSubscribe.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,32 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import org.eclipse.paho.client.mqttv3.MqttException;\n+\n+public interface MqttConnectionSubscribe {\n+\n+    /**\n+     * A Task subscribing to Topic. Adds an additional Topic to the Connection.\n+     *\n+     * @param topic Topic you want to subscribe to.\n+     * @param qos   Quality of Service.\n+     * @param id    ID of the Component .e.g chp01\n+     * @throws MqttException if an error occurred.\n+     */\n+    void subscribeToTopic(String topic, int qos, String id) throws MqttException;\n+\n+    /**\n+     * Gets the Payload of a certain topic. Will be handled by subscribeTask.\n+     *\n+     * @param topic of the Payload you want to get.\n+     * @return the Payload.\n+     */\n+    String getPayload(String topic);\n+\n+    /**\n+     * Unsubscribe from topic if it was subscribed before.\n+     *\n+     * @param topic Topic of the subscription\n+     * @throws MqttException if a Problem with Mqtt (Broker missing etc) occurs.\n+     */\n+    void unsubscribeFromTopic(String topic) throws MqttException;\n+}"
  },
  {
    "sha": "469cf1f44260eeaee6d8777ae57f31e6177d96ce",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttEventType.java",
    "status": "added",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttEventType.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttEventType.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttEventType.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,9 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * MqttEvents. Either published or received from broker.\n+ * These are just examples and not in use bc current broker has no Events or need for Events.\n+ */\n+public enum MqttEventType {\n+    ERROR, MODBUS_CONNECTION_ERROR, I2C_ERROR, SPI_ERROR, M_BUS_CONNECTION_ERROR,\n+}"
  },
  {
    "sha": "49499bc82b4cf13bb6b209541f78bef521fe40ed",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPriority.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPriority.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPriority.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPriority.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,11 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * Priorities. Depending on the Amount of Tasks, it could be possible, not every task will be handled in time.\n+ * The TIME configured for each topic and the Priorities create the current tasks.\n+ * QoS 0 don't take much time and therefore are almost not considered.\n+ * Reason: QoS 1 and 2 need ACK packages etc.\n+ */\n+public enum MqttPriority {\n+    URGENT, HIGH, LOW\n+}"
  },
  {
    "sha": "939e880d9c4143f40d367a323256da5674abbe19",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTask.java",
    "status": "added",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTask.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTask.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTask.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,10 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+public interface MqttPublishTask extends MqttTask {\n+    /**\n+     * Updates the Payload with the Timestamp. Usually called by Manager.\n+     *\n+     * @param now the Timestamp as a string.\n+     */\n+    void updatePayload(String now);\n+}"
  },
  {
    "sha": "27f8e2e825dd2fef01279014c688373b268ea103",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTaskImpl.java",
    "status": "added",
    "additions": 78,
    "deletions": 0,
    "changes": 78,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTaskImpl.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTaskImpl.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttPublishTaskImpl.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,78 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import io.openems.edge.common.channel.Channel;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+/**\n+ * The concrete Implementation of the AbstractMqttTask. This component handles it's payload by getting a map of\n+ * the Channels it has to publish.\n+ * See Code for details.\n+ */\n+public class MqttPublishTaskImpl extends AbstractMqttTask implements MqttPublishTask {\n+\n+\n+    public MqttPublishTaskImpl(MqttType type, MqttPriority priority, String topic, int qos, boolean retainFlag, boolean useTime,\n+                               int timeToWait, Map<String, Channel<?>> channelMapForTask, String payloadForTask, PayloadStyle style, String id, String mqttId) {\n+        super(topic, type, retainFlag, useTime, qos, priority, channelMapForTask,\n+                payloadForTask, timeToWait, style, id, mqttId);\n+\n+    }\n+\n+    /**\n+     * Updates the Payload. Usually called from MqttManager.\n+     * ATM. Only \"Standard\" Payload.\n+     * @param now the Timestamp as a string.\n+     */\n+    @Override\n+    public void updatePayload(String now) {\n+        createStandardPayload(now);\n+    }\n+\n+    /**\n+     * Creates the StandardPayload from a Config.\n+     *\n+     * @param now if Time should be added, now is added to the Payload.\n+     */\n+    private void createStandardPayload(String now) {\n+\n+\n+        JsonObject payload = new JsonObject();\n+        if (getAddTime()) {\n+            payload.addProperty(\"time\", now);\n+        }\n+        payload.addProperty(\"device\", super.mqttId);\n+        String[] configuredPayload = super.configuredPayload.split(\":\");\n+        AtomicInteger jsonCounter = new AtomicInteger(0);\n+        if (configuredPayload[0].equals(\"\")) {\n+            return;\n+        }\n+        //the configuredPayload follows the pattern of NameInBroker:ChannelId:NameInBroker:ChannelId --> therefore key  % 2 == 0\n+        Arrays.stream(configuredPayload).forEachOrdered(consumer -> {\n+            if (jsonCounter.get() % 2 == 0) {\n+                String value = \"\"; //\"Not Defined Yet\";\n+                //get the ChannelId --> since it's ordered forEach --> get correct Channel .\n+                Channel<?> channel = super.channels.get(configuredPayload[jsonCounter.incrementAndGet()]);\n+                if (channel.value().isDefined()) {\n+                    JsonElement channelObj = new Gson().toJsonTree(channel.value().get());\n+                    payload.add(consumer, channelObj);\n+                } else {\n+                    payload.addProperty(consumer, value);\n+                }\n+            } else {\n+                jsonCounter.getAndIncrement();\n+            }\n+        });\n+\n+        //UPDATED PAYLOAD saved.\n+        super.payloadToOrFromBroker = payload.toString();\n+    }\n+\n+}\n+"
  },
  {
    "sha": "0cc2df22eacff04c20ed94e2cbd577282959e038",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTask.java",
    "status": "added",
    "additions": 34,
    "deletions": 0,
    "changes": 34,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTask.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTask.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTask.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,34 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import java.util.Map;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+\n+\n+public interface MqttSubscribeTask extends MqttTask {\n+\n+    /**\n+     * Called by MqttSubscribeManager. Response to Payload.\n+     *\n+     * @param payload the Payload for the concrete MqttTask.\n+     */\n+    void response(String payload);\n+\n+    /**\n+     * Converts the time. Usually Called by Manager.\n+     *\n+     * @param timeZone given by Manager-Class.\n+     */\n+    void convertTime(DateTimeZone timeZone);\n+\n+    DateTime getTime();\n+\n+    /**\n+     * Get the Commands and their WrapperClass.\n+     *\n+     * @return The Map.\n+     */\n+    Map<MqttCommandType, CommandWrapper> getCommandValues();\n+}"
  },
  {
    "sha": "a54a989cdf4a7e2a29416e39a65c41ea10d69190",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTaskImpl.java",
    "status": "added",
    "additions": 201,
    "deletions": 0,
    "changes": 201,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTaskImpl.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTaskImpl.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttSubscribeTaskImpl.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,201 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import io.openems.edge.common.channel.Channel;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+\n+/**\n+ * The Concrete Implementation of the AbstractMqttTask. The SubscribeTaskImpl handles the\n+ */\n+public class MqttSubscribeTaskImpl extends AbstractMqttTask implements MqttSubscribeTask {\n+\n+    private String time;\n+    //converted time\n+    private DateTime timeDate;\n+    //                                               //name in Broker   // ID of channel\n+    //Map of ID For Broker and ChannelID --> e.g. roomTemperature: temperature.channelId.id();\n+    private Map<String, String> nameIdAndChannelIdMap;\n+    private Map<MqttCommandType, CommandWrapper> commandValueMap;\n+\n+    public MqttSubscribeTaskImpl(MqttType type, MqttPriority priority, String topic, int qos, boolean retainFlag, boolean useTime,\n+                                 int timeToWait, Map<String, Channel<?>> channelMapForTask, String payloadForTask,\n+                                 PayloadStyle payloadStyle, String id, String mqttId) {\n+        super(topic, type, retainFlag, useTime, qos, priority, channelMapForTask, payloadForTask, timeToWait,\n+                payloadStyle, id, mqttId);\n+        if (type.equals(MqttType.TELEMETRY)) {\n+\n+            this.nameIdAndChannelIdMap = new HashMap<>();\n+            //Important for Telemetry --> Mapping\n+\n+            String[] tokens = payloadForTask.split(\":\");\n+\n+            for (int x = 0; x < tokens.length; x += 2) {\n+                this.nameIdAndChannelIdMap.put(tokens[x], tokens[x + 1]);\n+            }\n+        }\n+        else if(type.equals(MqttType.COMMAND)) {\n+            commandValueMap = new HashMap<>();\n+            Arrays.stream(MqttCommandType.values()).forEach(consumer -> this.commandValueMap.put(consumer, new CommandWrapper(\"NOTDEFINED\", \"NOTDEFINED\")));\n+        }\n+    }\n+\n+    /**\n+     * Called by MqttSubscribeManager. Response to Payload.\n+     *\n+     * @param payload the Payload for the concrete MqttTask.\n+     */\n+    @Override\n+    public void response(String payload) {\n+        super.payloadToOrFromBroker = payload;\n+        standardResponse();\n+    }\n+\n+    /**\n+     * Standard Response for subscription.\n+     * <p>Each ID from broker has a value.\n+     * message contains {\n+     * \"SentOnDate\": time,\n+     * \"NameOfBrokerParam\": \"ID of Sensor\"\n+     * \"metrics\":{\n+     * \"NameOfBrokerParam\": \"Value for Param\"\n+     * }\n+     * }\n+     * </p>\n+     * <p>\n+     * The name of broker param after metrics --> has a value, this value will be written into an Openems channel.\n+     * It either writes directly in the channel and sets something (e.g. subscribe to telemetry)\n+     * or\n+     * MqttType --> Each MqttComponent got a channel for corresponding MqttType and therefore each component can react to\n+     * entries of such channel.\n+     * </p>\n+     * <p>\n+     * standard Response works as follows:\n+     * Replace the String with  \"\" if it is not a Alphanumeric a decimal or a : ... the leftover string will be split\n+     * at the :\n+     * the first part is for id/Name of broker params. the second part is for value.\n+     * The Id/Name of broker params was already saved and therefore the index of the id matches the index of the corresponding ChannelId in the list.\n+     * After that the Map where the ChannelId with the corresponding Channel is stored can be called and the next Value can be set.\n+     * </p>\n+     */\n+    private void standardResponse() {\n+        String response = super.payloadToOrFromBroker;\n+        if (response.equals(\"\")) {\n+            super.configuredPayload = response;\n+            return;\n+        }\n+\n+        JsonObject responseJson = new Gson().fromJson(response, JsonObject.class);\n+\n+        if (responseJson.has(\"time\")) {\n+            this.time = responseJson.get(\"time\").getAsString();\n+        } else if (responseJson.has(\"timestamp\")) {\n+            this.time = responseJson.get(\"timestamp\").getAsString();\n+        }\n+\n+\n+        switch (this.getMqttType()) {\n+            case TELEMETRY:\n+                standardTelemetryResponse(responseJson);\n+                break;\n+            case COMMAND:\n+                standardCommandResponse(responseJson);\n+                break;\n+            case EVENT:\n+                //System.out.println(\"Events are not supported by Subscribers yet!\");\n+                break;\n+        }\n+\n+    }\n+    private void standardCommandResponse(JsonObject tokens) {\n+        if (!super.getMqttType().equals(MqttType.COMMAND)) {\n+            return;\n+        }\n+        AtomicReference<String> commandTypeString = new AtomicReference<>(\"NotDefined\");\n+\n+\n+        tokens.keySet().forEach(entry -> {\n+            if (entry.toLowerCase().contains(\"method\")) {\n+                commandTypeString.set(tokens.get(entry).getAsString().toUpperCase());\n+\n+            } else if (entry.toLowerCase().contains(\"value\")) {\n+                this.commandValueMap.get(MqttCommandType.valueOf(commandTypeString.get())).setValue(tokens.get(entry).getAsString());\n+            } else if (entry.toLowerCase().contains(\"expires\") || entry.toLowerCase().contains(\"expiration\")) {\n+                if (tokens.get(entry).isJsonNull()) {\n+                    this.commandValueMap.get(MqttCommandType.valueOf(commandTypeString.get())).setExpiration(\"Infinite\");\n+                } else {\n+                    this.commandValueMap.get(MqttCommandType.valueOf(commandTypeString.get())).setExpiration(tokens.get(entry).getAsString());\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Standard Telemetry Response. Map the Data from the Broker to the OpenEMS channel.\n+     *\n+     * @param tokens response as a Json obj.\n+     */\n+    private void standardTelemetryResponse(JsonObject tokens) {\n+        //Events and Commands need to be handled by Component itself, only telemetry is allowed to update Channels directly.\n+        if (!super.getMqttType().equals(MqttType.TELEMETRY)) {\n+            return;\n+        }\n+        tokens.keySet().stream().filter(entry -> !entry.toUpperCase().equals(\"METRICS\") && !entry.toUpperCase().contains(\"TIME\") && !entry.toUpperCase().equals(\"ID\"))\n+                .collect(Collectors.toList()).forEach(key -> {\n+            String value = tokens.get(key).getAsString();\n+            //Check own ChannelId Map if key is in Map and Value\n+            if (this.nameIdAndChannelIdMap.containsKey(key)) {\n+                if (!value.equals(\"Not Defined Yet\")) {\n+                    String channelId = this.nameIdAndChannelIdMap.get(key);\n+                    Channel<?> channel = super.channels.get(channelId);\n+                    channel.setNextValue(value);\n+                    System.out.println(\"Update Channel: \" + channelId + \" with Value: \" + value);\n+                } else {\n+                    System.out.println(\"Value not defined yet for: \" + this.nameIdAndChannelIdMap.get(key));\n+                }\n+            } else {\n+                System.out.println(\"Key: \" + key + \" was not configured!\");\n+            }\n+        });\n+    }\n+\n+\n+    /**\n+     * Converts the time. Usually Called by Manager.\n+     *\n+     * @param timeZone given by Manager-Class.\n+     */\n+    @Override\n+    public void convertTime(DateTimeZone timeZone) {\n+        if (this.time != null && !this.time.equals(\"\")) {\n+            this.timeDate = DateTime.now(timeZone);\n+        }\n+    }\n+\n+    @Override\n+    public DateTime getTime() {\n+        return timeDate;\n+    }\n+\n+    /**\n+     * Get the Commands and their WrapperClass.\n+     *\n+     * @return The Map.\n+     */\n+    @Override\n+    public Map<MqttCommandType, CommandWrapper> getCommandValues() {\n+        return this.commandValueMap;\n+    }\n+\n+\n+}"
  },
  {
    "sha": "c7b6224251d6723cbd7a00db3045037fe1118770",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttTask.java",
    "status": "added",
    "additions": 26,
    "deletions": 0,
    "changes": 26,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttTask.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttTask.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttTask.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,26 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+public interface MqttTask {\n+\n+    int getQos();\n+\n+    String getTopic();\n+\n+    String getPayload();\n+\n+    boolean getRetainFlag();\n+\n+    boolean getAddTime();\n+\n+    MqttPriority getPriority();\n+\n+    MqttType getMqttType();\n+\n+    /**\n+     * Called by Abstract Cycle Worker for current Tasks to handle.\n+     *\n+     * @param currentTime the currentTime, calculated each cycle by abstractManager\n+     * @return aboolean.\n+     */\n+    boolean isReady(long currentTime);\n+}"
  },
  {
    "sha": "1751d39782de51089c68f2460f014c76a3390895",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttType.java",
    "status": "added",
    "additions": 8,
    "deletions": 0,
    "changes": 8,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttType.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttType.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/MqttType.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,8 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * The MQTT Types. ATM Only Telemetry, Command and EVENTS are available.\n+ */\n+public enum MqttType {\n+    TELEMETRY, COMMAND, EVENT\n+}"
  },
  {
    "sha": "be1d68d0f4115a1eb4d52dcaf5c34a0f8247e72f",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/PayloadStyle.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/PayloadStyle.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/PayloadStyle.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/PayloadStyle.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,31 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+/**\n+ * Payload-Styles.\n+ * <p>\n+ * \"STANDARD\" Payloadstyle for publish (Telemetry) is:\n+ * {\n+ * TimeStamp : TIME ,\n+ * ID : Id -Of-The-Component,\n+ * \"metrics\" : {\n+ * NameForBroker: Value,\n+ * NAME : VALUE,\n+ * }\n+ * }\n+ * For Subscribe and Command it is:\n+ *{\n+ *     \"time\": \"TIME_ISO_UTC\",\n+ *     \"method\":MethodName (look up MqttCommandTypes)\n+ *     \"device\": DeviceId (Usually can be ignored bc topics are unique therefore device ID is not important)\n+ *     \"value\": Value (Value for the Method)\n+ *     \"expires\": TimeInSeconds (Time till the Command Expires)\n+ *}\n+ * </p>\n+ *\n+ *\n+ *\n+ * If you need different Payload-Styles add here an enum and add them to pub and sub task.\n+ */\n+public enum PayloadStyle {\n+    STANDARD\n+}"
  },
  {
    "sha": "881bfaeddae6aa267fb0782b0af8186f0730809d",
    "filename": "io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/Schedule.java",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/OpenEMS/openems/blob/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/Schedule.java",
    "raw_url": "https://github.com/OpenEMS/openems/raw/c1fcd8f87d32a73ff77c8cffbd7b37a88c930417/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/Schedule.java",
    "contents_url": "https://api.github.com/repos/OpenEMS/openems/contents/io.openems.edge.bridge.mqtt/src/io/openems/edge/bridge/mqtt/api/Schedule.java?ref=c1fcd8f87d32a73ff77c8cffbd7b37a88c930417",
    "patch": "@@ -0,0 +1,36 @@\n+package io.openems.edge.bridge.mqtt.api;\n+\n+import io.openems.common.channel.AccessMode;\n+import io.openems.common.types.OpenemsType;\n+import io.openems.edge.common.channel.Doc;\n+import io.openems.edge.common.channel.StringWriteChannel;\n+import io.openems.edge.common.channel.WriteChannel;\n+import io.openems.edge.common.component.OpenemsComponent;\n+\n+/**\n+ * This will be an extra Nature for Components containing a Schedule controlled by the MQTT Cloud -->\n+ * When to run certain Power\n+ */\n+public interface Schedule extends OpenemsComponent {\n+    enum ChannelId implements io.openems.edge.common.channel.ChannelId {\n+\n+\n+        SCHEDULE(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_WRITE).onInit(\n+                channel -> ((StringWriteChannel) channel).onSetNextWrite(channel::setNextValue)));\n+\n+\n+        private final Doc doc;\n+\n+        ChannelId(Doc doc) {\n+            this.doc = doc;\n+        }\n+\n+        @Override\n+        public Doc doc() {\n+            return this.doc;\n+        }\n+    }\n+    default WriteChannel<String> getScheduleChannel(){\n+        return this.channel(ChannelId.SCHEDULE);\n+    }\n+}"
  }
]
