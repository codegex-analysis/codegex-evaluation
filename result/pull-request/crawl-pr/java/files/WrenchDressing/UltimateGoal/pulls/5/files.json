[
  {
    "sha": "61a9130cd9669c3843e6445dfe1fee2d493869bc",
    "filename": ".idea/compiler.xml",
    "status": "added",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/.idea/compiler.xml",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/.idea/compiler.xml",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/.idea/compiler.xml?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,6 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project version=\"4\">\n+  <component name=\"CompilerConfiguration\">\n+    <bytecodeTargetLevel target=\"1.8\" />\n+  </component>\n+</project>\n\\ No newline at end of file"
  },
  {
    "sha": "d5d35ec44f10991b508f6454a85204a276726364",
    "filename": ".idea/misc.xml",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/.idea/misc.xml",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/.idea/misc.xml",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/.idea/misc.xml?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <project version=\"4\">\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_7\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\n     <output url=\"file://$PROJECT_DIR$/build/classes\" />\n   </component>\n   <component name=\"ProjectType\">"
  },
  {
    "sha": "9c7485a03ea461f7009208195630939c1cdd6ec4",
    "filename": "FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java",
    "status": "modified",
    "additions": 6,
    "deletions": 5,
    "changes": 11,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -29,15 +29,16 @@\n \n package org.firstinspires.ftc.robotcontroller.external.samples;\n \n-import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n-import java.util.List;\n+\n import org.firstinspires.ftc.robotcore.external.ClassFactory;\n import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;\n-import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.List;\n \n /**\n  * This 2020-2021 OpMode illustrates the basics of using the TensorFlow Object Detection API to\n@@ -50,7 +51,7 @@\n  * is explained below.\n  */\n @TeleOp(name = \"Concept: TensorFlow Object Detection\", group = \"Concept\")\n-@Disabled\n+\n public class ConceptTensorFlowObjectDetection extends LinearOpMode {\n     private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n     private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n@@ -105,7 +106,7 @@ public void runOpMode() {\n             // (typically 1.78 or 16/9).\n \n             // Uncomment the following line if you want to adjust the magnification and/or the aspect ratio of the input images.\n-            //tfod.setZoom(2.5, 1.78);\n+            tfod.setZoom(2.5, 1.78);\n         }\n \n         /** Wait for the game to begin */"
  },
  {
    "sha": "51cad109d65ee42364eb6ccf807c67a11f3cc2c6",
    "filename": "FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java",
    "status": "modified",
    "additions": 5,
    "deletions": 4,
    "changes": 9,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -29,6 +29,7 @@\n \n package org.firstinspires.ftc.robotcontroller.external.samples;\n \n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n \n@@ -51,7 +52,7 @@\n  * is explained below.\n  */\n @TeleOp(name = \"Concept: TensorFlow Object Detection Webcam\", group = \"Concept\")\n-\n+@Disabled\n public class ConceptTensorFlowObjectDetectionWebcam extends LinearOpMode {\n     private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n     private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n@@ -106,7 +107,7 @@ public void runOpMode() {\n             // (typically 1.78 or 16/9).\n \n             // Uncomment the following line if you want to adjust the magnification and/or the aspect ratio of the input images.\n-            //tfod.setZoom(2.5, 1.78);\n+            tfod.setZoom(2.5, 1.78);\n         }\n \n         /** Wait for the game to begin */\n@@ -126,8 +127,8 @@ public void runOpMode() {\n                       int i = 0;\n                       for (Recognition recognition : updatedRecognitions) {\n                         telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n-                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n-                                recognition.getLeft(), recognition.getTop());\n+                          telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                  recognition.getLeft(), recognition.getTop());\n                         telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n                                 recognition.getRight(), recognition.getBottom());\n                       }"
  },
  {
    "sha": "fe39f738002ed03c9a29ec9d272a25c72d733656",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BestSTATEAutoEver.java",
    "status": "added",
    "additions": 1590,
    "deletions": 0,
    "changes": 1590,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BestSTATEAutoEver.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BestSTATEAutoEver.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/BestSTATEAutoEver.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,1590 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n+import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.PIDFCoefficients;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n+\n+//import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n+\n+/* TODO\n+- Check to make sure HW reads are being done efficiently.  Don't ask for hardware reads more often than required\n+- Consider adding a smoothing feature in MecanumFunction\n+- Fix the motor names.  THey are very awkward right now\n+- Confirm that WallTracking exits properly\n+- Add camera direction function into WallTracking\n+- Tune motors\n+    -Backright motor not tuned correctly. Wall tracking program bugging out. Not getting to desired location, but does exit the loop when robot is manually guided to Target Position.\n+- Create exact angular adjustment function\n+ */\n+\n+@Autonomous(name = \"BestSTATEAutoEver\", group = \"\")\n+\n+public class BestSTATEAutoEver extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    private CRServo Conveyor;\n+    private DcMotor intake;\n+    public static final double NEW_P = 20;\n+    public static final double NEW_I = 15;\n+    public static final double NEW_D = 0;\n+    public static final double NEW_F = 5;\n+    private DcMotor clarm;\n+    private Servo claw;\n+    private Servo ramp;\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private TFObjectDetector tfod;\n+    private static final float mmTargetHeight = (6) * mmPerInch;\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+    private OpenGLMatrix lastLocation = null;\n+    //WebcamName webcamName = null;\n+    private DcMotorEx motor_drive_flAsDcMotor, motor_drive_blAsDcMotor, motor_drive_brAsDcMotor, motor_drive_frAsDcMotor;\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    Orientation angles;\n+    ElapsedTime TimerA;\n+    ElapsedTime TimerC;\n+    double OneVote, NoneVote, QuadVote;\n+    double DecelConstant, DecelConstant2;\n+    ElapsedTime TimerD;\n+    ElapsedTime MagTimer;\n+    ElapsedTime AccelTimer;\n+    ElapsedTime DevelTimer;\n+    float CurrentHeading;\n+    ElapsedTime TimerB;\n+    double CurrentVal;\n+    double LastVal;\n+    double QuadRun;\n+    double OneRun;\n+    double YL, XL;\n+    double NoneRun;\n+    double YEncoderTicks;\n+    double AvgReadingY, AvgReadingX;\n+    double XEncoderTicks;\n+    double EncoderTicks;\n+    double YSpeed;\n+    double YPositionReset, XPositionReset, XPositionP, YPositionP;\n+    double XDecelerate;\n+    double TotalEncoderTicks;\n+    double Accelerate, Decelerate, XAccelerate;\n+    double mFr, mFl, mBl, mBr;\n+    double X, Y, XD, YD;\n+    double CurrentX, CurrentY;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale, YLin, XLin, XRin;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n+    double Heading;\n+    double Zrot = 0.0;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double avgEnc;\n+    double Xposition;\n+    double Yposition;\n+    double AccelConstant, AccelConstant2;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    boolean fullMag;\n+    private Servo camServo;\n+    ModernRoboticsI2cRangeSensor rangeSensor;\n+    private State CurrentState;\n+\n+    private enum State {\n+        MOVE_RIGHT,\n+        MOVE_LEFT,\n+        MOVE_FORWARD,\n+        MOVE_BACKWARDS,\n+        SHOOT,\n+        INTAKE,\n+        IDLE,\n+    }\n+\n+    private class PersonalityStateMachine implements Runnable {\n+        public PersonalityStateMachine() {\n+\n+        }\n+\n+        public void run() {\n+            while (opModeIsActive()) {\n+                PersonalityStateMachine();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void runOpMode() {\n+\n+        // vuforiaUltimateGoal = new VuforiaCurrentGame();\n+        motor_drive_flAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_flAsDcMotor\");\n+        motor_drive_frAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_frAsDcMotor\");\n+        motor_drive_blAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_blAsDcMotor\");\n+        motor_drive_brAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_brAsDcMotor\");\n+        RightLauncher = hardwareMap.get(DcMotor.class, \"RightLauncher\");\n+        LeftLauncher = hardwareMap.get(DcMotor.class, \"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        intake = hardwareMap.get(DcMotor.class, \"intake\");\n+        clarm = hardwareMap.get(DcMotor.class, \"clarm\");\n+        claw = hardwareMap.get(Servo.class, \"claw\");\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+\n+        PIDFCoefficients pidOrig = motor_drive_flAsDcMotor.getPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n+        rangeSensor = hardwareMap.get(ModernRoboticsI2cRangeSensor.class, \"rangeSensor\");\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+        Initialization();\n+\n+        // Activate here for camera preview.\n+        telemetry.addData(\">>\", \"Vuforia initialized, press start to continue...\");\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = -2.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n+\n+        if (tfod != null) {\n+            tfod.activate();\n+            tfod.setZoom(3, 1.78);\n+        }\n+        claw.setPosition(0);\n+        targetsUltimateGoal.activate();\n+        X = 1;\n+        Y = 1;\n+        YPositionReset = 0;\n+        XPositionReset = 0;\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        ringScan();\n+        CurrentState = State.IDLE;\n+        PersonalityStateMachine myThread = new PersonalityStateMachine();\n+        myThread.run();\n+        waitForStart();\n+        GoTov2(0, 25, 0.3, 0, 9, 9, true, true, 0.012, false);\n+        //Shooting Powershots Here!\n+        if (OneRun == 1) {\n+            GoTov2(0, 20, 0.25, 0, 9, 9, true, true, 0.012, false);\n+        }\n+        if (NoneRun == 1) {\n+            clarm.setTargetPosition(800);\n+            clarm.setPower(0.4);\n+            IMUTurn(38);\n+            GoTov2(0, 33, 0.4, 45, 5, 5, true, true, 0.004, false);\n+            IMUTurn(130);\n+            clarm.setTargetPosition(900);\n+            clarm.setPower(0.3);\n+            claw.setPosition(1);\n+            clarm.setTargetPosition(600);\n+            clarm.setPower(-0.6);\n+            IMUTurn(0);\n+            GoTov2(0, -13.25, 0.4, 0, 5, 5, true, true, 0.012, true);\n+            IMUTurn(-55);\n+            clarm.setTargetPosition(960);\n+            clarm.setPower(0.3);\n+            sleep(500);\n+            claw.setPosition(0);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.6);\n+            sleep(500);\n+        }\n+\n+\n+\n+/*\n+        GoTov2(0,24, 0.25, 0, 6,6,true,false,0.012,true);\n+        clarm.setTargetPosition(500);\n+        clarm.setPower(0.5);\n+        GoTov2(0,24, 0.25, 0, 6,6,false,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.5);\n+        GoTov2(0,24, 0.25, 0, 6,6,false,true,0.012,true);\n+        GoTov2(0,-24, 0.25, 0, 6,6,true,false,0.012,true);\n+        clarm.setTargetPosition(500);\n+        clarm.setPower(0.5);\n+        GoTov2(0,-24, 0.25, 0, 6,6,false,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.5);\n+        GoTov2(0,-24, 0.25, 0, 6,6,false,true,0.012,true);\n+        sleep(1000);\n+*/\n+\n+\n+  /*wallTargetTracking(vuforia, allTrackables, 90, 0, 58, 0, 10, 2, 1, 3, false, 0);\n+ /*\n+        AngularAdjustment(-6.1, 0.02);\n+\n+        AngularAdjustment(-3.5, 0.028);\n+\n+        AngularAdjustment(1.15, 0.028);\n+\n+        GoTo(0, 12,.2, 0, 14, 0, true, true, 0.012, true);\n+        if (QuadRun == 1) {\n+            intakeFunction(16, 1300, 0, true, .03);\n+            intakeFunction(6, 1300, 0, true, .03);\n+        }\n+/*\n+        GoTo(0, 10,.2, 0, 14, 0, true, false, 0.012, true);\n+        clarm.setTargetPosition(650);\n+        clarm.setPower(0.3);\n+        GoTo(10,10,0.2,0,14,0, false,true,0.012,true);\n+        GoTo(-10,-10,0.2,0,14,0, true,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.3);\n+        GoTo(0, -10,.2, 0, 14, 0, false, true, 0.012, true);\n+   /* GoTo(20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+*/\n+\n+\n+\n+\n+    /*\n+    GoTo(0, 40, .3, 0, 14, 0, false, true, 0.012, true);\n+IMUTurn(175);\n+*/\n+\n+    /*\n+    GoTo(20, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, 20, .3, 0, 14, 0, true, true, 0.012,true);\n+        GoTo(0, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(0, 20, .3, 0, 14, 0, true, true, 0.012,true);\n+\n+*/\n+\n+        /*while(Xposition <= 24 || Yposition <= 48){\n+    if (Xposition >= 24){\n+        X = 0;\n+    }\n+    if (Yposition >= 48){\n+        Y = 0;\n+    }\n+    MecanumFunction(0.1414 * Y,0.1 * X,0);\n+    DistanceTracker();\n+\n+}\n+\n+         */\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void DistanceTracker() {\n+        if (Yposition < 0) {\n+            YPositionP = -1;\n+        } else {\n+            YPositionP = 1;\n+        }\n+        if (Xposition < 0) {\n+            XPositionP = -1;\n+        } else {\n+            XPositionP = 1;\n+        }\n+        Yposition = (((((motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) * 0.25) * 0.00208333333) * 12.8) - YPositionReset);//((((motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 4) / 480) * 12.566);\n+        Xposition = ((((motor_drive_flAsDcMotor.getCurrentPosition() - motor_drive_blAsDcMotor.getCurrentPosition()) * 0.00208333333) * 11.5 * .5) - (XPositionReset));\n+\n+    }\n+\n+    private void ResetTracker() {\n+        XPositionReset = Xposition;\n+        YPositionReset = Yposition;\n+    }\n+\n+    private void WallTargetGoTo(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables, double xTarget, double yTarget, double Speed) {\n+        targetVisible = false;\n+        while (targetVisible == false) {\n+            for (int count = 0; count < 10; count++) {\n+                for (VuforiaTrackable trackable : allTrackables) {\n+                    if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                        targetVisible = true;\n+\n+                        // getUpdatedRobotLocation() will return null if no new information is available since\n+                        // the last time that call was made, or if the trackable is not currently visible.\n+                        OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                        if (robotLocationTransform != null) {\n+                            lastLocation = robotLocationTransform;\n+                        }\n+                        break;\n+                    } else {\n+                        targetVisible = false;\n+                    }\n+                }\n+                if (targetVisible) {\n+                    VectorF translation = lastLocation.getTranslation();\n+                    CurrentY = translation.get(1) / mmPerInch;\n+                    CurrentX = translation.get(0) / mmPerInch;\n+                    AvgReadingY += CurrentY;\n+                    AvgReadingX += CurrentX;\n+                }\n+\n+\n+            }\n+            AvgReadingY = (AvgReadingY / 10);\n+            AvgReadingX = (AvgReadingX / 10);\n+            // Provide feedback as to where the robot is located (if we know).\n+\n+        }\n+//yTarget - AvgReadingX\n+        //  GoTo( AvgReadingY - xTarget ,0, Speed, 0, 14,0,true,true,0.012,true);\n+        GoTo(-24, yTarget - AvgReadingX, Speed, 0, 14, 0, true, true, 0.012, true);\n+\n+\n+    }\n+\n+    private void SpeedCalculator(double XDistance, double YDistance, double Speed, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel) {\n+        if (Math.abs(Xposition) >= Math.abs(XDistance)) {\n+            if (Decel) {\n+                X = 0;\n+            }\n+        }\n+        if (XDistance == 0) {\n+            X = 0;\n+        }\n+        if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+            if (Decel) {\n+                Y = 0;\n+            }\n+        }\n+        if (XDistance < 0) {\n+            XD = -1;\n+        }\n+        if (YDistance < 0) {\n+            YD = -1;\n+        }\n+        if (XDistance == 0) {\n+            if (Accel && ((Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+                YL = Math.min(Math.max(AccelConstant * (Yposition * Yposition), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max(AccelConstant2 * (Xposition * Xposition), 0.025), Speed) * X * XD;\n+            } else if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) <= Math.abs(DecelDistance)))) {\n+                YL = Math.min(Math.max(0.025 + (DecelConstant * Math.abs((YDistance - Yposition))), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max((0.025 + (DecelConstant2 * Math.abs(((XDistance - Xposition))))), 0.025), Speed) * X * XD;\n+            } else {\n+                YL = YSpeed * YD;\n+                XL = Speed * XD;\n+            }\n+        } else {\n+            if (Accel && ((Math.abs(Xposition) <= Math.abs((AccelDistance * 0.7071067)) || Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+                YL = Math.min(Math.max(AccelConstant * (Yposition * Yposition), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max(AccelConstant2 * (Xposition * Xposition), 0.025), Speed) * X * XD;\n+                telemetry.addData(\"Accel?\", 1);\n+                telemetry.update();\n+            } else if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) <= Math.abs(DecelDistance) || Math.abs(XDistance) - Math.abs(Xposition) <= Math.abs(DecelDistance * 0.7071067)))) {\n+                YL = Math.min(Math.max(0.025 + (DecelConstant * (YDistance - Yposition)), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max((0.025 + (DecelConstant2 * ((XDistance - Xposition)))), 0.025), Speed) * X * XD;\n+                telemetry.addData(\"Decel?\", 1);\n+                telemetry.update();\n+            } else {\n+                YL = YSpeed;\n+                XL = Speed;\n+                telemetry.addData(\"Neither?\", 1);\n+                telemetry.update();\n+            }\n+        }\n+\n+\n+    }\n+\n+    private void GoTov2(double XDistance, double YDistance, double Speed, double MaintainAngle, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel, double IMUGain, boolean Reset) {\n+        if (Reset) {\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            Xposition = 0;\n+            Yposition = 0;\n+        } else {\n+            DistanceTracker();\n+            ResetTracker();\n+        }\n+        XPositionReset = Xposition;\n+        YPositionReset = Yposition;\n+        DistanceTracker();\n+        YSpeed = Math.abs(Speed * 0.7071067);\n+        AccelConstant = (Speed / AccelDistance);\n+        AccelConstant2 = (Speed / (AccelDistance * 0.7071067));\n+        DecelConstant = (((YSpeed - 0.025) / DecelDistance));\n+        DecelConstant2 = (((Speed - 0.025) / (DecelDistance * 0.7071067)));\n+        X = 1;\n+        Y = 1;\n+        XD = 1;\n+        YD = 1;\n+        if (!(XDistance == 0)) {\n+\n+            while (Math.abs(Xposition) <= Math.abs(XDistance) || Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                DistanceTracker();\n+                SpeedCalculator(XDistance, YDistance, Speed, AccelDistance, DecelDistance, Accel, Decel);\n+                MecanumFunction(YL, XL, (-MaintainAngle + CurrentHeading) * IMUGain);\n+            }\n+\n+            if (Decel) {\n+                YL = XL = 0;\n+            }\n+\n+        } else if (XDistance == 0) {\n+            while (Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                telemetry.addData(\"YPosition\", Yposition);\n+                telemetry.update();\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+                DistanceTracker();\n+                SpeedCalculator(XDistance, YDistance, Speed, AccelDistance, DecelDistance, Accel, Decel);\n+                MecanumFunction(YL, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+            }\n+\n+            if (Decel) {\n+                YL = XL = 0;\n+            }\n+\n+        }\n+    }\n+\n+\n+    private void intakeFunction(double distance, long sleep, double Angle, boolean Beltafter, double speed) {\n+        ramp.setPosition(0.8);\n+        sleep(300);\n+        intake.setPower(-1);\n+        Conveyor.setPower(-1);\n+        GoTo(0, distance, speed, Angle, 14, 0, true, true, 0.012, true);\n+\n+        intake.setPower(1);\n+        if (Beltafter == false) {\n+            Conveyor.setPower(0);\n+        }\n+        sleep(sleep);\n+        intake.setPower(0);\n+        ramp.setPosition(0);\n+    }\n+\n+    private void MagFull(double Yl, double Xl, double Timeout, double Distance, double MaintainAngle, double IMUGain) {\n+        ramp.setPosition(0.8);\n+\n+        ElapsedTime MagTimer = new ElapsedTime();\n+        while (MagTimer.seconds() < Timeout) {\n+            angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+            CurrentHeading = angles.firstAngle;\n+            intake.setPower(1);\n+            LeftLauncher.setPower(-0.75);\n+            RightLauncher.setPower(-0.75);\n+            if (rangeSensor.getDistance(DistanceUnit.CM) > Distance) {\n+                MagTimer.reset();\n+            }\n+            MecanumFunction(Yl, Xl, (-MaintainAngle + CurrentHeading) * IMUGain);\n+        }\n+        LeftLauncher.setPower(0);\n+        RightLauncher.setPower(0);\n+        MecanumFunction(0, 0, 0);\n+        intake.setPower(-1);\n+        sleep(250);\n+        ramp.setPosition(0);\n+    }\n+\n+    private void AngularAdjustment(double targetangle, double IMUgain) {\n+        ElapsedTime TimerD = new ElapsedTime();\n+        TimerD.reset();\n+        while ((TimerD.milliseconds() < 350)) {\n+\n+            // ANDREW: Consider the use of BulkCaching here since it is expensive to read all the motor positions if all you need is the imu angle\n+            BulkCaching();\n+            if (((-targetangle + CurrentHeading) >= 0.07 && (-targetangle + CurrentHeading) <= -0.07)) {\n+                TimerD.reset();\n+            }\n+            MecanumFunction(0, 0, IMUgain * (-targetangle + CurrentHeading));\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    //   while (!(40 - CurrentY <= 1 && 40 - CurrentY >= -1 && -3 - CurrentX <= 1 && -3 - CurrentX >= -1 && (180 - (180 + Zrot)) >= 1 && (180 - (180 + Zrot)) <= -1))\n+    private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+            /*  I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+             */\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 0.7 && yTarget - CurrentY >= -0.7 && xTarget - CurrentX <= 0.8 && xTarget - CurrentX >= -0.8))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+/*                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+  */\n+                telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+                if (camDir == 90) {\n+                    MecanumFunction(1 * (-0.01 * (xTarget - CurrentX)), (-1 * (0.018 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.01 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+                MecanumFunction(0, 0, 0);\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerB = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerC = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        //parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        CurrentHeading = angles.firstAngle;\n+        motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        PIDFCoefficients pidNew = new PIDFCoefficients(NEW_P, NEW_I, NEW_D, NEW_F);\n+        PIDFCoefficients brpidNew = new PIDFCoefficients(20, 15, 0, 0);\n+        motor_drive_flAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_frAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_blAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_brAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            //((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName vuforia = ClassFactory.getInstance().createVuforia(parameters);.class, \"Webcam 1\");\n+    }\n+\n+    private void ringScan() {\n+        QuadRun = 0;\n+        OneRun = 0;\n+        NoneRun = 0;\n+        QuadVote = OneVote = NoneVote = 0;\n+        TimerC = new ElapsedTime();\n+        TimerC.reset();\n+        while (!(isStarted())) {\n+            if (tfod != null) {\n+                // getUpdatedRecognitions() will return null if no new information is available since\n+                // the last time that call was made.\n+                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                if (updatedRecognitions != null) {\n+\n+                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+                    telemetry.addData(\"QuadVotes\", QuadVote);\n+                    telemetry.addData(\"NoneVotes\", NoneVote);\n+                    telemetry.addData(\"OneVotes\", OneVote);\n+                    telemetry.update();\n+                    // step through the list of recognitions and display boundary info.\n+                    int i = 0;\n+                    for (Recognition recognition : updatedRecognitions) {\n+                        if (recognition.getLabel() == \"Quad\") {\n+                            QuadVote += 1;\n+                        } else if (recognition.getLabel() == \"Single\") {\n+                            OneVote += 1;\n+                        } else {\n+                            NoneVote += 1;\n+                        }\n+                        /*\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                                */\n+\n+                    }\n+                    telemetry.update();\n+\n+                }\n+            }\n+\n+        }\n+        if (QuadVote > OneVote && QuadVote > NoneVote) {\n+            QuadRun = 1;\n+        } else if (OneVote > QuadVote && OneVote > NoneVote) {\n+            OneRun = 1;\n+        } else if (OneVote < 4 && QuadVote < 4) {\n+            NoneRun = 1;\n+        }\n+        if (tfod != null) {\n+            tfod.shutdown();\n+\n+        }\n+    }\n+\n+    private void Shoot(double RP, double LP, double Timer, boolean Stop) {\n+        ElapsedTime ShootTimer;\n+        ShootTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        ShootTimer.reset();\n+        while (ShootTimer.seconds() <= Timer) {\n+            LeftLauncher.setPower(LP);\n+            RightLauncher.setPower(RP);\n+            Conveyor.setPower(1);\n+        }\n+\n+        if (Stop == true) {\n+            LeftLauncher.setPower(0);\n+            RightLauncher.setPower(0);\n+        }\n+        Conveyor.setPower(0);\n+\n+    }\n+\n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n+\n+/*\n+Liam:\n+  The maximum power of each motor in the .setPower method is +/- 1.0.  The way MecanumFunction is implemented below\n+  is not 'correct' in that the calculated value could be as much as +/-3.0 which is not correct.  Please figure out an algorithm\n+  that will 'scale' the .setPower value to a maximum of 1.0.  This might mean that you will need to adjust the function input\n+  values so that the resulting setPower value is a maximum of +/-1.0 but keep the inputs keep the same ratio.\n+ */\n+\n+\n+    private void MecanumFunction(double YL, double XL, double XR) {\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n+        }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower(-(-YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((YL - XL - XR));\n+            motor_drive_brAsDcMotor.setPower(-(-YL - XL + XR));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower(-(-mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((mYL - mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower(-(-mYL - (-mXL + mXR)));\n+        }\n+\n+\n+    }\n+\n+    private void IMUTurn(double TrgtAngle) {\n+        double AngleToTurn;\n+\n+        BulkCaching();\n+        AngleToTurn = TrgtAngle - CurrentHeading;\n+        if (AngleToTurn < 0) {\n+            while (TrgtAngle + 6.5 <= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading < -40) {\n+                    MecanumFunction(0, 0, 0.8);\n+                } else if (TrgtAngle - CurrentHeading >= -40) {\n+                    MecanumFunction(0, 0, 0.2);\n+                }\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (TrgtAngle - 6.5 >= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading > 40) {\n+                    MecanumFunction(0, 0, -0.8);\n+                } else if (TrgtAngle - CurrentHeading <= 40) {\n+                    MecanumFunction(0, 0, -0.2);\n+                }\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void AngleAdjustment(double DegreeChange) {\n+        double AngleToTurn;\n+        double CurrentAngularPosition;\n+        BulkCaching();\n+        CurrentAngularPosition = CurrentHeading;\n+        AngleToTurn = DegreeChange - CurrentAngularPosition;\n+        if (AngleToTurn < 0) {\n+            while (CurrentAngularPosition + DegreeChange < CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                MecanumFunction(0, 0, 0.2);\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (CurrentAngularPosition + DegreeChange > CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+\n+                MecanumFunction(0, 0, -0.2);\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void readCurrentHeading() {\n+\n+    }\n+\n+    private void DistanceSmoothTravel(double Distance, double Speed, double MaintainAngle,\n+                                      double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.12 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.08 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void DistanceStrafe(double Distance, double Speed, double MaintainAngle,\n+                                double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"BR\", motor_drive_brAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.06 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"BR\", motor_drive_brAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.6 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+    }\n+\n+    private void GoTo(double XDistance, double YDistance, double Speed, double MaintainAngle, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel, double IMUGain, boolean Reset) {\n+\n+        Accelerate = Math.abs(Yposition) * 0.7;\n+        XAccelerate = Math.abs(Xposition) * 0.989;\n+        Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+        XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6);\n+        ResetTracker();\n+        DistanceTracker();\n+\n+\n+        /*\n+        if (Accel) {\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            Xposition = 0;\n+            Yposition = 0;\n+        }\n+*/\n+        X = 1;\n+        Y = 1;\n+        XD = 1;\n+        YD = 1;\n+        if (!(XDistance == 0)) {\n+\n+            while (Math.abs(Xposition) <= Math.abs(XDistance) || Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                DistanceTracker();\n+\n+                if (Math.abs(Xposition) >= Math.abs(XDistance)) {\n+                    if (Decel) {\n+                        X = 0;\n+                    }\n+                }\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (XDistance < 0) {\n+                    XD = -1;\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && ((Math.abs(Xposition) <= Math.abs((AccelDistance * 0.7071067)) || Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+\n+                    Accelerate = 1;\n+                    XAccelerate = 1;\n+                    if (Math.abs(Xposition) <= 8 || Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                    XAccelerate = Math.abs(Xposition) * 0.7;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        XDecelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                    XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 1);\n+                }\n+                telemetry.addData(\"fart\", (Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate), 0.49), Speed) * X * XD));\n+                //    telemetry.addData(\"fart\", (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate));\n+                telemetry.update();\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4) / Decelerate), 0.025), YSpeed) * Y * YD, Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.7) / XDecelerate), 0.49), Speed) * X * XD, (-MaintainAngle + CurrentHeading) * IMUGain);\n+\n+\n+                YSpeed = Math.abs(Speed * (Math.abs(YDistance) / Math.sqrt(((YDistance * YDistance) + (XDistance * XDistance)))) * Y);\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0);\n+            }\n+\n+        } else if (XDistance == 0) {\n+\n+            while (Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+                DistanceTracker();\n+\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && Math.abs(Yposition) <= Math.abs(AccelDistance)) {\n+\n+                    Accelerate = 1;\n+                    if (Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 18))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 18) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                }\n+\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.1) / Decelerate), 0.025), Speed) * Y * YD, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0);\n+            }\n+\n+\n+        }\n+\n+    }\n+\n+    private void PersonalityStateMachine() {\n+        switch (CurrentState) {\n+            case MOVE_RIGHT:\n+                if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    telemetry.addData(\"strafe and turn right\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_LEFT:\n+                if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    telemetry.addData(\"strafe or turn\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_FORWARD:\n+                if (Yposition > 0) {\n+                    telemetry.addData(\"move forward\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_BACKWARDS:\n+                if (Yposition < 0) {\n+                    telemetry.addData(\"move backwards\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case SHOOT:\n+                if (RightLauncher.getPower() < 0) {\n+                    telemetry.addData(\"shoot\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case INTAKE:\n+                if (intake.getPower() > 0) {\n+                    telemetry.addData(\"intake\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case IDLE:\n+                if ((RightLauncher.getPower() == 0) && (intake.getPower() == 0) && (gamepad1.right_stick_x == 0) && (Yposition == 0) && (gamepad1.left_stick_x == 0)) {\n+                    telemetry.addData(\"idle\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 && gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 && gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (Yposition > 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (Yposition < 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else {\n+                    CurrentState = State.INTAKE;\n+                }\n+                break;\n+\n+        }\n+    }\n+}\n+"
  },
  {
    "sha": "aa8754a63003e2453f62bc7748b43acbd08013cc",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest.java",
    "status": "modified",
    "additions": 181,
    "deletions": 24,
    "changes": 205,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -4,6 +4,7 @@\n import com.qualcomm.hardware.bosch.BNO055IMU;\n import com.qualcomm.hardware.lynx.LynxModule;\n import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.hardware.DcMotor;\n import com.qualcomm.robotcore.hardware.DcMotorEx;\n@@ -25,6 +26,8 @@\n import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n \n import java.util.ArrayList;\n import java.util.List;\n@@ -47,32 +50,41 @@\n  */\n \n @Autonomous(name = \"FunctionTest\", group = \"\")\n-\n+@Disabled\n public class FunctionTest extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+\n     public static final double NEW_P = 30;\n     public static final double NEW_I = 17;\n     public static final double NEW_D = 0;\n     public static final double NEW_F = 0;\n     private static final String VUFORIA_KEY =\n             \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n     private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private TFObjectDetector tfod;\n     private static final float mmTargetHeight = (6) * mmPerInch;\n     private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n     private static final boolean PHONE_IS_PORTRAIT = false;\n     private static final float halfField = 72 * mmPerInch;\n     private static final float quadField = 36 * mmPerInch;\n     private OpenGLMatrix lastLocation = null;\n-    private VuforiaLocalizer vuforia = null;\n     WebcamName webcamName = null;\n     private DcMotorEx motor_drive_flAsDcMotor, motor_drive_blAsDcMotor, motor_drive_brAsDcMotor, motor_drive_frAsDcMotor;\n     private BNO055IMU imu;\n     private VuforiaCurrentGame vuforiaUltimateGoal;\n     Orientation angles;\n     ElapsedTime TimerA;\n+    ElapsedTime TimerC;\n     float CurrentHeading;\n     ElapsedTime TimerB;\n     double CurrentVal;\n     double LastVal;\n+    double QuadRun;\n+    double OneRun;\n+    double NoneRun;\n     double EncoderTicks;\n     double mFr, mFl, mBl, mBr;\n     double CurrentX, CurrentY;\n@@ -97,18 +109,14 @@ public void runOpMode() {\n         motor_drive_frAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_frAsDcMotor\");\n         motor_drive_blAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_blAsDcMotor\");\n         motor_drive_brAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_brAsDcMotor\");\n+\n         PIDFCoefficients pidOrig = motor_drive_flAsDcMotor.getPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n \n         List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n         imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n         Initialization();\n-        webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n-        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n-        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);\n-        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n-        parameters.cameraName = webcamName;\n-        parameters.useExtendedTracking = false;\n-        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+\n+\n         // Activate here for camera preview.\n         telemetry.addData(\">>\", \"Vuforia initialized, press start to continue...\");\n         telemetry.update();\n@@ -165,14 +173,16 @@ public void runOpMode() {\n //                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n                 .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n \n+\n         /**  Let all the trackable listeners know where the phone is.  */\n-        for (VuforiaTrackable trackable : allTrackables) {\n-//            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n-            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n-        }\n+\n         targetVisible = false;\n+\n+        if (tfod != null) {\n+            tfod.activate();\n+        }\n         waitForStart();\n-        targetsUltimateGoal.activate();\n+        //targetsUltimateGoal.activate();\n \n //AngleAdjustment(5);\n //AngleAdjustment(-10);\n@@ -182,9 +192,19 @@ public void runOpMode() {\n         DistanceSmoothTravel(12, .6, 0, 0.1, true, false, 1400);\n         sleep(5000);\n         */\n+        ringScan();\n+        if (QuadRun == 1) {\n+\n+        } else if (OneRun == 1) {\n+\n+        } else if (NoneRun == 1) {\n+            //DistanceSmoothTravel(4, .6, 0, 0.1, true, true, 1400);\n+        }\n+        //  targetsUltimateGoal.activate();\n+        // wallTargetTracking(vuforia, allTrackables, 90, -3, 40, 0, 10, 2, 1, 70000, false, 0);\n \n \n-        wallTargetTracking(vuforia, allTrackables, 90, -3, 40.0, 0, 10, 2, 1, 70000, false, 5);\n+        // wallTargetTracking(vuforia, allTrackables, 90, -3, 40.0, 0, 10, 2, 1, 70000, false, 5);\n     }\n \n \n@@ -311,17 +331,37 @@ else if (TrueTrackSwitch == 0) {\n \n     private void Initialization() {\n         BNO055IMU.Parameters imuParameters;\n+\n         Acceleration gravity;\n         imuParameters = new BNO055IMU.Parameters();\n         TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n         TimerB = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerC = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n         imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n         imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n         imuParameters.loggingEnabled = false;\n         imu.initialize(imuParameters);\n         angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n         gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n         CurrentHeading = angles.firstAngle;\n+\n         motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n         motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n         motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n@@ -344,11 +384,126 @@ private void Initialization() {\n         motor_drive_frAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n         motor_drive_blAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n         motor_drive_brAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, brpidNew);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+    }\n+\n+    private void ringScan() {\n+        QuadRun = 0;\n+        OneRun = 0;\n+        NoneRun = 0;\n+        TimerC = new ElapsedTime();\n+        TimerC.reset();\n+        while ((TimerC.seconds() < 5)) {\n+            if (tfod != null) {\n+                // getUpdatedRecognitions() will return null if no new information is available since\n+                // the last time that call was made.\n+                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                if (updatedRecognitions != null) {\n+\n+                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+                    // step through the list of recognitions and display boundary info.\n+                    int i = 0;\n+                    for (Recognition recognition : updatedRecognitions) {\n+                        if (recognition.getLabel() == \"Quad\") {\n+                            QuadRun = 1;\n+                            break;\n+                        }\n+                        if (recognition.getLabel() == \"Single\") {\n+                            OneRun = 1;\n+                            break;\n+                        }\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                    }\n+                    telemetry.update();\n+\n+                }\n+            }\n+\n+        }\n+        if (tfod != null) {\n+            tfod.shutdown();\n+            if (QuadRun == 0 && OneRun == 0) {\n+                NoneRun = 1;\n+            }\n+\n+        }\n     }\n \n     private void readCurrentHeading() {\n     }\n \n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.8f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n \n /*\n Liam:\n@@ -360,16 +515,18 @@ private void readCurrentHeading() {\n \n \n     private void MecanumFunction(double YL, double XL, double XR) {\n-        flScale = (-YL - (XL - XR));\n-        blScale = (YL - (XL + XR));\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n         frScale = (-YL + XL - XR);\n         brScale = (YL + XL + XR);\n-        if ((-YL - (XL - XR)) > 1 || (-YL - (XL - XR)) < -1) {\n+\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n             flOverload = true;\n         } else {\n             flOverload = false;\n         }\n-        if ((YL - (XL + XR)) > 1 || (YL - (XL + XR)) < -1) {\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n             blOverload = true;\n         } else {\n             blOverload = false;\n@@ -379,7 +536,7 @@ private void MecanumFunction(double YL, double XL, double XR) {\n         } else {\n             frOverload = false;\n         }\n-        if ((YL + (XL + XR)) > 1 || (YL + (XL + XR)) < -1) {\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n             brOverload = true;\n         } else {\n             brOverload = false;\n@@ -405,13 +562,13 @@ private void MecanumFunction(double YL, double XL, double XR) {\n \n         }\n         if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n-            motor_drive_flAsDcMotor.setPower((-YL - (XL - XR)));\n-            motor_drive_blAsDcMotor.setPower((YL - (XL + XR)));\n+            motor_drive_flAsDcMotor.setPower((-YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower((YL - (-XL + XR)));\n             motor_drive_frAsDcMotor.setPower((-YL + XL - XR));\n             motor_drive_brAsDcMotor.setPower((YL + (XL + XR)));\n         } else {\n-            motor_drive_flAsDcMotor.setPower((-mYL - (mXL - mXR)));\n-            motor_drive_blAsDcMotor.setPower((mYL - (mXL + mXR)));\n+            motor_drive_flAsDcMotor.setPower((-mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower((mYL - (-mXL + mXR)));\n             motor_drive_frAsDcMotor.setPower((-mYL + mXL - mXR));\n             motor_drive_brAsDcMotor.setPower((mYL + (mXL + mXR)));\n         }"
  },
  {
    "sha": "431d991aec3bd8ce7cc3e46804332539adf60e1d",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest2.java",
    "status": "added",
    "additions": 938,
    "deletions": 0,
    "changes": 938,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest2.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest2.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest2.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,938 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.PIDFCoefficients;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n+\n+/* TODO\n+- Check to make sure HW reads are being done efficiently.  Don't ask for hardware reads more often than required\n+- Consider adding a smoothing feature in MecanumFunction\n+- Fix the motor names.  THey are very awkward right now\n+- Confirm that WallTracking exits properly\n+- Add camera direction function into WallTracking\n+- Tune motors\n+    -Backright motor not tuned correctly. Wall tracking program bugging out. Not getting to desired location, but does exit the loop when robot is manually guided to Target Position.\n+- Create exact angular adjustment function\n+ */\n+\n+@Autonomous(name = \"FunctionTest2\", group = \"\")\n+@Disabled\n+public class FunctionTest2 extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    private CRServo Conveyor;\n+    public static final double NEW_P = 25;\n+    public static final double NEW_I = 18;\n+    public static final double NEW_D = 0;\n+    public static final double NEW_F = 0;\n+    private DcMotor clarm;\n+    private DcMotor intake;\n+    private Servo claw;\n+    private Servo ramp;\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private TFObjectDetector tfod;\n+    private static final float mmTargetHeight = (6) * mmPerInch;\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+    private OpenGLMatrix lastLocation = null;\n+    WebcamName webcamName = null;\n+    private DcMotorEx motor_drive_flAsDcMotor, motor_drive_blAsDcMotor, motor_drive_brAsDcMotor, motor_drive_frAsDcMotor;\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    Orientation angles;\n+    ElapsedTime TimerA;\n+    ElapsedTime TimerC;\n+    float CurrentHeading;\n+    ElapsedTime TimerB;\n+    double CurrentVal;\n+    double LastVal;\n+    double QuadRun;\n+    double OneRun;\n+    double NoneRun;\n+    double EncoderTicks;\n+    double mFr, mFl, mBl, mBr;\n+    double CurrentX, CurrentY;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale, YLin, XLin, XRin;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n+    double Heading;\n+    double Zrot = 0.0;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double avgEnc;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    private Servo camServo;\n+\n+\n+    @Override\n+    public void runOpMode() {\n+\n+\n+        // vuforiaUltimateGoal = new VuforiaCurrentGame();\n+        motor_drive_flAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_flAsDcMotor\");\n+        motor_drive_frAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_frAsDcMotor\");\n+        motor_drive_blAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_blAsDcMotor\");\n+        motor_drive_brAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_brAsDcMotor\");\n+        RightLauncher = hardwareMap.get(DcMotor.class, \"RightLauncher\");\n+        LeftLauncher = hardwareMap.get(DcMotor.class, \"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        clarm = hardwareMap.get(DcMotor.class, \"clarm\");\n+        claw = hardwareMap.get(Servo.class, \"claw\");\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+        intake = hardwareMap.dcMotor.get(\"intake\");\n+        PIDFCoefficients pidOrig = motor_drive_flAsDcMotor.getPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n+\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+        Initialization();\n+\n+        // Activate here for camera preview.\n+        telemetry.addData(\">>\", \"Vuforia initialized, press start to continue...\");\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 0.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n+\n+        if (tfod != null) {\n+            tfod.activate();\n+        }\n+        waitForStart();\n+\n+        Conveyor.setPower(-0.6);\n+        targetsUltimateGoal.activate();\n+        camServo.setPosition(0.79);\n+        DistanceSmoothTravel(22, .4, 0, 0.025, true, true, 1400);\n+        ramp.setPosition(0.09);\n+        ringScan();\n+        camServo.setPosition(.5);\n+        DistanceSmoothTravel(42, .3, 0, 0.025, true, true, 4000);\n+\n+        AngularAdjustment(0, 0.01);\n+        Shoot(-0.31, 0.745, 1.5, false);\n+        AngularAdjustment(-4, 0.019);\n+        Shoot(-0.31, 0.73, 1.5, false);\n+        AngularAdjustment(-8.5, 0.025);\n+        Shoot(-0.31, 0.733, 1.5, true);\n+        IMUTurn(0);\n+\n+        clarm.setTargetPosition(700);\n+        clarm.setPower(0.6);\n+\n+        if (QuadRun == 1) {\n+            DistanceSmoothTravel(38, .6, 33, 0.025, true, true, 1400);\n+            IMUTurn(90);\n+            DistanceSmoothTravel(15, .4, 90, 0.025, true, true, 1400);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.15);\n+            sleep(250);\n+            claw.setPosition(0.35);\n+            sleep(400);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.6);\n+            sleep(200);\n+            IMUTurn(13);\n+            DistanceSmoothTravel(-22, .7, 13, 0.025, true, true, 1400);\n+            wallTargetTracking(vuforia, allTrackables, 90, 0, 58, 0, 10, 2, 1, 3, false, 0);\n+            DistanceSmoothTravel(-18, .5, 0, 0.025, true, true, 2800);\n+            IMUTurn(-64);\n+            clarm.setTargetPosition(950);\n+            clarm.setPower(0.5);\n+            sleep(750);\n+            claw.setPosition(0.03);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.7);\n+            IMUTurn(0);\n+            DistanceSmoothTravel(54, 0.7, 0, 0.025, true, true, 1400);\n+            IMUTurn(90);\n+            DistanceSmoothTravel(14, .4, 90, 0.025, true, true, 1400);\n+            IMUTurn(120);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.15);\n+            sleep(300);\n+            claw.setPosition(0.35);\n+            sleep(300);\n+            clarm.setTargetPosition(-5);\n+            clarm.setPower(-0.6);\n+            sleep(400);\n+            IMUTurn(0);\n+            DistanceSmoothTravel(-19, .7, 0, 0.025, true, true, 1400);\n+            MecanumFunction(0, 0, 0);\n+\n+\n+        } else if (OneRun == 1) {\n+            DistanceSmoothTravel(8, .4, 12.5, 0.025, true, true, 1400);\n+            IMUTurn(90);\n+            DistanceSmoothTravel(13, .4, 90, 0.025, true, true, 1400);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.15);\n+            sleep(500);\n+            claw.setPosition(0.35);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.6);\n+            sleep(750);\n+            DistanceSmoothTravel(3, .4, 90, 0.025, true, true, 1400);\n+            IMUTurn(-5);\n+            DistanceSmoothTravel(-4, .4, -5, 0.025, true, true, 1400);\n+            wallTargetTracking(vuforia, allTrackables, 90, 0, 58, 0, 10, 2, 1, 3, false, 0);\n+            DistanceSmoothTravel(-17.7, .4, 0, 0.025, true, true, 1400);\n+            IMUTurn(-68);\n+            clarm.setTargetPosition(950);\n+            clarm.setPower(0.5);\n+            sleep(400);\n+            claw.setPosition(0.03);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.7);\n+            IMUTurn(0);\n+            DistanceSmoothTravel(60, .4, 7, 0.025, true, true, 1400);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.7);\n+            sleep(1000);\n+            claw.setPosition(0.35);\n+            sleep(900);\n+            clarm.setTargetPosition(-5);\n+            clarm.setPower(-0.7);\n+            sleep(1000);\n+            DistanceSmoothTravel(-16, .4, 0, 0.025, true, true, 1400);\n+\n+\n+        } else if (NoneRun == 1) {\n+            IMUTurn(0);\n+            DistanceSmoothTravel(-6, .4, 0, 0.025, true, true, 1400);\n+            sleep(200);\n+            IMUTurn(90);\n+            DistanceSmoothTravel(36, .4, 90, 0.025, true, true, 1400);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.15);\n+            sleep(500);\n+            claw.setPosition(0.35);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.63);\n+            sleep(500);\n+            camServo.setPosition(0.6);\n+            DistanceSmoothTravel(-6, .4, 90, 0.025, true, true, 1400);\n+            IMUTurn(-5);\n+            DistanceSmoothTravel(2, .4, -5, 0.025, true, true, 1400);\n+            wallTargetTracking(vuforia, allTrackables, 90, -8.4, 60, 0, 10, 2, 1, 3, false, 0);\n+            camServo.setPosition(0.5);\n+            DistanceSmoothTravel(-8.25, .4, 0, 0.025, true, true, 1400);\n+            IMUTurn(-55.5);\n+            clarm.setTargetPosition(1000);\n+            clarm.setPower(0.5);\n+            sleep(400);\n+            claw.setPosition(0.03);\n+            sleep(500);\n+            clarm.setTargetPosition(450);\n+            clarm.setPower(-0.7);\n+            IMUTurn(0);\n+            DistanceSmoothTravel(10, .4, 0, 0.025, true, true, 1400);\n+            IMUTurn(90);\n+            DistanceSmoothTravel(10, .4, 90, 0.025, true, true, 1400);\n+            clarm.setTargetPosition(850);\n+            clarm.setPower(0.15);\n+            sleep(300);\n+            claw.setPosition(0.35);\n+            sleep(300);\n+            clarm.setTargetPosition(-5);\n+            clarm.setPower(-0.6);\n+            sleep(600);\n+            DistanceSmoothTravel(-26, .4, 90, 0.025, true, true, 1400);\n+            IMUTurn(0);\n+            DistanceSmoothTravel(18, .4, 0, 0.025, true, true, 1400);\n+\n+\n+            //DistanceSmoothTravel(4, .6, 0, 0.1, true, true, 1400);\n+        }\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(0.4);\n+        sleep(1500);\n+        //  targetsUltimateGoal.activate();\n+\n+\n+        // wallTargetTracking(vuforia, allTrackables, 90, -3, 40.0, 0, 10, 2, 1, 70000, false, 5);\n+    }\n+\n+    private void AngularAdjustment(double targetangle, double IMUgain) {\n+        while ((!((-targetangle + CurrentHeading) <= 0.25 && (-targetangle + CurrentHeading) >= -0.25))) {\n+            BulkCaching();\n+            MecanumFunction(0, 0, IMUgain * (-targetangle + CurrentHeading));\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    //   while (!(40 - CurrentY <= 1 && 40 - CurrentY >= -1 && -3 - CurrentX <= 1 && -3 - CurrentX >= -1 && (180 - (180 + Zrot)) >= 1 && (180 - (180 + Zrot)) <= -1))\n+    private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+            /*  I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+             */\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 1 && yTarget - CurrentY >= -1 && xTarget - CurrentX <= 1 && xTarget - CurrentX >= -1))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+/*                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+  */\n+                telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+                if (camDir == 90) {\n+                    MecanumFunction(1 * (-0.01 * (xTarget - CurrentX)), (-1 * (0.018 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.01 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+                MecanumFunction(0, 0, 0);\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerB = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerC = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        intake.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        CurrentHeading = angles.firstAngle;\n+        motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_flAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        PIDFCoefficients pidNew = new PIDFCoefficients(NEW_P, NEW_I, NEW_D, NEW_F);\n+        PIDFCoefficients brpidNew = new PIDFCoefficients(35, 25, 0, 0);\n+        motor_drive_flAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_frAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_blAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_brAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName vuforia = ClassFactory.getInstance().createVuforia(parameters);.class, \"Webcam 1\");\n+    }\n+\n+    private void ringScan() {\n+        QuadRun = 0;\n+        OneRun = 0;\n+        NoneRun = 0;\n+        TimerC = new ElapsedTime();\n+        TimerC.reset();\n+        while ((TimerC.seconds() < 1)) {\n+            if (tfod != null) {\n+                // getUpdatedRecognitions() will return null if no new information is available since\n+                // the last time that call was made.\n+                tfod.setZoom(2.5, 1.78);\n+                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                if (updatedRecognitions != null) {\n+\n+                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+                    // step through the list of recognitions and display boundary info.\n+                    int i = 0;\n+                    for (Recognition recognition : updatedRecognitions) {\n+                        if (recognition.getLabel() == \"Quad\") {\n+                            QuadRun = 1;\n+                            break;\n+                        }\n+                        if (recognition.getLabel() == \"Single\") {\n+                            OneRun = 1;\n+                            break;\n+                        }\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                    }\n+                    telemetry.update();\n+\n+                }\n+            }\n+\n+        }\n+        if (tfod != null) {\n+            tfod.shutdown();\n+            if (QuadRun == 0 && OneRun == 0) {\n+                NoneRun = 1;\n+            }\n+\n+        }\n+    }\n+\n+    private void Shoot(double RP, double LP, double Timer, boolean Stop) {\n+        ElapsedTime ShootTimer;\n+        ShootTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        ShootTimer.reset();\n+        while (ShootTimer.seconds() <= Timer) {\n+            LeftLauncher.setPower(LP);\n+            RightLauncher.setPower(RP);\n+            Conveyor.setPower(1);\n+        }\n+        if (Stop == true) {\n+            LeftLauncher.setPower(0);\n+            RightLauncher.setPower(0);\n+        }\n+        Conveyor.setPower(0);\n+\n+    }\n+\n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.8f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n+\n+/*\n+Liam:\n+  The maximum power of each motor in the .setPower method is +/- 1.0.  The way MecanumFunction is implemented below\n+  is not 'correct' in that the calculated value could be as much as +/-3.0 which is not correct.  Please figure out an algorithm\n+  that will 'scale' the .setPower value to a maximum of 1.0.  This might mean that you will need to adjust the function input\n+  values so that the resulting setPower value is a maximum of +/-1.0 but keep the inputs keep the same ratio.\n+ */\n+\n+\n+    private void MecanumFunction(double YL, double XL, double XR) {\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n+        }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((-YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower((YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((-YL + XL - XR));\n+            motor_drive_brAsDcMotor.setPower((YL + (XL + XR)));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((-mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower((mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((-mYL + mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower((mYL + (mXL + mXR)));\n+        }\n+\n+\n+    }\n+\n+    private void IMUTurn(double TrgtAngle) {\n+        double AngleToTurn;\n+\n+        BulkCaching();\n+        AngleToTurn = TrgtAngle - CurrentHeading;\n+        if (AngleToTurn < 0) {\n+            while (TrgtAngle + 6.5 <= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading < -40) {\n+                    MecanumFunction(0, 0, 0.8);\n+                } else if (TrgtAngle - CurrentHeading >= -40) {\n+                    MecanumFunction(0, 0, 0.2);\n+                }\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (TrgtAngle - 6.5 >= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading > 40) {\n+                    MecanumFunction(0, 0, -0.8);\n+                } else if (TrgtAngle - CurrentHeading <= 40) {\n+                    MecanumFunction(0, 0, -0.2);\n+                }\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void AngleAdjustment(double DegreeChange) {\n+        double AngleToTurn;\n+        double CurrentAngularPosition;\n+        BulkCaching();\n+        CurrentAngularPosition = CurrentHeading;\n+        AngleToTurn = DegreeChange - CurrentAngularPosition;\n+        if (AngleToTurn < 0) {\n+            while (CurrentAngularPosition + DegreeChange < CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                MecanumFunction(0, 0, 0.2);\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (CurrentAngularPosition + DegreeChange > CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+\n+                MecanumFunction(0, 0, -0.2);\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void readCurrentHeading() {\n+\n+    }\n+\n+    /*private void RingPickUp (double ringNumber, double timer) {\n+        if intake.setVelocity\n+    }*/\n+\n+    private void DistanceSmoothTravel(double Distance, double Speed, double MaintainAngle,\n+                                      double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.1 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.1 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+    }\n+}\n+"
  },
  {
    "sha": "202bf157e41d48a8bb3eaa8c2ad29379269383dd",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest3.java",
    "status": "added",
    "additions": 794,
    "deletions": 0,
    "changes": 794,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest3.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest3.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTest3.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,794 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.PIDFCoefficients;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n+\n+/* TODO\n+- Check to make sure HW reads are being done efficiently.  Don't ask for hardware reads more often than required\n+- Consider adding a smoothing feature in MecanumFunction\n+- Fix the motor names.  THey are very awkward right now\n+- Confirm that WallTracking exits properly\n+- Add camera direction function into WallTracking\n+- Tune motors\n+    -Backright motor not tuned correctly. Wall tracking program bugging out. Not getting to desired location, but does exit the loop when robot is manually guided to Target Position.\n+- Create exact angular adjustment function\n+ */\n+\n+@Autonomous(name = \"FunctionTest3\", group = \"\")\n+@Disabled\n+public class FunctionTest3 extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    private CRServo Conveyor;\n+    public static final double NEW_P = 25;\n+    public static final double NEW_I = 18;\n+    public static final double NEW_D = 0;\n+    public static final double NEW_F = 0;\n+    private DcMotor clarm;\n+    private Servo claw;\n+    private Servo ramp;\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private TFObjectDetector tfod;\n+    private static final float mmTargetHeight = (6) * mmPerInch;\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+    private OpenGLMatrix lastLocation = null;\n+    WebcamName webcamName = null;\n+    private DcMotorEx motor_drive_flAsDcMotor, motor_drive_blAsDcMotor, motor_drive_brAsDcMotor, motor_drive_frAsDcMotor;\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    Orientation angles;\n+    ElapsedTime TimerA;\n+    ElapsedTime TimerC;\n+    float CurrentHeading;\n+    ElapsedTime TimerB;\n+    double CurrentVal;\n+    double LastVal;\n+    double QuadRun;\n+    double OneRun;\n+    double NoneRun;\n+    double EncoderTicks;\n+    double mFr, mFl, mBl, mBr;\n+    double CurrentX, CurrentY;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale, YLin, XLin, XRin;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n+    double Heading;\n+    double Zrot = 0.0;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double avgEnc;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    private Servo camServo;\n+\n+    @Override\n+    public void runOpMode() {\n+\n+\n+        // vuforiaUltimateGoal = new VuforiaCurrentGame();\n+        motor_drive_flAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_flAsDcMotor\");\n+        motor_drive_frAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_frAsDcMotor\");\n+        motor_drive_blAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_blAsDcMotor\");\n+        motor_drive_brAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_brAsDcMotor\");\n+        RightLauncher = hardwareMap.get(DcMotor.class, \"RightLauncher\");\n+        LeftLauncher = hardwareMap.get(DcMotor.class, \"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        clarm = hardwareMap.get(DcMotor.class, \"clarm\");\n+        claw = hardwareMap.get(Servo.class, \"claw\");\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+        PIDFCoefficients pidOrig = motor_drive_flAsDcMotor.getPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n+\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+        Initialization();\n+\n+        // Activate here for camera preview.\n+        telemetry.addData(\">>\", \"Vuforia initialized, press start to continue...\");\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 0.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n+\n+        if (tfod != null) {\n+            tfod.activate();\n+        }\n+        waitForStart();\n+\n+        Conveyor.setPower(-0.25);\n+        targetsUltimateGoal.activate();\n+        camServo.setPosition(0.79);\n+        DistanceSmoothTravel(22, .4, 0, 0.025, true, true, 1400);\n+        ramp.setPosition(0.09);\n+        ringScan();\n+        camServo.setPosition(.5);\n+        DistanceSmoothTravel(42, .3, 0, 0.025, true, true, 4000);\n+\n+        AngularAdjustment(.8, 0.01);\n+        Shoot(-0.315, 0.737, 1.5, false);\n+        AngularAdjustment(-4, 0.02);\n+        Shoot(-0.315, 0.737, 1.5, false);\n+        AngularAdjustment(-8.5, 0.03);\n+        Shoot(-0.315, 0.737, 1.5, true);\n+        // wallTargetTracking(vuforia, allTrackables, 90, -3, 40.0, 0, 10, 2, 1, 70000, false, 5);\n+    }\n+\n+\n+    private void AngularAdjustment(double targetangle, double IMUgain) {\n+        while ((!((-targetangle + CurrentHeading) <= 0.5 && (-targetangle + CurrentHeading) >= -0.5))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            MecanumFunction(0, 0, IMUgain * (-targetangle + CurrentHeading));\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    //   while (!(40 - CurrentY <= 1 && 40 - CurrentY >= -1 && -3 - CurrentX <= 1 && -3 - CurrentX >= -1 && (180 - (180 + Zrot)) >= 1 && (180 - (180 + Zrot)) <= -1))\n+    private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+            /*  I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+             */\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 1 && yTarget - CurrentY >= -1 && xTarget - CurrentX <= 1 && xTarget - CurrentX >= -1))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+/*                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+  */\n+                telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+                if (camDir == 90) {\n+                    MecanumFunction(1 * (-0.01 * (xTarget - CurrentX)), (-1 * (0.018 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.01 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+                MecanumFunction(0, 0, 0);\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerB = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerC = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        CurrentHeading = angles.firstAngle;\n+        motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_flAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        PIDFCoefficients pidNew = new PIDFCoefficients(NEW_P, NEW_I, NEW_D, NEW_F);\n+        PIDFCoefficients brpidNew = new PIDFCoefficients(35, 25, 0, 0);\n+        motor_drive_flAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_frAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_blAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_brAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName vuforia = ClassFactory.getInstance().createVuforia(parameters);.class, \"Webcam 1\");\n+    }\n+\n+    private void ringScan() {\n+        QuadRun = 0;\n+        OneRun = 0;\n+        NoneRun = 0;\n+        TimerC = new ElapsedTime();\n+        TimerC.reset();\n+        while ((TimerC.seconds() < 1)) {\n+            if (tfod != null) {\n+                // getUpdatedRecognitions() will return null if no new information is available since\n+                // the last time that call was made.\n+                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                if (updatedRecognitions != null) {\n+\n+                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+                    // step through the list of recognitions and display boundary info.\n+                    int i = 0;\n+                    for (Recognition recognition : updatedRecognitions) {\n+                        if (recognition.getLabel() == \"Quad\") {\n+                            QuadRun = 1;\n+                            break;\n+                        }\n+                        if (recognition.getLabel() == \"Single\") {\n+                            OneRun = 1;\n+                            break;\n+                        }\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                    }\n+                    telemetry.update();\n+\n+                }\n+            }\n+\n+        }\n+        if (tfod != null) {\n+            tfod.shutdown();\n+            if (QuadRun == 0 && OneRun == 0) {\n+                NoneRun = 1;\n+            }\n+\n+        }\n+    }\n+\n+    private void Shoot(double RP, double LP, double Timer, boolean Stop) {\n+        ElapsedTime ShootTimer;\n+        ShootTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        ShootTimer.reset();\n+        while (ShootTimer.seconds() <= Timer) {\n+            LeftLauncher.setPower(LP);\n+            RightLauncher.setPower(RP);\n+            Conveyor.setPower(1);\n+        }\n+        if (Stop == true) {\n+            LeftLauncher.setPower(0);\n+            RightLauncher.setPower(0);\n+        }\n+        Conveyor.setPower(0);\n+\n+    }\n+\n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.8f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n+\n+/*\n+Liam:\n+  The maximum power of each motor in the .setPower method is +/- 1.0.  The way MecanumFunction is implemented below\n+  is not 'correct' in that the calculated value could be as much as +/-3.0 which is not correct.  Please figure out an algorithm\n+  that will 'scale' the .setPower value to a maximum of 1.0.  This might mean that you will need to adjust the function input\n+  values so that the resulting setPower value is a maximum of +/-1.0 but keep the inputs keep the same ratio.\n+ */\n+\n+\n+    private void MecanumFunction(double YL, double XL, double XR) {\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n+        }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((-YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower((YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((-YL + XL - XR));\n+            motor_drive_brAsDcMotor.setPower((YL + (XL + XR)));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((-mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower((mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((-mYL + mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower((mYL + (mXL + mXR)));\n+        }\n+\n+\n+    }\n+\n+    private void IMUTurn(double TrgtAngle) {\n+        double AngleToTurn;\n+\n+        BulkCaching();\n+        AngleToTurn = TrgtAngle - CurrentHeading;\n+        if (AngleToTurn < 0) {\n+            while (TrgtAngle + 6.5 <= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading < -40) {\n+                    MecanumFunction(0, 0, 0.8);\n+                } else if (TrgtAngle - CurrentHeading >= -40) {\n+                    MecanumFunction(0, 0, 0.2);\n+                }\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (TrgtAngle - 6.5 >= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading > 40) {\n+                    MecanumFunction(0, 0, -0.8);\n+                } else if (TrgtAngle - CurrentHeading <= 40) {\n+                    MecanumFunction(0, 0, -0.2);\n+                }\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void AngleAdjustment(double DegreeChange) {\n+        double AngleToTurn;\n+        double CurrentAngularPosition;\n+        BulkCaching();\n+        CurrentAngularPosition = CurrentHeading;\n+        AngleToTurn = DegreeChange - CurrentAngularPosition;\n+        if (AngleToTurn < 0) {\n+            while (CurrentAngularPosition + DegreeChange < CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                MecanumFunction(0, 0, 0.2);\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (CurrentAngularPosition + DegreeChange > CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+\n+                MecanumFunction(0, 0, -0.2);\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void readCurrentHeading() {\n+\n+    }\n+\n+    private void DistanceSmoothTravel(double Distance, double Speed, double MaintainAngle,\n+                                      double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.1 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.1 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+    }\n+}\n+"
  },
  {
    "sha": "6737e0c2e51f4deccd6322c0ecc926e0833e3c73",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTestCoach.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTestCoach.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTestCoach.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FunctionTestCoach.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -3,6 +3,7 @@\n import com.qualcomm.hardware.bosch.BNO055IMU;\n import com.qualcomm.hardware.lynx.LynxModule;\n import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.hardware.DcMotor;\n import com.qualcomm.robotcore.hardware.DcMotorEx;\n@@ -33,7 +34,7 @@\n import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n \n @Autonomous(name = \"FunctionTestCoach\", group = \"\")\n-\n+@Disabled\n public class FunctionTestCoach extends LinearOpMode {\n \n     private static final String VUFORIA_KEY ="
  },
  {
    "sha": "cb74326a266f75cdeac98791f8dab95e02fa80ce",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleop.java",
    "status": "added",
    "additions": 1028,
    "deletions": 0,
    "changes": 1028,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleop.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleop.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MainTeleop.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,1028 @@\n+/*to do list\n+- convert dc motor to dc motor ex\n+*/\n+\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.robotcore.hardware.Blinker;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n+\n+@TeleOp(name = \"MAINteleop\", group = \"\")\n+\n+public class MainTeleop extends LinearOpMode {\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private static final float mmTargetHeight = (6) * mmPerInch;          // the height of the center of the target image above the floor\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    // Constants for perimeter targets\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+    // WebcamName webcamName = null;\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    // Class Members\n+    private OpenGLMatrix lastLocation = null;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n+    private Blinker expansion_Hub_1;\n+    private DcMotor motor_drive_flAsDcMotor;\n+    private DcMotor motor_drive_frAsDcMotor;\n+    private DcMotor motor_drive_blAsDcMotor;\n+    private DcMotor motor_drive_brAsDcMotor;\n+    private DcMotor clarm;\n+    private Servo claw;\n+    private CRServo Conveyor;\n+    private Servo ramp;\n+    double Xposition;\n+    double Yposition;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double Accelerate, Decelerate, XAccelerate, XDecelerate;\n+    double CurrentVal;\n+    double YSpeed;\n+    double lsPower, rsPower;\n+    double LastVal;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale;\n+    double CurrentX, CurrentY;\n+    double mFr, mFl, mBl, mBr;\n+    double YPositionReset, XPositionReset, XPositionP, YPositionP;\n+    double ClawVariable;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    Orientation angles;\n+    boolean gamepadaAfter = false;\n+    boolean gamepada2After = false;\n+    boolean gamepad2lbafter = false;\n+    boolean gamepadbAfter = false;\n+    boolean lastGamepadX = false;\n+    boolean lastGamepadY = false;\n+    double lastClarm;\n+    double X, Y, XD, YD;\n+    private DcMotor intake;\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    boolean lastDPadUp = false;\n+    boolean lastDPadDown = false;\n+    double gamepadxpolar;\n+    boolean lastDPadRight = false;\n+    boolean LastDPadUp2 = false, LastDpadDown2 = false;\n+    boolean lastDPadLeft = false;\n+    boolean lastBumper = false;\n+    float CurrentHeading;\n+    double clarmvariable;\n+    private Servo camServo;\n+    double LastValue = 0.0;\n+    double PosDiffValue;\n+    double NegDiffValue;\n+    double FinalAngle = 0.0;\n+    double MaintainAngle = 0;\n+    ElapsedTime TimerA;\n+    private enum State {\n+        MOVE_RIGHT,\n+        MOVE_LEFT,\n+        MOVE_FORWARD,\n+        MOVE_BACKWARDS,\n+        SHOOT,\n+        INTAKE,\n+        IDLE,\n+    }\n+    private State CurrentState;\n+\n+\n+    @Override\n+    public void runOpMode() {\n+        motor_drive_flAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_flAsDcMotor\");\n+        motor_drive_frAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_frAsDcMotor\");\n+        motor_drive_blAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_blAsDcMotor\");\n+        motor_drive_brAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_brAsDcMotor\");\n+        clarm = hardwareMap.dcMotor.get(\"clarm\");\n+        clarm.setDirection(DcMotor.Direction.FORWARD);\n+        intake = hardwareMap.dcMotor.get(\"intake\");\n+        RightLauncher = hardwareMap.dcMotor.get(\"RightLauncher\");\n+        LeftLauncher = hardwareMap.dcMotor.get(\"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+\n+        //start of homing for clarm\n+        lastClarm = clarm.getCurrentPosition();\n+        clarm.setPower(-0.4);\n+        sleep(200);\n+        while (lastClarm != clarm.getCurrentPosition()) {\n+            lastClarm = clarm.getCurrentPosition();\n+            sleep(100);\n+        }\n+        clarm.setPower(0);\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        clarm.setPower(0);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        //end of homing for clarm\n+\n+        Initialization();\n+\n+\n+        ramp.setPosition(0.6);\n+        claw = hardwareMap.servo.get(\"claw\");\n+        motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        intake.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 0.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n+\n+        // WARNING:\n+        // In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.\n+        // This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.\n+        // CONSEQUENTLY do not put any driving commands in this loop.\n+        // To restore the normal opmode structure, just un-comment the following line:\n+        ClawVariable = 1;\n+        clarmvariable = 0;\n+\n+        CurrentState = State.IDLE;\n+\n+        waitForStart();\n+\n+\n+        //Set this to ZERO if you want to disable testing mode ^^^^^\n+        clarmvariable = 1;\n+        //targetsUltimateGoal.activate();\n+        //camServo.setPosition(.5);\n+        while (opModeIsActive()) {\n+            PersonalityStateMachine();\n+            ContinuedIMU();\n+            if (gamepad1.left_stick_x < 0) {\n+                gamepadxpolar = -1;\n+            } else if (gamepad1.left_stick_x >= 0) {\n+                gamepadxpolar = 1;\n+            }\n+            MecanumFunction(gamepad1.left_stick_y, gamepad1.left_stick_x, gamepad1.right_stick_x, FinalAngle);\n+            /*motor_drive_flAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);\n+            motor_drive_blAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_frAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_brAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);*/\n+            CurrentX = 0;\n+            CurrentY = 0;\n+            /*\n+            if (gamepad1.a && !gamepada2After) {\n+                wallTargetTracking(vuforia, allTrackables, 90, -2.5, 41.8, 0, 10, 2, 1, 3, false, 0);\n+            }\n+            */\n+\n+            LastDpadDown2 = gamepad1.dpad_down;\n+            if (gamepad2.b && !gamepadbAfter) {\n+                ClawVariable = ClawVariable * -1;\n+            }\n+                /*if (ClawVariable > 0) {\n+                    claw.setPosition(0);\n+                } else if (ClawVariable < 0) {\n+                    claw.setPosition(1);\n+                }*/\n+\n+            gamepadaAfter = gamepad2.a;\n+            gamepadbAfter = gamepad2.b;\n+            gamepada2After = gamepad1.a;\n+\n+\n+            if (gamepad2.dpad_up && !lastDPadUp) {\n+                ramp.setPosition(0.0);\n+\n+                RightLauncher.setPower(-0.37);\n+                LeftLauncher.setPower(0.79);\n+\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+            if (gamepad2.left_bumper && !gamepad2lbafter) {\n+                ramp.setPosition(0);\n+\n+                RightLauncher.setPower(-0.31);\n+                LeftLauncher.setPower(0.745);\n+\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+\n+            }\n+            gamepad2.left_bumper = gamepad2lbafter;\n+            if (gamepad2.dpad_down && !lastDPadDown) {\n+                ramp.setPosition(0.6);\n+                RightLauncher.setPower(0);\n+                LeftLauncher.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+            lastDPadUp = gamepad2.dpad_up;\n+            lastDPadDown = gamepad2.dpad_down;\n+\n+\n+            //  lastDPadRight = gamepad2.dpad_right;\n+            //taking in rings\n+            if (gamepad2.dpad_right) {//&& !lastDPadRight) {\n+                intake.setPower(-1);\n+                Conveyor.setPower(-1);\n+                //spitting out rings\n+            } else if (gamepad2.dpad_left) {//&& !lastDPadLeft) {\n+                intake.setPower(0.8);\n+                Conveyor.setPower(0.8);\n+            } else {\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+\n+\n+            //  lastDPadLeft = gamepad2.dpad_left;\n+\n+            if ((!gamepad2.dpad_right) && (!gamepad2.dpad_left)) {\n+                intake.setPower(0);\n+                if (ramp.getPosition() > 0.3) { // Check here to make sure we don't step on the other Conveyor.setPower commands below\n+                    Conveyor.setPower(0);\n+                }\n+            }\n+\n+\n+            if (gamepad2.right_bumper && !lastBumper) {\n+                clarmvariable = -clarmvariable;\n+                if (clarmvariable > 0) {\n+                    clarm.setTargetPosition(990);\n+                    clarm.setPower(0.4);\n+                }\n+                if (clarmvariable < 0) {\n+                    clarm.setTargetPosition(400);\n+                    clarm.setPower(0.4);\n+                }\n+            }\n+\n+            lastBumper = gamepad2.right_bumper;\n+\n+\n+        }\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        telemetry.addData(\"IMU\", CurrentHeading);\n+        telemetry.addData(\"LeftShooterPower\", LeftLauncher.getPower());\n+        telemetry.addData(\"RightShooterPower\", RightLauncher.getPower());\n+        telemetry.update();\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        //parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        CurrentHeading = angles.firstAngle;\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+      /*  VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+    }\n+*/\n+    }\n+\n+    private void PowerShot() {\n+        GoTo(0, 20, .3, 0, 14, 0, true, true, 0.012, true);\n+        AngularAdjustment(0, 0.28);\n+    }\n+\n+    private void AngularAdjustment(double targetangle, double IMUgain) {\n+        ElapsedTime TimerD = new ElapsedTime();\n+        TimerD.reset();\n+        while ((TimerD.milliseconds() < 350)) {\n+\n+            // ANDREW: Consider the use of BulkCaching here since it is expensive to read all the motor positions if all you need is the imu angle\n+            BulkCaching();\n+            if (((-targetangle + CurrentHeading) >= 0.07 && (-targetangle + CurrentHeading) <= -0.07)) {\n+                TimerD.reset();\n+            }\n+            MecanumFunction(0, 0, IMUgain * (-targetangle + CurrentHeading), 0);\n+        }\n+        MecanumFunction(0, 0, 0, 0);\n+    }\n+\n+    private void Shoot(double RP, double LP, double Timer, boolean Stop) {\n+        ElapsedTime ShootTimer;\n+        ShootTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        ShootTimer.reset();\n+        while (ShootTimer.seconds() <= Timer) {\n+            LeftLauncher.setPower(LP);\n+            RightLauncher.setPower(RP);\n+            Conveyor.setPower(1);\n+        }\n+\n+        if (Stop == true) {\n+            LeftLauncher.setPower(0);\n+            RightLauncher.setPower(0);\n+        }\n+        Conveyor.setPower(0);\n+\n+    }\n+\n+    private void ContinuedIMU() {\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        if ((LastValue - angles.firstAngle) > 180) {\n+            PosDiffValue = 360 - (LastValue - angles.firstAngle);\n+            FinalAngle += PosDiffValue;\n+        } else if ((LastValue - angles.firstAngle) < -180) {\n+            NegDiffValue = 360 + (LastValue - angles.firstAngle);\n+            FinalAngle -= NegDiffValue;\n+        } else {\n+            FinalAngle += LastValue - angles.firstAngle;\n+        }\n+        LastValue = angles.firstAngle;\n+        telemetry.addData(\"FinalAngle\", FinalAngle);\n+        telemetry.addData(\"LastValue\", LastValue);\n+        telemetry.addData(\"CurrentValue\", angles.firstAngle);\n+        telemetry.update();\n+    }\n+\n+    private void DistanceTracker() {\n+        if (Yposition < 0) {\n+            YPositionP = -1;\n+        } else {\n+            YPositionP = 1;\n+        }\n+        if (Xposition < 0) {\n+            XPositionP = -1;\n+        } else {\n+            XPositionP = 1;\n+        }\n+        Yposition = (((((motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) * 0.25) * 0.00208333333) * 15.75) - YPositionReset);//((((motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 4) / 480) * 12.566);\n+        Xposition = ((((motor_drive_flAsDcMotor.getCurrentPosition() - motor_drive_blAsDcMotor.getCurrentPosition()) * 0.00208333333) * 11.5 * .5) - (XPositionReset));\n+\n+    }\n+\n+    private void ResetTracker() {\n+        XPositionReset = Xposition;\n+        YPositionReset = Yposition;\n+    }\n+\n+    private void GoTo(double XDistance, double YDistance, double Speed, double MaintainAngle,\n+                      double AccelDistance, double DecelDistance, boolean Accel, boolean Decel, double IMUGain,\n+                      boolean Reset) {\n+\n+        Accelerate = Math.abs(Yposition) * 0.7;\n+        XAccelerate = Math.abs(Xposition) * 0.989;\n+        Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+        XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6);\n+        ResetTracker();\n+        DistanceTracker();\n+\n+\n+        /*\n+        if (Accel) {\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            Xposition = 0;\n+            Yposition = 0;\n+        }\n+*/\n+        X = 1;\n+        Y = 1;\n+        XD = 1;\n+        YD = 1;\n+        if (!(XDistance == 0)) {\n+\n+            while (Math.abs(Xposition) <= Math.abs(XDistance) || Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                DistanceTracker();\n+\n+                if (Math.abs(Xposition) >= Math.abs(XDistance)) {\n+                    if (Decel) {\n+                        X = 0;\n+                    }\n+                }\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (XDistance < 0) {\n+                    XD = -1;\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && ((Math.abs(Xposition) <= Math.abs((AccelDistance * 0.7071067)) || Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+\n+                    Accelerate = 1;\n+                    XAccelerate = 1;\n+                    if (Math.abs(Xposition) <= 8 || Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                    XAccelerate = Math.abs(Xposition) * 0.7;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        XDecelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                    XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 1);\n+                }\n+                telemetry.addData(\"fart\", (Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate), 0.49), Speed) * X * XD));\n+                //    telemetry.addData(\"fart\", (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate));\n+                telemetry.update();\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4) / Decelerate), 0.05), YSpeed) * Y * YD, Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.7) / XDecelerate), 0.49), Speed) * X * XD, (-MaintainAngle + CurrentHeading) * IMUGain, 0);\n+\n+\n+                YSpeed = Math.abs(Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y);\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0, 0);\n+            }\n+\n+        } else if (XDistance == 0) {\n+\n+            while (Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+                DistanceTracker();\n+\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && Math.abs(Yposition) <= Math.abs(AccelDistance)) {\n+\n+                    Accelerate = 1;\n+                    if (Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 13))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 13) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                }\n+\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4) / Decelerate), 0.05), Speed) * Y * YD, 0, (-MaintainAngle + CurrentHeading) * IMUGain, 0);\n+\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0, 0);\n+            }\n+\n+\n+        }\n+    }\n+\n+\n+    private void MecanumFunction(double YL, double XL, double XR, double ContinuosIMU) {\n+        double Correction;\n+        double NXL;\n+        double NYL;\n+        double NXR = 0;\n+        double IMUGain = -0.025;\n+\n+        if (gamepad1.right_stick_x != 0) {\n+            MaintainAngle = ContinuosIMU;\n+            TimerA.reset();\n+        }\n+        if (TimerA.seconds() >= .2) {\n+            NXR = (ContinuosIMU - MaintainAngle) * IMUGain;\n+        } else {\n+            MaintainAngle = ContinuosIMU;\n+        }\n+        XR += NXR;\n+        telemetry.addData(\"NewXR\", NXR);\n+        telemetry.addData(\"IMU\", ContinuosIMU);\n+        telemetry.update();\n+\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n+        /*motor_drive_flAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);\n+            motor_drive_blAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_frAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_brAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);*/\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n+        }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((-YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower(-(YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((-YL - XL - XR));\n+            motor_drive_brAsDcMotor.setPower(-(YL - XL + XR));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((-mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower(-(mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((-mYL - mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower(-(mYL - mXL + mXR));\n+        }\n+\n+\n+    }\n+\n+    private void PersonalityStateMachine() {\n+        switch (CurrentState) {\n+            case MOVE_RIGHT:\n+                if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    telemetry.addData(\"strafe and turn right\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_LEFT:\n+                if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    telemetry.addData(\"strafe or turn\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_FORWARD:\n+                if (gamepad1.left_stick_y < 0) {\n+                    telemetry.addData(\"move forward\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case MOVE_BACKWARDS:\n+                if (gamepad1.left_stick_y > 0) {\n+                    telemetry.addData(\"move backwards\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case SHOOT:\n+                if (RightLauncher.getPower() < 0) {\n+                    telemetry.addData(\"shoot\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (intake.getPower() > 0) {\n+                    CurrentState = State.INTAKE;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case INTAKE:\n+                if (intake.getPower() > 0) {\n+                    telemetry.addData(\"intake\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 || gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 || gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else {\n+                    CurrentState = State.IDLE;\n+                }\n+                break;\n+\n+            case IDLE:\n+                if ((RightLauncher.getPower() == 0) && (intake.getPower() == 0) && (gamepad1.right_stick_x == 0) && (gamepad1.left_stick_y == 0) && (gamepad1.left_stick_x == 0)) {\n+                    telemetry.addData(\"idle\", CurrentState);\n+                    telemetry.update();\n+                } else if (gamepad1.right_stick_x > 0 && gamepad1.left_stick_x > 0) {\n+                    CurrentState = State.MOVE_RIGHT;\n+                } else if (gamepad1.right_stick_x < 0 && gamepad1.left_stick_x < 0) {\n+                    CurrentState = State.MOVE_LEFT;\n+                } else if (gamepad1.left_stick_y < 0) {\n+                    CurrentState = State.MOVE_FORWARD;\n+                } else if (gamepad1.left_stick_y > 0) {\n+                    CurrentState = State.MOVE_BACKWARDS;\n+                } else if (RightLauncher.getPower() < 0) {\n+                    CurrentState = State.SHOOT;\n+                } else {\n+                    CurrentState = State.INTAKE;\n+                }\n+                break;\n+\n+        }\n+    }\n+\n+   /* private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+              I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 0.75 && yTarget - CurrentY >= -0.75 && xTarget - CurrentX <= 0.75 && xTarget - CurrentX >= -0.75 && (-TargetAngle + CurrentHeading) <= 2 && (-TargetAngle + CurrentHeading) >= -2))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+\n+              //  telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+              //if (camDir == 90) {\n+            //MecanumFunction(1 * (-0.013 * (xTarget - CurrentX)), (-1 * (0.021 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.02 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+\n+                MecanumFunction(0, 0, 0);\n+                break;\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+        */\n+}\n+\n+\n+"
  },
  {
    "sha": "9e7487d56caec340fdf3a1c0d6884e1cb55ca1b3",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RunnablesTestAuto.java",
    "status": "added",
    "additions": 1504,
    "deletions": 0,
    "changes": 1504,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RunnablesTestAuto.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RunnablesTestAuto.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RunnablesTestAuto.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -0,0 +1,1504 @@\n+package org.firstinspires.ftc.teamcode;\n+\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n+import com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;\n+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.hardware.CRServo;\n+import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorEx;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.PIDFCoefficients;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;\n+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n+\n+//import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n+\n+/* TODO\n+- Check to make sure HW reads are being done efficiently.  Don't ask for hardware reads more often than required\n+- Consider adding a smoothing feature in MecanumFunction\n+- Fix the motor names.  THey are very awkward right now\n+- Confirm that WallTracking exits properly\n+- Add camera direction function into WallTracking\n+- Tune motors\n+    -Backright motor not tuned correctly. Wall tracking program bugging out. Not getting to desired location, but does exit the loop when robot is manually guided to Target Position.\n+- Create exact angular adjustment function\n+ */\n+\n+@Autonomous(name = \"RunnablesTestAuto\", group = \"\")\n+\n+public class RunnablesTestAuto extends LinearOpMode {\n+    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\n+    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\n+    private static final String LABEL_SECOND_ELEMENT = \"Single\";\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    private CRServo Conveyor;\n+    private DcMotor intake;\n+    public static final double NEW_P = 20;\n+    public static final double NEW_I = 15;\n+    public static final double NEW_D = 0;\n+    public static final double NEW_F = 5;\n+    private DcMotor clarm;\n+    private Servo claw;\n+    private Servo ramp;\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private TFObjectDetector tfod;\n+    private static final float mmTargetHeight = (6) * mmPerInch;\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+    private OpenGLMatrix lastLocation = null;\n+    //WebcamName webcamName = null;\n+    private DcMotorEx motor_drive_flAsDcMotor, motor_drive_blAsDcMotor, motor_drive_brAsDcMotor, motor_drive_frAsDcMotor;\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    Orientation angles;\n+    ElapsedTime TimerA;\n+    ElapsedTime TimerC;\n+    double OneVote, NoneVote, QuadVote;\n+    double DecelConstant, DecelConstant2;\n+    ElapsedTime TimerD;\n+    ElapsedTime MagTimer;\n+    ElapsedTime AccelTimer;\n+    ElapsedTime DevelTimer;\n+    float CurrentHeading;\n+    ElapsedTime TimerB;\n+    double CurrentVal;\n+    double LastVal;\n+    double QuadRun;\n+    double OneRun;\n+    double YL, XL;\n+    double NoneRun;\n+    double YEncoderTicks;\n+    double AvgReadingY, AvgReadingX;\n+    double XEncoderTicks;\n+    double EncoderTicks;\n+    double YSpeed;\n+    double YPositionReset, XPositionReset, XPositionP, YPositionP;\n+    double XDecelerate;\n+    double TotalEncoderTicks;\n+    double Accelerate, Decelerate, XAccelerate;\n+    double mFr, mFl, mBl, mBr;\n+    double X, Y, XD, YD;\n+    double CurrentX, CurrentY;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale, YLin, XLin, XRin;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n+    double Heading;\n+    double Zrot = 0.0;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double avgEnc;\n+    double Xposition;\n+    double Yposition;\n+    double AccelConstant, AccelConstant2;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    boolean fullMag;\n+    private Servo camServo;\n+    ModernRoboticsI2cRangeSensor rangeSensor;\n+\n+    private enum State {\n+        IDLE,\n+        FORWARD_FIVE,\n+        FORWARD_TEN,\n+        BACKWARDS_FIVE,\n+        BACKWARDS_TEN\n+    }\n+\n+    ElapsedTime RunnableTimer;\n+\n+\n+    private State CurrentState;\n+\n+    private class AutoStateMachine implements Runnable {\n+        public AutoStateMachine() {\n+\n+        }\n+\n+        public void run() {\n+            while (opModeIsActive()) {\n+                DistanceTracker();\n+                telemetry.addData(\"DistanceTracker\", Yposition);\n+                telemetry.addData(\"timer\", RunnableTimer);\n+                switch (CurrentState) {\n+                    case IDLE:\n+                        if (Yposition < 5 && Yposition > -5) {\n+                            telemetry.addData(\"IDLE\", CurrentState);\n+                            telemetry.update();\n+                        } else if (Yposition >= 5 && Yposition < 10) {\n+                            CurrentState = State.FORWARD_FIVE;\n+                        } else if (Yposition >= 10) {\n+                            CurrentState = State.FORWARD_TEN;\n+                        } else if (Yposition <= -5 && Yposition > -10) {\n+                            CurrentState = State.BACKWARDS_FIVE;\n+                        } else {\n+                            CurrentState = State.BACKWARDS_TEN;\n+                        }\n+                        break;\n+                    case FORWARD_FIVE:\n+                        if (Yposition >= 5 && Yposition < 10) {\n+                            telemetry.addData(\"Forward 5\", CurrentState);\n+                            telemetry.update();\n+                        } else if (Yposition >= 10) {\n+                            CurrentState = State.FORWARD_TEN;\n+                        } else if (Yposition <= -10) {\n+                            CurrentState = State.BACKWARDS_TEN;\n+                        } else if (Yposition <= -5 && Yposition > -10) {\n+                            CurrentState = State.BACKWARDS_FIVE;\n+                        } else {\n+                            CurrentState = State.IDLE;\n+                        }\n+                        break;\n+                    case FORWARD_TEN:\n+                        if (Yposition >= 10) {\n+                            telemetry.addData(\"Forward 10\", CurrentState);\n+                            telemetry.update();\n+                        } else if (Yposition >= 5 && Yposition < 10) {\n+                            CurrentState = State.FORWARD_FIVE;\n+                        } else if (Yposition <= -10) {\n+                            CurrentState = State.BACKWARDS_TEN;\n+                        } else if (Yposition <= -5 && Yposition > -10) {\n+                            CurrentState = State.BACKWARDS_FIVE;\n+                        } else {\n+                            CurrentState = State.IDLE;\n+                        }\n+                        break;\n+                    case BACKWARDS_FIVE:\n+                        if (Yposition <= -5 && Yposition > -10) {\n+                            telemetry.addData(\"Backwards 5\", CurrentState);\n+                            telemetry.update();\n+                        } else if (Yposition >= 5 && Yposition < 10) {\n+                            CurrentState = State.FORWARD_FIVE;\n+                        } else if (Yposition <= -10) {\n+                            CurrentState = State.BACKWARDS_TEN;\n+                        } else if (Yposition >= 10) {\n+                            CurrentState = State.FORWARD_TEN;\n+                        } else {\n+                            CurrentState = State.IDLE;\n+                        }\n+                        break;\n+                    case BACKWARDS_TEN:\n+                        if (Yposition <= -10) {\n+                            telemetry.addData(\"Backwards 10\", CurrentState);\n+                            telemetry.update();\n+                        } else if (Yposition >= 5 && Yposition < 10) {\n+                            CurrentState = State.FORWARD_FIVE;\n+                        } else if (Yposition <= -5 && Yposition > -10) {\n+                            CurrentState = State.BACKWARDS_FIVE;\n+                        } else if (Yposition >= 10) {\n+                            CurrentState = State.FORWARD_TEN;\n+                        } else {\n+                            CurrentState = State.IDLE;\n+                        }\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void runOpMode() {\n+\n+        // vuforiaUltimateGoal = new VuforiaCurrentGame();\n+        motor_drive_flAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_flAsDcMotor\");\n+        motor_drive_frAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_frAsDcMotor\");\n+        motor_drive_blAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_blAsDcMotor\");\n+        motor_drive_brAsDcMotor = hardwareMap.get(DcMotorEx.class, \"motor_drive_brAsDcMotor\");\n+        RightLauncher = hardwareMap.get(DcMotor.class, \"RightLauncher\");\n+        LeftLauncher = hardwareMap.get(DcMotor.class, \"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        intake = hardwareMap.get(DcMotor.class, \"intake\");\n+        clarm = hardwareMap.get(DcMotor.class, \"clarm\");\n+        claw = hardwareMap.get(Servo.class, \"claw\");\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+\n+        RunnableTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        RunnableTimer.reset();\n+\n+        PIDFCoefficients pidOrig = motor_drive_flAsDcMotor.getPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n+        rangeSensor = hardwareMap.get(ModernRoboticsI2cRangeSensor.class, \"rangeSensor\");\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+        Initialization();\n+\n+        // Activate here for camera preview.\n+        telemetry.addData(\">>\", \"Vuforia initialized, press start to continue...\");\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = -2.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n+\n+        if (tfod != null) {\n+            tfod.activate();\n+            tfod.setZoom(3, 1.78);\n+        }\n+        claw.setPosition(0);\n+        targetsUltimateGoal.activate();\n+        X = 1;\n+        Y = 1;\n+        YPositionReset = 0;\n+        XPositionReset = 0;\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        ringScan();\n+        AutoStateMachine myThread = new AutoStateMachine();\n+        myThread.run();\n+        waitForStart();\n+        while (opModeIsActive()) {\n+            DistanceTracker();\n+        }\n+\n+\n+\n+/*\n+        GoTov2(0,24, 0.25, 0, 6,6,true,false,0.012,true);\n+        clarm.setTargetPosition(500);\n+        clarm.setPower(0.5);\n+        GoTov2(0,24, 0.25, 0, 6,6,false,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.5);\n+        GoTov2(0,24, 0.25, 0, 6,6,false,true,0.012,true);\n+        GoTov2(0,-24, 0.25, 0, 6,6,true,false,0.012,true);\n+        clarm.setTargetPosition(500);\n+        clarm.setPower(0.5);\n+        GoTov2(0,-24, 0.25, 0, 6,6,false,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.5);\n+        GoTov2(0,-24, 0.25, 0, 6,6,false,true,0.012,true);\n+        sleep(1000);\n+*/\n+\n+\n+  /*wallTargetTracking(vuforia, allTrackables, 90, 0, 58, 0, 10, 2, 1, 3, false, 0);\n+ /*\n+        AngularAdjustment(-6.1, 0.02);\n+\n+        AngularAdjustment(-3.5, 0.028);\n+\n+        AngularAdjustment(1.15, 0.028);\n+\n+        GoTo(0, 12,.2, 0, 14, 0, true, true, 0.012, true);\n+        if (QuadRun == 1) {\n+            intakeFunction(16, 1300, 0, true, .03);\n+            intakeFunction(6, 1300, 0, true, .03);\n+        }\n+/*\n+        GoTo(0, 10,.2, 0, 14, 0, true, false, 0.012, true);\n+        clarm.setTargetPosition(650);\n+        clarm.setPower(0.3);\n+        GoTo(10,10,0.2,0,14,0, false,true,0.012,true);\n+        GoTo(-10,-10,0.2,0,14,0, true,false,0.012,true);\n+        clarm.setTargetPosition(0);\n+        clarm.setPower(-0.3);\n+        GoTo(0, -10,.2, 0, 14, 0, false, true, 0.012, true);\n+   /* GoTo(20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, -20,.2, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20,.2, 0, 14, 0, true, true, 0.012, true);\n+*/\n+\n+\n+\n+\n+    /*\n+    GoTo(0, 40, .3, 0, 14, 0, false, true, 0.012, true);\n+IMUTurn(175);\n+*/\n+\n+    /*\n+    GoTo(20, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(20, 20, .3, 0, 14, 0, true, true, 0.012,true);\n+        GoTo(0, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, 20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(-20, -20, .3, 0, 14, 0, true, true, 0.012, true);\n+        GoTo(0, 20, .3, 0, 14, 0, true, true, 0.012,true);\n+\n+*/\n+\n+        /*while(Xposition <= 24 || Yposition <= 48){\n+    if (Xposition >= 24){\n+        X = 0;\n+    }\n+    if (Yposition >= 48){\n+        Y = 0;\n+    }\n+    MecanumFunction(0.1414 * Y,0.1 * X,0);\n+    DistanceTracker();\n+\n+}\n+\n+         */\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void DistanceTracker() {\n+        if (Yposition < 0) {\n+            YPositionP = -1;\n+        } else {\n+            YPositionP = 1;\n+        }\n+        if (Xposition < 0) {\n+            XPositionP = -1;\n+        } else {\n+            XPositionP = 1;\n+        }\n+        Yposition = (((((motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) * 0.25) * 0.00208333333) * 12.8) - YPositionReset);//((((motor_drive_brAsDcMotor.getCurrentPosition() + motor_drive_blAsDcMotor.getCurrentPosition() + motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 4) / 480) * 12.566);\n+        Xposition = ((((motor_drive_flAsDcMotor.getCurrentPosition() - motor_drive_blAsDcMotor.getCurrentPosition()) * 0.00208333333) * 11.5 * .5) - (XPositionReset));\n+\n+    }\n+\n+    private void ResetTracker() {\n+        XPositionReset = Xposition;\n+        YPositionReset = Yposition;\n+    }\n+\n+    private void WallTargetGoTo(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables, double xTarget, double yTarget, double Speed) {\n+        targetVisible = false;\n+        while (targetVisible == false) {\n+            for (int count = 0; count < 10; count++) {\n+                for (VuforiaTrackable trackable : allTrackables) {\n+                    if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                        targetVisible = true;\n+\n+                        // getUpdatedRobotLocation() will return null if no new information is available since\n+                        // the last time that call was made, or if the trackable is not currently visible.\n+                        OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                        if (robotLocationTransform != null) {\n+                            lastLocation = robotLocationTransform;\n+                        }\n+                        break;\n+                    } else {\n+                        targetVisible = false;\n+                    }\n+                }\n+                if (targetVisible) {\n+                    VectorF translation = lastLocation.getTranslation();\n+                    CurrentY = translation.get(1) / mmPerInch;\n+                    CurrentX = translation.get(0) / mmPerInch;\n+                    AvgReadingY += CurrentY;\n+                    AvgReadingX += CurrentX;\n+                }\n+\n+\n+            }\n+            AvgReadingY = (AvgReadingY / 10);\n+            AvgReadingX = (AvgReadingX / 10);\n+            // Provide feedback as to where the robot is located (if we know).\n+\n+        }\n+//yTarget - AvgReadingX\n+        //  GoTo( AvgReadingY - xTarget ,0, Speed, 0, 14,0,true,true,0.012,true);\n+        GoTo(-24, yTarget - AvgReadingX, Speed, 0, 14, 0, true, true, 0.012, true);\n+\n+\n+    }\n+\n+    private void SpeedCalculator(double XDistance, double YDistance, double Speed, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel) {\n+        if (Math.abs(Xposition) >= Math.abs(XDistance)) {\n+            if (Decel) {\n+                X = 0;\n+            }\n+        }\n+        if (XDistance == 0) {\n+            X = 0;\n+        }\n+        if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+            if (Decel) {\n+                Y = 0;\n+            }\n+        }\n+        if (XDistance < 0) {\n+            XD = -1;\n+        }\n+        if (YDistance < 0) {\n+            YD = -1;\n+        }\n+        if (XDistance == 0) {\n+            if (Accel && ((Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+                YL = Math.min(Math.max(AccelConstant * (Yposition * Yposition), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max(AccelConstant2 * (Xposition * Xposition), 0.025), Speed) * X * XD;\n+            } else if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) <= Math.abs(DecelDistance)))) {\n+                YL = Math.min(Math.max(0.025 + (DecelConstant * Math.abs((YDistance - Yposition))), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max((0.025 + (DecelConstant2 * Math.abs(((XDistance - Xposition))))), 0.025), Speed) * X * XD;\n+            } else {\n+                YL = YSpeed * YD;\n+                XL = Speed * XD;\n+            }\n+        } else {\n+            if (Accel && ((Math.abs(Xposition) <= Math.abs((AccelDistance * 0.7071067)) || Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+                YL = Math.min(Math.max(AccelConstant * (Yposition * Yposition), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max(AccelConstant2 * (Xposition * Xposition), 0.025), Speed) * X * XD;\n+                telemetry.addData(\"Accel?\", 1);\n+                telemetry.update();\n+            } else if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) <= Math.abs(DecelDistance) || Math.abs(XDistance) - Math.abs(Xposition) <= Math.abs(DecelDistance * 0.7071067)))) {\n+                YL = Math.min(Math.max(0.025 + (DecelConstant * (YDistance - Yposition)), 0.025), YSpeed) * Y * YD;\n+                XL = Math.min(Math.max((0.025 + (DecelConstant2 * ((XDistance - Xposition)))), 0.025), Speed) * X * XD;\n+                telemetry.addData(\"Decel?\", 1);\n+                telemetry.update();\n+            } else {\n+                YL = YSpeed;\n+                XL = Speed;\n+                telemetry.addData(\"Neither?\", 1);\n+                telemetry.update();\n+            }\n+        }\n+\n+\n+    }\n+\n+    private void GoTov2(double XDistance, double YDistance, double Speed, double MaintainAngle, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel, double IMUGain, boolean Reset) {\n+        if (Reset) {\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            Xposition = 0;\n+            Yposition = 0;\n+        } else {\n+            DistanceTracker();\n+            ResetTracker();\n+        }\n+        XPositionReset = Xposition;\n+        YPositionReset = Yposition;\n+        DistanceTracker();\n+        YSpeed = Math.abs(Speed * 0.7071067);\n+        AccelConstant = (Speed / AccelDistance);\n+        AccelConstant2 = (Speed / (AccelDistance * 0.7071067));\n+        DecelConstant = (((YSpeed - 0.025) / DecelDistance));\n+        DecelConstant2 = (((Speed - 0.025) / (DecelDistance * 0.7071067)));\n+        X = 1;\n+        Y = 1;\n+        XD = 1;\n+        YD = 1;\n+        if (!(XDistance == 0)) {\n+\n+            while (Math.abs(Xposition) <= Math.abs(XDistance) || Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                DistanceTracker();\n+                SpeedCalculator(XDistance, YDistance, Speed, AccelDistance, DecelDistance, Accel, Decel);\n+                MecanumFunction(YL, XL, (-MaintainAngle + CurrentHeading) * IMUGain);\n+            }\n+\n+            if (Decel) {\n+                YL = XL = 0;\n+            }\n+\n+        } else if (XDistance == 0) {\n+            while (Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                telemetry.addData(\"YPosition\", Yposition);\n+                telemetry.update();\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+                DistanceTracker();\n+                SpeedCalculator(XDistance, YDistance, Speed, AccelDistance, DecelDistance, Accel, Decel);\n+                MecanumFunction(YL, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+            }\n+\n+            if (Decel) {\n+                YL = XL = 0;\n+            }\n+\n+        }\n+    }\n+\n+\n+    private void intakeFunction(double distance, long sleep, double Angle, boolean Beltafter, double speed) {\n+        ramp.setPosition(0.8);\n+        sleep(300);\n+        intake.setPower(-1);\n+        Conveyor.setPower(-1);\n+        GoTo(0, distance, speed, Angle, 14, 0, true, true, 0.012, true);\n+\n+        intake.setPower(1);\n+        if (Beltafter == false) {\n+            Conveyor.setPower(0);\n+        }\n+        sleep(sleep);\n+        intake.setPower(0);\n+        ramp.setPosition(0);\n+    }\n+\n+    private void MagFull(double Yl, double Xl, double Timeout, double Distance, double MaintainAngle, double IMUGain) {\n+        ramp.setPosition(0.8);\n+\n+        ElapsedTime MagTimer = new ElapsedTime();\n+        while (MagTimer.seconds() < Timeout) {\n+            angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+            CurrentHeading = angles.firstAngle;\n+            intake.setPower(1);\n+            LeftLauncher.setPower(-0.75);\n+            RightLauncher.setPower(-0.75);\n+            if (rangeSensor.getDistance(DistanceUnit.CM) > Distance) {\n+                MagTimer.reset();\n+            }\n+            MecanumFunction(Yl, Xl, (-MaintainAngle + CurrentHeading) * IMUGain);\n+        }\n+        LeftLauncher.setPower(0);\n+        RightLauncher.setPower(0);\n+        MecanumFunction(0, 0, 0);\n+        intake.setPower(-1);\n+        sleep(250);\n+        ramp.setPosition(0);\n+    }\n+\n+    private void AngularAdjustment(double targetangle, double IMUgain) {\n+        ElapsedTime TimerD = new ElapsedTime();\n+        TimerD.reset();\n+        while ((TimerD.milliseconds() < 350)) {\n+\n+            // ANDREW: Consider the use of BulkCaching here since it is expensive to read all the motor positions if all you need is the imu angle\n+            BulkCaching();\n+            if (((-targetangle + CurrentHeading) >= 0.07 && (-targetangle + CurrentHeading) <= -0.07)) {\n+                TimerD.reset();\n+            }\n+            MecanumFunction(0, 0, IMUgain * (-targetangle + CurrentHeading));\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    //   while (!(40 - CurrentY <= 1 && 40 - CurrentY >= -1 && -3 - CurrentX <= 1 && -3 - CurrentX >= -1 && (180 - (180 + Zrot)) >= 1 && (180 - (180 + Zrot)) <= -1))\n+    private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+            /*  I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+             */\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 0.7 && yTarget - CurrentY >= -0.7 && xTarget - CurrentX <= 0.8 && xTarget - CurrentX >= -0.8))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+/*                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+  */\n+                telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+                if (camDir == 90) {\n+                    MecanumFunction(1 * (-0.01 * (xTarget - CurrentX)), (-1 * (0.018 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.01 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+                MecanumFunction(0, 0, 0);\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        TimerA = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerB = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        TimerC = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+        //parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+\n+        // webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        CurrentHeading = angles.firstAngle;\n+        motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n+        motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n+        motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        PIDFCoefficients pidNew = new PIDFCoefficients(NEW_P, NEW_I, NEW_D, NEW_F);\n+        PIDFCoefficients brpidNew = new PIDFCoefficients(20, 15, 0, 0);\n+        motor_drive_flAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_frAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_blAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        motor_drive_brAsDcMotor.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+            //((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(webcamName, robotFromCamera);\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName vuforia = ClassFactory.getInstance().createVuforia(parameters);.class, \"Webcam 1\");\n+    }\n+\n+    private void ringScan() {\n+        QuadRun = 0;\n+        OneRun = 0;\n+        NoneRun = 0;\n+        QuadVote = OneVote = NoneVote = 0;\n+        TimerC = new ElapsedTime();\n+        TimerC.reset();\n+        while (!(isStarted())) {\n+            if (tfod != null) {\n+                // getUpdatedRecognitions() will return null if no new information is available since\n+                // the last time that call was made.\n+                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n+                if (updatedRecognitions != null) {\n+\n+                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n+                    telemetry.addData(\"QuadVotes\", QuadVote);\n+                    telemetry.addData(\"NoneVotes\", NoneVote);\n+                    telemetry.addData(\"OneVotes\", OneVote);\n+                    telemetry.update();\n+                    // step through the list of recognitions and display boundary info.\n+                    int i = 0;\n+                    for (Recognition recognition : updatedRecognitions) {\n+                        if (recognition.getLabel() == \"Quad\") {\n+                            QuadVote += 1;\n+                        } else if (recognition.getLabel() == \"Single\") {\n+                            OneVote += 1;\n+                        } else {\n+                            NoneVote += 1;\n+                        }\n+                        /*\n+                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n+                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getLeft(), recognition.getTop());\n+                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n+                                recognition.getRight(), recognition.getBottom());\n+                                */\n+\n+                    }\n+                    telemetry.update();\n+\n+                }\n+            }\n+\n+        }\n+        if (QuadVote > OneVote && QuadVote > NoneVote) {\n+            QuadRun = 1;\n+        } else if (OneVote > QuadVote && OneVote > NoneVote) {\n+            OneRun = 1;\n+        } else if (OneVote < 4 && QuadVote < 4) {\n+            NoneRun = 1;\n+        }\n+        if (tfod != null) {\n+            tfod.shutdown();\n+\n+        }\n+    }\n+\n+    private void Shoot(double RP, double LP, double Timer, boolean Stop) {\n+        ElapsedTime ShootTimer;\n+        ShootTimer = new ElapsedTime(ElapsedTime.Resolution.SECONDS);\n+        ShootTimer.reset();\n+        while (ShootTimer.seconds() <= Timer) {\n+            LeftLauncher.setPower(LP);\n+            RightLauncher.setPower(RP);\n+            Conveyor.setPower(1);\n+        }\n+\n+        if (Stop == true) {\n+            LeftLauncher.setPower(0);\n+            RightLauncher.setPower(0);\n+        }\n+        Conveyor.setPower(0);\n+\n+    }\n+\n+    private void initTfod() {\n+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\n+        tfodParameters.minResultConfidence = 0.6f;\n+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\n+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\n+    }\n+\n+/*\n+Liam:\n+  The maximum power of each motor in the .setPower method is +/- 1.0.  The way MecanumFunction is implemented below\n+  is not 'correct' in that the calculated value could be as much as +/-3.0 which is not correct.  Please figure out an algorithm\n+  that will 'scale' the .setPower value to a maximum of 1.0.  This might mean that you will need to adjust the function input\n+  values so that the resulting setPower value is a maximum of +/-1.0 but keep the inputs keep the same ratio.\n+ */\n+\n+\n+    private void MecanumFunction(double YL, double XL, double XR) {\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n+\n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n+        }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower(-(-YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((YL - XL - XR));\n+            motor_drive_brAsDcMotor.setPower(-(-YL - XL + XR));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower(-(-mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((mYL - mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower(-(-mYL - (-mXL + mXR)));\n+        }\n+\n+\n+    }\n+\n+    private void IMUTurn(double TrgtAngle) {\n+        double AngleToTurn;\n+\n+        BulkCaching();\n+        AngleToTurn = TrgtAngle - CurrentHeading;\n+        if (AngleToTurn < 0) {\n+            while (TrgtAngle + 6.5 <= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading < -40) {\n+                    MecanumFunction(0, 0, 0.8);\n+                } else if (TrgtAngle - CurrentHeading >= -40) {\n+                    MecanumFunction(0, 0, 0.2);\n+                }\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (TrgtAngle - 6.5 >= CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                if (TrgtAngle - CurrentHeading > 40) {\n+                    MecanumFunction(0, 0, -0.8);\n+                } else if (TrgtAngle - CurrentHeading <= 40) {\n+                    MecanumFunction(0, 0, -0.2);\n+                }\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void AngleAdjustment(double DegreeChange) {\n+        double AngleToTurn;\n+        double CurrentAngularPosition;\n+        BulkCaching();\n+        CurrentAngularPosition = CurrentHeading;\n+        AngleToTurn = DegreeChange - CurrentAngularPosition;\n+        if (AngleToTurn < 0) {\n+            while (CurrentAngularPosition + DegreeChange < CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                MecanumFunction(0, 0, 0.2);\n+            }\n+        } else if (AngleToTurn > 0) {\n+            while (CurrentAngularPosition + DegreeChange > CurrentHeading) {\n+                BulkCaching();\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+\n+                MecanumFunction(0, 0, -0.2);\n+            }\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void readCurrentHeading() {\n+\n+    }\n+\n+    private void DistanceSmoothTravel(double Distance, double Speed, double MaintainAngle,\n+                                      double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.12 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                if (isStopRequested()) {\n+                    break;\n+                }\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_frAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"FR\", motor_drive_frAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.08 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+        MecanumFunction(0, 0, 0);\n+    }\n+\n+    private void DistanceStrafe(double Distance, double Speed, double MaintainAngle,\n+                                double IMUGain, boolean Accel_, boolean Decel_, double DecelDistance) {\n+        ElapsedTime TimerAccel;\n+        ElapsedTime TimerDecel;\n+        double AccelDist;\n+        double DecelDist;\n+        double ResetTimerAccel_;\n+        double ResetTimerDecel_;\n+\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        Distance = -Distance;\n+        TimerAccel = new ElapsedTime();\n+        TimerDecel = new ElapsedTime();\n+        AccelDist = 240;\n+        DecelDist = DecelDistance;\n+        readCurrentHeading();\n+        EncoderTicks = (Distance / 12.566) * 370;\n+        ResetTimerAccel_ = 1;\n+        ResetTimerDecel_ = 1;\n+        avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+        if (Distance > 0) {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+            while (avgEnc >= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"BR\", motor_drive_brAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (TimerAccel.seconds() + 1) * 15, -0.2), Speed), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc >= -EncoderTicks + DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(Speed * (0.1 / (0.06 + TimerDecel.seconds())), 0.1), Math.abs(Speed)), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+            MecanumFunction(0, 0, 0);\n+        } else {\n+            TimerDecel.reset();\n+            TimerAccel.reset();\n+\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+            while (avgEnc <= -EncoderTicks && opModeIsActive()) {\n+                BulkCaching();\n+                avgEnc = (motor_drive_flAsDcMotor.getCurrentPosition() + motor_drive_brAsDcMotor.getCurrentPosition()) / 2;\n+                telemetry.addData(\"Encoder Ticks Target\", -EncoderTicks);\n+                telemetry.addData(\"FL\", motor_drive_flAsDcMotor.getCurrentPosition());\n+                telemetry.addData(\"BR\", motor_drive_brAsDcMotor.getCurrentPosition());\n+                telemetry.update();\n+                if (avgEnc >= -AccelDist && Accel_ == true) {\n+                    if (ResetTimerAccel_ == 1) {\n+                        TimerAccel.reset();\n+                        ResetTimerAccel_ = 0;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * TimerAccel.seconds() * 1, -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else if (avgEnc <= -EncoderTicks - DecelDist && Decel_ == true) {\n+                    if (ResetTimerDecel_ == 1) {\n+                        TimerDecel.reset();\n+                        ResetTimerDecel_ = 0;\n+                    } else if (avgEnc >= -EncoderTicks) {\n+                        break;\n+                    }\n+                    MecanumFunction(Math.min(Math.max(-Speed * (0.1 / (0.6 + TimerDecel.seconds())), -Speed), -0.1), 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                } else {\n+                    MecanumFunction(-Speed, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+                }\n+            }\n+            TimerAccel.reset();\n+            TimerDecel.reset();\n+            if (Decel_ == true) {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n+                MecanumFunction(0, 0, 0);\n+\n+            } else {\n+                motor_drive_flAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_frAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_blAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+                motor_drive_brAsDcMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);\n+\n+            }\n+\n+        }\n+    }\n+\n+    private void GoTo(double XDistance, double YDistance, double Speed, double MaintainAngle, double AccelDistance, double DecelDistance, boolean Accel, boolean Decel, double IMUGain, boolean Reset) {\n+\n+        Accelerate = Math.abs(Yposition) * 0.7;\n+        XAccelerate = Math.abs(Xposition) * 0.989;\n+        Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+        XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6);\n+        ResetTracker();\n+        DistanceTracker();\n+\n+\n+        /*\n+        if (Accel) {\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+            motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+            Xposition = 0;\n+            Yposition = 0;\n+        }\n+*/\n+        X = 1;\n+        Y = 1;\n+        XD = 1;\n+        YD = 1;\n+        if (!(XDistance == 0)) {\n+\n+            while (Math.abs(Xposition) <= Math.abs(XDistance) || Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                // telemetry.addData(\"Speed\", Math.max(Math.min(Speed * ((Math.abs(Yposition) * 0.006) / Accelerate) - 0/*(Decelerate * (1 / (Math.abs(YDistance) - Math.abs(Yposition))))*/, 0.0001), Speed * 0.707106781 * Math.abs((YDistance / XDistance)) * Y));\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                DistanceTracker();\n+\n+                if (Math.abs(Xposition) >= Math.abs(XDistance)) {\n+                    if (Decel) {\n+                        X = 0;\n+                    }\n+                }\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (XDistance < 0) {\n+                    XD = -1;\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && ((Math.abs(Xposition) <= Math.abs((AccelDistance * 0.7071067)) || Math.abs(Yposition) <= Math.abs(AccelDistance)))) {\n+\n+                    Accelerate = 1;\n+                    XAccelerate = 1;\n+                    if (Math.abs(Xposition) <= 8 || Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                    XAccelerate = Math.abs(Xposition) * 0.7;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 13 || Math.abs(XDistance) - Math.abs(Xposition) < 8) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        XDecelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                    XDecelerate = ((Math.abs(XDistance) - Math.abs(Xposition)) * 1);\n+                }\n+                telemetry.addData(\"fart\", (Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate), 0.49), Speed) * X * XD));\n+                //    telemetry.addData(\"fart\", (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.6) / XDecelerate));\n+                telemetry.update();\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4) / Decelerate), 0.025), YSpeed) * Y * YD, Math.min(Math.max(Speed * ((Math.abs(Xposition) * 1) / XAccelerate) * (((Math.abs(XDistance) - Math.abs(Xposition)) * 0.7) / XDecelerate), 0.49), Speed) * X * XD, (-MaintainAngle + CurrentHeading) * IMUGain);\n+\n+\n+                YSpeed = Math.abs(Speed * (Math.abs(YDistance) / Math.sqrt(((YDistance * YDistance) + (XDistance * XDistance)))) * Y);\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0);\n+            }\n+\n+        } else if (XDistance == 0) {\n+\n+            while (Math.abs(Yposition) <= Math.abs(YDistance)) {\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+                DistanceTracker();\n+\n+                if (Math.abs(Yposition) >= Math.abs(YDistance)) {\n+                    if (Decel) {\n+                        Y = 0;\n+                    }\n+                }\n+                if (YDistance < 0) {\n+                    YD = -1;\n+                }\n+                if (Accel && Math.abs(Yposition) <= Math.abs(AccelDistance)) {\n+\n+                    Accelerate = 1;\n+                    if (Math.abs(Yposition) <= 13) {\n+                        telemetry.addData(\"Accel?\", 1);\n+                        telemetry.update();\n+                    }\n+                } else {\n+                    Accelerate = Math.abs(Yposition) * 0.6;\n+                }\n+                if (Decel && ((Math.abs(YDistance) - Math.abs(Yposition) < 18))) {\n+                    if (Math.abs(YDistance) - Math.abs(Yposition) < 18) {\n+                        //  telemetry.addData(\"Decel?\", 1);\n+                        Decelerate = 1;\n+                        // telemetry.update();\n+\n+                    }\n+                } else {\n+                    Decelerate = ((Math.abs(YDistance) - Math.abs(Yposition)) * 0.4);\n+                }\n+\n+                MecanumFunction(Math.min(Math.max(Speed * ((Math.abs(Yposition) * 0.6) / Accelerate) * (((Math.abs(YDistance) - Math.abs(Yposition)) * 0.1) / Decelerate), 0.025), Speed) * Y * YD, 0, (-MaintainAngle + CurrentHeading) * IMUGain);\n+\n+            }\n+\n+            if (Decel) {\n+                MecanumFunction(0, 0, 0);\n+            }\n+\n+\n+        }\n+\n+    }\n+}"
  },
  {
    "sha": "ce1527e8a0fa75cdf3943810337da2fd0f2c82d3",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ShootingTestASv1.java",
    "status": "modified",
    "additions": 3,
    "deletions": 5,
    "changes": 8,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ShootingTestASv1.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ShootingTestASv1.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ShootingTestASv1.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -1,15 +1,13 @@\n package org.firstinspires.ftc.teamcode;\n \n+import com.qualcomm.robotcore.eventloop.opmode.Disabled;\n+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n-import com.qualcomm.robotcore.hardware.DcMotor;\n import com.qualcomm.robotcore.hardware.Blinker;\n-import com.qualcomm.robotcore.hardware.DcMotorEx;\n-import com.qualcomm.robotcore.hardware.Gyroscope;\n-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n import com.qualcomm.robotcore.hardware.DcMotor;\n \n @TeleOp(name = \"ShootingTestASv1\", group = \"\")\n-\n+@Disabled\n public class ShootingTestASv1 extends LinearOpMode{\n     private Blinker expansion_Hub_1;\n     private DcMotor LeftShooter;"
  },
  {
    "sha": "694fc25adff9bee4fda707d978096bef2bb97e3c",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleopAS.java",
    "status": "modified",
    "additions": 589,
    "deletions": 9,
    "changes": 598,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleopAS.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleopAS.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestTeleopAS.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -1,28 +1,145 @@\n+/*to do list\n+- convert dc motor to dc motor ex\n+*/\n+\n package org.firstinspires.ftc.teamcode;\n \n-import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n+import com.qualcomm.hardware.bosch.BNO055IMU;\n+import com.qualcomm.hardware.lynx.LynxModule;\n import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n import com.qualcomm.robotcore.hardware.Blinker;\n-import com.qualcomm.robotcore.hardware.DcMotorSimple;\n-import com.qualcomm.robotcore.hardware.Gyroscope;\n+import com.qualcomm.robotcore.hardware.CRServo;\n import com.qualcomm.robotcore.hardware.DcMotor;\n+import com.qualcomm.robotcore.hardware.DcMotorSimple;\n+import com.qualcomm.robotcore.hardware.Servo;\n+import com.qualcomm.robotcore.util.ElapsedTime;\n+\n+import org.firstinspires.ftc.robotcore.external.ClassFactory;\n+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n+import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\n+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\n+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\n+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaCurrentGame;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;\n+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.YZX;\n+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;\n+import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\n \n @TeleOp(name = \"TestTeleopAS\", group = \"\")\n \n-public class TestTeleopAS extends LinearOpMode{\n+public class TestTeleopAS extends LinearOpMode {\n+    private static final String VUFORIA_KEY =\n+            \"Ae2mEyz/////AAABmQBmoTE94ki5quwzTT/OlIIeOueUfjuHL/5k1VNWN943meU2RmiXCJ9eX3rUR/2CkwguvbBU45e1SzrbTAwz3ZzJXc7XN1ObKk/7yPHQeulWpyJgpeZx+EqmZW6VE6yG4mNI1mshKI7vOgOtYxqdR8Yf7YwBPd4Ruy3NVK01BwBl1F8V/ndY26skaSlnWqpibCR3XIvVG0LXHTdNn/ftZyAFmCedLgLi1UtNhr2eXZdr6ioikyRYEe7qsWZPlnwVn5DaQoTcgccZV4bR1/PEvDLn7jn1YNwSimTC8glK+5gnNpO+X7BiZa5LcqtYEpvk/QNQda0Fd+wHQDXA8ojeMUagawtkQGJvpPpz9c6p4fad\";\n+    private static final float mmPerInch = 25.4f;\n+    private VuforiaLocalizer vuforia;\n+    private static final float mmTargetHeight = (6) * mmPerInch;          // the height of the center of the target image above the floor\n+    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;\n+    private static final boolean PHONE_IS_PORTRAIT = false;\n+    // Constants for perimeter targets\n+    private static final float halfField = 72 * mmPerInch;\n+    private static final float quadField = 36 * mmPerInch;\n+\n+    private BNO055IMU imu;\n+    private VuforiaCurrentGame vuforiaUltimateGoal;\n+    // Class Members\n+    private OpenGLMatrix lastLocation = null;\n+    private boolean targetVisible = false;\n+    private float phoneXRotate = 0;\n+    private float phoneYRotate = 0;\n+    private float phoneZRotate = 90;\n     private Blinker expansion_Hub_1;\n-    private Gyroscope imu;\n     private DcMotor motor_drive_flAsDcMotor;\n     private DcMotor motor_drive_frAsDcMotor;\n     private DcMotor motor_drive_blAsDcMotor;\n     private DcMotor motor_drive_brAsDcMotor;\n+    private DcMotor clarm;\n+    private Servo claw;\n+    private CRServo Conveyor;\n+    private Servo ramp;\n+    double TrueTrackSwitch;\n+    double IMUTrackSwitch;\n+    double CurrentVal;\n+    double lsPower, rsPower;\n+    double LastVal;\n+    double mXR, mYL, mXL, flScale, frScale, blScale, brScale;\n+    double CurrentX, CurrentY;\n+    double mFr, mFl, mBl, mBr;\n+    double ClawVariable;\n+    boolean frOverload, flOverload, blOverload, brOverload;\n+    Orientation angles;\n+    boolean gamepadaAfter = false;\n+    double LPower, RPower;\n+    boolean gamepada2After = false;\n+    boolean gamepad2lbafter = false;\n+    boolean gamepadbAfter = false;\n+    boolean lastGamepadX = false;\n+    boolean lastGamepadY = false;\n+    double lastClarm;\n+    private DcMotor intake;\n+    private DcMotor RightLauncher;\n+    private DcMotor LeftLauncher;\n+    boolean lastDPadUp = false;\n+    boolean lastDPadDown = false;\n+    double gamepadxpolar;\n+    boolean lastDPadRight = false;\n+    boolean LastDPadUp2 = false, LastDpadDown2 = false;\n+    boolean lastDPadLeft = false;\n+    boolean lastBumper = false;\n+    float CurrentHeading;\n+    double clarmvariable;\n+    private Servo camServo;\n+\n \n     @Override\n     public void runOpMode() {\n         motor_drive_flAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_flAsDcMotor\");\n         motor_drive_frAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_frAsDcMotor\");\n         motor_drive_blAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_blAsDcMotor\");\n         motor_drive_brAsDcMotor = hardwareMap.dcMotor.get(\"motor_drive_brAsDcMotor\");\n+        clarm = hardwareMap.dcMotor.get(\"clarm\");\n+        clarm.setDirection(DcMotor.Direction.FORWARD);\n+        intake = hardwareMap.dcMotor.get(\"intake\");\n+        RightLauncher = hardwareMap.dcMotor.get(\"RightLauncher\");\n+        LeftLauncher = hardwareMap.dcMotor.get(\"LeftLauncher\");\n+        Conveyor = hardwareMap.get(CRServo.class, \"Conveyor\");\n+        ramp = hardwareMap.get(Servo.class, \"ramp\");\n+        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);\n+        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\n+\n+        //start of homing for clarm\n+        lastClarm = clarm.getCurrentPosition();\n+        clarm.setPower(-0.25);\n+        sleep(200);\n+        while (lastClarm != clarm.getCurrentPosition()) {\n+            lastClarm = clarm.getCurrentPosition();\n+            sleep(100);\n+        }\n+        clarm.setPower(0);\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        clarm.setPower(0);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        //end of homing for clarm\n+\n+        Initialization();\n+\n+\n+        ramp.setPosition(0.42);\n+        claw = hardwareMap.servo.get(\"claw\");\n         motor_drive_brAsDcMotor.setDirection(DcMotorSimple.Direction.FORWARD);\n         motor_drive_frAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n         motor_drive_blAsDcMotor.setDirection(DcMotorSimple.Direction.REVERSE);\n@@ -35,14 +152,477 @@ public void runOpMode() {\n         motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n         motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n         motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        intake.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        RightLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        LeftLauncher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        telemetry.update();\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        // Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 0.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 9.0f;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+\n+        /**  Let all the trackable listeners know where the phone is.  */\n+\n+        targetVisible = false;\n \n+        // WARNING:\n+        // In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.\n+        // This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.\n+        // CONSEQUENTLY do not put any driving commands in this loop.\n+        // To restore the normal opmode structure, just un-comment the following line:\n+        ClawVariable = 1;\n+        clarmvariable = 0;\n         waitForStart();\n+        ramp.setPosition(0.0);\n+        RPower = -0.33;\n+        LPower = 0.77;\n+        //*Set this to ZERO if you want to disable testing mode ^^^^^\n+        clarmvariable = 1;\n+        targetsUltimateGoal.activate();\n+        camServo.setPosition(.5);\n         while (opModeIsActive()) {\n-            motor_drive_flAsDcMotor.setPower(-gamepad1.left_stick_y - (-gamepad1.left_stick_x - gamepad1.right_stick_x));\n-            motor_drive_blAsDcMotor.setPower(gamepad1.left_stick_y - (-gamepad1.left_stick_x + gamepad1.right_stick_x));\n-            motor_drive_frAsDcMotor.setPower(-gamepad1.left_stick_y + (-gamepad1.left_stick_x - gamepad1.right_stick_x));\n-            motor_drive_brAsDcMotor.setPower(gamepad1.left_stick_y + (-gamepad1.left_stick_x + gamepad1.right_stick_x));\n+            RightLauncher.setPower(RPower);\n+            LeftLauncher.setPower(LPower);\n+            BulkCaching();\n+            if (gamepad1.left_stick_x < 0) {\n+                gamepadxpolar = -1;\n+            } else if (gamepad1.left_stick_x >= 0) {\n+                gamepadxpolar = 1;\n+            }\n+            motor_drive_flAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);\n+            motor_drive_blAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_frAsDcMotor.setPower(-gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) - gamepad1.right_stick_x);\n+            motor_drive_brAsDcMotor.setPower(gamepad1.left_stick_y + (gamepadxpolar * (gamepad1.left_stick_x * gamepad1.left_stick_x)) + gamepad1.right_stick_x);\n+            CurrentX = 0;\n+            CurrentY = 0;\n+            if (gamepad1.a && !gamepada2After) {\n+                wallTargetTracking(vuforia, allTrackables, 90, -2.5, 41.8, 0, 10, 2, 1, 3, false, 0);\n+            }\n+            if (gamepad1.dpad_up && !LastDPadUp2) {\n+                RPower = RightLauncher.getPower() - 0.03;\n+                LPower = LeftLauncher.getPower() + 0.03;\n+\n+            }\n+            LastDPadUp2 = gamepad1.dpad_up;\n+            if (gamepad1.dpad_down && !LastDpadDown2) {\n+                RPower = RightLauncher.getPower() + 0.03;\n+                LPower = LeftLauncher.getPower() - 0.03;\n+            }\n+            LastDpadDown2 = gamepad1.dpad_down;\n+            if (gamepad2.b && !gamepadbAfter) {\n+                ClawVariable = ClawVariable * -1;\n+            }\n+            if (ClawVariable > 0) {\n+                claw.setPosition(.35);\n+            } else if (ClawVariable < 0) {\n+                claw.setPosition(0.03);\n+            }\n+\n+            gamepadaAfter = gamepad2.a;\n+            gamepadbAfter = gamepad2.b;\n+            gamepada2After = gamepad1.a;\n+\n+\n+            if (gamepad2.dpad_up && !lastDPadUp) {\n+                ramp.setPosition(0.0);\n+\n+                RightLauncher.setPower(-0.33);\n+                LeftLauncher.setPower(0.775);\n+\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+            if (gamepad2.left_bumper && !gamepad2lbafter) {\n+                ramp.setPosition(0);\n+\n+                RightLauncher.setPower(-0.36);\n+                LeftLauncher.setPower(0.9);\n+\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+\n+            }\n+            gamepad2.left_bumper = gamepad2lbafter;\n+            if (gamepad2.dpad_down && !lastDPadDown) {\n+                ramp.setPosition(0.475);\n+                RightLauncher.setPower(0);\n+                LeftLauncher.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+            lastDPadUp = gamepad2.dpad_up;\n+            lastDPadDown = gamepad2.dpad_down;\n+\n+\n+            //  lastDPadRight = gamepad2.dpad_right;\n+            //taking in rings\n+            if (gamepad2.dpad_right) {//&& !lastDPadRight) {\n+                intake.setPower(-1);\n+                Conveyor.setPower(-1);\n+                //spitting out rings\n+            } else if (gamepad2.dpad_left) {//&& !lastDPadLeft) {\n+                intake.setPower(0.8);\n+                Conveyor.setPower(0.8);\n+            } else {\n+                intake.setPower(0);\n+                Conveyor.setPower(0);\n+            }\n+\n+\n+            //  lastDPadLeft = gamepad2.dpad_left;\n+\n+            if ((!gamepad2.dpad_right) && (!gamepad2.dpad_left)) {\n+                intake.setPower(0);\n+                if (ramp.getPosition() > 0.3) { // Check here to make sure we don't step on the other Conveyor.setPower commands below\n+                    Conveyor.setPower(0);\n+                }\n+            }\n+\n+\n+            if (gamepad2.right_bumper && !lastBumper) {\n+                clarmvariable = -clarmvariable;\n+                if (clarmvariable > 0) {\n+                    clarm.setTargetPosition(955);\n+                    clarm.setPower(0.2);\n+                }\n+                if (clarmvariable < 0) {\n+                    clarm.setTargetPosition(400);\n+                    clarm.setPower(0.2);\n+                }\n+            }\n+\n+            lastBumper = gamepad2.right_bumper;\n+\n+\n+        }\n+    }\n+\n+    private void BulkCaching() {\n+        mFr = motor_drive_frAsDcMotor.getCurrentPosition();\n+        mFl = motor_drive_flAsDcMotor.getCurrentPosition();\n+        mBr = motor_drive_brAsDcMotor.getCurrentPosition();\n+        mBl = motor_drive_blAsDcMotor.getCurrentPosition();\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        CurrentHeading = angles.firstAngle;\n+        telemetry.addData(\"IMU\", CurrentHeading);\n+        telemetry.addData(\"LeftShooterPower\", LeftLauncher.getPower());\n+        telemetry.addData(\"RightShooterPower\", RightLauncher.getPower());\n+        telemetry.update();\n+        if (targetVisible) {\n+\n+\n+        }\n+    }\n+\n+    private void Initialization() {\n+        BNO055IMU.Parameters imuParameters;\n+\n+        Acceleration gravity;\n+        imuParameters = new BNO055IMU.Parameters();\n+        imuParameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;\n+        imuParameters.accelUnit = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n+        imuParameters.loggingEnabled = false;\n+        imu.initialize(imuParameters);\n+        angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+        gravity = imu.getGravity();\n+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\n+                \"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\n+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\n+        parameters.vuforiaLicenseKey = VUFORIA_KEY;\n+\n+\n+        vuforia = ClassFactory.getInstance().createVuforia(parameters); //  <<<====  THIS LINE WAS MISSING\n+\n+        clarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n+        clarm.setTargetPosition(0);\n+        clarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n+        CurrentHeading = angles.firstAngle;\n+\n+        motor_drive_flAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_frAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_blAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        motor_drive_brAsDcMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\"UltimateGoal\");\n+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);\n+        blueTowerGoalTarget.setName(\"Blue Tower Goal Target\");\n+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);\n+        redTowerGoalTarget.setName(\"Red Tower Goal Target\");\n+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);\n+        redAllianceTarget.setName(\"Red Alliance Target\");\n+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);\n+        blueAllianceTarget.setName(\"Blue Alliance Target\");\n+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);\n+        frontWallTarget.setName(\"Front Wall Target\");\n+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();\n+        allTrackables.addAll(targetsUltimateGoal);\n+        camServo = hardwareMap.get(Servo.class, \"camServo\");\n+\n+\n+        redAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, -halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));\n+        blueAllianceTarget.setLocation(OpenGLMatrix\n+                .translation(0, halfField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));\n+        frontWallTarget.setLocation(OpenGLMatrix\n+                .translation(-halfField, 0, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));\n+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.\n+        blueTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+        redTowerGoalTarget.setLocation(OpenGLMatrix\n+                .translation(halfField, -quadField, mmTargetHeight)\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));\n+\n+        if (CAMERA_CHOICE == BACK) {\n+            phoneYRotate = -90;\n+        } else {\n+            phoneYRotate = 90;\n+        }\n+\n+        //Rotate the phone vertical about the X axis if it's in portrait mode\n+        if (PHONE_IS_PORTRAIT) {\n+            phoneXRotate = 90;\n+        }\n+\n+        // Next, translate the camera lens to where it is on the robot.\n+        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.\n+        final float CAMERA_FORWARD_DISPLACEMENT = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center\n+        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground\n+        final float CAMERA_LEFT_DISPLACEMENT = 0;     // eg: Camera is ON the robot's center line\n+        OpenGLMatrix robotFromCamera = OpenGLMatrix\n+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)\n+//                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));\n+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, 90, 0, 90));\n+\n+        for (VuforiaTrackable trackable : allTrackables) {\n+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);\n+\n+        }\n+\n+//        vuforia = ClassFactory.getInstance().createVuforia(parameters);\n+        // initTfod();\n+        //webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n+    }\n+\n+    private void MecanumFunction(double YL, double XL, double XR) {\n+        flScale = (-YL - (-XL - XR));\n+        blScale = (YL - (-XL + XR));\n+        frScale = (-YL + XL - XR);\n+        brScale = (YL + XL + XR);\n+\n \n+        if ((-YL - (-XL - XR)) > 1 || (-YL - (-XL - XR)) < -1) {\n+            flOverload = true;\n+        } else {\n+            flOverload = false;\n         }\n+        if ((YL - (-XL + XR)) > 1 || (YL - (-XL + XR)) < -1) {\n+            blOverload = true;\n+        } else {\n+            blOverload = false;\n+        }\n+        if ((-YL + XL - XR) > 1 || (-YL + XL - XR) < -1) {\n+            frOverload = true;\n+        } else {\n+            frOverload = false;\n+        }\n+        if ((YL + (-XL + XR)) > 1 || (YL + (-XL + XR)) < -1) {\n+            brOverload = true;\n+        } else {\n+            brOverload = false;\n+        }\n+        if (frOverload == true || flOverload == true || blOverload == true || brOverload == true) {\n+            if (flScale > frScale && flScale > brScale && flScale > blScale) {\n+                mYL = YL / Math.abs(flScale);\n+                mXL = XL / Math.abs(flScale);\n+                mXR = XR / Math.abs(flScale);\n+            } else if (frScale > flScale && frScale > brScale && frScale > blScale) {\n+                mYL = YL / Math.abs(frScale);\n+                mXL = XL / Math.abs(frScale);\n+                mXR = XR / Math.abs(frScale);\n+            } else if (blScale > frScale && blScale > brScale && blScale > flScale) {\n+                mYL = YL / Math.abs(blScale);\n+                mXL = XL / Math.abs(blScale);\n+                mXR = XR / Math.abs(blScale);\n+            } else if (brScale > frScale && brScale > flScale && brScale > blScale) {\n+                mYL = YL / Math.abs(brScale);\n+                mXL = XL / Math.abs(brScale);\n+                mXR = XR / Math.abs(brScale);\n+            }\n+\n+        }\n+        if (frOverload == false && flOverload == false && brOverload == false && blOverload == false) {\n+            motor_drive_flAsDcMotor.setPower((-YL - (-XL - XR)));\n+            motor_drive_blAsDcMotor.setPower((YL - (-XL + XR)));\n+            motor_drive_frAsDcMotor.setPower((-YL + XL - XR));\n+            motor_drive_brAsDcMotor.setPower((YL + (XL + XR)));\n+        } else {\n+            motor_drive_flAsDcMotor.setPower((-mYL - (-mXL - mXR)));\n+            motor_drive_blAsDcMotor.setPower((mYL - (-mXL + mXR)));\n+            motor_drive_frAsDcMotor.setPower((-mYL + mXL - mXR));\n+            motor_drive_brAsDcMotor.setPower((mYL + (mXL + mXR)));\n+        }\n+\n+\n     }\n+\n+    private void wallTargetTracking(VuforiaLocalizer vufor, Iterable<? extends VuforiaTrackable> allTrackables,\n+                                    int camDir, double xTarget, double yTarget, double yawTarget, double linTol, double angleTol, double pGain,\n+                                    long timeOut, boolean TrueTracking, double TargetAngle) {\n+\n+            /*  I am a function that tracks a wall target using Vuforia using parameters passed on to me\n+                camDir - Direction that my webcam is pointed.  -1 is to the left, 0 is straight ahead, 1 is to the right\n+                xTarget - X coordinate target value\n+                yTarget - Y coord target value\n+                yawTarget - yaw angle target value\n+                linTol - XY distance tolerance before deciding we are at target location\n+                angleTol - angular tolerance before deciding we are at the target location\n+                pGain - Overall Proportional gain for motor commands based on error\n+                timeOut - How long to wait before exiting function\n+             */\n+        if (TrueTracking == true) {\n+            TrueTrackSwitch = 1;\n+            IMUTrackSwitch = 0;\n+        } else if (TrueTracking == false) {\n+            IMUTrackSwitch = 1;\n+            TrueTrackSwitch = 0;\n+        }\n+        boolean exitFlag = false;\n+        ElapsedTime exitTimer = new ElapsedTime();\n+        exitTimer.reset();\n+        LastVal = CurrentVal = 175;\n+        //   (!exitFlag && (exitTimer.time() <= timeOut)) ||\n+        while ((!(yTarget - CurrentY <= 0.75 && yTarget - CurrentY >= -0.75 && xTarget - CurrentX <= 0.75 && xTarget - CurrentX >= -0.75 && (-TargetAngle + CurrentHeading) <= 2 && (-TargetAngle + CurrentHeading) >= -2))) {\n+            if (isStopRequested()) {\n+                break;\n+            }\n+            BulkCaching();\n+            // express the rotation of the robot in degrees.\n+            // check all the trackable targets to see which one (if any) is visible.\n+            telemetry.addData(\"YOffset\", 18.1 - CurrentY);\n+            telemetry.addData(\"XOffset\", 1.9 - CurrentX);\n+            telemetry.update();\n+            for (VuforiaTrackable trackable : allTrackables) {\n+                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) {\n+                    targetVisible = true;\n+\n+                    // getUpdatedRobotLocation() will return null if no new information is available since\n+                    // the last time that call was made, or if the trackable is not currently visible.\n+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener) trackable.getListener()).getUpdatedRobotLocation();\n+                    if (robotLocationTransform != null) {\n+                        lastLocation = robotLocationTransform;\n+                    }\n+                    break;\n+                } else {\n+                    targetVisible = false;\n+                }\n+            }\n+\n+\n+            // Provide feedback as to where the robot is located (if we know).\n+            if (targetVisible) {\n+                VectorF translation = lastLocation.getTranslation();\n+                CurrentY = translation.get(1) / mmPerInch;\n+                CurrentX = translation.get(0) / mmPerInch;\n+                angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\n+                CurrentHeading = angles.firstAngle;\n+\n+                //telemetry.addData(\"Pos (in)\", \"{X, Y, Z} = %.1f, %.1f, %.1f\",\n+                //        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);\n+\n+                // express the rotation of the robot in degrees.\n+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);\n+                //telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+\n+                CurrentVal = rotation.thirdAngle;\n+/*                        //                   telemetry.addData(\"Rot (deg)\", \"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);\n+                        if (LastVal - CurrentVal > 180){\n+                            CurrentVal += 360;\n+                        }\n+                        else if(LastVal - CurrentVal < -180){\n+                            CurrentVal -= 360;\n+                        }\n+                        if (TrueTrackSwitch == 1){\n+                            telemetry.addData(\"Switch on!\",1);\n+                        }\n+                        else if (TrueTrackSwitch == 0) {\n+                            telemetry.addData(\"Switch Off!\", -TargetAngle + CurrentHeading);\n+                        }\n+  */\n+                telemetry.update();\n+\n+//                        Heading = (180 + (180 - rotation.thirdAngle));\n+                if (camDir == 90) {\n+                    MecanumFunction(1 * (-0.013 * (xTarget - CurrentX)), (-1 * (0.021 * (yTarget - CurrentY))), TrueTrackSwitch * (-0.0075 * (yawTarget - (CurrentVal))) + (-1 * IMUTrackSwitch * -0.02 * (-TargetAngle + CurrentHeading)));\n+                }\n+                //else if (camDir == 90){\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+                //}\n+                //else {\n+                //    MecanumFunction(0 * (-0.02 * (40 - CurrentX)), (0 * (-0.02 * (-3 - CurrentY))), TrueTrackSwitch * (0.0008 * (yawTarget - (180 + Zrot) + (IMUTrackSwitch * 0.0008 * (-TargetAngle + CurrentHeading)))));\n+\n+                //}\n+            } else {\n+                telemetry.addData(\"Visible Target\", \"none\");\n+\n+                MecanumFunction(0, 0, 0);\n+                break;\n+            }\n+//                    telemetry.update();\n+            LastVal = CurrentVal;\n+\n+        }\n+    }\n+\n+\n }\n\\ No newline at end of file"
  },
  {
    "sha": "428500cb07a2c72ef3bee90619490e942d989d44",
    "filename": "TeamCode/src/main/java/org/firstinspires/ftc/teamcode/VuforiaTestAS.java",
    "status": "modified",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/VuforiaTestAS.java",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/VuforiaTestAS.java",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/VuforiaTestAS.java?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -35,7 +35,6 @@\n import com.qualcomm.robotcore.eventloop.opmode.TeleOp;\n \n import org.firstinspires.ftc.robotcore.external.ClassFactory;\n-import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\n import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\n import org.firstinspires.ftc.robotcore.external.matrices.VectorF;\n import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\n@@ -124,7 +123,6 @@\n      * This is the webcam we are to use. As with other hardware devices such as motors and\n      * servos, this device is identified using the robot configuration tool in the FTC application.\n      */\n-    WebcamName webcamName = null;\n \n     private boolean targetVisible = false;\n     private float phoneXRotate = 0;\n@@ -136,7 +134,6 @@ public void runOpMode() {\n         /*\n          * Retrieve the camera we are to use.\n          */\n-        webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\n \n         /*\n          * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\n@@ -153,7 +150,6 @@ public void runOpMode() {\n         /**\n          * We also indicate which camera on the RC we wish to use.\n          */\n-        parameters.cameraName = webcamName;\n \n         // Make sure extended tracking is disabled for this example.\n         parameters.useExtendedTracking = false;"
  },
  {
    "sha": "9075dde24d5ba3ff681421cd642b0ef801a2ce2b",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/build.gradle",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/build.gradle",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/build.gradle?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -9,7 +9,7 @@ buildscript {\n         jcenter()\n     }\n     dependencies {\n-        classpath 'com.android.tools.build:gradle:4.0.2'\n+        classpath 'com.android.tools.build:gradle:4.1.2'\n     }\n }\n "
  },
  {
    "sha": "1babd2f6c13a1b3af0e4da554593e1c483befdd1",
    "filename": "gradle/wrapper/gradle-wrapper.properties",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/WrenchDressing/UltimateGoal/blob/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/gradle/wrapper/gradle-wrapper.properties",
    "raw_url": "https://github.com/WrenchDressing/UltimateGoal/raw/90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04/gradle/wrapper/gradle-wrapper.properties",
    "contents_url": "https://api.github.com/repos/WrenchDressing/UltimateGoal/contents/gradle/wrapper/gradle-wrapper.properties?ref=90e3fbdaa1a2ec540ad7caaa6d0a88999d2dfe04",
    "patch": "@@ -1,6 +1,6 @@\n-#Fri Jul 24 14:30:03 PDT 2020\n+#Wed Mar 03 18:46:07 CST 2021\n distributionBase=GRADLE_USER_HOME\n distributionPath=wrapper/dists\n zipStoreBase=GRADLE_USER_HOME\n zipStorePath=wrapper/dists\n-distributionUrl=https\\://services.gradle.org/distributions/gradle-6.1.1-all.zip\n+distributionUrl=https\\://services.gradle.org/distributions/gradle-6.5-bin.zip"
  }
]
