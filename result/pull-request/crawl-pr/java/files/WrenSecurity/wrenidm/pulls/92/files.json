[
  {
    "sha": "eafe484bf290a6fa7285d744474db700854ea7b1",
    "filename": "legal/THIRDPARTYREADME.txt",
    "status": "modified",
    "additions": 0,
    "deletions": 25,
    "changes": 25,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/legal/THIRDPARTYREADME.txt",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/legal/THIRDPARTYREADME.txt",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/legal/THIRDPARTYREADME.txt?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -7,20 +7,10 @@ Apache Software License, Version 2.0\n Version: less-1.5.1-min.js\r\n Copyright: Copyright (c) 2009-2013, Alexis Sellier <self@cloudhead.net>\r\n \r\n-Version: orientdb-api.js\r\n-Copyright: Copyright 1999-2010 Luca Molino\r\n \r\n-Version: orientdb-app.js\r\n-Copyright: Copyright 1999-2010 Luca Garulli (l.garulli--at--orientechnologies.com)\r\n \r\n-Version: orientdb-controller.js\r\n-Copyright: Copyright 1999-2011 Luca Garulli (l.garulli--at--orientechnologies.com)\r\n \r\n-Version: orientdb-form.js\r\n-Copyright: Copyright 1999-2011 Luca Garulli (l.garulli--at--orientechnologies.com)\r\n \r\n-Version: orientweb-crud.js\r\n-Copyright: Copyright 1999-2010 Luca Garulli (l.garulli--at--orientechnologies.com)\r\n \r\n Version: felix.jar\r\n Copyright: Copyright 2006 The Apache Software Foundation\r\n@@ -232,23 +222,11 @@ Version: org.springframework:spring-beans:jar:2.5.6.SEC01\n          org.springframework:spring-context:jar:2.5.6.SEC01\r\n Copyright:  Copyright 2002-2015 the original author or authors.\r\n \r\n-Version: orient-commons-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n-Version: orientdb-client-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n-Version: orientdb-core-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n-Version: orientdb-enterprise-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n-Version: orientdb-server-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n-Version: orientdb-nativeos-1.7.10.jar\r\n-Copyright: Copyright 2010-2012 Luca Garulli (l.garulli(at)orientechnologies.com)\r\n \r\n Version: pax-swissbox-extender-1.8.0.jar\r\n Copyright: Copyright 2007-2008 Alin Dreghiciu.\r\n@@ -722,9 +700,6 @@ Copyright: Copyright 2015 ForgeRock AS.\n Version: openidm-repo-jdbc-4.0.0.jar\r\n Copyright: Copyright 2015 ForgeRock AS.\r\n \r\n-Version: openidm-repo-orientdb-4.0.0.jar\r\n-Copyright: Copyright 2015 ForgeRock AS.\r\n-\r\n Version: openidm-router-4.0.0.jar\r\n Copyright: Copyright 2015 ForgeRock AS.\r\n \r"
  },
  {
    "sha": "38dde342a7305b92206d566de097bfc4233443c7",
    "filename": "openidm-infoservice/src/main/java/org/forgerock/openidm/info/impl/HealthService.java",
    "status": "modified",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-infoservice/src/main/java/org/forgerock/openidm/info/impl/HealthService.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-infoservice/src/main/java/org/forgerock/openidm/info/impl/HealthService.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-infoservice/src/main/java/org/forgerock/openidm/info/impl/HealthService.java?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -168,7 +168,7 @@\n      * Bundles and bundle fragments required to be started or resolved respectively for the system to\n      * consider itself READY. Required bundles may be expressed as a regex, for example:\n      *\n-     * \"org.forgerock.openidm.repo-(orientdb|jdbc)\"\n+     * \"org.forgerock.openidm.repo-jdbc\"\n      */\n     private List<String> requiredBundles = new ArrayList<String>();\n \n@@ -225,7 +225,7 @@\n         \"org.forgerock.openidm.provisioner-openicf\",\n         \"org.forgerock.openidm.quartz-fragment\",\n         \"org.forgerock.openidm.repo\",\n-        \"org.forgerock.openidm.repo-(orientdb|jdbc)\",\n+        \"org.forgerock.openidm.repo-jdbc\",\n         \"org.forgerock.openidm.router\",\n         \"org.forgerock.openidm.scheduler\",\n         \"org.forgerock.openidm.security\",\n@@ -252,21 +252,21 @@\n      * Services required to be registered for the system to consider itself READY. Required services\n      * may be expressed as a regex, for example:\n      *\n-     * \"org.forgerock.openidm.bootrepo.(orientdb|jdbc)\"\n+     * \"org.forgerock.openidm.bootrepo.jdbc\"\n      */\n     private List<String> requiredServices = new ArrayList<String>();\n \n     /**\n      * An array default services required to be registered for the system to consider itself READY.\n      * Required services may be expressed as a regex, for example:\n      *\n-     * \"org.forgerock.openidm.bootrepo.(orientdb|jdbc)\"\n+     * \"org.forgerock.openidm.bootrepo.jdbc\"\n      */\n     private final String[] defaultRequiredServices = new String[] {\n             \"org.forgerock.openidm.api-servlet\",\n             \"org.forgerock.openidm.audit\",\n             \"org.forgerock.openidm.authentication\",\n-            \"org.forgerock.openidm.bootrepo.(orientdb|jdbc)\",\n+            \"org.forgerock.openidm.bootrepo.jdbc\",\n             \"org.forgerock.openidm.cluster\",\n             \"org.forgerock.openidm.config.enhanced\",\n             \"org.forgerock.openidm.config.manage\",\n@@ -277,7 +277,7 @@\n             \"org.forgerock.openidm.policy\",\n             \"org.forgerock.openidm.provisioner\",\n             \"org.forgerock.openidm.provisioner.openicf.connectorinfoprovider\",\n-            \"org.forgerock.openidm.repo.(orientdb|jdbc)\",\n+            \"org.forgerock.openidm.repo.jdbc\",\n             \"org.forgerock.openidm.router.internal\",\n             \"org.forgerock.openidm.router.servlet\",\n             \"org.forgerock.openidm.scheduler\",\n@@ -560,7 +560,7 @@ private void checkState() {\n \n         // Scan the registered services for matches to our list of\n         // required services.  Required services can be expressed as a regex,\n-        // for example: \"org.forgerock.openidm.bootrepo.(orientdb|jdbc)\"\n+        // for example: \"org.forgerock.openidm.bootrepo.jdbc\"\n         List<String> missingServices = new ArrayList<String>(requiredServices);\n         if (refs != null && refs.length > 0) {\n             for (String req : requiredServices) {"
  },
  {
    "sha": "1173f7a208dc4b1a0c42369958e15d206cace51c",
    "filename": "openidm-maintenance/src/main/java/org/forgerock/openidm/maintenance/upgrade/UpdateManagerImpl.java",
    "status": "modified",
    "additions": 0,
    "deletions": 4,
    "changes": 4,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-maintenance/src/main/java/org/forgerock/openidm/maintenance/upgrade/UpdateManagerImpl.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-maintenance/src/main/java/org/forgerock/openidm/maintenance/upgrade/UpdateManagerImpl.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-maintenance/src/main/java/org/forgerock/openidm/maintenance/upgrade/UpdateManagerImpl.java?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -1167,10 +1167,6 @@ void replaceBundle(BundleHandler bundleHandler, Path path) throws IOException, U\n         }\n \n         void createNewConfig(Path path) throws IOException, UpdateException {\n-            // Never create this file if it is missing -- the installed IDM uses another database\n-            if (path.getFileName().toString().equals(\"repo.orientdb.json\")) {\n-                return;\n-            }\n             File configFile = new File(new File(tempDirectory.toString(), \"openidm\").toString(),\n                     path.toString());\n             UpdateFileLogEntry fileEntry = new UpdateFileLogEntry()"
  },
  {
    "sha": "d78a548c8b91b7199c834b21c262c61131fa8de6",
    "filename": "openidm-repo-jdbc/pom.xml",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/pom.xml",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/pom.xml",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-jdbc/pom.xml?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -71,6 +71,11 @@\n             <version>${project.version}</version>\n         </dependency>\n \n+        <dependency>\n+          <groupId>com.h2database</groupId>\n+          <artifactId>h2</artifactId>\n+        </dependency>\n+\n         <dependency>\n             <groupId>org.forgerock.openidm</groupId>\n             <artifactId>openidm-util</artifactId>"
  },
  {
    "sha": "6baf293937547fcc5cbae46580e5706e5bdb6b20",
    "filename": "openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2MappedTableHandler.java",
    "status": "added",
    "additions": 61,
    "deletions": 0,
    "changes": 61,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2MappedTableHandler.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2MappedTableHandler.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2MappedTableHandler.java?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -0,0 +1,61 @@\n+package org.forgerock.openidm.repo.jdbc.impl;\n+\n+import org.forgerock.json.JsonValue;\n+import org.forgerock.json.resource.InternalServerErrorException;\n+import org.forgerock.openidm.crypto.CryptoService;\n+import org.forgerock.openidm.repo.jdbc.SQLExceptionHandler;\n+import org.forgerock.openidm.util.Accessor;\n+\n+import java.util.Map;\n+\n+public class H2MappedTableHandler extends MappedTableHandler {\n+\n+    public H2MappedTableHandler(String tableName, Map<String, Object> mapping, String dbSchemaName, JsonValue queriesConfig, JsonValue commandsConfig,\n+            SQLExceptionHandler sqlExceptionHandler, Accessor<CryptoService> cryptoServiceAccessor) throws InternalServerErrorException {\n+        super(tableName, mapping, dbSchemaName, queriesConfig, commandsConfig, sqlExceptionHandler, cryptoServiceAccessor);\n+    }\n+\n+    @Override\n+    protected void initializeQueries() {\n+        final String mainTable = dbSchemaName == null ? tableName : dbSchemaName + \".\" + tableName;\n+        final StringBuffer colNames = new StringBuffer();\n+        final StringBuffer tokenNames = new StringBuffer();\n+        final StringBuffer prepTokens = new StringBuffer();\n+        final StringBuffer updateAssign = new StringBuffer();\n+        boolean isFirst = true;\n+\n+        for (ColumnMapping colMapping : explicitMapping.getColumnMappings()) {\n+            if (!isFirst) {\n+                colNames.append(\", \");\n+                tokenNames.append(\",\");\n+                prepTokens.append(\",\");\n+                updateAssign.append(\", \");\n+            }\n+            colNames.append(colMapping.dbColName);\n+            tokenNames.append(\"${\").append(colMapping.objectColName).append(\"}\");\n+\n+            if (ColumnMapping.TYPE_JSON_LIST.equals(colMapping.dbColType) ||\n+                    ColumnMapping.TYPE_JSON_MAP.equals(colMapping.dbColType)) {\n+                prepTokens.append(\"? FORMAT JSON\");\n+                updateAssign.append(colMapping.dbColName).append(\" = ? FORMAT JSON\");\n+            } else {\n+                prepTokens.append(\"?\");\n+                updateAssign.append(colMapping.dbColName).append(\" = ?\");\n+            }\n+\n+            tokenReplacementPropPointers.add(colMapping.objectColPointer);\n+            isFirst = false;\n+        }\n+\n+        readQueryStr = \"SELECT * FROM \" + mainTable + \" WHERE objectid = ?\";\n+        readForUpdateQueryStr = \"SELECT * FROM \" + mainTable + \" WHERE objectid = ? FOR UPDATE\";\n+        createQueryStr =\n+                \"INSERT INTO \" + mainTable + \" (\" + colNames + \") VALUES ( \" + prepTokens + \")\";\n+        updateQueryStr = \"UPDATE \" + mainTable + \" SET \" + updateAssign + \" WHERE objectid = ?\";\n+        deleteQueryStr = \"DELETE FROM \" + mainTable + \" WHERE objectid = ? AND rev = ?\";\n+\n+        logger.debug(\"Unprepared query strings {} {} {} {} {}\",\n+                readQueryStr, createQueryStr, updateQueryStr, deleteQueryStr);\n+    }\n+\n+}"
  },
  {
    "sha": "06d905bd7460c3ef5135ddbd55bed7a93b35ded8",
    "filename": "openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2TableHandler.java",
    "status": "added",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2TableHandler.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2TableHandler.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/H2TableHandler.java?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -0,0 +1,31 @@\n+package org.forgerock.openidm.repo.jdbc.impl;\n+\n+import org.forgerock.json.JsonValue;\n+import org.forgerock.openidm.repo.jdbc.SQLExceptionHandler;\n+import org.forgerock.openidm.repo.jdbc.impl.GenericTableHandler.QueryDefinition;\n+\n+import java.util.Map;\n+\n+public class H2TableHandler extends GenericTableHandler {\n+\n+    public H2TableHandler(JsonValue tableConfig, String dbSchemaName, JsonValue queriesConfig, JsonValue commandsConfig, int maxBatchSize,\n+            SQLExceptionHandler sqlExceptionHandler) {\n+        super(tableConfig, dbSchemaName, queriesConfig, commandsConfig, maxBatchSize, sqlExceptionHandler);\n+    }\n+\n+    protected Map<QueryDefinition, String> initializeQueryMap() {\n+        Map<QueryDefinition, String> result = super.initializeQueryMap();\n+\n+        String typeTable = dbSchemaName == null ? \"objecttypes\" : dbSchemaName + \".objecttypes\";\n+        String mainTable = dbSchemaName == null ? mainTableName : dbSchemaName + \".\" + mainTableName;\n+        String propertyTable = dbSchemaName == null ? propTableName : dbSchemaName + \".\" + propTableName;\n+\n+        result.put(QueryDefinition.UPDATEQUERYSTR, \"UPDATE \" + mainTable + \" SET objectid = ?, rev = ?, fullobject = ? FORMAT JSON WHERE id = ?\");\n+        result.put(QueryDefinition.CREATEQUERYSTR, \"INSERT INTO \" + mainTable + \" (objecttypes_id, objectid, rev, fullobject) VALUES (?,?,?,? FORMAT JSON)\");\n+        result.put(QueryDefinition.DELETEQUERYSTR, \"DELETE FROM \" + mainTable + \" obj WHERE EXISTS (SELECT 1 FROM \" + typeTable + \" objtype WHERE obj.objecttypes_id = objtype.id AND objtype.objecttype = ?) AND obj.objectid = ? AND obj.rev = ?\");\n+        result.put(QueryDefinition.PROPDELETEQUERYSTR, \"DELETE FROM \" + propertyTable + \" WHERE \" + mainTableName + \"_id IN (SELECT obj.id FROM \" + mainTable + \" obj INNER JOIN \" + typeTable + \" objtype ON obj.objecttypes_id = objtype.id WHERE objtype.objecttype = ? AND obj.objectid = ?)\");\n+        result.put(QueryDefinition.READFORUPDATEQUERYSTR, \"SELECT obj.* FROM \" + mainTable + \" obj INNER JOIN \" + typeTable + \" objtype ON obj.objecttypes_id = objtype.id AND objtype.objecttype = ? WHERE obj.objectid  = ? FOR UPDATE OF obj\");\n+        return result;\n+    }\n+\n+}"
  },
  {
    "sha": "eaede4dd2f1ed255298b034be0f4fb70d79c865e",
    "filename": "openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/JDBCRepoService.java",
    "status": "modified",
    "additions": 7,
    "deletions": 0,
    "changes": 7,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/JDBCRepoService.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/a55d18fd580d2a05da3238daff7e25a732e55acc/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/JDBCRepoService.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-jdbc/src/main/java/org/forgerock/openidm/repo/jdbc/impl/JDBCRepoService.java?ref=a55d18fd580d2a05da3238daff7e25a732e55acc",
    "patch": "@@ -998,6 +998,10 @@ GenericTableHandler getGenericTableHandler(DatabaseType databaseType, JsonValue\n             return\n                     new OracleTableHandler(tableConfig, dbSchemaName, queries, commands, maxBatchSize,\n                             new DefaultSQLExceptionHandler());\n+        case H2:\n+            return\n+                    new H2TableHandler(tableConfig, dbSchemaName, queries, commands, maxBatchSize,\n+                            new DefaultSQLExceptionHandler());\n         case POSTGRESQL:\n             return\n                     new PostgreSQLTableHandler(tableConfig, dbSchemaName, queries, commands, maxBatchSize,\n@@ -1040,6 +1044,9 @@ public CryptoService access() {\n             return\n                     new OracleMappedTableHandler(table, objectToColumn, dbSchemaName, explicitQueries, explicitCommands,\n                             new DefaultSQLExceptionHandler(), cryptoServiceAccessor);\n+        case H2:\n+            return new H2MappedTableHandler(table, objectToColumn, dbSchemaName, explicitQueries, explicitCommands,\n+                    new DefaultSQLExceptionHandler(), cryptoServiceAccessor);\n         case POSTGRESQL:\n             return\n                     new PostgreSQLMappedTableHandler(table, objectToColumn, dbSchemaName, explicitQueries, explicitCommands,"
  },
  {
    "sha": "e76b9e1024c417d65006bb9b2bb5d36290fda8b5",
    "filename": "openidm-repo-orientdb/pom.xml",
    "status": "removed",
    "additions": 0,
    "deletions": 193,
    "changes": 193,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/pom.xml",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/pom.xml",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/pom.xml?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,193 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n-  ~ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n-  ~\n-  ~ Copyright (c) 2011-2014 ForgeRock AS. All Rights Reserved\n-  ~ Portions Copyright 2017-2020 Wren Security.\n-  ~\n-  ~ The contents of this file are subject to the terms\n-  ~ of the Common Development and Distribution License\n-  ~ (the License). You may not use this file except in\n-  ~ compliance with the License.\n-  ~\n-  ~ You can obtain a copy of the License at\n-  ~ http://forgerock.org/license/CDDLv1.0.html\n-  ~ See the License for the specific language governing\n-  ~ permission and limitations under the License.\n-  ~\n-  ~ When distributing Covered Code, include this CDDL\n-  ~ Header Notice in each file and include the License file\n-  ~ at http://forgerock.org/license/CDDLv1.0.html\n-  ~ If applicable, add the following below the CDDL Header,\n-  ~ with the fields enclosed by brackets [] replaced by\n-  ~ your own identifying information:\n-  ~ \"Portions Copyrighted [year] [name of copyright owner]\"\n-  -->\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n-    <modelVersion>4.0.0</modelVersion>\n-\n-    <parent>\n-        <groupId>org.forgerock.openidm</groupId>\n-        <artifactId>openidm-project</artifactId>\n-        <version>6.0.0-SNAPSHOT</version>\n-    </parent>\n-\n-    <artifactId>openidm-repo-orientdb</artifactId>\n-    <packaging>bundle</packaging>\n-\n-    <name>Wren:IDM - Repository Bundle - OrientDB</name>\n-    <description>\n-        This bundle provides an OrientDB-based repository for objects and settings.\n-    </description>\n-\n-    <properties>\n-        <openidm.osgi.import.before.defaults>!org.testng.annotations</openidm.osgi.import.before.defaults>\n-    </properties>\n-\n-    <dependencies>\n-        <dependency>\n-            <groupId>org.forgerock.commons</groupId>\n-            <artifactId>json-resource</artifactId>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-repo</artifactId>\n-            <version>${project.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-enhanced-config</artifactId>\n-            <version>${project.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-config</artifactId>\n-            <version>${project.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-smartevent</artifactId>\n-            <version>${project.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-util</artifactId>\n-            <version>${project.version}</version>\n-        </dependency>\n-\n-        <!-- Commons -->\n-        <dependency>\n-            <groupId>org.forgerock.commons.guava</groupId>\n-            <artifactId>forgerock-guava-collect</artifactId>\n-        </dependency>\n-\n-        <!-- OrientDB -->\n-        <dependency>\n-            <groupId>com.orientechnologies</groupId>\n-            <artifactId>orientdb-core</artifactId>\n-            <version>${orientdb.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>com.orientechnologies</groupId>\n-            <artifactId>orient-commons</artifactId>\n-            <version>${orientdb.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>com.orientechnologies</groupId>\n-            <artifactId>orientdb-server</artifactId>\n-            <version>${orientdb.version}</version>\n-            <exclusions>\n-                <exclusion>\n-                    <groupId>javax.activation</groupId>\n-                    <artifactId>activation</artifactId>\n-                </exclusion>\n-            </exclusions>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>com.orientechnologies</groupId>\n-            <artifactId>orientdb-enterprise</artifactId>\n-            <version>${orientdb.version}</version>\n-        </dependency>\n-\n-        <dependency>\n-          <groupId>org.xerial.snappy</groupId>\n-          <artifactId>snappy-java</artifactId>\n-          <version>1.1.1.6</version>\n-        </dependency>\n-\n-<!--        <dependency>\n-            <groupId>javax.persistence</groupId>\n-            <artifactId>persistence-api</artifactId>\n-            <version>1.0</version>\n-            <scope>provided</scope>\n-        </dependency>\n--->\n-        <!-- Provided OSGi Dependencies -->\n-        <dependency>\n-            <groupId>org.osgi</groupId>\n-            <artifactId>osgi.core</artifactId>\n-\n-            <scope>provided</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.osgi</groupId>\n-            <artifactId>osgi.cmpn</artifactId>\n-            <scope>provided</scope>\n-        </dependency>\n-\n-        <!-- Test Dependencies -->\n-        <dependency>\n-            <groupId>org.assertj</groupId>\n-            <artifactId>assertj-core</artifactId>\n-            <scope>test</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.testng</groupId>\n-            <artifactId>testng</artifactId>\n-            <scope>test</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.mockito</groupId>\n-            <artifactId>mockito-core</artifactId>\n-            <scope>test</scope>\n-        </dependency>\n-\n-        <dependency>\n-            <groupId>org.forgerock.openidm</groupId>\n-            <artifactId>openidm-system</artifactId>\n-            <version>${project.version}</version>\n-            <type>test-jar</type>\n-            <scope>test</scope>\n-        </dependency>\n-    </dependencies>\n-\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.felix</groupId>\n-                <artifactId>maven-bundle-plugin</artifactId>\n-                <extensions>true</extensions>\n-\n-                <configuration>\n-                    <instructions>\n-                        <Embed-Dependency>persistence-api;scope=provided</Embed-Dependency>\n-                        <Export-Package>org.forgerock.openidm.repo.orientdb.metadata;version=${project.version}</Export-Package>\n-                        <Private-Package>org.forgerock.openidm.repo.orientdb.impl.*</Private-Package>\n-                        <Bundle-Activator>org.forgerock.openidm.repo.orientdb.impl.Activator</Bundle-Activator>\n-                    </instructions>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n-</project>"
  },
  {
    "sha": "f17f2387978b45d690044cc41b60ab90893ac90c",
    "filename": "openidm-repo-orientdb/src/license/THIRD-PARTY.properties",
    "status": "removed",
    "additions": 0,
    "deletions": 1,
    "changes": 1,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/license/THIRD-PARTY.properties",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/license/THIRD-PARTY.properties",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/license/THIRD-PARTY.properties?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1 +0,0 @@\n-org.osgi--org.osgi.compendium--4.2.0=Apache 2.0"
  },
  {
    "sha": "570e696d94d4b4837e52ff14031aad382bee4197",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/Activator.java",
    "status": "removed",
    "additions": 0,
    "deletions": 86,
    "changes": 86,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/Activator.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/Activator.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/Activator.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,86 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2015 ForgeRock AS.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import java.util.HashMap;\n-import java.util.Hashtable;\n-import java.util.Map;\n-\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.openidm.config.persistence.ConfigBootstrapHelper;\n-import org.forgerock.openidm.repo.RepoBootService;\n-import org.osgi.framework.BundleActivator;\n-import org.osgi.framework.BundleContext;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * OSGi bundle activator\n- */\n-public class Activator implements BundleActivator {\n-    final static Logger logger = LoggerFactory.getLogger(Activator.class);\n-\n-    // Bootstrap repository\n-    OrientDBRepoService bootSvc;\n-    \n-    public void start(BundleContext context) {\n-        logger.trace(\"OrientDB bundle starting\");\n-        \n-        JsonValue repoConfig = ConfigBootstrapHelper.getRepoBootConfig(\"orientdb\", context);\n-         \n-        if (repoConfig != null) {\n-            logger.info(\"Bootstrapping OrientDB repository\");\n-            // Only take the configuration strictly needed for bootstrapping the repository\n-            // Also, bootstrap property keys are lower case, Repo expects camel case\n-            Map<String,Object> bootConfig = new HashMap<String,Object>();\n-            bootConfig.put(OrientDBRepoService.CONFIG_DB_URL, repoConfig.get(OrientDBRepoService.CONFIG_DB_URL.toLowerCase()).getObject());\n-            bootConfig.put(OrientDBRepoService.CONFIG_USER, repoConfig.get(OrientDBRepoService.CONFIG_USER.toLowerCase()).getObject());\n-            bootConfig.put(OrientDBRepoService.CONFIG_PASSWORD, repoConfig.get(OrientDBRepoService.CONFIG_PASSWORD.toLowerCase()).getObject());\n-            bootConfig.put(OrientDBRepoService.CONFIG_POOL_MIN_SIZE, repoConfig.get(OrientDBRepoService.CONFIG_POOL_MIN_SIZE.toLowerCase()).getObject());\n-            bootConfig.put(OrientDBRepoService.CONFIG_POOL_MAX_SIZE, repoConfig.get(OrientDBRepoService.CONFIG_POOL_MAX_SIZE.toLowerCase()).getObject());\n-\n-            // Init the bootstrap repo\n-            bootSvc = OrientDBRepoService.getRepoBootService(bootConfig);\n-             \n-            // Register bootstrap repo\n-            Hashtable<String, String> prop = new Hashtable<String, String>();\n-            prop.put(\"service.pid\", \"org.forgerock.openidm.bootrepo.orientdb\");\n-            prop.put(\"openidm.router.prefix\", \"bootrepo\");\n-            prop.put(\"db.type\", \"OrientDB\");\n-            context.registerService(RepoBootService.class.getName(), bootSvc, prop);\n-            logger.info(\"Registered bootstrap repo service\");\n-        } else {\n-            logger.debug(\"No OrientDB configuration detected\");\n-        }\n-        logger.trace(\"OrientDB bundle started\");\n-    }\n-\n-    public void stop(BundleContext context) {\n-        if (bootSvc != null) {\n-            logger.debug(\"Cleaning up OrientDB bootstrap repository\");\n-            bootSvc.cleanup();\n-        }\n-        logger.trace(\"OrientDB bundle stopped\");\n-    }\n-}"
  },
  {
    "sha": "9d46de3c416cdda0c6bc10fad1d1adfa65d9d2b0",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DBHelper.java",
    "status": "removed",
    "additions": 0,
    "deletions": 576,
    "changes": 576,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DBHelper.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DBHelper.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DBHelper.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,576 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2015 ForgeRock AS.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.json.resource.ConflictException;\n-import org.forgerock.openidm.config.enhanced.InvalidException;\n-import org.forgerock.openidm.util.RelationshipUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.orientechnologies.common.exception.OException;\n-import com.orientechnologies.orient.core.config.OGlobalConfiguration;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentPool;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.index.OIndex;\n-import com.orientechnologies.orient.core.index.OIndexManager;\n-import com.orientechnologies.orient.core.metadata.schema.OClass;\n-import com.orientechnologies.orient.core.metadata.schema.OProperty;\n-import com.orientechnologies.orient.core.metadata.schema.OSchema;\n-import com.orientechnologies.orient.core.metadata.schema.OType;\n-import com.orientechnologies.orient.core.metadata.security.ORole;\n-import com.orientechnologies.orient.core.metadata.security.OSecurity;\n-import com.orientechnologies.orient.core.metadata.security.OUser;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.core.storage.OStorage;\n-\n-import java.util.Collection;\n-import java.util.Set;\n-\n-import static org.forgerock.json.JsonValue.array;\n-import static org.forgerock.json.JsonValue.json;\n-import static org.forgerock.json.JsonValue.field;\n-import static org.forgerock.json.JsonValue.object;\n-\n-/**\n- * A Helper to interact with the OrientDB\n- */\n-public class DBHelper {\n-    final static Logger logger = LoggerFactory.getLogger(DBHelper.class);\n-\n-    private static Map<String, ODatabaseDocumentPool> pools = new HashMap<String, ODatabaseDocumentPool>();\n-\n-    /**\n-     * Get the DB pool for the given URL. May return an existing pool instance.\n-     * Also can initialize/create/update the DB to meet the passed\n-     * configuration if setupDB is enabled\n-     *\n-     * Do not close the returned pool directly as it may be used by others.\n-     *\n-     * To cleanly shut down the application, call closePools at the end\n-     *\n-     * @param dbURL the orientdb URL\n-     * @param user the orientdb user to connect\n-     * @param password the orientdb password to connect\n-     * @param minSize the orientdb pool minimum size\n-     * @param maxSize the orientdb pool maximum size\n-     * @param completeConfig the full configuration for the DB\n-     * @param setupDB true if it should also check the DB exists in the state\n-     * to match the passed configuration, and to set it up to match\n-     * @return the pool\n-     * @throws org.forgerock.openidm.config.enhanced.InvalidException\n-     */\n-    public synchronized static ODatabaseDocumentPool getPool(String dbURL, String user, String password,\n-            int minSize, int maxSize, JsonValue completeConfig, boolean setupDB) throws InvalidException {\n-\n-        ODatabaseDocumentTx setupDbConn = null;\n-        ODatabaseDocumentPool pool = null;\n-        try {\n-            if (setupDB) {\n-                logger.debug(\"Check DB exists in expected state for pool {}\", dbURL);\n-                setupDbConn = checkDB(dbURL, user, password, completeConfig);\n-            }\n-            logger.debug(\"Getting pool {}\", dbURL);\n-            pool = pools.get(dbURL);\n-            if (pool == null) {\n-                pool = initPool(dbURL, user, password, minSize, maxSize);\n-                pools.put(dbURL, pool);\n-            }\n-        } finally {\n-            if (setupDbConn != null) {\n-                setupDbConn.close();\n-            }\n-        }\n-\n-        return pool;\n-    }\n-\n-    /**\n-     * Updates the username and password for the default admin user\n-     *\n-     * @param dbURL the orientdb URL\n-     * @param oldUser the old orientdb user to update\n-     * @param oldPassword the old orientdb password to update\n-     * @param newUser the new orientdb user\n-     * @param newPassword the new orientdb password\n-     */\n-    public synchronized static void updateDbCredentials(String dbURL, String oldUser, String oldPassword,\n-            String newUser, String newPassword) {\n-\n-        ODatabaseDocumentTx db = null;\n-        try {\n-            db = new ODatabaseDocumentTx(dbURL);\n-            db.open(oldUser, oldPassword);\n-            OSecurity security = db.getMetadata().getSecurity();\n-            // Delete the old admin user\n-            security.dropUser(oldUser);\n-            // Create new admin user with new username and password\n-            security.createUser(newUser, newPassword, security.getRole(ORole.ADMIN));\n-        } catch (Exception e) {\n-            logger.error(\"Error updating DB credentials\", e);\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Closes all pools managed by this helper\n-     * Call at application shut-down to cleanly shut down the pools.\n-     */\n-    public synchronized static void closePools() {\n-        logger.debug(\"Close DB pools\");\n-        for (ODatabaseDocumentPool pool : pools.values()) {\n-            try {\n-                pool.close();\n-                logger.trace(\"Closed pool {}\", pool);\n-            } catch (Exception ex) {\n-                logger.info(\"Faillure reported in closing pool {}\", pool, ex);\n-            }\n-        }\n-        // release all our closed pool references\n-        pools.clear();\n-        pools = new HashMap<String, ODatabaseDocumentPool>();\n-    }\n-\n-    /**\n-     * Close and remove a pool managed by this helper\n-     */\n-    public synchronized static void closePool(String dbUrl, ODatabaseDocumentPool pool) {\n-        logger.debug(\"Close DB pool for {} {}\", dbUrl, pool);\n-        try {\n-            pools.remove(dbUrl);\n-            pool.close();\n-            logger.trace(\"Closed pool for {} {}\", dbUrl, pool);\n-        } catch (Exception ex) {\n-            logger.info(\"Failure reported in closing pool {} {}\", dbUrl, pool, ex);\n-        }\n-    }\n-\n-    /**\n-     * Initialize the DB pool.\n-     * @param dbURL the orientdb URL\n-     * @param user the orientdb user to connect\n-     * @param password the orientdb password to connect\n-     * @param minSize the orientdb pool minimum size\n-     * @param maxSize the orientdb pool maximum size\n-     * @return the initialized pool\n-     * @throws org.forgerock.openidm.config.enhanced.InvalidException\n-     */\n-    private static ODatabaseDocumentPool initPool(String dbURL, String user, String password,  int minSize, int maxSize)\n-            throws InvalidException {\n-        logger.trace(\"Initializing DB Pool {}\", dbURL);\n-\n-        // Enable transaction log\n-        OGlobalConfiguration.TX_USE_LOG.setValue(true);\n-\n-        // Immediate disk sync for commit\n-        OGlobalConfiguration.TX_COMMIT_SYNCH.setValue(true);\n-\n-        // Have the storage closed when the DB is closed.\n-        OGlobalConfiguration.STORAGE_KEEP_OPEN.setValue(false);\n-\n-        boolean success = false;\n-        int maxRetry = 10;\n-        int retryCount = 0;\n-        ODatabaseDocumentPool pool = null;\n-\n-        // Initialize and try to verify the DB. Retry maxRetry times.\n-        do {\n-            retryCount++;\n-            if (pool != null) {\n-                pool.close();\n-            }\n-            pool = new ODatabaseDocumentPool();\n-            pool.setup(minSize, maxSize);\n-            warmUpPool(pool, dbURL, user, password, 1);\n-\n-            boolean finalTry = (retryCount >= maxRetry);\n-            success = test(pool, dbURL, user, password, finalTry);\n-        } while (!success && retryCount < maxRetry);\n-\n-        if (!success) {\n-            logger.warn(\"DB could not be verified.\");\n-        } else {\n-            logger.info(\"DB verified on try {}\", retryCount);\n-        }\n-\n-        logger.debug(\"Opened and initialized pool {}\", pool);\n-\n-        return pool;\n-    }\n-\n-    /**\n-     * Perform a basic access on the DB for a rudimentary test\n-     * @return whether the basic access succeeded\n-     */\n-    private static boolean test(ODatabaseDocumentPool pool, String dbURL, String user,\n-            String password, boolean finalTry) {\n-\n-        ODatabaseDocumentTx db = null;\n-        try {\n-            logger.info(\"Verifying the DB.\");\n-            db = pool.acquire(dbURL, user, password);\n-            Iterator<ODocument> iter = db.browseClass(\"config\"); // Config always should exist\n-            if (iter.hasNext()) {\n-                iter.next();\n-            }\n-        } catch (OException ex) {\n-            if (finalTry) {\n-                logger.info(\"Exceptions encountered in verifying the DB\", ex);\n-            } else {\n-                logger.debug(\"DB exception in testing.\", ex);\n-            }\n-            return false;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Ensure the min size pool entries are initilized.\n-     * Cuts down on some (small) initial latency with lazy init\n-     * Do not call with a min past the real pool max, it will block.\n-     */\n-    private static void warmUpPool(ODatabaseDocumentPool pool, String dbURL, String user,\n-            String password, int minSize) {\n-\n-        logger.trace(\"Warming up pool up to minSize {}\", Integer.valueOf(minSize));\n-        List<ODatabaseDocumentTx> list = new ArrayList<ODatabaseDocumentTx>();\n-        for (int count=0; count < minSize; count++) {\n-            logger.trace(\"Warming up entry {}\", Integer.valueOf(count));\n-            try {\n-                list.add(pool.acquire(dbURL, user, password));\n-            } catch (Exception ex) {\n-                logger.warn(\"Issue in warming up db pool, entry {}\", Integer.valueOf(count), ex);\n-            }\n-        }\n-        for (ODatabaseDocumentTx entry : list) {\n-            try {\n-                if (entry != null) {\n-                    entry.close();\n-                }\n-            } catch (Exception ex) {\n-                logger.warn(\"Issue in connection close during warming up db pool, entry {}\", entry, ex);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Ensures the DB is present in the expected form.\n-     * @return the db reference. The caller MUST reliably close that DB when done with it, e.g. in a finally.\n-     * Be aware that an in-memory DB will disappear if there is no connection open to it,\n-     * and the keep open setting is not explicitly set to true\n-     */\n-    private static ODatabaseDocumentTx checkDB(String dbURL, String user, String password, JsonValue completeConfig)\n-            throws InvalidException {\n-\n-        // TODO: Creation/opening of db may be not be necessary if we require this managed externally\n-        ODatabaseDocumentTx db = new ODatabaseDocumentTx(dbURL);\n-\n-        // To add support for remote DB checking/creation one\n-        // would need to use OServerAdmin instead\n-        // boolean dbExists = new OServerAdmin(dbURL).connect(user, password).existsDatabase();\n-\n-        // Local DB we can auto populate\n-        if (isLocalDB(dbURL) || isMemoryDB(dbURL)) {\n-            if (db.exists()) {\n-                logger.info(\"Using DB at {}\", dbURL);\n-                db.open(user, password);\n-                populateSample(db, completeConfig);\n-            } else {\n-                logger.info(\"DB does not exist, creating {}\", dbURL);\n-                db.create();\n-                // Delete default admin user\n-                OSecurity security = db.getMetadata().getSecurity();\n-                security.dropUser(OUser.ADMIN);\n-                // Create new admin user with new username and password\n-                security.createUser(user, password, security.getRole(ORole.ADMIN));\n-                populateSample(db, completeConfig);\n-            }\n-        } else {\n-            logger.info(\"Using remote DB at {}\", dbURL);\n-        }\n-        return db;\n-    }\n-\n-    /**\n-     * Whether the URL represents a local DB\n-     * @param dbURL the OrientDB db url\n-     * @return true if local, false if remote\n-     * @throws InvalidException if the dbURL is null or otherwise known to be invalid\n-     */\n-    public static boolean isLocalDB(String dbURL) throws InvalidException {\n-        if (dbURL == null) {\n-            throw new InvalidException(\"dbURL is not set\");\n-        }\n-        return dbURL.startsWith(\"local:\") || dbURL.startsWith(\"plocal\");\n-    }\n-\n-    /**\n-     * Whether the URL represents a memory DB\n-     * @param dbURL the OrientDB db url\n-     * @return true if local, false if remote\n-     * @throws InvalidException if the dbURL is null or otherwise known to be invalid\n-     */\n-    public static boolean isMemoryDB(String dbURL) throws InvalidException {\n-    \tif (dbURL == null) {\n-    \t\tthrow new InvalidException(\"dbURL is not set\");\n-    \t}\n-    \treturn dbURL.startsWith(\"memory:\");\n-    }\n-\n-    // TODO: Review the initialization mechanism\n-    private static void populateSample(ODatabaseDocumentTx db, JsonValue completeConfig)\n-            throws InvalidException {\n-\n-        JsonValue dbStructure = completeConfig.get(OrientDBRepoService.CONFIG_DB_STRUCTURE);\n-        if (dbStructure == null) {\n-            logger.warn(\"No database structure defined in the configuration.\" + completeConfig);\n-        } else {\n-            JsonValue orientDBClasses = dbStructure.get(OrientDBRepoService.CONFIG_ORIENTDB_CLASS);\n-            OSchema schema = db.getMetadata().getSchema();\n-\n-            // Default always to create Config class for bootstrapping\n-            if (orientDBClasses == null || orientDBClasses.isNull()) {\n-                orientDBClasses = json(object());\n-            }\n-\n-            orientDBClasses.put(\"config\", object());\n-\n-            logger.info(\"Setting up database\");\n-            for (Object key : orientDBClasses.keys()) {\n-                String orientClassName = (String) key;\n-                JsonValue orientClassConfig = orientDBClasses.get(orientClassName);\n-\n-                boolean classAlreadyExists = schema.existsClass(orientClassName);\n-                createOrUpdateOrientDBClass(db, schema, orientClassName, orientClassConfig);\n-                if (!classAlreadyExists && \"internal_user\".equals(orientClassName)) {\n-                    populateDefaultUsers(orientClassName, db);\n-                }\n-                if (!classAlreadyExists && \"internal_role\".equals(orientClassName)) {\n-                    populateDefaultRoles(orientClassName, db);\n-                }\n-            }\n-        }\n-    }\n-\n-    // Populates the default roles\n-    private static void populateDefaultRoles(String defaultTableName, ODatabaseDocumentTx db) throws InvalidException {\n-        populateDefaultRole(defaultTableName, db, \"openidm-reg\", \"Anonymous access\");\n-        populateDefaultRole(defaultTableName, db, \"openidm-authorized\", \"Basic minimum user\");\n-        populateDefaultRole(defaultTableName, db, \"openidm-admin\", \"Administrative access\");\n-        populateDefaultRole(defaultTableName, db, \"openidm-cert\", \"Authenticated via certificate\");\n-        populateDefaultRole(defaultTableName, db, \"openidm-tasks-manager\", \"Allowed to reassign workflow tasks\");\n-    }\n-\n-    private static void populateDefaultRole(String defaultTableName, ODatabaseDocumentTx db,\n-            String id, String description) throws InvalidException {\n-\n-        JsonValue role = new JsonValue(new HashMap<String, Object>());\n-        role.put(\"_openidm_id\", id);\n-        role.put(\"description\", description);\n-\n-        try {\n-            ODocument newDoc = DocumentUtil.toDocument(role.asMap(), null, db, defaultTableName);\n-            newDoc.save();\n-            logger.trace(\"Created default role {}\", id);\n-        } catch (ConflictException ex) {\n-            throw new InvalidException(\"Unexpected failure during DB set-up of default role\", ex);\n-        }\n-    }\n-\n-    // Populates the default user, the pwd needs to be changed by the installer\n-    private static void populateDefaultUsers(String defaultTableName, ODatabaseDocumentTx db) throws InvalidException {\n-\n-        String defaultAdminUser = \"openidm-admin\";\n-        // Default password needs to be replaced after installation\n-        String defaultAdminPwd = \"openidm-admin\";\n-        JsonValue defaultAdminRoles = json(array(\n-                object(field(RelationshipUtil.REFERENCE_ID, \"repo/internal/role/openidm-admin\")),\n-                object(field(RelationshipUtil.REFERENCE_ID, \"repo/internal/role/openidm-authorized\"))));\n-        populateDefaultUser(defaultTableName, db, defaultAdminUser, defaultAdminPwd, defaultAdminRoles);\n-        logger.trace(\"Created default user {}. Please change the assigned default password.\",\n-                defaultAdminUser);\n-\n-        String anonymousUser = \"anonymous\";\n-        String anonymousPwd = \"anonymous\";\n-        JsonValue anonymousRoles = json(array(\n-                object(field(RelationshipUtil.REFERENCE_ID, \"repo/internal/role/openidm-reg\"))));\n-        populateDefaultUser(defaultTableName, db, anonymousUser, anonymousPwd, anonymousRoles);\n-        logger.trace(\"Created default user {} for registration purposes.\", anonymousUser);\n-    }\n-\n-    private static void populateDefaultUser(String defaultTableName, ODatabaseDocumentTx db,\n-            String user, String pwd, JsonValue roles) throws InvalidException {\n-\n-        JsonValue defaultAdmin = new JsonValue(new HashMap<String, Object>());\n-        defaultAdmin.put(\"_openidm_id\", user);\n-        defaultAdmin.put(\"userName\", user);\n-        defaultAdmin.put(\"password\", pwd);\n-        defaultAdmin.put(\"roles\", roles.getObject());\n-\n-        try {\n-            ODocument newDoc = DocumentUtil.toDocument(defaultAdmin.asMap(), null, db, defaultTableName);\n-            newDoc.save();\n-        } catch (ConflictException ex) {\n-            throw new InvalidException(\"Unexpected failure during DB set-up of default user\", ex);\n-        }\n-    }\n-\n-    private static String uniqueIndexName(String orientClassName, String[] propertyNames) {\n-        // Determine a unique name to use for the index\n-        // Naming pattern used is <class>!property1[!propertyN]*!Idx\n-        StringBuilder sb = new StringBuilder(orientClassName);\n-        sb.append(\"!\");\n-        for (String entry : propertyNames) {\n-            sb.append(entry);\n-            sb.append(\"!\");\n-        }\n-        sb.append(\"Idx\");\n-        return sb.toString();\n-    }\n-\n-    private static void createProperty(OClass orientClass, String propName, String propertyType) {\n-        try {\n-            // Create property type object\n-            OType orientPropertyType = OType.valueOf(propertyType.toUpperCase());\n-            // Create property\n-            orientClass.createProperty(propName, orientPropertyType);\n-        } catch (IllegalArgumentException ex) {\n-            throw new InvalidException(\"Invalid property type '\"\n-                    + propertyType + \"' in configuration for property '\"\n-                    + propName + \" on \" + orientClass.getName()\n-                    + \" valid values: { \" + StringUtils.join(OType.values(), \", \") + \" }\"\n-                    + \" failure message: \" + ex.getMessage(), ex);\n-        }\n-    }\n-\n-    private static void createIndex(OClass orientClass, String indexType, String[] propertyNames, String propertyType) {\n-            logger.info(\"Creating index on properties {} of type {} with index type {} on {} for OrientDB class \",\n-                    propertyNames, propertyType, indexType, orientClass.getName());\n-            try {\n-                // Create the index\n-                String indexName = uniqueIndexName(orientClass.getName(), propertyNames);\n-                OClass.INDEX_TYPE orientIndexType = OClass.INDEX_TYPE.valueOf(indexType.toUpperCase());\n-                orientClass.createIndex(indexName, orientIndexType, propertyNames);\n-            } catch (IllegalArgumentException ex) {\n-                throw new InvalidException(\"Invalid index type '\" + indexType +\n-                        \"' in configuration on properties \"\n-                        + propertyNames + \" of type \" + propertyType + \" on \"\n-                        + orientClass.getName() + \" valid values: { \"\n-                        + StringUtils.join(OClass.INDEX_TYPE.values(), \", \") + \" }\"\n-                        + \" failure message: \" + ex.getMessage(), ex);\n-            }\n-        }\n-\n-    private static void createOrUpdateOrientDBClass(ODatabaseDocumentTx db, OSchema schema,\n-            String orientClassName, JsonValue orientClassConfig) {\n-\n-        OIndexManager indexManager = db.getMetadata().getIndexManager();\n-        OClass orientClass = schema.getClass(orientClassName);\n-        if (orientClass == null) {\n-            logger.info(\"OrientDB class {} does not exist and is being created.\", orientClassName);\n-            orientClass = schema.createClass(orientClassName,\n-                    db.addCluster(orientClassName,\n-                    OStorage.CLUSTER_TYPE.PHYSICAL));\n-        }\n-\n-        List<String> indexProperties = new ArrayList<String>();\n-        JsonValue indexes = orientClassConfig.get(OrientDBRepoService.CONFIG_INDEX);\n-        for (JsonValue index : indexes) {\n-            String propertyType = index.get(OrientDBRepoService.CONFIG_PROPERTY_TYPE).asString();\n-            String indexType = index.get(OrientDBRepoService.CONFIG_INDEX_TYPE).asString();\n-            String propertyName = index.get(OrientDBRepoService.CONFIG_PROPERTY_NAME).asString();\n-            ArrayList<String> propNamesList = new ArrayList<String>();\n-            if (propertyName != null) {\n-                propNamesList.add(propertyName);\n-            } else {\n-                propNamesList.addAll(index.get(OrientDBRepoService.CONFIG_PROPERTY_NAMES).asList(String.class));\n-                if (propNamesList.isEmpty()) {\n-                    throw new InvalidException(\"Invalid index configuration. \"\n-                            + \"Missing property name(s) on index configuration for property type \"\n-                            + propertyType + \" with index type \" + indexType + \" on \" + orientClassName);\n-                }\n-            }\n-\n-            // Add new Class properties\n-            for (String propName : propNamesList) {\n-                if (!orientClass.existsProperty(propName)) {\n-                    logger.info(\"Creating property {} of type {}\", new Object[] {propName, propertyType});\n-                    createProperty(orientClass, propName, propertyType);\n-                }\n-            }\n-\n-            // Add or re-create indexes. No need to rebuild indexes as automatic\n-            // indexes are rebuilt by OrientDB when they are created.\n-            String[] propertyNames = propNamesList.toArray(new String[propNamesList.size()]);\n-            if (propertyNames.length > 0) {\n-                String indexName = uniqueIndexName(orientClass.getName(), propertyNames);\n-                OIndex<?> oIndex = orientClass.getClassIndex(indexName);\n-                if (oIndex != null && !oIndex.getType().equalsIgnoreCase(indexType)) {\n-                    indexManager.dropIndex(indexName);\n-                    oIndex = null;\n-                }\n-                if (oIndex == null) {\n-                    createIndex(orientClass, indexType, propertyNames, propertyType);\n-                }\n-            }\n-           // Add to master list of configured class properties\n-           indexProperties.addAll(propNamesList);\n-        }\n-\n-        // Remove obsolete indexes but do not remove the associated\n-        // Class properties as we are using a hybrid schema and do not\n-        // know who created the Class properties\n-        Collection<OProperty> classProperties = orientClass.properties();\n-        for (OProperty property : classProperties) {\n-            String propName = property.getName();\n-            if (!indexProperties.contains(propName))\n-            {\n-                Set<OIndex<?>> propIndexes = indexManager.getClassInvolvedIndexes(orientClass.getName(), propName);\n-                for (OIndex<?> propIndex : propIndexes) {\n-                    // Ensure that we only drop indexes which we created and\n-                    // match the OpenIDM index naming convention\n-                    String indexRegex = uniqueIndexName(orientClass.getName(), new String[]{\".*\"});\n-                    if (propIndex.getName().matches(indexRegex)) {\n-                        indexManager.dropIndex(propIndex.getName());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"
  },
  {
    "sha": "4a99c819a942d64eef33eb6f96f583518a190309",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtil.java",
    "status": "removed",
    "additions": 0,
    "deletions": 372,
    "changes": 372,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtil.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtil.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtil.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,372 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2016 ForgeRock AS.\n- * Portions Copyright 2020 Wren Security\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.metadata.schema.OType;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-import java.util.LinkedHashMap;\n-import java.util.Set;\n-\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.json.resource.ResourceResponse;\n-import org.forgerock.json.resource.ConflictException;\n-\n-import org.forgerock.json.resource.Responses;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.forgerock.json.JsonValue.json;\n-\n-/**\n- * A utility class for handling and converting OrientDB ODocuments\n- *\n- */\n-public class DocumentUtil  {\n-    final static Logger logger = LoggerFactory.getLogger(DocumentUtil.class);\n-\n-    // Identifiers in the object model.\n-    // TDOO: replace with common definitions of these global variables\n-    public final static String TAG_ID = \"_id\";\n-    public final static String TAG_REV = \"_rev\";\n-\n-    // Identifier in the DB representation\n-    public final static String ORIENTDB_PRIMARY_KEY = \"_openidm_id\";\n-\n-    public final static String ORIENTDB_VERSION_KEY = \"version\";\n-\n-    /**\n-     * Convert to JSON object structures (akin to simple binding), composed of\n-     * the basic Java types: {@link Map}, {@link List}, {@link String},\n-     * {@link Number}, {@link Boolean}.\n-     *\n-     * @param doc\n-     *            the OrientDB document to convert\n-     * @return the Resource with the id, rev, and the doc converted into maps, lists,\n-     *         java types; or null if the doc was null\n-     */\n-    public static ResourceResponse toResource(ODocument doc) {\n-        ResourceResponse result = null;\n-        Map<String, Object> map = toMap(doc);\n-        if (map != null) {\n-            String id = (String) map.get(ResourceResponse.FIELD_CONTENT_ID);\n-            String rev = (String) map.get(ResourceResponse.FIELD_CONTENT_REVISION);\n-            result = Responses.newResourceResponse(id, rev, new JsonValue(map));\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Convert to JSON object structures (akin to simple binding),\n-     * composed of the basic Java types: {@link Map}, {@link List}, {@link String}, {@link Number}, {@link Boolean}.\n-     * @param doc the OrientDB document to convert\n-     * @return the doc converted into maps, lists, java types; or null if the doc was null\n-     */\n-    public static Map<String, Object> toMap(ODocument doc) {\n-        return toMap(doc, true);\n-    }\n-\n-    /**\n-     * Convert to JSON object structures (akin to simple binding),\n-     * composed of the basic Java types: {@link Map}, {@link List}, {@link String}, {@link Number}, {@link Boolean}.\n-     * This may change the objects in the passed doc, it is not safe to use doc contents after calling this method.\n-     *\n-     * @param doc the OrientDB document to convert\n-     * @param topLevel if the passed in document represents a top level orientdb class, or false if it is an embedded document\n-     * @return the doc converted into maps, lists, java types; or null if the doc was null\n-     */\n-    private static Map<String, Object> toMap(ODocument doc, boolean topLevel) {\n-        Map<String, Object> result = null;\n-        if (doc != null) {\n-            result = new LinkedHashMap<String, Object>(); // TODO: As JSON doesn't, do we really want to maintain order?\n-            for (java.util.Map.Entry<String, Object> entry : doc) {\n-                Object value = entry.getValue();\n-                String key = entry.getKey();\n-                if (key.equals(ORIENTDB_PRIMARY_KEY)) {\n-                    logger.trace(\"Setting primary key to value {}\", value);\n-                    result.put(TAG_ID, value);\n-                    String revision = Integer.toString(doc.getVersion());\n-                    if (!result.containsKey(TAG_REV)) {\n-                        //don't overwrite the rev value if it is already in the result\n-                        logger.trace(\"Setting revision to {}\", revision);\n-                        result.put(TAG_REV, revision);\n-                    }\n-                } else if (key.equals(ORIENTDB_VERSION_KEY)) {\n-                    logger.trace(\"Setting revision to {}\", value.toString());\n-                    result.put(TAG_REV, value.toString());\n-                } else {\n-                    // TODO: optimization switch: if we know that no embedded ODocuments are used\n-                    // (i.e. only embedded Maps, Lists) then we would not need to traverse the whole graph\n-                    value = asSimpleBinding(value);\n-                    logger.trace(\"Map setting {} to value {}\", key, value);\n-                    result.put(key, value);\n-                }\n-            }\n-        }\n-        logger.trace(\"Converted document {} to {}\", doc, result);\n-        return result;\n-    }\n-\n-    /**\n-     * Recursively ensure that the passed type is represented\n-     * or converted to JSON object model simple binding types,\n-     * i.e. ODocument to Map, Set to List\n-     *\n-     * Modifies the passed in objToClean where possible (List, Map),\n-     * returns new types where it is not (ODocument, Set)\n-     *\n-     * @param objToClean the object to clean/bind\n-     * @return the object in JSON object model representation\n-     */\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private static Object asSimpleBinding(Object objToClean) {\n-        if (objToClean instanceof ODocument) {\n-            logger.trace(\"Converting embedded ODocument {} to map \", objToClean);\n-            return DocumentUtil.toMap((ODocument) objToClean, false);\n-        } else if (objToClean instanceof List) {\n-            logger.trace(\"Checking embedded list {} \", objToClean);\n-            return toSimpleModel((List) objToClean);\n-        } else if (objToClean instanceof Set) {\n-            logger.trace(\"Converting embedded Set {} \", objToClean);\n-            return toSimpleModel((Set) objToClean);\n-        } else if (objToClean instanceof Map) {\n-            logger.trace(\"Checking embedded map {} \", objToClean);\n-            return toSimpleModel((Map) objToClean);\n-        } else if (objToClean instanceof com.orientechnologies.orient.core.id.ORID) {\n-            // OrientDB should have resolved to an ODocument, might indicate a bug in OrientDB\n-            logger.warn(\"Unexpected value of type ORecordId in document. Returning as String.{}\", objToClean);\n-            return objToClean.toString();\n-        } else {\n-            return objToClean;\n-        }\n-    }\n-\n-    /**\n-     * Iteratively convert contents as necessary to simple model\n-     * @param listToClean list to modify if necessary\n-     * @return the modified list\n-     */\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private static List toSimpleModel(List listToClean) {\n-        ListIterator<Object> listIter = listToClean.listIterator();\n-        while(listIter.hasNext()) {\n-            Object listEntry = listIter.next();\n-            if (listEntry instanceof ODocument || listEntry instanceof Set) {\n-                // Replace the entry with new type\n-                listIter.set(asSimpleBinding(listEntry));\n-            } else {\n-                // Replace directly in the entry\n-                asSimpleBinding(listEntry);\n-            }\n-        }\n-        return listToClean;\n-    }\n-\n-    /**\n-     * Iteratively convert contents as necessary to simple model\n-     * @param setToClean set to convert to List and modify if necessary\n-     * @return the modified list\n-     */\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private static List toSimpleModel(Set setToClean) {\n-        // In JSON there are ordered lists, not Set\n-        List replacementList = new ArrayList();\n-        for (Object setEntry : setToClean) {\n-            replacementList.add(asSimpleBinding(setEntry));\n-        }\n-        return replacementList;\n-    }\n-\n-    /**\n-     * Iteratively convert contents as necessary to simple model\n-     * @param mapToClean map to modify if necessary\n-     * @return the modified map\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    private static Map toSimpleModel(Map<String, Object> mapToClean) {\n-        for(Map.Entry<String, Object> entry : mapToClean.entrySet()) {\n-            entry.setValue(asSimpleBinding(entry.getValue()));\n-        }\n-        return mapToClean;\n-    }\n-\n-    /**\n-     * Convert from JSON object structures (akin to simple binding),\n-     * composed of the basic Java types: {@link Map}, {@link List}, {@link String}, {@link Number}, {@link Boolean}.\n-     * to OrientDB document\n-     * @param objModel the JSON object structure to convert\n-     * @param docToPopulate an optional existing ODocument to update with new values from {@code objModel}\n-     * @param db the database to associate with the ODocument\n-     * @param orientDocClass the OrientDB class of the ODocument to create\n-     * @return the converted orientdb document, or null if objModel was null\n-     * @throws ConflictException when the revision in the Object model is invalid\n-     */\n-    public static ODocument toDocument(JsonValue objModel, ODocument docToPopulate, ODatabaseDocumentTx db, String orientDocClass)\n-            throws ConflictException {\n-        return toDocument(objModel.asMap(), docToPopulate, db, orientDocClass, false, true);\n-    }\n-\n-    /**\n-     * Convert from JSON object structures (akin to simple binding),\n-     * composed of the basic Java types: {@link Map}, {@link List}, {@link String}, {@link Number}, {@link Boolean}.\n-     * to OrientDB document\n-     * @param objModel the JSON object structure to convert\n-     * @param docToPopulate an optional existing ODocument to update with new values from {@code objModel}\n-     * @param db the database to associate with the ODocument\n-     * @param orientDocClass the OrientDB class of the ODocument to create\n-     * @return the converted orientdb document, or null if objModel was null\n-     * @throws ConflictException when the revision in the Object model is invalid\n-     */\n-    public static ODocument toDocument(Map<String, Object> objModel, ODocument docToPopulate, ODatabaseDocumentTx db, String orientDocClass)\n-            throws ConflictException {\n-        return toDocument(objModel, docToPopulate, db, orientDocClass, false, true);\n-    }\n-\n-    /**\n-     * Convert from JSON object structures (akin to simple binding),\n-     * composed of the basic Java types: {@link Map}, {@link List}, {@link String}, {@link Number}, {@link Boolean}.\n-     * to OrientDB document\n-     * @param objModel the JSON object structure to convert\n-     * @param docToPopulate an optional existing ODocument to update with new values from {@code objModel}\n-     * @param db the database to associate with the ODocument\n-     * @param orientDocClass the OrientDB class of the ODocument to create\n-     * @param patch whether the objModel passed in is only partial values (replacing and adding values),\n-     * or if false replaces the whole document with the given {@code objModel}\n-     * @param topLevel\n-     * @return the converted orientdb document, or null if objModel was null\n-     * @throws ConflictException when the revision in the Object model is invalid\n-     */\n-    protected static ODocument toDocument(Map<String, Object> objModel, ODocument docToPopulate, ODatabaseDocumentTx db, String orientDocClass, boolean patch,\n-            boolean topLevel) throws ConflictException {\n-\n-        ODocument result = null;\n-        if (objModel != null) {\n-            if (docToPopulate == null) {\n-                result = db.newInstance(orientDocClass);\n-                result.setAllowChainedAccess(false);\n-            } else {\n-                result = docToPopulate;\n-                if (!patch) {\n-                    // Remove entries from existing doc that don't exist anymore. ODocument.reset resets too much.\n-                    List<String> removalList = new ArrayList<String>();\n-                    for (java.util.Map.Entry<String, Object> entry : result) {\n-                        String key = entry.getKey();\n-                        if (!key.equals(ORIENTDB_PRIMARY_KEY) && !objModel.containsKey(key)) {\n-                            removalList.add(key);\n-                        }\n-                    }\n-                    for (String entry : removalList) {\n-                        logger.trace(\"Removing entry {} \", entry);\n-                        result.removeField(entry);\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<String, Object> entry : objModel.entrySet()) {\n-                String key = entry.getKey();\n-                Object value = entry.getValue();\n-                if (entry.getKey().equals(TAG_ID)) {\n-                    // OpenIDM ID mapping\n-                    if (topLevel) {\n-                        if (!result.containsField(ORIENTDB_PRIMARY_KEY)\n-                                || !result.field(ORIENTDB_PRIMARY_KEY).equals(value)) {\n-                            logger.trace(\"Setting primary key to {}\", value);\n-                            result.field(ORIENTDB_PRIMARY_KEY, value);\n-                        }\n-                    } else {\n-                        logger.trace(\"Setting field {} to value {}\", key, value);\n-                        result.field(entry.getKey(), value);\n-                    }\n-                } else if (key.equals(TAG_REV)) {\n-                    // OpenIDM revision to document version mapping\n-                    if (topLevel) {\n-                        String revString = (String) objModel.get(TAG_REV);\n-                        if (revString != null) {\n-                            int rev = parseVersion(revString);\n-                            logger.trace(\"Setting version to {}\", rev);\n-                            if (result.getVersion() != rev) {\n-                                result.setVersion(rev);\n-                            }\n-                        }\n-                    } else {\n-                        logger.trace(\"Setting field {} to value {}\", key, value);\n-                        result.field(entry.getKey(), value);\n-                    }\n-                } else if (value instanceof Map) {\n-                    // TODO: consider if we should replace this with nested maps rather than nested ODocuments\n-                    logger.trace(\"Handling field {} with embedded map {}\", key, value);\n-                    ODocument existingDoc = null;\n-                    if (docToPopulate != null) {\n-                        logger.trace(\"Update existing embedded map entry {}\", key);\n-                        Object o = docToPopulate.field(entry.getKey());\n-                        if (o instanceof ODocument) {\n-                            existingDoc = (ODocument) o;\n-                        } else {\n-                            docToPopulate.removeField(entry.getKey());\n-                        }\n-                    }\n-                    // TODO: below is temporary work-around for OrientDB update not saving embedded ODocument,\n-                    // unless it is a new instance\n-                    //if (existingDoc == null) {\n-                    logger.trace(\"Instantiate new ODocument to represent embedded map for {}.\", key);\n-                    existingDoc = new ODocument();\n-                    //necessary for fields which contain '.'. See javadocs for ODocument.field for details\n-                    existingDoc.setAllowChainedAccess(false);\n-\n-                    //}\n-                    ODocument converted = toDocument(json(value).asMap(), existingDoc, db, null, patch, false);\n-                    result.field(entry.getKey(), converted, OType.EMBEDDED);\n-                } else {\n-                    logger.trace(\"Setting field {} to value {}\", key, value);\n-                    result.field(entry.getKey(), value);\n-                }\n-            }\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Parse an OpenIDM revision into an OrientDB MVCC version. OrientDB expects these to be ints.\n-     * @param revision the revision String with the OrientDB version in it.\n-     * @return the OrientDB version\n-     * @throws ConflictException if the revision String could not be parsed into the int expected by OrientDB\n-     */\n-    public static int parseVersion(String revision) throws ConflictException {\n-        int ver = -1;\n-        try {\n-            ver = Integer.parseInt(revision);\n-        } catch (NumberFormatException ex) {\n-            throw new ConflictException(\"OrientDB repository expects revisions as int, \"\n-                    + \"unable to parse passed revision: \" + revision);\n-        }\n-        return ver;\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "f4038bda4c413ae0efef5c330918e86e5879f56d",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerService.java",
    "status": "removed",
    "additions": 0,
    "deletions": 277,
    "changes": 277,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerService.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerService.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerService.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,277 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2015 ForgeRock AS.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-\n-import org.forgerock.openidm.core.IdentityServer;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.forgerock.json.JsonValue;\n-\n-import com.orientechnologies.orient.server.OServer;\n-import com.orientechnologies.orient.server.OServerMain;\n-import com.orientechnologies.orient.server.config.OServerCommandConfiguration;\n-import com.orientechnologies.orient.server.config.OServerConfiguration;\n-import com.orientechnologies.orient.server.config.OServerEntryConfiguration;\n-import com.orientechnologies.orient.server.config.OServerHandlerConfiguration;\n-import com.orientechnologies.orient.server.config.OServerNetworkConfiguration;\n-import com.orientechnologies.orient.server.config.OServerNetworkListenerConfiguration;\n-import com.orientechnologies.orient.server.config.OServerNetworkProtocolConfiguration;\n-import com.orientechnologies.orient.server.config.OServerParameterConfiguration;\n-import com.orientechnologies.orient.server.config.OServerStorageConfiguration;\n-import com.orientechnologies.orient.server.config.OServerUserConfiguration;\n-import com.orientechnologies.orient.server.network.OServerNetworkListener;\n-import com.orientechnologies.orient.server.network.protocol.ONetworkProtocol;\n-import java.util.List;\n-import java.util.Map;\n-\n-/**\n- * Component for embedded OrientDB server\n- *\n- */\n-public class EmbeddedOServerService {\n-    final static Logger logger = LoggerFactory.getLogger(EmbeddedOServerService.class);\n-\n-    OServer orientDBServer;\n-\n-    void activate(JsonValue config) throws Exception {\n-        logger.trace(\"Activating Service with configuration {}\", config);\n-        try {\n-            JsonValue enabled = config.get(\"embeddedServer\").get(\"enabled\");\n-\n-            // Create regardless of whether enabled to ensure proper shutdown handling (observed in RC9)\n-            orientDBServer = OServerMain.create();\n-            \n-            // enabled flag should be Boolean, but allow for (deprecated) String representation for now.\n-            if ((enabled.isBoolean() && Boolean.TRUE.equals(enabled.asBoolean())\n-                    || enabled.isString() && \"true\".equalsIgnoreCase(enabled.asString()))) {\n-                OServerConfiguration serverConfig = getOrientDBConfig(config);\n-                orientDBServer.startup(serverConfig);\n-                orientDBServer.activate();\n-                logger.info(\"Embedded DB server started.\");\n-            }\n-        } catch (Exception ex) {\n-            logger.warn(\"Could not start OrientDB embedded server, service disabled.\", ex);\n-            throw ex;\n-        }\n-    }\n-    \n-    void modified(JsonValue config) throws Exception {\n-        logger.trace(\"Handle service modified notification\");\n-        Map<String,Class<? extends ONetworkProtocol>> networkProtocols = orientDBServer.getNetworkProtocols();\n-        \n-        List<OServerNetworkListener> networkListeners = orientDBServer.getNetworkListeners();\n-        for (OServerNetworkListener listener : networkListeners) {\n-            listener.shutdown();\n-        }\n-        networkListeners.clear();\n-        \n-        List<OServerNetworkListenerConfiguration> listeners = getListeners(config);\n-        for (OServerNetworkListenerConfiguration listener : listeners) {\n-            networkListeners.add(new OServerNetworkListener(orientDBServer, null, listener.ipAddress, \n-                    listener.portRange, listener.protocol, networkProtocols.get(listener.protocol),\n-                    listener.parameters, listener.commands)\n-            );\n-        }\n-    }\n-\n-    void deactivate() {\n-        if (orientDBServer != null) {\n-            orientDBServer.shutdown();\n-            logger.debug(\"Embedded DB server stopped.\");\n-        }\n-    }\n- \n-    private List<OServerNetworkListenerConfiguration> getListeners(JsonValue config) {\n-\n-        List<OServerNetworkListenerConfiguration> listeners = new ArrayList<OServerNetworkListenerConfiguration>();\n-\n-        Boolean clustered  = config.get(\"embeddedServer\").get(\"clustered\").defaultTo(Boolean.FALSE).asBoolean();\n-        JsonValue binaryConfig = config.get(\"embeddedServer\").get(\"overrideConfig\")\n-        \t\t.get(\"network\").get(\"listeners\").get(\"binary\");                \n-        OServerNetworkListenerConfiguration serverListener = new OServerNetworkListenerConfiguration();\n-        serverListener.ipAddress = binaryConfig.get(\"ipAddress\").defaultTo(\"0.0.0.0\").asString();\n-        serverListener.portRange = binaryConfig.get(\"portRange\").defaultTo(\"2424-2424\").asString();\n-        if (clustered) {\n-            serverListener.protocol = \"distributed\";\n-        } else {\n-            serverListener.protocol = \"binary\";\n-        }\n-        listeners.add(serverListener);\n-\n-        Boolean studioUiEnabled  = config.get(\"embeddedServer\").get(\"studioUi\")\n-                .get(\"enabled\").defaultTo(Boolean.FALSE).asBoolean();\n-        if (studioUiEnabled) {\n-            JsonValue httpConfig = config.get(\"embeddedServer\").get(\"overrideConfig\")\n-                            .get(\"network\").get(\"listeners\").get(\"http\");\n-            OServerNetworkListenerConfiguration studioListener = new OServerNetworkListenerConfiguration();\n-            studioListener.ipAddress = httpConfig.get(\"ipAddress\").defaultTo(\"127.0.0.1\").asString();\n-            studioListener.portRange = httpConfig.get(\"portRange\").defaultTo(\"2480-2480\").asString();\n-            studioListener.protocol = \"http\";\n-\n-            // Access to the studio web app\n-            OServerCommandConfiguration command = new OServerCommandConfiguration();\n-            command.pattern = \"GET|www GET|studio/ GET| GET|*.htm GET|*.html GET|*.xml GET|*.jpeg GET|*.jpg GET|*.png GET|*.gif GET|*.js GET|*.css GET|*.swf GET|*.ico GET|*.txt GET|*.otf GET|*.pjs GET|*.svg\";\n-            command.implementation = \"com.orientechnologies.orient.server.network.protocol.http.command.get.OServerCommandGetStaticContent\";\n-            command.parameters = new OServerEntryConfiguration[2];\n-            command.parameters[0] = new OServerEntryConfiguration(\"http.cache:*.htm *.html\", \"Cache-Control: no-cache, no-store, max-age=0, must-revalidate\\r\\nPragma: no-cache\");\n-            command.parameters[1] = new OServerEntryConfiguration(\"http.cache:default\", \"Cache-Control: max-age=120\");\n-\n-            studioListener.commands = new OServerCommandConfiguration[]{\n-                command\n-            };\n-\n-            studioListener.parameters = new OServerParameterConfiguration[1];\n-            // Connection custom parameters. If not specified the global configuration will be taken\n-            studioListener.parameters[0] = new OServerParameterConfiguration(\"network.http.charset\", \"utf-8\");\n-            listeners.add(studioListener);\n-        }\n-\n-        return listeners;\n-    }\n-    \n-    \n-    // TODO: make configurable\n-    protected OServerConfiguration getOrientDBConfig(JsonValue config) {\n-\n-        OServerConfiguration configuration = new OServerConfiguration();\n-\n-        Boolean studioUiEnabled  = config.get(\"embeddedServer\").get(\"studioUi\")\n-                .get(\"enabled\").defaultTo(Boolean.FALSE).asBoolean();\n-        \n-        Boolean clustered  = config.get(\"embeddedServer\").get(\"clustered\").defaultTo(Boolean.FALSE).asBoolean();\n-        \n-        if (clustered) {\n-            configuration.handlers = new ArrayList<OServerHandlerConfiguration>();\n-            OServerHandlerConfiguration handler = new OServerHandlerConfiguration();\n-            handler.clazz = \"com.orientechnologies.orient.server.handler.distributed.ODistributedServerManager\";\n-            configuration.handlers.add(handler);\n-            \n-            String clusterName = config.get(\"embeddedServer\").get(\"clusterName\").defaultTo(\"openidm\").asString();\n-            String multicastAddress = config.get(\"embeddedServer\").get(\"clusterAddress\").defaultTo(\"235.1.1.1\").asString();\n-            String multicastPort = config.get(\"embeddedServer\").get(\"clusterPort\").defaultTo(\"2424\").asString();\n-            String clusterSecurityKey = config.get(\"embeddedServer\").get(\"clusterSecurityKey\").defaultTo(\"hw3CgjSzqm8I/axu\").asString();\n-            \n-            handler.parameters = new OServerParameterConfiguration[]{\n-                    new OServerParameterConfiguration(\"enabled\", Boolean.toString(clustered)),\n-                    new OServerParameterConfiguration(\"name\", clusterName),\n-                    new OServerParameterConfiguration(\"security.algorithm\", \"Blowfish\"),\n-                    new OServerParameterConfiguration(\"network.multicast.address\", multicastAddress),\n-                    new OServerParameterConfiguration(\"network.multicast.port\", multicastPort),\n-                    new OServerParameterConfiguration(\"network.multicast.heartbeat\", \"10\"),\n-                    new OServerParameterConfiguration(\"server.update.delay\", \"5000\"),\n-                    new OServerParameterConfiguration(\"server.electedForLeadership\", \"true\"),\n-                    new OServerParameterConfiguration(\"security.key\", clusterSecurityKey),\n-            };\n-            logger.info(\"OrientDB clustering enabled on {}:{} with cluster name {}\", new Object[] {multicastAddress, multicastPort, clusterName});\n-        }\n-\n-        JsonValue automaticBackup  = config.get(\"embeddedServer\").get(\"automaticBackup\");\n-        Boolean backupEnabled = automaticBackup.get(\"enabled\").defaultTo(Boolean.FALSE).asBoolean();\n-        \n-        if (backupEnabled) {\n-            configuration.handlers = new ArrayList<OServerHandlerConfiguration>();\n-            OServerHandlerConfiguration handler = new OServerHandlerConfiguration();\n-            handler.clazz = \"com.orientechnologies.orient.server.handler.OAutomaticBackup\";\n-            configuration.handlers.add(handler);\n-            \n-            String targetDirectory = automaticBackup.get(\"targetDirectory\").defaultTo(\"db/backup\").asString();\n-            String targetFileName = automaticBackup.get(\"targetFile\").defaultTo(\"${DBNAME}-${DATE:yyyyMMddHHmmss}.zip\").asString();\n-            String firstTime = automaticBackup.get(\"firsttime\").defaultTo(\"23:59:00\").asString();\n-            String delay = automaticBackup.get(\"delay\").defaultTo(\"1d\").asString();\n-            String dbExclude = automaticBackup.get(\"dbExclude\").defaultTo(\"temp\").asString();\n-            String dbInclude = automaticBackup.get(\"dbInclude\").defaultTo(\"openidm\").asString();\n-            \n-            handler.parameters = new OServerParameterConfiguration[]{\n-                    new OServerParameterConfiguration(\"enabled\", Boolean.toString(backupEnabled)),\n-                    new OServerParameterConfiguration(\"target.directory\", targetDirectory),\n-                    new OServerParameterConfiguration(\"target.fileName\", targetFileName),\n-                    new OServerParameterConfiguration(\"firsttime\", firstTime),\n-                    new OServerParameterConfiguration(\"delay\", delay),\n-                    new OServerParameterConfiguration(\"db.exclude\", dbExclude),\n-                    new OServerParameterConfiguration(\"db.include\", dbInclude)\n-            };\n-            logger.info(\"OrientDB automatic backups enabled every {} starting today at {}\", new Object[] {delay, firstTime});\n-        }\n-\n-        configuration.network = new OServerNetworkConfiguration();\n-        configuration.network.protocols = new ArrayList<OServerNetworkProtocolConfiguration>();\n-        OServerNetworkProtocolConfiguration protocol1 = new OServerNetworkProtocolConfiguration();\n-        protocol1.name = \"binary\";\n-        protocol1.implementation = \"com.orientechnologies.orient.server.network.protocol.binary.ONetworkProtocolBinary\";\n-        configuration.network.protocols.add(protocol1);\n-        OServerNetworkProtocolConfiguration protocol2 = new OServerNetworkProtocolConfiguration();\n-        protocol2.name = \"http\";\n-        protocol2.implementation = \"com.orientechnologies.orient.server.network.protocol.http.ONetworkProtocolHttpDb\";\n-        configuration.network.protocols.add(protocol2);\n-        configuration.network.listeners = getListeners(config);\n-\n-        OServerStorageConfiguration storage1 = new OServerStorageConfiguration();\n-        storage1.name = \"temp\";\n-        storage1.path = \"memory:temp\";\n-        storage1.userName = \"admin\";\n-        storage1.userPassword = \"admin\";\n-        storage1.loadOnStartup = false;\n-        String user = config.get(OrientDBRepoService.CONFIG_USER).defaultTo(\"admin\").asString();\n-        String pwd = config.get(OrientDBRepoService.CONFIG_PASSWORD).defaultTo(\"admin\").asString();\n-        String dbURL = config.get(OrientDBRepoService.CONFIG_DB_URL).asString();\n-        if (dbURL == null || dbURL.isEmpty()) {\n-            dbURL = \"plocal:\" + IdentityServer.getFileForWorkingPath(\"db/openidm\").getAbsolutePath();\n-        }\n-        File dbFolder = IdentityServer.getFileForWorkingPath(dbURL.split(\":\")[1]);\n-\n-        OServerStorageConfiguration storage2 = new OServerStorageConfiguration();\n-        storage2.name = \"openidm\";\n-        storage2.path = dbURL;\n-        storage2.userName = user;\n-        storage2.userPassword = pwd;\n-        storage2.loadOnStartup = false;\n-\n-        configuration.storages = new OServerStorageConfiguration[]{\n-                storage1,\n-                storage2\n-        };\n-\n-        // Defaulted to the same as the regular user\n-        String rootPwd = config.get(\"embeddedServer\").get(\"rootPwd\").defaultTo(pwd).asString();\n-        configuration.users = new OServerUserConfiguration[]\n-        {\n-                new OServerUserConfiguration(\"root\", rootPwd, \"*\"),\n-                new OServerUserConfiguration(\"guest\", null, \"server.listDatabases\")\n-        };\n-        configuration.properties = new OServerEntryConfiguration[]{\n-                new OServerEntryConfiguration(\"server.cache.staticResources\", \"false\"),\n-                new OServerEntryConfiguration(\"orientdb.www.path\", \"db/util/orientdb/studio\"),\n-                new OServerEntryConfiguration(\"orient.home\", dbFolder.getAbsolutePath())\n-        };\n-        // OrientDB currently logs a warning if this is not set, \n-        // although it should be taking the setting from the config above instead.\n-        System.setProperty(\"ORIENTDB_HOME\", dbFolder.getAbsolutePath());\n-\n-        return configuration;\n-    }\n-\n-}"
  },
  {
    "sha": "d60b6979f0914c17687e03556550fe31ab88c9bf",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/OrientDBRepoService.java",
    "status": "removed",
    "additions": 0,
    "deletions": 988,
    "changes": 988,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/OrientDBRepoService.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/OrientDBRepoService.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/OrientDBRepoService.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,988 +0,0 @@\n-/*\n- * The contents of this file are subject to the terms of the Common Development and\n- * Distribution License (the License). You may not use this file except in compliance with the\n- * License.\n- *\n- * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\n- * specific language governing permission and limitations under the License.\n- *\n- * When distributing Covered Software, include this CDDL Header Notice in each file and include\n- * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\n- * Header, with the fields enclosed by brackets [] replaced by your own identifying\n- * information: \"Portions copyright [year] [name of copyright owner]\".\n- *\n- * Copyright 2011-2016 ForgeRock AS.\n- * Portions Copyright 2018-2020 Wren Security.\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import static org.forgerock.json.resource.CountPolicy.EXACT;\n-import static org.forgerock.json.resource.QueryResponse.NO_COUNT;\n-import static org.forgerock.json.resource.ResourceException.newResourceException;\n-import static org.forgerock.json.resource.Responses.newActionResponse;\n-import static org.forgerock.json.resource.Responses.newQueryResponse;\n-import static org.forgerock.json.resource.Responses.newResourceResponse;\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.UUID;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.json.JsonValueException;\n-import org.forgerock.json.resource.ActionRequest;\n-import org.forgerock.json.resource.ActionResponse;\n-import org.forgerock.json.resource.BadRequestException;\n-import org.forgerock.json.resource.ConflictException;\n-import org.forgerock.json.resource.CreateRequest;\n-import org.forgerock.json.resource.DeleteRequest;\n-import org.forgerock.json.resource.ForbiddenException;\n-import org.forgerock.json.resource.InternalServerErrorException;\n-import org.forgerock.json.resource.NotFoundException;\n-import org.forgerock.json.resource.NotSupportedException;\n-import org.forgerock.json.resource.PatchRequest;\n-import org.forgerock.json.resource.PreconditionFailedException;\n-import org.forgerock.json.resource.QueryRequest;\n-import org.forgerock.json.resource.QueryResourceHandler;\n-import org.forgerock.json.resource.QueryResponse;\n-import org.forgerock.json.resource.ReadRequest;\n-import org.forgerock.json.resource.RequestHandler;\n-import org.forgerock.json.resource.Requests;\n-import org.forgerock.json.resource.ResourceException;\n-import org.forgerock.json.resource.ResourceResponse;\n-import org.forgerock.json.resource.UpdateRequest;\n-import org.forgerock.openidm.config.enhanced.EnhancedConfig;\n-import org.forgerock.openidm.core.IdentityServer;\n-import org.forgerock.openidm.core.ServerConstants;\n-import org.forgerock.openidm.repo.QueryConstants;\n-import org.forgerock.openidm.repo.RepoBootService;\n-import org.forgerock.openidm.repo.RepositoryService;\n-import org.forgerock.openidm.repo.orientdb.impl.query.Commands;\n-import org.forgerock.openidm.repo.orientdb.impl.query.PredefinedQueries;\n-import org.forgerock.openidm.repo.orientdb.impl.query.Queries;\n-import org.forgerock.openidm.router.IDMConnectionFactory;\n-import org.forgerock.services.context.Context;\n-import org.forgerock.util.Reject;\n-import org.forgerock.util.promise.Promise;\n-import org.osgi.service.component.ComponentContext;\n-import org.osgi.service.component.annotations.Activate;\n-import org.osgi.service.component.annotations.Component;\n-import org.osgi.service.component.annotations.ConfigurationPolicy;\n-import org.osgi.service.component.annotations.Deactivate;\n-import org.osgi.service.component.annotations.Modified;\n-import org.osgi.service.component.annotations.Reference;\n-import org.osgi.service.component.annotations.ReferencePolicy;\n-import org.osgi.service.component.propertytypes.ServiceDescription;\n-import org.osgi.service.component.propertytypes.ServiceVendor;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentPool;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.exception.OConcurrentModificationException;\n-import com.orientechnologies.orient.core.exception.ODatabaseException;\n-import com.orientechnologies.orient.core.index.OIndexException;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.core.storage.ORecordDuplicatedException;\n-import com.orientechnologies.orient.core.version.OSimpleVersion;\n-\n-/**\n- * Repository service implementation using OrientDB\n- */\n-@Component(\n-        name = OrientDBRepoService.PID,\n-        immediate = true,\n-        configurationPolicy = ConfigurationPolicy.REQUIRE,\n-        property = {\n-                ServerConstants.ROUTER_PREFIX + \"=/repo/*\"\n-        },\n-        service = { RepositoryService.class, RequestHandler.class })\n-@ServiceVendor(ServerConstants.SERVER_VENDOR_NAME)\n-@ServiceDescription(\"Repository Service using OrientDB\")\n-public class OrientDBRepoService implements RequestHandler, RepositoryService, RepoBootService {\n-\n-    final static Logger logger = LoggerFactory.getLogger(OrientDBRepoService.class);\n-    public static final String PID = \"org.forgerock.openidm.repo.orientdb\";\n-\n-    // Keys in the JSON configuration\n-    public static final String CONFIG_QUERIES = \"queries\";\n-    public static final String CONFIG_COMMANDS = \"commands\";\n-    public static final String CONFIG_DB_URL = \"dbUrl\";\n-    public static final String CONFIG_USER = \"user\";\n-    public static final String CONFIG_PASSWORD = \"password\";\n-    public static final String CONFIG_POOL_MIN_SIZE = \"poolMinSize\";\n-    public static final String CONFIG_POOL_MAX_SIZE = \"poolMaxSize\";\n-    public static final String CONFIG_DB_STRUCTURE = \"dbStructure\";\n-    public static final String CONFIG_ORIENTDB_CLASS = \"orientdbClass\";\n-    public static final String CONFIG_INDEX = \"index\";\n-    public static final String CONFIG_PROPERTY_NAME = \"propertyName\";\n-    public static final String CONFIG_PROPERTY_NAMES = \"propertyNames\";\n-    public static final String CONFIG_PROPERTY_TYPE = \"propertyType\";\n-    public static final String CONFIG_INDEX_TYPE = \"indexType\";\n-\n-    private enum Action {\n-        updateDbCredentials,\n-        command\n-    }\n-\n-    /** The Connection Factory */\n-    @Reference(policy = ReferencePolicy.STATIC)\n-    protected IDMConnectionFactory connectionFactory;\n-\n-    /** Enhanced configuration service. */\n-    @Reference(policy = ReferencePolicy.DYNAMIC)\n-    private volatile EnhancedConfig enhancedConfig;\n-\n-    private ODatabaseDocumentPool pool;\n-\n-    private static final int DEFAULT_POOL_MIN_SIZE = 5;\n-    private static final int DEFAULT_POOL_MAX_SIZE = 20;\n-\n-    private String dbURL;\n-    private String user;\n-    private String password;\n-    private int poolMinSize;\n-    private int poolMaxSize;\n-\n-    // Used to synchronize operations on the DB that require user/password credentials\n-    private static Object dbLock = new Object();\n-\n-    private static OrientDBRepoService bootRepo = null;\n-\n-    // Current configuration\n-    JsonValue existingConfig;\n-\n-    // TODO: evaluate use of Guice instead\n-    PredefinedQueries predefinedQueries = new PredefinedQueries();\n-    Queries queries = new Queries();\n-    Commands commands = new Commands();\n-\n-    EmbeddedOServerService embeddedServer;\n-\n-    @Override\n-    public Promise<ResourceResponse, ResourceException> handleRead(final Context context, final ReadRequest request) {\n-        try {\n-            return read(request).asPromise();\n-        } catch (Exception ex) {\n-            return adapt(ex).asPromise();\n-        }\n-    }\n-\n-    @Override\n-    public Promise<ResourceResponse, ResourceException> handleCreate(final Context context, final CreateRequest request) {\n-        try {\n-            return create(request).asPromise();\n-        } catch (Exception ex) {\n-            return adapt(ex).asPromise();\n-        }\n-    }\n-\n-    @Override\n-    public Promise<ResourceResponse, ResourceException> handleUpdate(final Context context, UpdateRequest request) {\n-        try {\n-            return update(request).asPromise();\n-        } catch (Exception ex) {\n-            return adapt(ex).asPromise();\n-        }\n-    }\n-\n-\n-    @Override\n-    public Promise<ResourceResponse, ResourceException> handleDelete(final Context context, final DeleteRequest request) {\n-        try {\n-            return delete(request).asPromise();\n-        } catch (Exception ex) {\n-            return adapt(ex).asPromise();\n-        }\n-    }\n-\n-\n-    /**\n-     * <p>\n-     * The object will contain metadata properties, including object identifier\n-     * {@code _id}, and object version {@code _rev} to enable optimistic\n-     * concurrency supported by OrientDB and OpenIDM.\n-     *\n-     * @param request\n-     *            the identifier of the object to retrieve from the object set.\n-     * @throws NotFoundException\n-     *             if the specified object could not be found.\n-     * @throws ForbiddenException\n-     *             if access to the object is forbidden.\n-     * @throws BadRequestException\n-     *             if the passed identifier is invalid\n-     * @return the requested object.\n-     */\n-    @Override\n-    public ResourceResponse read(ReadRequest request) throws ResourceException {\n-        if (request.getResourcePathObject().size() < 2) {\n-            throw new NotFoundException(\"The object identifier did not include sufficient information to determine the object type and identifier of the object to read: \" + request.getResourcePath());\n-        }\n-\n-        final String type = request.getResourcePathObject().parent().toString();\n-        final String localId = request.getResourcePathObject().leaf();\n-        ResourceResponse result = null;\n-        ODatabaseDocumentTx db = getConnection();\n-        try {\n-            ODocument doc = predefinedQueries.getByID(localId, type, db);\n-            if (doc == null) {\n-                throw new NotFoundException(\"Object \" + localId + \" not found in \" + type);\n-            }\n-            result = DocumentUtil.toResource(doc);\n-            logger.trace(\"Completed get for id: {} result: {}\", request.getResourcePath(), result);\n-            return result;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Creates a new object in the object set.\n-     * <p>\n-     * This method sets the {@code _id} property to the assigned identifier for the object,\n-     * and the {@code _rev} property to the revised object version (For optimistic concurrency)\n-     *\n-     * @param request\n-     *            the contents of the object to create in the object set.\n-     * @throws NotFoundException\n-     *             if the specified id could not be resolved.\n-     * @throws ForbiddenException\n-     *             if access to the object or object set is forbidden.\n-     * @throws ConflictException\n-     *             if an object with the same ID already exists.\n-     */\n-    @Override\n-    public ResourceResponse create(CreateRequest request) throws ResourceException {\n-        if (request.getResourcePathObject().isEmpty()) {\n-            throw new NotFoundException(\"The object identifier did not include sufficient information to determine the object type: \" + request.getResourcePath());\n-        }\n-\n-        final String type = request.getResourcePath();\n-        // TODO: should CREST support server side generation of ID itself?\n-        final String localId = (request.getNewResourceId() == null || \"\".equals(request.getNewResourceId()))\n-                ? UUID.randomUUID().toString() // Generate ID server side.\n-                : request.getNewResourceId();\n-\n-        // Used currently for logging\n-        String fullId = request.getResourcePathObject().child(localId).toString();\n-\n-        String orientClassName = typeToOrientClassName(type);\n-        JsonValue obj = request.getContent();\n-\n-        obj.put(DocumentUtil.TAG_ID, localId);\n-\n-        ODatabaseDocumentTx db = getConnection();\n-        try{\n-            // Rather than using MVCC for insert, rely on primary key uniqueness constraints to detect duplicate create\n-            ODocument newDoc = DocumentUtil.toDocument(obj, null, db, orientClassName);\n-            logger.trace(\"Created doc for id: {} to save {}\", fullId, newDoc);\n-            newDoc.save();\n-\n-            obj.put(DocumentUtil.TAG_REV, Integer.toString(newDoc.getVersion()));\n-            logger.debug(\"Completed create for id: {} revision: {}\", fullId, newDoc.getVersion());\n-            logger.trace(\"Create payload for id: {} doc: {}\", fullId, newDoc);\n-            return newResourceResponse(obj.get(DocumentUtil.TAG_ID).asString(), obj.get(DocumentUtil.TAG_REV).asString(), obj);\n-        } catch (ORecordDuplicatedException ex) {\n-            // Because the OpenIDM ID is defined as unique, duplicate inserts must fail\n-            throw new PreconditionFailedException(\"Create rejected as Object with same ID already exists. \" + ex.getMessage(), ex);\n-        } catch (OIndexException ex) {\n-            // Because the OpenIDM ID is defined as unique, duplicate inserts must fail\n-            throw new PreconditionFailedException(\"Create rejected as Object with same ID already exists. \" + ex.getMessage(), ex);\n-        } catch (ODatabaseException ex) {\n-            // Because the OpenIDM ID is defined as unique, duplicate inserts must fail.\n-            // OrientDB may wrap the IndexException root cause.\n-            if (isCauseIndexException(ex, 10) || isCauseRecordDuplicatedException(ex, 10)) {\n-                throw new PreconditionFailedException(\"Create rejected as Object with same ID already exists and was detected. \"\n-                        + ex.getMessage(), ex);\n-            } else {\n-                throw ex;\n-            }\n-        } catch (RuntimeException e){\n-            throw e;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Updates the specified object in the object set.\n-     * <p>\n-     * This implementation does not require MVCC and uses the current revision if no revision\n-     * is specified in the request.\n-     * <p>\n-     * If successful, this method updates metadata properties within the passed object,\n-     * including: a new {@code _rev} value for the revised object's version\n-     *\n-     * @param request the contents of the object to update\n-     * @throws ConflictException if version is required but is {@code null}.\n-     * @throws ForbiddenException if access to the object is forbidden.\n-     * @throws NotFoundException if the specified object could not be found.\n-     * @throws PreconditionFailedException if version did not match the existing object in the set.\n-     * @throws BadRequestException if the passed identifier is invalid\n-     */\n-    @Override\n-    public ResourceResponse update(UpdateRequest request) throws ResourceException {\n-        if (request.getResourcePathObject().size() < 2) {\n-            throw new NotFoundException(\"The object identifier did not include sufficient information to determine the object type and identifier of the object to update: \" + request.getResourcePath());\n-        }\n-\n-        final String type = request.getResourcePathObject().parent().toString();\n-        final String localId = request.getResourcePathObject().leaf();\n-\n-        String orientClassName = typeToOrientClassName(type);\n-        JsonValue obj = request.getContent();\n-\n-        if (request.getRevision() != null && !\"\".equals(request.getRevision())) {\n-            obj.put(DocumentUtil.TAG_REV, request.getRevision());\n-        }\n-\n-        ODatabaseDocumentTx db = getConnection();\n-        try{\n-            ODocument existingDoc = predefinedQueries.getByID(localId, type, db);\n-            if (existingDoc == null) {\n-                throw new NotFoundException(\"Update on object \" + request.getResourcePath() + \" could not find existing object.\");\n-            }\n-            ODocument updatedDoc = DocumentUtil.toDocument(obj, existingDoc, db, orientClassName);\n-            logger.trace(\"Updated doc for id {} to save {}\", request.getResourcePath(), updatedDoc);\n-\n-            updatedDoc.save();\n-\n-            obj.put(DocumentUtil.TAG_REV, Integer.toString(updatedDoc.getVersion()));\n-            // Set ID to return to caller\n-            obj.put(DocumentUtil.TAG_ID, updatedDoc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY));\n-            logger.debug(\"Committed update for id: {} revision: {}\", request.getResourcePath(), updatedDoc.getVersion());\n-            logger.trace(\"Update payload for id: {} doc: {}\", request.getResourcePath(), updatedDoc);\n-            return newResourceResponse(obj.get(DocumentUtil.TAG_ID).asString(),\n-                    obj.get(DocumentUtil.TAG_REV).asString(), obj);\n-        } catch (ODatabaseException ex) {\n-            // Without transaction the concurrent modification exception gets nested instead\n-            if (isCauseConcurrentModificationException(ex, 10)) {\n-                throw new PreconditionFailedException(\n-                        \"Update rejected as current Object revision is different than expected by caller, the object has changed since retrieval: \"\n-                        + ex.getMessage(), ex);\n-            } else {\n-                throw ex;\n-            }\n-        } catch (OConcurrentModificationException ex) {\n-            throw new PreconditionFailedException(\"Update rejected as current Object revision is different than expected by caller, the object has changed since retrieval: \" + ex.getMessage(), ex);\n-        } catch (RuntimeException e){\n-            throw e;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Deletes the specified object from the object set.\n-     *\n-     * {@inheritDoc}\n-     *\n-     * @throws NotFoundException\n-     *             if the specified object could not be found.\n-     * @throws ForbiddenException\n-     *             if access to the object is forbidden.\n-     * @throws ConflictException\n-     *             if version is required but is {@code null}.\n-     * @throws PreconditionFailedException\n-     *             if version did not match the existing object in the set.\n-     */\n-    @Override\n-    public ResourceResponse delete(DeleteRequest request) throws ResourceException {\n-        if (request.getResourcePathObject().size() < 2) {\n-            throw new NotFoundException(\"The object identifier did not include sufficient information to determine the object type and identifier of the object to update: \" + request.getResourcePath());\n-        }\n-\n-        if (request.getRevision() == null || \"\".equals(request.getRevision())) {\n-            throw new ConflictException(\"Object passed into delete does not have revision it expects set.\");\n-        }\n-\n-        final String type = request.getResourcePathObject().parent().toString();\n-        final String localId = request.getResourcePathObject().leaf();\n-\n-        int ver = DocumentUtil.parseVersion(request.getRevision()); // This throws ConflictException if parse fails\n-\n-        ODatabaseDocumentTx db = getConnection();\n-        try {\n-            ODocument existingDoc = predefinedQueries.getByID(localId, type, db);\n-            if (existingDoc == null) {\n-                throw new NotFoundException(\"Object does not exist for delete on: \" + request.getResourcePath());\n-            }\n-\n-            db.delete(existingDoc.getIdentity(), new OSimpleVersion(ver));\n-            logger.debug(\"delete for id succeeded: {} revision: {}\", localId, request.getRevision());\n-            return DocumentUtil.toResource(existingDoc);\n-        } catch (ODatabaseException ex) {\n-            // Without transaction the concurrent modification exception gets nested instead\n-            if (isCauseConcurrentModificationException(ex, 10)) {\n-                throw new PreconditionFailedException(\n-                        \"Delete rejected as current Object revision is different than expected by caller, the object has changed since retrieval. \"\n-                        + ex.getMessage(), ex);\n-            } else {\n-                throw ex;\n-            }\n-\n-        } catch (OConcurrentModificationException ex) {\n-            throw new PreconditionFailedException(\n-                    \"Delete rejected as current Object revision is different than expected by caller, the object has changed since retrieval.\"\n-                    + ex.getMessage(), ex);\n-        } catch (RuntimeException e){\n-            throw e;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Promise<ResourceResponse, ResourceException> handlePatch(final Context context, final PatchRequest request) {\n-        // TODO: impl\n-        return adapt(new NotSupportedException(\"Patch not supported yet\")).asPromise();\n-    }\n-\n-    @Override\n-    public Promise<ActionResponse, ResourceException> handleAction(final Context context, final ActionRequest request) {\n-        try {\n-            Map<String, String> params = request.getAdditionalParameters();\n-            switch (request.getActionAsEnum(Action.class)) {\n-                case updateDbCredentials:\n-                    String newUser = params.get(\"user\");\n-                    String newPassword = params.get(\"password\");\n-                    if (newUser == null || newPassword == null) {\n-                        return adapt(new BadRequestException(\"Expecting 'user' and 'password' parameters\")).asPromise();\n-                    }\n-                    synchronized (dbLock) {\n-                        DBHelper.updateDbCredentials(dbURL, user, password, newUser, newPassword);\n-                        JsonValue config = connectionFactory.getConnection().read(context, Requests.newReadRequest(\"config\", PID)).getContent();\n-                        config.put(\"user\", newUser);\n-                        config.put(\"password\", newPassword);\n-                        UpdateRequest updateRequest = Requests.newUpdateRequest(\"config/\" + PID, config);\n-                        connectionFactory.getConnection().update(context, updateRequest);\n-                        return newActionResponse(new JsonValue(params)).asPromise();\n-                    }\n-                case command:\n-                    return newActionResponse(new JsonValue(command(request))).asPromise();\n-                default:\n-                    return adapt(new BadRequestException(\"Unknown action: \" + request.getAction())).asPromise();\n-            }\n-        } catch (IllegalArgumentException e) {\n-            return adapt(new BadRequestException(\"Unknown action: \" + request.getAction())).asPromise();\n-        } catch (ResourceException e) {\n-            return e.asPromise();\n-        }\n-    }\n-\n-    /**\n-     * Execute a database command according to the details in the action request.\n-     *\n-     * @param request the ActionRequest\n-     * @return the number of affected rows/records.\n-     * @throws ResourceException on failure to resolved query\n-     */\n-    public Object command(ActionRequest request) throws ResourceException {\n-\n-        ODatabaseDocumentTx db = getConnection();\n-        try {\n-            return commands.query(request.getResourcePath(), request, db);\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Performs the query on the specified object and returns the associated\n-     * results.\n-     * <p>\n-     * Queries are parametric; a set of named parameters is provided as the\n-     * query criteria. The query result is a JSON object structure composed of\n-     * basic Java types.\n-     *\n-     * The returned map is structured as follows:\n-     * <ul>\n-     *   <li>The top level map contains meta-data about the query, plus an entry\n-     *       with the actual result records.</li>\n-     *   <li>The <code>QueryConstants</code> defines the map keys, including the\n-     *       result records (QUERY_RESULT).</li>\n-     * </ul>\n-     *\n-     * @param   context\n-     *          Identifies the object to query.\n-     * @param   request\n-     *          The parameters of the query to perform.\n-     * @return  A promise containing the query results, which includes meta-data\n-     *          and the result records in JSON object structure format. If a\n-     *          failure occurs, the promise will wrap an exception of one of the\n-     *          following types:\n-     *          <dl>\n-     *            <dt>{@link NotFoundException}</dt>\n-     *            <dd>If the specified object could not be found.</dd>\n-     *\n-     *            <dt>{@link BadRequestException}</dt>\n-     *            <dd>If the specified params contain invalid arguments, e.g. a\n-     *                query id that is not configured, a query expression that\n-     *                is invalid, or missing query substitution tokens.</dd>\n-     *\n-     *            <dt>{@link ForbiddenException}</dt>\n-     *            <dd>If access to the object or specified query is\n-     *                forbidden.</dd>\n-     *          </dl>\n-     */\n-    @Override\n-    public Promise<QueryResponse, ResourceException> handleQuery(\n-                              final Context context, final QueryRequest request,\n-                              final QueryResourceHandler handler) {\n-        // If paged results are requested then decode the cookie in order to\n-        // determine the index of the first result to be returned.\n-        final int requestPageSize = request.getPageSize();\n-\n-        // Cookie containing offset of last request\n-        final String pagedResultsCookie = request.getPagedResultsCookie();\n-\n-        final boolean pagedResultsRequested = requestPageSize > 0;\n-\n-        // index of first record (used for SKIP/OFFSET)\n-        final int firstResultIndex;\n-\n-        if (pagedResultsRequested) {\n-            if (StringUtils.isNotEmpty(pagedResultsCookie)) {\n-                try {\n-                    firstResultIndex = Integer.parseInt(pagedResultsCookie);\n-                } catch (final NumberFormatException e) {\n-                    return new BadRequestException(\"Invalid paged results cookie\").asPromise();\n-                }\n-            } else {\n-                firstResultIndex = Math.max(0, request.getPagedResultsOffset());\n-            }\n-        } else {\n-            firstResultIndex = 0;\n-        }\n-\n-        // Once cookie is processed Queries.query() can rely on the offset.\n-        request.setPagedResultsOffset(firstResultIndex);\n-\n-        try {\n-            List<ResourceResponse> results = query(request);\n-            for (ResourceResponse result : results) {\n-                handler.handleResource(result);\n-            }\n-\n-            /*\n-             * Execute additional -count query if we are paging\n-             */\n-            final String nextCookie;\n-            // The number of results (if known)\n-            final int resultCount;\n-\n-            if (pagedResultsRequested) {\n-                // count if requested\n-                switch (request.getTotalPagedResultsPolicy()) {\n-                    case ESTIMATE:\n-                    case EXACT:\n-                        // Get total if -count query is available\n-                        final String countQueryId = request.getQueryId() + \"-count\";\n-                        if (queries.queryIdExists(countQueryId)) {\n-                            QueryRequest countRequest = Requests.copyOfQueryRequest(request);\n-                            countRequest.setQueryId(countQueryId);\n-\n-                            // Strip pagination parameters\n-                            countRequest.setPageSize(0);\n-                            countRequest.setPagedResultsOffset(0);\n-                            countRequest.setPagedResultsCookie(null);\n-\n-                            List<ResourceResponse> countResult = query(countRequest);\n-\n-                            if (countResult != null && !countResult.isEmpty()) {\n-                                resultCount = countResult.get(0).getContent().get(\"total\").asInteger();\n-                            } else {\n-                                logger.debug(\"Count query {} failed.\", countQueryId);\n-                                resultCount = NO_COUNT;\n-                            }\n-                        } else {\n-                            logger.debug(\"No count query found with id {}\", countQueryId);\n-                            resultCount = NO_COUNT;\n-                        }\n-                        break;\n-                    case NONE:\n-                    default:\n-                        resultCount = NO_COUNT;\n-                        break;\n-                }\n-\n-\n-                if (results.size() < requestPageSize) {\n-                    nextCookie = null;\n-                } else {\n-                    final int remainingResults = resultCount - (firstResultIndex + results.size());\n-                    if (remainingResults == 0) {\n-                        nextCookie = null;\n-                    } else {\n-                        nextCookie = String.valueOf(firstResultIndex + requestPageSize);\n-                    }\n-                }\n-            } else {\n-                resultCount = NO_COUNT;\n-                nextCookie = null;\n-            }\n-\n-            if (resultCount == NO_COUNT) {\n-                return newQueryResponse(nextCookie).asPromise();\n-            } else {\n-                return newQueryResponse(nextCookie, EXACT, resultCount).asPromise();\n-            }\n-        } catch (ResourceException e) {\n-            return e.asPromise();\n-        }\n-\n-    }\n-\n-    @Override\n-    public List<ResourceResponse> query(final QueryRequest request) throws ResourceException {\n-        List<ResourceResponse> results = new ArrayList<ResourceResponse>();\n-\n-        logger.trace(\"Full id: {} Extracted type: {}\", request.getResourcePath(), request.getResourcePath());\n-        // TODO: Statistics is not returned in result anymore\n-        // TODO: result is not needed in map form anymore\n-        Map<String, Object> result = new HashMap<String, Object>();\n-        ODatabaseDocumentTx db = getConnection();\n-        try {\n-            //List<Map<String, Object>> docs = new ArrayList<Map<String, Object>>();\n-            //result.put(QueryConstants.QUERY_RESULT, docs);\n-            long start = System.currentTimeMillis();\n-            List<ODocument> queryResult = queries.query(request.getResourcePath(), request, db);\n-            long end = System.currentTimeMillis();\n-            if (queryResult != null) {\n-                long convStart = System.currentTimeMillis();\n-                for (ODocument entry : queryResult) {\n-                    Map<String, Object> convertedEntry = DocumentUtil.toMap(entry);\n-                    //docs.add(convertedEntry);\n-                    results.add(newResourceResponse(\n-                            (String) convertedEntry.get(DocumentUtil.TAG_ID),\n-                            (String) convertedEntry.get(DocumentUtil.TAG_REV),\n-                            new JsonValue(convertedEntry)));\n-                }\n-                long convEnd = System.currentTimeMillis();\n-                result.put(QueryConstants.STATISTICS_CONVERSION_TIME, Long.valueOf(convEnd-convStart));\n-            }\n-            result.put(QueryConstants.STATISTICS_QUERY_TIME, Long.valueOf(end-start));\n-\n-            if (logger.isDebugEnabled()) {\n-                logger.debug(\"Query result contains {} records, took {} ms and took {} ms to convert result.\",\n-                        new Object[] {results.size(),\n-                        result.get(QueryConstants.STATISTICS_QUERY_TIME),\n-                        result.get(QueryConstants.STATISTICS_CONVERSION_TIME)});\n-            }\n-            return results;\n-        } finally {\n-            if (db != null) {\n-                db.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @return A connection from the pool. Call close on the connection when done to return to the pool.\n-     * @throws InternalServerErrorException\n-     */\n-    ODatabaseDocumentTx getConnection() throws InternalServerErrorException {\n-        ODatabaseDocumentTx db = null;\n-        int maxRetry = 100; // give it up to approx 10 seconds to recover\n-        int retryCount = 0;\n-\n-        synchronized (dbLock) {\n-            while (db == null && retryCount < maxRetry) {\n-                retryCount++;\n-                try {\n-                    db = pool.acquire(dbURL, user, password);\n-                    if (retryCount > 1) {\n-                        logger.info(\"Succeeded in acquiring connection from pool in retry attempt {}\", retryCount);\n-                    }\n-                    retryCount = maxRetry;\n-                } catch (com.orientechnologies.common.concur.lock.OLockException ex) {\n-                    // TODO: remove work-around once OrientDB resolves this condition\n-                    if (retryCount == maxRetry) {\n-                        logger.warn(\"Failure reported acquiring connection from pool, retried {} times before giving up.\", retryCount, ex);\n-                        throw new InternalServerErrorException(\n-                                \"Failure reported acquiring connection from pool, retried \" + retryCount + \" times before giving up: \"\n-                                        + ex.getMessage(), ex);\n-                    } else {\n-                        logger.info(\"Pool acquire reported failure, retrying - attempt {}\", retryCount);\n-                        logger.trace(\"Pool acquire failure detail \", ex);\n-                        try {\n-                            Thread.sleep(100); // Give the DB time to complete what it's doing before retrying\n-                        } catch (InterruptedException iex) {\n-                            // ignore that sleep was interrupted\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return db;\n-    }\n-\n-    public static String typeToOrientClassName(String type) {\n-        return type.replace(\"/\", \"_\");\n-    }\n-\n-    //public static String idToOrientClassName(String id) {\n-    //    String type = getObjectType(id);\n-    //    return typeToOrientClassName(type);\n-    //}\n-\n-    /**\n-     * Detect if the root cause of the exception is a duplicate record.\n-     * This is necessary as the database may wrap this root cause in further exceptions,\n-     * masking the underlying cause\n-     * @param ex The throwable to check\n-     * @param maxLevels the maximum level of causes to check, avoiding the cost\n-     * of checking recursiveness\n-     * @return\n-     */\n-    private boolean isCauseRecordDuplicatedException(Throwable ex, int maxLevels) {\n-        return isCauseException (ex, ORecordDuplicatedException.class, maxLevels);\n-    }\n-\n-    /**\n-     * Detect if the root cause of the exception is an index constraint violation\n-     * This is necessary as the database may wrap this root cause in further exceptions,\n-     * masking the underlying cause\n-     * @param ex The throwable to check\n-     * @param maxLevels the maximum level of causes to check, avoiding the cost\n-     * of checking recursiveness\n-     * @return\n-     */\n-    private boolean isCauseIndexException(Throwable ex, int maxLevels) {\n-        return isCauseException (ex, OIndexException.class, maxLevels);\n-    }\n-\n-    /**\n-     * Detect if the root cause of the exception is an index constraint violation\n-     * This is necessary as the database may wrap this root cause in further exceptions,\n-     * masking the underlying cause\n-     * @param ex The throwable to check\n-     * @param maxLevels the maximum level of causes to check, avoiding the cost\n-     * of checking recursiveness\n-     * @return\n-     */\n-    private boolean isCauseConcurrentModificationException(Throwable ex, int maxLevels) {\n-        return isCauseException (ex, OConcurrentModificationException.class, maxLevels);\n-    }\n-\n-    /**\n-     * Detect if the root cause of the exception is a specific OrientDB exception\n-     * This is necessary as the database may wrap this root cause in further exceptions,\n-     * masking the underlying cause\n-     * @param ex The throwable to check\n-     * @param clazz the specific OrientDB exception to check for\n-     * @param maxLevels the maximum level of causes to check, avoiding the cost\n-     * of checking recursiveness\n-     * @return whether the root cause is the specified exception\n-     */\n-    private boolean isCauseException(Throwable ex, Class<?> clazz, int maxLevels) {\n-        if (maxLevels > 0) {\n-            Throwable cause = ex.getCause();\n-            if (cause != null) {\n-                return clazz.isInstance(cause) || isCauseException(cause, clazz, maxLevels - 1);\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Populate and return a repository service that knows how to query and manipulate configuration.\n-     *\n-     * @param repoConfig the bootstrap configuration\n-     * @return the boot repository service. This instance is not managed by SCR and needs to be manually registered.\n-     */\n-    static OrientDBRepoService getRepoBootService(Map<String, Object> repoConfig) {\n-        if (bootRepo == null) {\n-            bootRepo = new OrientDBRepoService();\n-        }\n-        JsonValue cfg = new JsonValue(repoConfig);\n-        bootRepo.init(cfg);\n-        return bootRepo;\n-    }\n-\n-    @Activate\n-    void activate(ComponentContext compContext) throws Exception {\n-        logger.debug(\"Activating Service with configuration {}\", compContext.getProperties());\n-\n-        try {\n-            existingConfig = enhancedConfig.getConfigurationAsJson(compContext);\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Configuration invalid and could not be parsed, can not start OrientDB repository: \"\n-                    + ex.getMessage(), ex);\n-            throw ex;\n-        }\n-        embeddedServer = new EmbeddedOServerService();\n-        embeddedServer.activate(existingConfig);\n-\n-        init(existingConfig);\n-\n-        logger.info(\"Repository started.\");\n-    }\n-\n-    /**\n-     * Initialize the instance with the given configuration.\n-     *\n-     * This can configure managed (DS/SCR) instances, as well as explicitly instantiated\n-     * (bootstrap) instances.\n-     *\n-     * @param config the configuration\n-     */\n-    void init (JsonValue config) {\n-        synchronized (dbLock) {\n-        try {\n-            dbURL = getDBUrl(config);\n-            logger.info(\"Use DB at dbURL: {}\", dbURL);\n-\n-            user = config.get(CONFIG_USER).defaultTo(\"admin\").asString();\n-            password = config.get(CONFIG_PASSWORD).defaultTo(\"admin\").asString();\n-            poolMinSize = config.get(CONFIG_POOL_MIN_SIZE).defaultTo(DEFAULT_POOL_MIN_SIZE).asInteger();\n-            poolMaxSize = config.get(CONFIG_POOL_MAX_SIZE).defaultTo(DEFAULT_POOL_MAX_SIZE).asInteger();\n-\n-            Map<String, String> queryMap = config.get(CONFIG_QUERIES)\n-                    .defaultTo(new HashMap<String, String>())\n-                    .asMap(String.class);\n-            queries.setConfiguredQueries(queryMap);\n-            Map<String, String> commandMap = config.get(CONFIG_COMMANDS)\n-                    .defaultTo(new HashMap<String, String>())\n-                    .asMap(String.class);\n-            commands.setConfiguredQueries(commandMap);\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Configuration invalid, can not start OrientDB repository\", ex);\n-            throw ex;\n-        }\n-\n-        try {\n-            pool = DBHelper.getPool(dbURL, user, password, poolMinSize, poolMaxSize, config, true);\n-            logger.debug(\"Obtained pool {}\", pool);\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Initializing database pool failed\", ex);\n-            throw ex;\n-        }\n-        }\n-    }\n-\n-    private String getDBUrl(JsonValue config) {\n-        File dbFolder = IdentityServer.getFileForWorkingPath(\"db/openidm\");\n-        String orientDbFolder = dbFolder.getAbsolutePath();\n-        orientDbFolder = orientDbFolder.replace('\\\\', '/'); // OrientDB does not handle backslashes well\n-        return config.get(OrientDBRepoService.CONFIG_DB_URL).defaultTo(\"local:\" + orientDbFolder).asString();\n-    }\n-\n-    private String getUser(JsonValue config) {\n-        return config.get(CONFIG_USER).defaultTo(\"admin\").asString();\n-    }\n-\n-    private String getPassword(JsonValue config) {\n-        return config.get(CONFIG_PASSWORD).defaultTo(\"admin\").asString();\n-    }\n-\n-    private int getPoolMinSize(JsonValue config) {\n-        return config.get(CONFIG_POOL_MIN_SIZE).defaultTo(DEFAULT_POOL_MIN_SIZE).asInteger();\n-    }\n-\n-    private int getPoolMaxSize(JsonValue config) {\n-        return config.get(CONFIG_POOL_MAX_SIZE).defaultTo(DEFAULT_POOL_MAX_SIZE).asInteger();\n-    }\n-\n-    /**\n-     * Adapts an {@code Exception} to a {@code ResourceException}. If the\n-     * {@code Exception} is an JSON {@code JsonValueException} then an\n-     * appropriate {@code ResourceException} is returned, otherwise an\n-     * {@code InternalServerErrorException} is returned.\n-     *\n-     * @param ex\n-     *            The {@code Exception} to be converted.\n-     * @return The equivalent resource exception.\n-     */\n-    private ResourceException adapt(final Exception ex) {\n-        Reject.ifNull(ex);\n-        int resourceResultCode;\n-        try {\n-            throw ex;\n-        } catch (OConcurrentModificationException e) {\n-            resourceResultCode = ResourceException.VERSION_MISMATCH;\n-        } catch (final ResourceException e) {\n-            return e;\n-        } catch (final JsonValueException e) {\n-            resourceResultCode = ResourceException.BAD_REQUEST;\n-        } catch (final Exception e) {\n-            resourceResultCode = ResourceException.INTERNAL_ERROR;\n-        }\n-        return newResourceException(resourceResultCode, ex.getMessage(), ex);\n-    }\n-\n-    /**\n-     * Handle an existing activated service getting changed;\n-     * e.g. configuration changes or dependency changes\n-     *\n-     * @param compContext THe OSGI component context\n-     * @throws Exception if handling the modified event failed\n-     */\n-    @Modified\n-    void modified(ComponentContext compContext) throws Exception {\n-        logger.debug(\"Handle repository service modified notification\");\n-        JsonValue newConfig = null;\n-        try {\n-            newConfig = enhancedConfig.getConfigurationAsJson(compContext);\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Configuration invalid and could not be parsed, can not start OrientDB repository\", ex);\n-            throw ex;\n-        }\n-        if (existingConfig != null\n-                && !existingConfig.get(\"embeddedServer\").equals(newConfig.get(\"embeddedServer\"))) {\n-            // The embedded server configuration has changed so re-initialize it.\n-            embeddedServer.modified(newConfig);\n-        }\n-        if (existingConfig != null\n-                && user.equals(getUser(newConfig))\n-                && password.equals(getPassword(newConfig))\n-                && dbURL.equals(getDBUrl(newConfig))\n-                && poolMinSize == getPoolMinSize(newConfig)\n-                && poolMaxSize == getPoolMaxSize(newConfig)) {\n-            // If the DB pool settings don't change keep the existing pool\n-            logger.info(\"(Re-)initialize repository with latest configuration.\");\n-        } else {\n-            // If the DB pool settings changed do a more complete re-initialization\n-            logger.info(\"Re-initialize repository with latest configuration - including DB pool setting changes.\");\n-            DBHelper.closePool(dbURL, pool);\n-        }\n-        init(newConfig);\n-\n-        if (bootRepo != null) {\n-            bootRepo.init(newConfig);\n-        }\n-\n-        existingConfig = newConfig;\n-        logger.debug(\"Repository service modified\");\n-    }\n-\n-    @Deactivate\n-    void deactivate(ComponentContext compContext) {\n-        logger.debug(\"Deactivating Service {}\", compContext);\n-        cleanup();\n-        if (embeddedServer != null) {\n-            embeddedServer.deactivate();\n-        }\n-        logger.info(\"Repository stopped.\");\n-    }\n-\n-    /**\n-     * Cleanup and close the repository\n-     */\n-    void cleanup() {\n-        DBHelper.closePools();\n-    }\n-}"
  },
  {
    "sha": "8904489b1fe3a0e3cdec380d02f25645375ba3a2",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Commands.java",
    "status": "removed",
    "additions": 0,
    "deletions": 127,
    "changes": 127,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Commands.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Commands.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Commands.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,127 +0,0 @@\n-/*\n-/*\n- * The contents of this file are subject to the terms of the Common Development and\n- * Distribution License (the License). You may not use this file except in compliance with the\n- * License.\n- *\n- * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\n- * specific language governing permission and limitations under the License.\n- *\n- * When distributing Covered Software, include this CDDL Header Notice in each file and include\n- * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\n- * Header, with the fields enclosed by brackets [] replaced by your own identifying\n- * information: \"Portions copyright [year] [name of copyright owner]\".\n- *\n- * Copyright 2014-2016 ForgeRock AS.\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.orientechnologies.common.exception.OException;\n-import org.forgerock.json.resource.ActionRequest;\n-import org.forgerock.json.resource.BadRequestException;\n-import org.forgerock.openidm.repo.QueryConstants;\n-import org.forgerock.openidm.repo.orientdb.impl.OrientDBRepoService;\n-import org.forgerock.openidm.smartevent.EventEntry;\n-import org.forgerock.openidm.smartevent.Name;\n-import org.forgerock.openidm.smartevent.Publisher;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.exception.OQueryParsingException;\n-import com.orientechnologies.orient.core.sql.OCommandSQL;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Configured and add-hoc command support on OrientDB\n- * \n- * Commands can contain tokens of the format ${token-name}\n- * \n- */\n-public class Commands extends ConfiguredQueries<OCommandSQL, ActionRequest, Integer> {\n-\n-    final static Logger logger = LoggerFactory.getLogger(Commands.class);\n-\n-    private static final String COMMAND_ID = \"commandId\";\n-    private static final String COMMAND_EXPRESSION = \"commandExpression\";\n-\n-    public Commands() {\n-        super(new HashMap<String, QueryInfo<OCommandSQL>>());\n-    }\n-\n-    /**\n-     * Create an SQL command to execute the command query.\n-     *\n-     * @param queryString the query expression, including tokens to replace\n-     * @return the prepared query object\n-     */\n-    protected OCommandSQL createQueryObject(String queryString) {\n-        return new OCommandSQL(queryString);\n-    }\n-\n-    /**\n-     * Execute a command, either a pre-configured command by using the command ID, or a command expression passed as\n-     * part of the params.\n-     *\n-     * The keys for the input parameters as well as the return map entries are in QueryConstants.\n-     *\n-     * @param type the relative/local resource name, which needs to be converted to match the OrientDB document class name\n-     * @param request the query request, including parameters which include the query id, or the query expression, as well as the\n-     *        token key/value pairs to replace in the query\n-     * @param database a handle to a database connection instance for exclusive use by the query method whilst it is executing.\n-     * @return The query result, which includes meta-data about the query, and the result set itself.\n-     * @throws org.forgerock.json.resource.BadRequestException if the passed request parameters are invalid, e.g. missing query id or query expression or tokens.\n-     */\n-    public Integer query(final String type, final ActionRequest request, final ODatabaseDocumentTx database)\n-            throws BadRequestException {\n-\n-        final Map<String, String> params = new HashMap<String, String>(request.getAdditionalParameters());\n-        params.put(QueryConstants.RESOURCE_NAME, OrientDBRepoService.typeToOrientClassName(type));\n-\n-        if (params.get(COMMAND_ID) == null && params.get(COMMAND_EXPRESSION) == null) {\n-            throw new BadRequestException(\"Either \" + COMMAND_ID + \" or \" + COMMAND_EXPRESSION\n-                    + \" to identify/define a command must be passed in the parameters. \" + params);\n-        }\n-\n-        final QueryInfo<OCommandSQL> queryInfo;\n-        try {\n-            queryInfo = findQueryInfo(type, params.get(COMMAND_ID), params.get(COMMAND_EXPRESSION));\n-        } catch (IllegalArgumentException e) {\n-            throw new BadRequestException(\"The passed command identifier \" + params.get(COMMAND_ID)\n-                    + \" does not match any configured commands on the OrientDB repository service.\");\n-        }\n-\n-        Integer result = null;\n-\n-        logger.debug(\"Evaluate command {}\", queryInfo.getQueryString());\n-        Name eventName = getEventName(params.get(COMMAND_ID), params.get(COMMAND_EXPRESSION));\n-        EventEntry measure = Publisher.start(eventName, queryInfo, null);\n-\n-        try {\n-            result = doTokenSubsitutionQuery(queryInfo, params, database);\n-            measure.setResult(result);\n-            return result;\n-        } catch (OQueryParsingException firstTryEx) {\n-            // TODO: consider differentiating between bad configuration and bad request\n-            throw new BadRequestException(\"Failed to resolve and parse the command \"\n-                    + queryInfo.getQueryString() + \" with params: \" + params, firstTryEx);\n-        } catch (IllegalArgumentException ex) {\n-            // TODO: consider differentiating between bad configuration and bad request\n-            logger.debug(\"Command is invalid: {} {}\", queryInfo.getQueryString(), ex.getMessage(), ex);\n-            throw new BadRequestException(\"Command is invalid.\");\n-        } catch (OException ex) {\n-            logger.debug(\"Error executing DB command {} {}\", queryInfo.getQueryString(), ex.getMessage(), ex);\n-            throw new BadRequestException(\"Error executing DB command.\");\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Unexpected failure during DB command: {}\", ex.getMessage());\n-            throw ex;\n-        } finally {\n-            measure.end();\n-        }\n-    }\n-\n-}"
  },
  {
    "sha": "2dbfbd1902bd86ed80fd5e187d45c5910c1fd42c",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/ConfiguredQueries.java",
    "status": "removed",
    "additions": 0,
    "deletions": 227,
    "changes": 227,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/ConfiguredQueries.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/ConfiguredQueries.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/ConfiguredQueries.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,227 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011-2014 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import com.orientechnologies.orient.core.command.OCommandRequest;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-\n-import java.util.Map;\n-\n-import org.forgerock.json.resource.BadRequestException;\n-import org.forgerock.json.resource.Request;\n-import org.forgerock.openidm.smartevent.Name;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-\n-/**\n- * Configured and ad-hoc query support on OrientDB\n- * \n- * Queries can contain tokens of the format ${token-name}\n- *\n- * @param <Q> The query object type\n- * @param <R> The request type\n- * @param <U> The result type\n- *\n- */\n-public abstract class ConfiguredQueries<Q extends OCommandRequest, R extends Request, U> {\n-\n-    final static Logger logger = LoggerFactory.getLogger(ConfiguredQueries.class);\n-    \n-    // Monitoring event name prefix\n-    static final String EVENT_RAW_QUERY_PREFIX = \"openidm/internal/repo/orientdb/raw/query/\";\n-\n-    private final TokenHandler tokenHandler = new TokenHandler();\n-    \n-    // Pre-configured queries, key is query id\n-    private final Map<String, QueryInfo<Q>> configuredQueries;\n-\n-    ConfiguredQueries(Map<String, QueryInfo<Q>> configuredQueries) {\n-        this.configuredQueries = configuredQueries;\n-    }\n-\n-    /**\n-     * Set the pre-configured queries, which are identified by a query identifier and can be\n-     * invoked using this identifier\n-     * \n-     * Success to set the queries does not mean they are valid as some can only be validated at\n-     * query execution time.\n-     * \n-     * @param queries the complete list of configured queries, mapping from query id to the \n-     * query expression which may optionally contain tokens in the form ${token-name}.\n-     */\n-    public void setConfiguredQueries(Map<String, String> queries) {\n-        configuredQueries.clear();\n-        \n-        // Populate/Override with Queries configured\n-        if (queries != null) {\n-            for (Map.Entry<String, String> entry : queries.entrySet()) {\n-                String queryId = entry.getKey();\n-                String queryString = entry.getValue();\n-                QueryInfo<Q> queryInfo = prepareQuery(queryString);\n-                configuredQueries.put(queryId, queryInfo);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Check if a {@code queryId} is present in the set of configured queries.\n-     *\n-     * @param queryId Id of the query to check for\n-     *\n-     * @return true if the queryId is present in the set of configured queries.\n-     */\n-    public boolean queryIdExists(final String queryId) {\n-        return configuredQueries.containsKey(queryId);\n-    }\n-\n-    /**\n-     * Resolve the query string which can contain %{token} tokens to a fully resolved query\n-     * Doing the resolution ourselves means it can not be a prepared statement with tokens\n-     * that gets re-used, but it allows us to replace more parts of the query than just\n-     * the where clause.\n-     *  \n-     * @param queryString The query with tokens\n-     * @param params THe parameters to replace the tokens with\n-     * @return the query with any found tokens replaced\n-     * @throws BadRequestException if the queryString contains token missing from params\n-     */\n-    private Q resolveQuery(String queryString, Map<String, String> params)\n-            throws BadRequestException {\n-        String resolvedQueryString = tokenHandler.replaceTokensWithValues(queryString, params);\n-        return createQueryObject(resolvedQueryString);\n-    }\n-\n-    /**\n-     * Populate and prepare the query information with the query expression passed in the parameters\n-     *\n-     * @param type the relative/local resource name\n-     * @param queryExpression the parameters with the query expression and token replacement key/values\n-     * @return the populated query info\n-     */\n-    private QueryInfo<Q> resolveInlineQuery(final String type, String queryExpression) {\n-        // TODO: LRU cache\n-        return prepareQuery(queryExpression);\n-    }\n-\n-    /**\n-     * Construct a prepared statement from the query String\n-     * \n-     * The constructed prepared query can only be verified at query execution time\n-     * and hence the query execution may later fall back onto non-prepared execution\n-     * \n-     * @param queryString the query expression, including tokens to replace\n-     * @return the constructed (but not validated) prepared statement\n-     */\n-    private QueryInfo<Q> prepareQuery(String queryString) {\n-        try {\n-            String replacedQueryString = tokenHandler.replaceTokensWithOrientToken(queryString);\n-            Q query = createQueryObject(replacedQueryString);\n-            return new QueryInfo<>(true, query, queryString);\n-        } catch (PrepareNotSupported ex) {\n-            // Statement not in a format that it can be converted into prepared statement\n-            return new QueryInfo<>(false, null, queryString);\n-        } catch (com.orientechnologies.orient.core.exception.OQueryParsingException ex) {\n-            // With current OrientDB impl parsing will actually only fail on first use,\n-            // hence unless the implementation changes this is unlikely to trigger\n-            return new QueryInfo<>(false, null, queryString);\n-        }\n-    }\n-\n-    /**\n-     * Create the prepared query object type according to the implementation.\n-     *\n-     * @param queryString the query expression, including tokens to replace\n-     * @return the prepared query object\n-     */\n-    protected abstract Q createQueryObject(String queryString);\n-\n-    /**\n-     * @return the smartevent Name for a given query\n-     */\n-    Name getEventName(String queryId, String queryExpression) {\n-        if (queryId == null) {\n-            return Name.get(EVENT_RAW_QUERY_PREFIX + \"_query_expression\");\n-        } else {\n-            return Name.get(EVENT_RAW_QUERY_PREFIX + queryId);\n-        }\n-    }\n-\n-    /**\n-     * Find the QueryInfo according to the commandId or commandExpression.\n-     *\n-     * @param type the type/resource to query\n-     * @param queryId the queryId parameter\n-     * @param queryExpression the queryExpression parameter\n-     * @return\n-     * @throws NullPointerException if neither queryId or queryExpression are provided\n-     * @throws IllegalArgumentException if the queryId is not known/configured\n-     */\n-    QueryInfo<Q> findQueryInfo(String type, String queryId, String queryExpression) {\n-\n-        if (queryId == null && queryExpression == null) {\n-            throw new NullPointerException();\n-        }\n-        if (queryExpression != null) {\n-            return resolveInlineQuery(type, queryExpression);\n-        }\n-        if (queryIdExists(queryId)) {\n-            return configuredQueries.get(queryId);\n-        }\n-        throw new IllegalArgumentException();\n-    }\n-\n-    /**\n-     * Execute a query, either a pre-configured query by using the query ID, or a query expression passed as \n-     * part of the params.\n-     * \n-     * The keys for the input parameters as well as the return map entries are in QueryConstants.\n-     * \n-     * @param type the relative/local resource name, which needs to be converted to match the OrientDB document class name\n-     * @param request the query request, including parameters which include the query id, or the query expression, as well as the \n-     *        token key/value pairs to replace in the query\n-     * @param database a handle to a database connection instance for exclusive use by the query method whilst it is executing.\n-     * @return The query result, which includes meta-data about the query, and the result set itself.\n-     * @throws BadRequestException if the passed request parameters are invalid, e.g. missing query id or query expression or tokens.\n-     */\n-    public abstract U query(final String type, R request, ODatabaseDocumentTx database) throws BadRequestException;\n-\n-    U doTokenSubsitutionQuery(QueryInfo<Q> queryInfo, Map<String, String> params, ODatabaseDocumentTx database)\n-            throws BadRequestException {\n-        // Substitute tokens manually, which supports replacing any part of the query\n-        Q query = resolveQuery(queryInfo.getQueryString(), params);\n-        logger.debug(\"Manual token substitution for {} resulted in {}\", queryInfo.getQueryString(), query);\n-        return database.command(query).execute(params);\n-    }\n-\n-    U doPreparedQuery(QueryInfo<Q> queryInfo, Map<String, String> params, ODatabaseDocumentTx database)\n-            throws BadRequestException {\n-        // Try to use the prepared statement, which supports token substitution of where clause\n-        Q query = queryInfo.getPreparedQuery();\n-        logger.debug(\"Prepared query {} \", query);\n-        return database.command(query).execute(params);\n-    }\n-\n-}"
  },
  {
    "sha": "da04ab61cfaa9bdcb8846ca7e5099da92409141a",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PredefinedQueries.java",
    "status": "removed",
    "additions": 0,
    "deletions": 82,
    "changes": 82,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PredefinedQueries.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PredefinedQueries.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PredefinedQueries.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,82 +0,0 @@\n-/*\n- * The contents of this file are subject to the terms of the Common Development and\n- * Distribution License (the License). You may not use this file except in compliance with the\n- * License.\n- *\n- * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\n- * specific language governing permission and limitations under the License.\n- *\n- * When distributing Covered Software, include this CDDL Header Notice in each file and include\n- * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\n- * Header, with the fields enclosed by brackets [] replaced by your own identifying\n- * information: \"Portions copyright [year] [name of copyright owner]\".\n- *\n- * Copyright 2011-2016 ForgeRock AS.\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import java.util.List;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.exception.OCommandExecutionException;\n-import com.orientechnologies.orient.core.exception.OQueryParsingException;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.core.sql.query.OSQLSynchQuery;\n-\n-import org.forgerock.json.resource.BadRequestException;\n-import org.forgerock.json.resource.InternalServerErrorException;\n-import org.forgerock.json.resource.ResourceException;\n-import org.forgerock.openidm.repo.orientdb.impl.DocumentUtil;\n-import org.forgerock.openidm.repo.orientdb.impl.OrientDBRepoService;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Queries pre-defined by the system\n- * \n- */\n-public class PredefinedQueries {\n-\n-    final static Logger logger = LoggerFactory.getLogger(PredefinedQueries.class);\n-    \n-    /**\n-     * Query by primary key, the OpenIDM identifier. This identifier is different from the OrientDB internal record id.\n-     * \n-     * @param id the OpenIDM identifier for an object\n-     * @param type the OrientDB class\n-     * @param database a handle to the OrientDB database object. No other thread must operate on this concurrently.\n-     * @return The ODocument if found, null if not found.\n-     * @throws ResourceException if the passed identifier or type are invalid or error on execution\n-     */\n-    public ODocument getByID(final String id, final String type, ODatabaseDocumentTx database)\n-            throws ResourceException {\n-\n-        String orientClassName = OrientDBRepoService.typeToOrientClassName(type);\n-\n-        if (id == null) {\n-            throw new BadRequestException(\"Query by id the passed id was null.\");\n-        } else if (type == null) {\n-            throw new BadRequestException(\"Query by id the passed type was null.\");\n-        }\n-\n-        // TODO: convert into a prepared statement\n-        OSQLSynchQuery<ODocument> query = new OSQLSynchQuery<ODocument>(\n-                \"select * from \" + orientClassName + \" where \" + DocumentUtil.ORIENTDB_PRIMARY_KEY + \" = '\" + id + \"'\");\n-\n-        ODocument first = null;\n-        try {\n-            List<ODocument> result = database.query(query);\n-            logger.trace(\"Query: {} Result: {}\", query, result);\n-            if (result.size() > 0) {\n-                first = result.get(0); // ID is of type unique index, there must only be one at most\n-            }\n-        } catch (OQueryParsingException | OCommandExecutionException e) {\n-            logger.debug(\"The passed id: {} or type: {} is invalid.\", id, type, e);\n-            throw new BadRequestException(\"Illegal query request.\", e);\n-        } catch (Exception e) {\n-            logger.debug(\"Could not complete query for id: {} and type: {}.\", id, type, e);\n-            throw new InternalServerErrorException(\"An error occurred processing the query request.\", e);\n-        }\n-        return first;\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "ef6703760457c1f33b2a02e2fb06d99436b16f06",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PrepareNotSupported.java",
    "status": "removed",
    "additions": 0,
    "deletions": 62,
    "changes": 62,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PrepareNotSupported.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PrepareNotSupported.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/PrepareNotSupported.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,62 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright (c) 2012 ForgeRock AS. All Rights Reserved\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-/**\n- * An exception to indicate that a statement can not be converted into \n- * a prepared statement \n- *\n- */\n-public class PrepareNotSupported extends Exception {\n-\n-    /** Serializable class a version number. */\n-    static final long serialVersionUID = 1L;\n-\n-    /**\n-     * Constructs a new exception with {@code null} as its detail message.\n-     */\n-    public PrepareNotSupported() {\n-    }\n-\n-    /**\n-     * Constructs a new exception with the specified detail message.\n-     */\n-    public PrepareNotSupported(String message) {\n-        super(message);\n-    }\n-    \n-    /**\n-     * Constructs a new exception with the specified cause.\n-     */\n-    public PrepareNotSupported(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    /**\n-     * Constructs a new exception with the specified detail message and cause.\n-     */\n-    public PrepareNotSupported(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-}"
  },
  {
    "sha": "c2ed3067a99248c5b3dbc30e96a307248ee625f8",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Queries.java",
    "status": "removed",
    "additions": 0,
    "deletions": 255,
    "changes": 255,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Queries.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Queries.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/Queries.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,255 +0,0 @@\n-/*\n- * The contents of this file are subject to the terms of the Common Development and\n- * Distribution License (the License). You may not use this file except in compliance with the\n- * License.\n- *\n- * You can obtain a copy of the License at legal/CDDLv1.0.txt. See the License for the\n- * specific language governing permission and limitations under the License.\n- *\n- * When distributing Covered Software, include this CDDL Header Notice in each file and include\n- * the License file at legal/CDDLv1.0.txt. If applicable, add the following below the CDDL\n- * Header, with the fields enclosed by brackets [] replaced by your own identifying\n- * information: \"Portions copyright [year] [name of copyright owner]\".\n- *\n- * Copyright 2011-2016 ForgeRock AS.\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\n-import com.orientechnologies.common.exception.OException;\n-import org.apache.commons.lang3.StringUtils;\n-import org.forgerock.json.JsonPointer;\n-import org.forgerock.json.resource.BadRequestException;\n-import org.forgerock.json.resource.QueryRequest;\n-import org.forgerock.json.resource.SortKey;\n-import org.forgerock.openidm.repo.QueryConstants;\n-import org.forgerock.openidm.repo.orientdb.impl.DocumentUtil;\n-import org.forgerock.openidm.repo.orientdb.impl.OrientDBRepoService;\n-import org.forgerock.openidm.repo.util.StringSQLQueryFilterVisitor;\n-import org.forgerock.openidm.repo.util.StringSQLRenderer;\n-import org.forgerock.openidm.smartevent.EventEntry;\n-import org.forgerock.openidm.smartevent.Name;\n-import org.forgerock.openidm.smartevent.Publisher;\n-import org.forgerock.openidm.util.ResourceUtil;\n-import org.forgerock.util.query.QueryFilter;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.exception.OQueryParsingException;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.core.sql.query.OSQLSynchQuery;\n-\n-/**\n- * Configured and add-hoc query support on OrientDB\n- * \n- * Queries can contain tokens of the format ${token-name}\n- */\n-public class Queries extends ConfiguredQueries<OSQLSynchQuery<ODocument>, QueryRequest, List<ODocument>> {\n-\n-    final static Logger logger = LoggerFactory.getLogger(Queries.class);\n-\n-    private class OrientQueryFilterVisitor extends StringSQLQueryFilterVisitor<Map<String, String>> {\n-        int objectNumber = 0;\n-        @Override\n-        public StringSQLRenderer visitValueAssertion(Map<String, String> objects, String operand, JsonPointer field, Object valueAssertion) {\n-            ++objectNumber;\n-            String value = \"v\"+objectNumber;\n-            if (ResourceUtil.RESOURCE_FIELD_CONTENT_ID_POINTER.equals(field)) {\n-                objects.put(field.toString(), DocumentUtil.ORIENTDB_PRIMARY_KEY);\n-            } else {\n-                objects.put(field.toString(), field.toString());\n-            }\n-            objects.put(value, String.valueOf(valueAssertion));\n-            return new StringSQLRenderer(\"(${dotnotation:\" + field.toString() + \"} \" + operand + \" ${\" + value + \"})\");\n-        }\n-\n-        @Override\n-        public StringSQLRenderer visitPresentFilter(Map<String, String> objects, JsonPointer field) {\n-            if (ResourceUtil.RESOURCE_FIELD_CONTENT_ID_POINTER.equals(field)) {\n-                objects.put(field.toString(), DocumentUtil.ORIENTDB_PRIMARY_KEY);\n-            } else {\n-                objects.put(field.toString(), field.toString());\n-            }\n-            return new StringSQLRenderer(\"(${dotnotation:\" + field.toString() + \"} IS NOT NULL)\");\n-        }\n-\n-        @Override\n-        public StringSQLRenderer visitNotFilter(Map<String, String> objects, QueryFilter<JsonPointer> subFilter) {\n-            return new StringSQLRenderer(\"(NOT \" + subFilter.accept(this, objects) + \")\");\n-        }\n-\n-        @Override\n-        public StringSQLRenderer visitStartsWithFilter(Map<String, String> parameters, JsonPointer field, Object valueAssertion) {\n-            // OrientDB needs double % for \"like anything\"\n-            return \"\".equals(valueAssertion)\n-                ? visitValueAssertion(parameters, \"LIKE\", field, \"%%\")\n-                : visitValueAssertion(parameters, \"LIKE\", field, valueAssertion + \"%\");\n-        }\n-    }\n-\n-    public Queries() {\n-        super(new HashMap<String, QueryInfo<OSQLSynchQuery<ODocument>>>());\n-    }\n-    \n-    /**\n-     * Set the pre-configured queries, which are identified by a query identifier and can be\n-     * invoked using this identifier\n-     * \n-     * Success to set the queries does not mean they are valid as some can only be validated at\n-     * query execution time.\n-     * \n-     * @param queries the complete list of configured queries, mapping from query id to the \n-     * query expression which may optionally contain tokens in the form ${token-name}.\n-     */\n-    @Override\n-    public void setConfiguredQueries(Map<String, String> queries) {\n-        // Query all IDs is a mandatory query, default it and allow override.\n-        if (!queries.containsKey(\"query-all-ids\")) {\n-            queries.put(\"query-all-ids\", \"select _openidm_id from ${unquoted:_resource}\");\n-        }\n-\n-        super.setConfiguredQueries(queries);\n-    }\n-\n-    /**\n-     * Create an SQL synchronous query returning an ODocument containing the query result.\n-     *\n-     * @param queryString the query expression, including tokens to replace\n-     * @return the prepared query object\n-     * */\n-    protected OSQLSynchQuery<ODocument> createQueryObject(String queryString) {\n-        return new OSQLSynchQuery<ODocument>(queryString);\n-    }\n-\n-    private QueryInfo<OSQLSynchQuery<ODocument>> findQueryInfo(String type, Map<String, String> params,\n-            String queryId, String queryExpression, QueryFilter<JsonPointer> filter) {\n-        String queryString = queryExpression == null ? null : queryExpression + params.get(\"pageClause\");\n-        if (filter != null) {\n-            // If there is a filter, use it's query string\n-            queryString = \"SELECT * FROM ${unquoted:_resource} WHERE \"\n-                    + filter.accept(new OrientQueryFilterVisitor(), params).toSQL()\n-                    + \" \" + params.get(QueryConstants.PAGE_CLAUSE);\n-        }\n-        // treat the query created by the filter as a queryExpression\n-        return findQueryInfo(type, queryId, queryString);\n-    }\n-\n-    /**\n-     * Execute a query, either a pre-configured query by using the query ID, or a query expression passed as \n-     * part of the params.\n-     * \n-     * The keys for the input parameters as well as the return map entries are in QueryConstants.\n-     * \n-     * @param type the relative/local resource name, which needs to be converted to match the OrientDB document class name\n-     * @param request the query request, including parameters which include the query id, or the query expression, as well as the \n-     *        token key/value pairs to replace in the query\n-     * @param database a handle to a database connection instance for exclusive use by the query method whilst it is executing.\n-     * @return The query result, which includes meta-data about the query, and the result set itself.\n-     * @throws BadRequestException if the passed request parameters are invalid, e.g. missing query id or query expression or tokens.\n-     */\n-    public List<ODocument> query(final String type, QueryRequest request, final ODatabaseDocumentTx database)\n-            throws BadRequestException {\n-\n-        final Map<String, String> params = new HashMap<String, String>(request.getAdditionalParameters());\n-        params.put(QueryConstants.RESOURCE_NAME, OrientDBRepoService.typeToOrientClassName(type));\n-        params.putAll(getPagingParameters(request));\n-\n-        if (request.getQueryId() == null \n-                && request.getQueryExpression() == null \n-                && request.getQueryFilter() == null) {\n-            throw new BadRequestException(\"Either \" + QueryConstants.QUERY_ID + \", \" \n-                    + QueryConstants.QUERY_EXPRESSION + \", or \" + QueryConstants.QUERY_FILTER\n-                    + \" to identify/define a query must be passed in the parameters. \" + params);\n-        }\n-\n-        final QueryInfo<OSQLSynchQuery<ODocument>> queryInfo;\n-        try {\n-            queryInfo = findQueryInfo(type, params, request.getQueryId(), request.getQueryExpression(), request.getQueryFilter());\n-        } catch (IllegalArgumentException e) {\n-            throw new BadRequestException(\"The passed identifier \" + request.getQueryId()\n-                    + \" does not match any configured queries on the OrientDB repository service.\");\n-        }\n-\n-        List<ODocument> result = null;\n-\n-        logger.debug(\"Evaluate query {}\", queryInfo.getQueryString());\n-        Name eventName = getEventName(request.getQueryId(), request.getQueryExpression());\n-        EventEntry measure = Publisher.start(eventName, queryInfo, null);\n-\n-        try {\n-            result = doTokenSubsitutionQuery(queryInfo, params, database);\n-            measure.setResult(result);\n-        } catch (OQueryParsingException firstTryEx) {\n-            // TODO: consider differentiating between bad configuration and bad request\n-            logger.debug(\"Failed to resolve and parse the query {} with params: {}\",\n-                    queryInfo.getQueryString(), params, firstTryEx);\n-            throw new BadRequestException(\"Failed to resolve and parse the query.\");\n-        } catch (IllegalArgumentException ex) {\n-            // TODO: consider differentiating between bad configuration and bad request\n-            logger.debug(\"Query is invalid: {} {}\", queryInfo.getQueryString(), ex.getMessage(), ex);\n-            throw new BadRequestException(\"Query is invalid.\");\n-        } catch (OException ex) {\n-            logger.debug(\"Error executing DB command {} {}\", queryInfo.getQueryString(), ex.getMessage(), ex);\n-            throw new BadRequestException(\"Error executing DB command.\");\n-        } catch (RuntimeException ex) {\n-            logger.warn(\"Unexpected failure during DB query: {}\", ex.getMessage());\n-            throw ex;\n-        } finally {\n-            measure.end();\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Return the page size and offset parameters as requested.\n-     *\n-     * @param request the QueryRequest\n-     * @return the Map of page size and results offset\n-     */\n-    private Map<String, String> getPagingParameters(QueryRequest request) {\n-        final Map<String, String> params = new HashMap<String, String>(2);\n-\n-        // If paged results are requested then decode the cookie in order to determine\n-        // the index of the first result to be returned.\n-        final int requestPageSize = request.getPageSize();\n-\n-        final String offsetParam;\n-        final String pageSizeParam;\n-        final List<SortKey> sortKeys;\n-        String pageClause;\n-\n-        if (requestPageSize > 0) {\n-            offsetParam = String.valueOf(request.getPagedResultsOffset());\n-            pageSizeParam = String.valueOf(requestPageSize);\n-            sortKeys = request.getSortKeys();\n-            pageClause = \"SKIP \" + offsetParam + \" LIMIT \" + pageSizeParam;\n-            // Add sort keys, if any\n-            if (sortKeys != null && sortKeys.size() > 0) {\n-                List<String> keys = new ArrayList<String>();\n-                for (SortKey sortKey : sortKeys) {\n-                    String field = sortKey.getField().toString().substring(1);\n-                    keys.add(field + (sortKey.isAscendingOrder() ? \" ASC\" : \" DESC\"));\n-                }\n-                pageClause += \" ORDER BY \" + StringUtils.join(keys, \", \");\n-            }\n-        } else {\n-            offsetParam = \"0\";\n-            pageSizeParam = \"-1\"; // unlimited in Orient\n-            pageClause = \"\";\n-        }\n-\n-        params.put(QueryConstants.PAGED_RESULTS_OFFSET, offsetParam);\n-        params.put(QueryConstants.PAGE_SIZE, pageSizeParam);\n-        params.put(QueryConstants.PAGE_CLAUSE, pageClause);\n-\n-        return params;\n-    }\n-\n-}"
  },
  {
    "sha": "f42c47ae4178212b76ac54b86aebccaa6418a630",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfo.java",
    "status": "removed",
    "additions": 0,
    "deletions": 75,
    "changes": 75,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfo.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfo.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfo.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,75 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011-2014 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-/**\n- * Information about a query, and state of the query\n- * \n- */\n-final class QueryInfo<Q> {\n-    private boolean usePrepared;\n-    private Q preparedQuery;\n-    private String queryString;\n-\n-    /**\n-     * Constructor\n-     * \n-     * @param usePrepared whether queries should attempt to use the prepared query representation.\n-     * @param preparedQuery an optional prepared query representation\n-     * @param queryString the query in string form with optional OpenIDM tokens\n-     */\n-    public QueryInfo(boolean usePrepared, Q preparedQuery, String queryString) {\n-        this.usePrepared = usePrepared;\n-        this.preparedQuery = preparedQuery;\n-        this.queryString = queryString;\n-    }\n-    \n-    /**\n-     * @return whether queries should attempt to use the prepared query representation.\n-     */\n-    public boolean isUsePrepared() {\n-        return usePrepared;\n-    }\n-\n-    /**\n-     * @param prep whether queries should attempt to use the prepared query representation.\n-     */\n-    public void setUsePrepared(boolean prep) {\n-        this.usePrepared = prep;\n-    }\n-    \n-    /**\n-     * @return an optional prepared query representation\n-     */\n-    public Q getPreparedQuery() {\n-        return preparedQuery;\n-    }\n-    \n-    /**\n-     * @return the query in string form with optional OpenIDM tokens\n-     */\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "f3f41115bf44dd223da7c63a54887901e568d564",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandler.java",
    "status": "removed",
    "additions": 0,
    "deletions": 201,
    "changes": 201,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandler.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandler.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandler.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,201 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.forgerock.guava.common.base.Function;\n-import org.forgerock.guava.common.collect.FluentIterable;\n-import org.forgerock.json.resource.BadRequestException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-// TODO: replace use of this class with TokenHandler in org.forgerock.openidm.repo.util\n-public class TokenHandler {\n-\n-    public static final String PREFIX_UNQUOTED = \"unquoted\";\n-\n-    public static final String PREFIX_DOTNOTATION = \"dotnotation\";\n-\n-    public static final String PREFIX_LIST = \"list\";\n-\n-    final static Logger logger = LoggerFactory.getLogger(TokenHandler.class);\n-    \n-    // The OpenIDM query token is of format ${token-name}\n-    private static final Pattern tokenPattern = Pattern.compile(\"\\\\$\\\\{(.+?)\\\\}\");\n-\n-    /** {@link Function} to trim leading dot from orient object name */\n-    private static final Function<String, String> TRIM_LEADING_DOT =\n-            new Function<String, String>() {\n-                @Override\n-                public String apply(String object) {\n-                    return object.startsWith(\".\")\n-                            ? object.substring(1)\n-                            : object;\n-                }\n-            };\n-    /** {@link Function} to convert json-pointer path-element to orient field */\n-    private static final Function<String, String> JSON_POINTER_PATH_ELEMENT_TO_ORIENT_FIELD =\n-            new Function<String, String>() {\n-                @Override\n-                public String apply(String path) {\n-                    // numeric path elements are actually array-indices - add brackets\n-                    return (path.matches(\"[0-9]+\"))\n-                            ? \"[\" + path + \"]\"\n-                            : path;\n-                }\n-            };\n-\n-    /** {@link Function} to convert JsonPointer to dot-notation orient object name */\n-    private static final Function<String, String> JSON_POINTER_TO_DOT_NOTATION =\n-            new Function<String, String>() {\n-                @Override\n-                public String apply(String jsonPointer) {\n-                    return TRIM_LEADING_DOT.apply(\n-                            StringUtils.join(\n-                                    FluentIterable.from(Arrays.asList(jsonPointer.split(\"/\")))\n-                                            .transform(JSON_POINTER_PATH_ELEMENT_TO_ORIENT_FIELD),\n-                                    \".\"));\n-                }\n-            };\n-\n-    /**\n-     * Replaces a query string with tokens of format ${token-name} with the values from the\n-     * passed in map, where the token-name must be the key in the map\n-     * \n-     * @param queryString the query with tokens\n-     * @param params the parameters to replace the tokens. Values can be String or List.\n-     * @return the query with all tokens replace with their found values\n-     * @throws BadRequestException if token in the query is not in the passed parameters\n-     */\n-    String replaceTokensWithValues(String queryString, Map<String, String> params) \n-            throws BadRequestException {\n-        java.util.regex.Matcher matcher = tokenPattern.matcher(queryString);\n-        StringBuffer buffer = new StringBuffer();\n-        while (matcher.find()) {\n-            String fullTokenKey = matcher.group(1);\n-            String tokenKey = fullTokenKey;\n-            String tokenPrefix = null;\n-            String[] tokenKeyParts = tokenKey.split(\":\", 2);\n-            // if prefix found\n-            if (tokenKeyParts.length == 2) {\n-                tokenPrefix = tokenKeyParts[0];\n-                tokenKey = tokenKeyParts[1];\n-            }\n-            if (!params.containsKey(tokenKey)) {\n-                // fail with an exception if token not found\n-                throw new BadRequestException(\"Missing entry in params passed to query for token \" + tokenKey);\n-            } else {\n-                Object replacement = params.get(tokenKey);\n-\n-                if (PREFIX_LIST.equals(tokenPrefix)) {\n-                    // escape quotes, quote each element, and split on ,\n-                    replacement = Arrays.asList((\"'\" + replacement.toString().replaceAll(\"'\", \"\\\\\\\\'\").replaceAll(\",\", \"','\") + \"'\").split(\",\"));\n-                }\n-\n-                if (replacement instanceof List) {\n-                    StringBuffer commaSeparated = new StringBuffer();\n-                    boolean first = true;\n-                    for (Object entry : ((List) replacement)) {\n-                        if (!first) {\n-                            commaSeparated.append(\",\");\n-                        } else {\n-                            first = false;\n-                        }\n-                        commaSeparated.append(entry.toString());\n-                    }\n-                    replacement = commaSeparated.toString();\n-                }\n-\n-                if (replacement == null) {\n-                    replacement = \"\";\n-                }\n-                \n-                // Optional control of representation via prefix\n-                if (tokenPrefix != null) {\n-                    if (tokenPrefix.equals(PREFIX_UNQUOTED)) {\n-                        // Leave replacement unquoted\n-                    } else if (tokenPrefix.equals(PREFIX_DOTNOTATION)) {\n-                        // Convert Json Pointer to OrientDB dot notation\n-                        replacement = JSON_POINTER_TO_DOT_NOTATION.apply(replacement.toString());\n-                    }\n-                } else {\n-                    // Default is single quoted string replacement (escaping single quotes in replacement)\n-                    replacement = \"'\" + replacement.toString().replaceAll(\"'\", \"\\\\\\\\'\") + \"'\";\n-                }\n-                \n-                matcher.appendReplacement(buffer, \"\");\n-                buffer.append(replacement);\n-            }\n-        }\n-        matcher.appendTail(buffer);\n-        return buffer.toString();\n-    }\n-\n-    /**\n-     * Replaces a query string with tokens of format ${token-name} with the \n-     * token format in OrientDB, which is of the form :token-name.\n-     * \n-     * OrientDB tokens has some limitations, e.g. they can currently only be used\n-     * in the where clause, and hence the returned string is not guaranteed to be\n-     * valid for use in a prepared statement. If the parsing fails the system may\n-     * have to fall back onto non-prepared statements and manual token replacement.\n-     * \n-     * @param queryString the query with OpenIDM format tokens ${token}\n-     * @return the query with all tokens replaced with the OrientDB style tokens :token\n-     * @throws PrepareNotSupported if this method knows a given statement can not be converted into a prepared statement.\n-     * That a statement was not rejected here though does not mean it could not fail during the parsing phase later.\n-     */\n-    String replaceTokensWithOrientToken(String queryString) throws PrepareNotSupported {\n-        Matcher matcher = tokenPattern.matcher(queryString);\n-        StringBuffer buf = new StringBuffer();\n-        while (matcher.find()) {\n-            String origToken = matcher.group(1);\n-            \n-            String tokenKey = origToken;\n-            String tokenPrefix = null;\n-            String[] tokenKeyParts = tokenKey.split(\":\", 2);\n-            // if prefix found\n-            if (tokenKeyParts.length == 2) {\n-                tokenPrefix = tokenKeyParts[0];\n-                tokenKey = tokenKeyParts[1];\n-            }\n-            matcher.appendReplacement(buf, \"\");\n-            if (tokenPrefix != null && tokenPrefix.equals(PREFIX_DOTNOTATION)) {\n-                buf.append(JSON_POINTER_TO_DOT_NOTATION.apply(tokenKey));\n-            } else if (tokenKey != null && tokenKey.length() > 0) {\n-                // OrientDB token is of format :token-name\n-                String newToken = \":\" + tokenKey;\n-                buf.append(newToken);\n-            }\n-        }\n-        matcher.appendTail(buf);\n-        return buf.toString();\n-    }\n-}"
  },
  {
    "sha": "f119ba2cb79d3bdcf54ea8e1d76cf1687ecf6612",
    "filename": "openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/metadata/ConfigMeta.java",
    "status": "removed",
    "additions": 0,
    "deletions": 64,
    "changes": 64,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/metadata/ConfigMeta.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/metadata/ConfigMeta.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/java/org/forgerock/openidm/repo/orientdb/metadata/ConfigMeta.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,64 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2015 ForgeRock AS.\n- * Portions Copyright 2018 Wren Security.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.metadata;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.json.JsonPointer;\n-import org.forgerock.openidm.metadata.MetaDataProvider;\n-import org.forgerock.openidm.metadata.MetaDataProviderCallback;\n-import org.forgerock.openidm.repo.orientdb.impl.OrientDBRepoService;\n-\n-/**\n- * Meta data provider to describe configuration\n- * requirements of this bundle\n- *\n- */\n-public class ConfigMeta implements MetaDataProvider {\n-\n-    private final List<JsonPointer> propertiesToEncrypt;\n-\n-    public ConfigMeta() {\n-        List<JsonPointer> props = new ArrayList<JsonPointer>();\n-        props.add(new JsonPointer(OrientDBRepoService.CONFIG_PASSWORD));\n-        props.add(new JsonPointer(\"/embeddedServer/users/*/password\"));\n-        propertiesToEncrypt = Collections.unmodifiableList(props);\n-    }\n-\n-    public List<JsonPointer> getPropertiesToEncrypt(String pidOrFactory, String instanceAlias,\n-            JsonValue config) {\n-        if (OrientDBRepoService.PID.equals(pidOrFactory)) {\n-            return propertiesToEncrypt;\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public void setCallback(MetaDataProviderCallback callback) {\n-    }\n-}"
  },
  {
    "sha": "5b61ab2d0a254a8d3ce4c27f5b90e7a709d405e5",
    "filename": "openidm-repo-orientdb/src/main/javadoc/overview.html",
    "status": "removed",
    "additions": 0,
    "deletions": 16,
    "changes": 16,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/javadoc/overview.html",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/javadoc/overview.html",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/javadoc/overview.html?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,16 +0,0 @@\n-<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n-<html>\n-<head>\n-  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n-  <meta http-equiv=\"Content-Style-Type\" content=\"text/css\">\n-  <title></title>\n-  <meta name=\"Generator\" content=\"Cocoa HTML Writer\">\n-  <meta name=\"CocoaVersion\" content=\"1038.35\">\n-  <style type=\"text/css\">\n-    p.p1 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times}\n-  </style>\n-</head>\n-<body>\n-<p class=\"p1\">OpenIDM repository using OrientDB.</p>\n-</body>\n-</html>"
  },
  {
    "sha": "44e0ddae1b6f543fff5657df3b9a46757604f0c6",
    "filename": "openidm-repo-orientdb/src/main/resources/org/forgerock/metadata/bundle.json",
    "status": "removed",
    "additions": 0,
    "deletions": 3,
    "changes": 3,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/resources/org/forgerock/metadata/bundle.json",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/main/resources/org/forgerock/metadata/bundle.json",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/main/resources/org/forgerock/metadata/bundle.json?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,3 +0,0 @@\n-{\n-    \"metaDataProvider\" : \"org.forgerock.openidm.repo.orientdb.metadata.ConfigMeta\"\n-}"
  },
  {
    "sha": "110e45fe2739a711d7d7f33eba06e84a6c6cdfa3",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DBHelperTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 74,
    "changes": 74,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DBHelperTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DBHelperTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DBHelperTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,74 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.forgerock.json.JsonValue.json;\n-import static org.forgerock.json.JsonValue.object;\n-\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentPool;\n-\n-import org.forgerock.json.JsonValue;\n-import org.testng.annotations.*;\n-\n-public class DBHelperTest {\n-\n-    private String dbURL = \"plocal:./target/testdb\";\n-    private String user = \"admin\";\n-    private String password = \"admin\";\n-    private int minSize = 5;\n-    private int maxSize = 20;\n-\n-    @Test\n-    public void initPoolTest() throws Exception {\n-        ODatabaseDocumentPool pool = DBHelper.getPool(dbURL, user, password, minSize, maxSize, json(object()), true);\n-        assertThat(pool).isNotNull();\n-        ODatabaseDocumentTx db = pool.acquire(dbURL, user, password);\n-        assertThat(db).isNotNull();\n-        db.drop();\n-        db.close();\n-        DBHelper.closePools();\n-    }\n-    \n-    @Test\n-    public void updateDbCredentialsTest() throws Exception {\n-        String newUser = \"user1\";\n-        String newPassword = \"pass1\";\n-        JsonValue completeConfig = json(object());\n-        int minSize = 5;\n-        int maxSize = 20;\n-        ODatabaseDocumentPool pool = DBHelper.getPool(dbURL, user, password, minSize, maxSize, completeConfig, true);\n-        assertThat(pool).isNotNull();\n-        DBHelper.updateDbCredentials(dbURL, user, password, newUser, newPassword);\n-        pool = DBHelper.getPool(dbURL, newUser, newPassword, minSize, maxSize, completeConfig, true);\n-        assertThat(pool).isNotNull();\n-        ODatabaseDocumentTx db = pool.acquire(dbURL, newUser, newPassword);\n-        assertThat(db).isNotNull();\n-        db.drop();\n-        db.close();\n-        DBHelper.closePools();\n-    }\n-\n-}"
  },
  {
    "sha": "12a9b96bf8d7af0f1403ec605ce617874785dc54",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtilTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 674,
    "changes": 674,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtilTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtilTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/DocumentUtilTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,674 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright 2011-2016 ForgeRock AS.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.data.MapEntry.entry;\n-import static org.forgerock.json.JsonValue.json;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.orientechnologies.orient.core.db.ODatabaseRecordThreadLocal;\n-import com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx;\n-import com.orientechnologies.orient.core.metadata.schema.OType;\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.server.OServer;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.json.resource.ConflictException;\n-\n-import org.testng.annotations.*;\n-\n-\n-public class DocumentUtilTest {\n-\n-    String dbURL = \"plocal:./target/docutiltestdb\";\n-    ODatabaseDocumentTx db = null;\n-    String orientDocClass = \"Sample\";\n-    OServer server;\n-\n-    @BeforeClass\n-    public void init() throws Exception {\n-        db = new ODatabaseDocumentTx(dbURL);\n-        if (!db.exists()) {\n-            db.create();\n-        } else {\n-            db.open(\"admin\", \"admin\");\n-        }\n-    }\n-\n-    @AfterClass\n-    public void cleanup() {\n-        if (db != null) {\n-            db.close();\n-        }\n-    }\n-\n-    public ODatabaseDocumentTx getDatabase() {\n-        ODatabaseRecordThreadLocal.INSTANCE.set(db);\n-        return db;\n-    }\n-\n-    @Test\n-    public void docToMapNullTest() {\n-        assertThat(DocumentUtil.toMap(null)).isNull();\n-    }\n-\n-    @Test\n-    public void flatDocToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        doc.field(\"firstname\", \"Sam\");\n-        doc.field(\"lastname\", \"Iam\");\n-        doc.field(\"telephone\", \"(555) 123-4567\");\n-        doc.field(\"age\", 20);\n-        doc.field(\"longnumber\", Long.MAX_VALUE);\n-        doc.field(\"amount\", Float.valueOf(12345678.89f));\n-        doc.field(\"present\", Boolean.FALSE);\n-        doc.field(\"somedate\", new Date());\n-\n-        Map<String, Object> result = DocumentUtil.toMap(doc);\n-\n-        assertThat(result).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"), //\"-1:-1\"), // ID when doc not yet stored\n-                entry(DocumentUtil.TAG_REV, \"0\"),      // Doc version starts at 0\n-                entry(\"firstname\", \"Sam\"),\n-                entry(\"lastname\", \"Iam\"),\n-                entry(\"telephone\", \"(555) 123-4567\"),\n-                entry(\"age\", 20),\n-                entry(\"longnumber\", Long.MAX_VALUE),\n-                entry(\"amount\", 12345678.89f),\n-                entry(\"present\", false));\n-\n-        Object somedate = result.get(\"somedate\");\n-        assertThat(somedate).isNotNull().overridingErrorMessage(\"somedate entry null\");\n-        assertThat(somedate).isInstanceOf(Date.class);\n-\n-        // The ID should appear in map not as the key we use for OrientDB internal\n-        assertThat(result.containsKey(DocumentUtil.ORIENTDB_PRIMARY_KEY))\n-                .isFalse()\n-                .overridingErrorMessage(\"DB layer internal key \" + DocumentUtil.ORIENTDB_PRIMARY_KEY\n-                        + \" should not appear in map, but did.\");\n-    }\n-\n-    @Test\n-    public void embeddedDocToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        doc.field(\"firstname\", \"John\");\n-        doc.field(\"lastname\", \"Doe\");\n-        doc.field(\"city\", new ODocument().field(\"name\",\"Paris\").field(\"country\", \"France\"));\n-        doc.field(\"phonenumbers\", new ODocument().field(\"home\",\"555-666-7777\").field(\"mobile\", \"555-111-2222\"), OType.EMBEDDED);\n-\n-        // wrap result in JsonValue to help with typing\n-        JsonValue result = json(DocumentUtil.toMap(doc));\n-\n-        assertThat(result.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"), //\"-1:-1\"), // ID when doc not yet stored\n-                entry(DocumentUtil.TAG_REV, \"0\"), // Doc version starts at 0\n-                entry(\"firstname\", \"John\"),\n-                entry(\"lastname\", \"Doe\"));\n-\n-        JsonValue city = result.get(\"city\");\n-        assertThat(city.isNotNull()).overridingErrorMessage(\"city map entry null\");\n-        assertThat(city.isMap());\n-        assertThat(city.asMap())\n-                .hasSize(2)\n-                .contains(entry(\"name\", \"Paris\"), entry(\"country\", \"France\"));\n-\n-        JsonValue phonenumbers = result.get(\"phonenumbers\");\n-        assertThat(phonenumbers)\n-                .isNotNull()\n-                .overridingErrorMessage(\"phonenumbers map entry null\");\n-        assertThat(phonenumbers.isMap());\n-        assertThat(phonenumbers.asMap())\n-                .hasSize(2)\n-                .contains(entry(\"home\", \"555-666-7777\"), entry(\"mobile\", \"555-111-2222\"));\n-    }\n-\n-    @Test\n-    public void embeddedListToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        doc.field(\"firstname\", \"John\");\n-        doc.field(\"lastname\", \"Doe\");\n-        doc.field(\"city\", new ODocument().field(\"name\",\"Paris\").field(\"country\", \"France\"));\n-        List<ODocument> addresses = new ArrayList<ODocument>();\n-        addresses.add(new ODocument().field(\"type\", \"home\").field(\"street\", \"Main st.\").field(\"city\", \"San Francisco\") );\n-        addresses.add(new ODocument().field(\"type\", \"business\").field(\"street\", \"Wall st.\").field(\"city\", \"New York\") );\n-        doc.field(\"addresses\",  addresses, OType.EMBEDDED);\n-\n-        // wrap result in JsonValue to help with typing\n-        JsonValue result = json(DocumentUtil.toMap(doc));\n-\n-        assertThat(result.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"), //\"-1:-1\"), // ID when doc not yet stored\n-                entry(DocumentUtil.TAG_REV, \"0\"), // Doc version starts at 0\n-                entry(\"firstname\", \"John\"),\n-                entry(\"lastname\", \"Doe\"));\n-\n-        JsonValue addrResult = result.get(\"addresses\");\n-        assertThat(addrResult).isNotNull().overridingErrorMessage(\"addresses map entry null\");\n-        assertThat(addrResult.isList());\n-        assertThat(addrResult.asList())\n-                .hasSize(2);\n-\n-        JsonValue firstEntry = addrResult.get(0);\n-        assertThat(firstEntry.isMap());\n-        assertThat(firstEntry.asMap()).contains(\n-                entry(\"type\", \"home\"),\n-                entry(\"street\", \"Main st.\"),\n-                entry(\"city\", \"San Francisco\"));\n-        JsonValue secondEntry = addrResult.get(1);\n-        assertThat(secondEntry.isMap());\n-        assertThat(secondEntry.asMap()).contains(\n-                entry(\"type\", \"business\"),\n-                entry(\"street\", \"Wall st.\"),\n-                entry(\"city\", \"New York\"));\n-    }\n-\n-    @Test\n-    public void deepNestingToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        List<ODocument> detail = new ArrayList<ODocument>();\n-        List<ODocument> addresses = new ArrayList<ODocument>();\n-        ODocument status1 = new ODocument(\"inventory\", 10);\n-        ODocument status2 = new ODocument(\"inventory\", 20);\n-        addresses.add(new ODocument().field(\"street\", \"Main st.\").field(\"city\", \"San Francisco\").field(\"status\", status1, OType.EMBEDDED));\n-        addresses.add(new ODocument().field(\"street\", \"Wall st.\").field(\"city\", \"New York\").field(\"status\", status2, OType.EMBEDDED));\n-        detail.add(new ODocument().field(\"locations\", addresses, OType.EMBEDDED));\n-\n-        doc.field(\"widget\", new ODocument().field(\"name\",\"widget-a\").field(\"detail\", detail), OType.EMBEDDED);\n-\n-        // wrap result in JsonValue to help with typing\n-        JsonValue resultWidgets = json(DocumentUtil.toMap(doc));\n-\n-        assertThat(resultWidgets.isMap());\n-        assertThat(resultWidgets.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"),\n-                entry(DocumentUtil.TAG_REV, \"0\"));\n-\n-        JsonValue resultWidget = resultWidgets.get(\"widget\");\n-        JsonValue resultDetails = resultWidget.get(\"detail\");\n-        JsonValue resultDetail1 = resultDetails.get(0);\n-        JsonValue resultLocations = resultDetail1.get(\"locations\");\n-        JsonValue resultAddress2 = resultLocations.get(1);\n-        System.out.println(resultAddress2);\n-        JsonValue resultStatus = resultAddress2.get(\"status\");\n-        JsonValue resultInventory = resultStatus.get(\"inventory\");\n-        assertThat(resultInventory.isNumber()).isTrue();\n-        assertThat(resultInventory.asInteger()).isEqualTo(20);\n-    }\n-\n-    @Test\n-    public void deepNestingWithSetToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        Set<ODocument> detail = new HashSet<ODocument>();\n-        Set<ODocument> addresses = new HashSet<ODocument>();\n-        ODocument status1 = new ODocument(\"inventory\", 10);\n-        ODocument status2 = new ODocument(\"inventory\", 20);\n-        addresses.add(new ODocument().field(\"street\", \"Main st.\").field(\"city\", \"San Francisco\").field(\"status\", status1, OType.EMBEDDED));\n-        detail.add(new ODocument().field(\"locations\", addresses, OType.EMBEDDED));\n-\n-        doc.field(\"widget\", new ODocument().field(\"name\",\"widget-a\").field(\"detail\", detail), OType.EMBEDDED);\n-\n-        // wrap result in JsonValue to help with typing\n-        JsonValue resultWidgets = json(DocumentUtil.toMap(doc));\n-\n-        assertThat(resultWidgets.isMap()).isTrue();\n-        assertThat(resultWidgets.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"),\n-                entry(DocumentUtil.TAG_REV, \"0\"));\n-\n-        JsonValue resultWidget = resultWidgets.get(\"widget\");\n-        JsonValue resultDetails = resultWidget.get(\"detail\");\n-        JsonValue resultDetail1 = resultDetails.get(0);\n-        JsonValue resultLocations = resultDetail1.get(\"locations\");\n-        JsonValue resultAddress1 = resultLocations.get(0);\n-        System.out.println(resultAddress1);\n-        JsonValue resultStatus = resultAddress1.get(\"status\");\n-        JsonValue resultInventory = resultStatus.get(\"inventory\");\n-        assertThat(resultInventory.isNumber()).isTrue();\n-        assertThat(resultInventory.asInteger()).isEqualTo(10);\n-    }\n-\n-    @Test\n-    public void deepNestingMixedODocAndMapToMap() {\n-\n-        ODocument doc = new ODocument();\n-        doc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        List<Map<String, Object>> detail = new ArrayList<Map<String, Object>>();\n-        List<ODocument> addresses = new ArrayList<ODocument>();\n-        ODocument status1 = new ODocument(\"inventory\", 10);\n-        ODocument status2 = new ODocument(\"inventory\", 20);\n-        addresses.add(new ODocument().field(\"street\", \"Main st.\").field(\"city\", \"San Francisco\").field(\"status\", status1, OType.EMBEDDED));\n-        addresses.add(new ODocument().field(\"street\", \"Wall st.\").field(\"city\", \"New York\").field(\"status\", status2, OType.EMBEDDED));\n-        Map<String, Object> locationsMap = new HashMap<String, Object>();\n-        locationsMap.put(\"locations\", addresses);\n-        detail.add(locationsMap);\n-\n-        doc.field(\"widget\", new ODocument().field(\"name\",\"widget-a\").field(\"detail\", detail), OType.EMBEDDED);\n-\n-        // wrap result in JsonValue to help with typing\n-        JsonValue resultWidgets = json(DocumentUtil.toMap(doc));\n-\n-        assertThat(resultWidgets.isMap()).isTrue();\n-        assertThat(resultWidgets.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"),\n-                entry(DocumentUtil.TAG_REV, \"0\"));\n-\n-        JsonValue resultWidget = resultWidgets.get(\"widget\");\n-        JsonValue resultDetails = resultWidget.get(\"detail\");\n-        JsonValue resultDetail1 = resultDetails.get(0);\n-        JsonValue resultLocations = resultDetail1.get(\"locations\");\n-        JsonValue resultAddress2 = resultLocations.get(1);\n-        System.out.println(resultAddress2);\n-        JsonValue resultStatus = resultAddress2.get(\"status\");\n-        JsonValue resultInventory = resultStatus.get(\"inventory\");\n-        assertThat(resultInventory.isNumber()).isTrue();\n-        assertThat(resultInventory.asInteger()).isEqualTo(20);\n-    }\n-\n-    @Test\n-    public void mapToDocNullTest() throws ConflictException {\n-        assertThat((Object) DocumentUtil.toDocument(null, null, getDatabase(), orientDocClass, false, true)).isNull();\n-    }\n-\n-    @Test\n-    public void mapToNewFlatDoc() throws ConflictException{\n-\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(DocumentUtil.TAG_REV, \"1\");\n-        map.put(\"firstname\", \"Sam\");\n-        map.put(\"lastname\", \"Iam\");\n-        map.put(\"telephone\", \"(555) 123-4567\");\n-        map.put(\"age\", 20);\n-        map.put(\"longnumber\", Long.MAX_VALUE);\n-        map.put(\"amount\", 12345678.89f);\n-        map.put(\"present\", Boolean.FALSE);\n-        map.put(\"somedate\", new Date());\n-\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY)).isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((String) result.field(\"firstname\")).isEqualTo(\"Sam\")\n-                .overridingErrorMessage(\"unexpected firstname\");\n-        assertThat((String) result.field(\"lastname\")).isEqualTo(\"Iam\")\n-                .overridingErrorMessage(\"unexpected lastname\");\n-        assertThat((String) result.field(\"telephone\")).isEqualTo(\"(555) 123-4567\")\n-                .overridingErrorMessage(\"unexpected telephone\");\n-        assertThat((Integer) result.field(\"age\")).isEqualTo(20)\n-                .overridingErrorMessage(\"unexpected age\");\n-        assertThat((Long) result.field(\"longnumber\")).isEqualTo(Long.MAX_VALUE)\n-                .overridingErrorMessage(\"unexpected longnumber\");\n-        assertThat((Float) result.field(\"amount\")).isEqualTo(12345678.89f)\n-                .overridingErrorMessage(\"unexpected amount\");\n-        assertThat((Boolean) result.field(\"present\")).isEqualTo(false)\n-                .overridingErrorMessage(\"unexpected present boolean\");\n-        assertThat(result.getVersion()).isEqualTo(1)\n-                .overridingErrorMessage( \"Version not as expected\");\n-        Object somedate = result.field(\"somedate\");\n-        assertThat(somedate).isNotNull().overridingErrorMessage(\"somedate entry null\");\n-        assertThat(somedate).isInstanceOf(Date.class).overridingErrorMessage(\"Date not of expected type.\");\n-    }\n-\n-    @Test\n-    public void mapToExistingFlatDoc() throws ConflictException {\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(DocumentUtil.TAG_REV, \"1\");\n-        map.put(\"firstname\", \"Sam\");\n-        map.put(\"lastname\", \"Iam\");\n-        map.put(\"telephone\", \"(555) 123-4567\");\n-        map.put(\"age\", 20);\n-        map.put(\"longnumber\", Long.MAX_VALUE);\n-        map.put(\"amount\", 12345678.89f);\n-        map.put(\"present\", Boolean.FALSE);\n-        map.put(\"somedate\", new Date());\n-\n-        // An existing document to get updated from the map\n-        ODocument existingDoc = getDatabase().newInstance(orientDocClass);\n-        existingDoc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        // firstname and lastname deliberately not in the existing doc\n-        existingDoc.field(\"fieldtoberemoved\", \"ABC\");\n-        existingDoc.field(\"telephone\", \"(999) 999-9999\");\n-        existingDoc.field(\"age\", 20);\n-        existingDoc.field(\"longnumber\", 0);\n-        existingDoc.field(\"amount\", 12345678.89f);\n-        existingDoc.field(\"present\", Boolean.FALSE);\n-        existingDoc.field(\"somedate\", new Date());\n-        existingDoc.field(\"AnotherFieldToBeRemoved\", new Date());\n-\n-        ODocument result = DocumentUtil.toDocument(map, existingDoc, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY)).isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((String) result.field(\"firstname\")).isEqualTo(\"Sam\")\n-                .overridingErrorMessage(\"unexpected firstname\");\n-        assertThat((String) result.field(\"lastname\")).isEqualTo(\"Iam\")\n-                .overridingErrorMessage( \"unexpected lastname\");\n-        assertThat((String) result.field(\"telephone\")).isEqualTo(\"(555) 123-4567\")\n-                .overridingErrorMessage( \"unexpected telephone\");\n-        assertThat((Integer) result.field(\"age\")).isEqualTo(20)\n-                .overridingErrorMessage(\"unexpected age\");\n-        assertThat((Long) result.field(\"longnumber\")).isEqualTo(Long.MAX_VALUE)\n-                .overridingErrorMessage( \"unexpected longnumber\");\n-        assertThat((Float) result.field(\"amount\")).isEqualTo(12345678.89f)\n-                .overridingErrorMessage( \"unexpected amount\");\n-        assertThat((Boolean) result.field(\"present\")).isEqualTo(false)\n-                .overridingErrorMessage( \"unexpected present boolean\");\n-        assertThat(result.containsField(\"fieldtoberemoved\")).isFalse()\n-                .overridingErrorMessage(\"Field 'fieldtoberemoved' not removed as expected\");\n-        assertThat(result.containsField(\"AnotherFieldToBeRemoved\")).isFalse()\n-                .overridingErrorMessage(\"Field 'AnotherFieldToBeRemoved' not removed as expected\");\n-        assertThat(result.getVersion()).isEqualTo(1)\n-                .overridingErrorMessage(\"Version not as expected\");\n-        Object somedate = result.field(\"somedate\");\n-        assertThat(somedate).isNotNull().overridingErrorMessage(\"somedate entry null\");\n-        assertThat(somedate).isInstanceOf(Date.class).overridingErrorMessage(\"date not of expected type.\");\n-    }\n-\n-    @Test\n-    public void mapToNewDocExistingRevision() throws ConflictException {\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(DocumentUtil.TAG_REV, \"100\");\n-        map.put(\"firstname\", \"John\");\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY))\n-                .isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((String) result.field(\"firstname\"))\n-                .isEqualTo(\"John\")\n-                .overridingErrorMessage(\"unexpected firstname\");\n-        assertThat(result.getVersion())\n-                .isEqualTo(100)\n-                .overridingErrorMessage(\"Version not as expected\");\n-    }\n-\n-    @Test\n-    public void mapToNewEmbeddedDoc() throws ConflictException {\n-\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(\"firstname\", \"John\");\n-        map.put(\"lastname\", \"Doe\");\n-\n-        Map<String, Object> city = new HashMap<String, Object>();\n-        city.put(\"name\",\"Paris\");\n-        city.put(\"country\", \"France\");\n-        map.put(\"city\", city);\n-\n-        Map<String, Object> phone = new HashMap<String, Object>();\n-        phone.put(\"home\",\"555-666-7777\");\n-        phone.put(\"mobile\", \"555-111-2222\");\n-        map.put(\"phonenumbers\", phone);\n-\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY))\n-                .isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((String) result.field(\"firstname\"))\n-                .isEqualTo(\"John\")\n-                .overridingErrorMessage(\"unexpected firstname\");\n-        assertThat((String) result.field(\"lastname\"))\n-                .isEqualTo(\"Doe\")\n-                .overridingErrorMessage(\"unexpected lastname\");\n-        assertThat(result.getVersion())\n-                .isEqualTo(0)\n-                .overridingErrorMessage(\"Version not as expected\");\n-\n-        final ODocument phonenumbers = result.field(\"phonenumbers\");\n-        assertThat((Object) phonenumbers)\n-                .isNotNull()\n-                .overridingErrorMessage(\"phonenumbers map entry null\");\n-        assertThat((String) phonenumbers.field(\"home\"))\n-                .isEqualTo(\"555-666-7777\")\n-                .overridingErrorMessage(\"unexpected home phone\");\n-        assertThat((String) phonenumbers.field(\"mobile\"))\n-                .isEqualTo(\"555-111-2222\")\n-                .overridingErrorMessage(\"unexpected mobile phone\");\n-        // disambiguate assertThat(ODocument) from assertThat(Iterable) and avoid casting\n-        assertThat(new Iterable<Map.Entry<String, Object>>() {\n-            @Override\n-            public Iterator<Map.Entry<String, Object>> iterator() {\n-                return phonenumbers.iterator();\n-            }\n-        }).hasSize(2);\n-    }\n-\n-    @Test\n-    public void mapToExistingEmbeddedDoc() throws ConflictException {\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        // deliberately remove the firstname\n-        map.put(\"lastname\", \"Doe\");\n-        // deliberately remove the city\n-        Map<String, Object> phone = new HashMap<String, Object>();\n-        //remove the home number, change the mobile, add a work number\n-        phone.put(\"mobile\", \"555-111-2229\");\n-        phone.put(\"work\",\"666-777-8888\");\n-        map.put(\"phonenumbers\", phone);\n-\n-        ODocument existingDoc = new ODocument();\n-        existingDoc.field(DocumentUtil.ORIENTDB_PRIMARY_KEY, \"client-assigned-id\");\n-        existingDoc.field(\"firstname\", \"Johnathan\");\n-        // lastname deliberately not in existing doc\n-        existingDoc.field(\"city\", new ODocument().field(\"name\",\"Paris\").field(\"country\", \"France\"));\n-        existingDoc.field(\"phonenumbers\", new ODocument().field(\"home\",\"555-666-7777\").field(\"mobile\", \"555-111-2222\"), OType.EMBEDDED);\n-\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY))\n-                .isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((Boolean) result.containsField(\"firstname\"))\n-                .isFalse()\n-                .overridingErrorMessage(\"Firstname should have been removed but is present\");\n-        assertThat((String) result.field(\"lastname\"))\n-                .isEqualTo(\"Doe\")\n-                .overridingErrorMessage(\"unexpected lastname\");\n-        assertThat((Integer) result.getVersion())\n-                .isEqualTo(0)\n-                .overridingErrorMessage(\"Version not as expected\");\n-\n-        assertThat(result.containsField(\"city\"))\n-                .isFalse()\n-                .overridingErrorMessage(\"City map should have been removed but is present.\");\n-\n-        final ODocument phonenumbers = result.field(\"phonenumbers\");\n-        assertThat((Object) phonenumbers)\n-                .isNotNull()\n-                .overridingErrorMessage(\"phonenumbers map entry null\");\n-        assertThat((String) phonenumbers.field(\"work\"))\n-                .isEqualTo(\"666-777-8888\")\n-                .overridingErrorMessage(\"unexpected work phone\");\n-        assertThat((String) phonenumbers.field(\"mobile\"))\n-                .isEqualTo(\"555-111-2229\")\n-                .overridingErrorMessage(\"unexpected mobile phone\");\n-        assertThat(phonenumbers.containsField(\"home\"))\n-                .isFalse()\n-                .overridingErrorMessage(\"Home phone should have been removed but is present.\");\n-        // disambiguate assertThat(ODocument) from assertThat(Iterable) and avoid casting\n-        assertThat(new Iterable<Map.Entry<String, Object>>() {\n-            @Override\n-            public Iterator<Map.Entry<String, Object>> iterator() {\n-                return phonenumbers.iterator();\n-            }\n-        }).hasSize(2);\n-    }\n-\n-    @Test\n-    public void listToEmbeddedList() throws ConflictException {\n-\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(\"firstname\", \"John\");\n-        map.put(\"lastname\", \"Doe\");\n-\n-        List<Object> cities = new ArrayList<Object>();\n-        cities.add(\"Paris\");\n-        cities.add(\"St. Louis\");\n-        map.put(\"cities\", cities);\n-\n-        Map<String, Object> phone = new HashMap<String, Object>();\n-        phone.put(\"home\",\"555-666-7777\");\n-        phone.put(\"mobile\", \"555-111-2222\");\n-        map.put(\"phonenumbers\", phone);\n-\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        assertThat((String) result.field(DocumentUtil.ORIENTDB_PRIMARY_KEY))\n-                .isEqualTo(\"client-assigned-id\")\n-                .overridingErrorMessage(\"unexpected ID\");\n-        assertThat((String) result.field(\"firstname\"))\n-                .isEqualTo(\"John\")\n-                .overridingErrorMessage(\"unexpected firstname\");\n-        assertThat((String) result.field(\"lastname\"))\n-                .isEqualTo(\"Doe\")\n-                .overridingErrorMessage(\"unexpected lastname\");\n-        assertThat(result.getVersion())\n-                .isEqualTo(0)\n-                .overridingErrorMessage(\"Version not as expected\");\n-\n-        final ODocument phonenumbers = result.field(\"phonenumbers\");\n-        assertThat((Object) phonenumbers)\n-                .isNotNull()\n-                .overridingErrorMessage(\"phonenumbers map entry null\");\n-        assertThat((String) phonenumbers.field(\"home\"))\n-                .isEqualTo(\"555-666-7777\")\n-                .overridingErrorMessage(\"unexpected home phone\");\n-        assertThat((String) phonenumbers.field(\"mobile\"))\n-                .isEqualTo(\"555-111-2222\")\n-                .overridingErrorMessage(\"unexpected mobile phone\");\n-        // disambiguate assertThat(ODocument) from assertThat(Iterable) and avoid casting\n-        assertThat(new Iterable<Map.Entry<String, Object>>() {\n-            @Override\n-            public Iterator<Map.Entry<String, Object>> iterator() {\n-                return phonenumbers.iterator();\n-            }\n-        }).hasSize(2);\n-    }\n-\n-    @Test(expectedExceptions = ConflictException.class)\n-    public void mapToDocInvalidRevision() throws ConflictException {\n-        // Check ConflictException is thrown for invalid versions\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(DocumentUtil.TAG_REV, \"invalid-version\"); // OrientDB revisions are ints\n-        map.put(\"firstname\", \"John\");\n-        ODocument result = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-        assertThat(false).isTrue().overridingErrorMessage(\"Invalid Revision must trigger failure\");\n-    }\n-\n-    @Test\n-    public void mapToDocToMap() throws ConflictException {\n-        Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(DocumentUtil.TAG_ID, \"client-assigned-id\");\n-        map.put(DocumentUtil.TAG_REV, \"2\");\n-        map.put(\"firstname\", \"John\");\n-        map.put(\"lastname\", \"Doe\");\n-\n-        Map<String, Object> city = new HashMap<String, Object>();\n-        city.put(\"name\",\"Paris\");\n-        city.put(\"country\", \"France\");\n-        map.put(\"city\", city);\n-\n-        Map<String, Object> phone = new HashMap<String, Object>();\n-        phone.put(\"home\",\"555-666-7777\");\n-        phone.put(\"mobile\", \"555-111-2222\");\n-        map.put(\"phonenumbers\", phone);\n-\n-        ODocument intermediateResult = DocumentUtil.toDocument(map, null, getDatabase(), orientDocClass);\n-\n-        // wrap in JsonValue to help in typing\n-        JsonValue result = json(DocumentUtil.toMap(intermediateResult));\n-\n-        assertThat(result.isMap()).isTrue();\n-        assertThat(result.asMap()).contains(\n-                entry(DocumentUtil.TAG_ID, \"client-assigned-id\"),\n-                entry(DocumentUtil.TAG_REV, \"2\"),\n-                entry(\"firstname\", \"John\"),\n-                entry(\"lastname\", \"Doe\"));\n-\n-        JsonValue checkCity = result.get(\"city\");\n-        assertThat(checkCity)\n-                .isNotNull()\n-                .overridingErrorMessage(\"city map entry null\");\n-        assertThat(checkCity.isMap()).isTrue();\n-        assertThat(checkCity.asMap())\n-                .hasSize(2)\n-                .contains(entry(\"name\", \"Paris\"), entry(\"country\", \"France\"));\n-\n-        JsonValue phonenumbers = result.get(\"phonenumbers\");\n-        assertThat(phonenumbers)\n-                .isNotNull()\n-                .overridingErrorMessage(\"phonenumbers map entry null\");\n-        assertThat(phonenumbers.isMap()).isTrue();\n-        assertThat(phonenumbers.asMap())\n-                .hasSize(2)\n-                .contains(entry(\"home\", \"555-666-7777\"), entry(\"mobile\", \"555-111-2222\"));\n-    }\n-\n-    @Test\n-    public void parseValidRevision() throws ConflictException {\n-        int ver = DocumentUtil.parseVersion(\"98765\");\n-        assertThat(ver).isEqualTo(98765);\n-    }\n-\n-    @Test(expectedExceptions = ConflictException.class)\n-    public void parseInvalidRevision() throws ConflictException {\n-        int ver = DocumentUtil.parseVersion(\"some-text-98765\");\n-        assertThat(false).isTrue().overridingErrorMessage(\"Parsing of invalid revision must fail, but did not.\");\n-    }\n-\n-    @Test\n-    public void testNestedObjectMarshaling() throws IOException {\n-        final JsonValue scriptJson =\n-                new JsonValue(new ObjectMapper().readValue(getClass().getResourceAsStream(\"/script.json\"), Map.class));\n-        final ODocument scriptODoc = DocumentUtil.toDocument(scriptJson, null, getDatabase(), orientDocClass);\n-        final Map<String, Object> roundTripMap = DocumentUtil.toMap(scriptODoc);\n-        assertThat(roundTripMap).isEqualTo(scriptJson.asMap());\n-    }\n-}"
  },
  {
    "sha": "79cd58f809c66b9dd9ba608b7551f53931995b54",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerServiceTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 83,
    "changes": 83,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerServiceTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerServiceTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/EmbeddedOServerServiceTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,83 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2014 ForgeRock AS. All rights reserved.\n- * Portions Copyright 2018 Wren Security.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-\n-package org.forgerock.openidm.repo.orientdb.impl;\n-\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.orientechnologies.orient.server.plugin.OServerPlugin;\n-import java.util.Map;\n-import org.forgerock.json.JsonValue;\n-import org.forgerock.openidm.core.IdentityServerTestUtils;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-\n-public class EmbeddedOServerServiceTest {\n-    @BeforeTest\n-    public void setup() {\n-        IdentityServerTestUtils.initInstanceForTest();\n-    }\n-\n-    @AfterTest\n-    public void automaticBackupHandlerConfigTest() throws Exception {\n-        String automaticBackupConfig = \"{\"\n-                + \"\\\"dbUrl\\\" : \\\"plocal:./target/backuptestdb\\\",\"\n-                + \"\\\"embeddedServer\\\" : {\"\n-                + \"    \\\"automaticBackup\\\" : {\"\n-                + \"        \\\"enabled\\\" : true,\"\n-                + \"        \\\"targetDirectory\\\" : \\\"./target/backups\\\",\"\n-                + \"        \\\"targetFile\\\" : \\\"${DBNAME}-${DATE:yyyyMMddHHmmss}.zip\\\",\"\n-                + \"        \\\"firsttime\\\" : \\\"23:59:00\\\",\"\n-                + \"        \\\"delay\\\" : \\\"1d\\\"\"\n-                + \"    },\"\n-                + \"    \\\"enabled\\\" : true,\"\n-                + \"    \\\"overrideConfig\\\" : {\"\n-                + \"        \\\"network\\\" : {\"\n-                + \"            \\\"listeners\\\" : {\"\n-                + \"                \\\"binary\\\" : {\"\n-                + \"                    \\\"ipAddress\\\" : \\\"0.0.0.0\\\",\"\n-                + \"                    \\\"portRange\\\" : \\\"2424-3434\\\"\"\n-                + \"                },\"\n-                + \"                \\\"http\\\" : {\"\n-                + \"                    \\\"ipAddress\\\" : \\\"127.0.0.1\\\",\"\n-                + \"                    \\\"portRange\\\" : \\\"2480-3480\\\"\"\n-                + \"                }\"\n-                + \"            }\"\n-                + \"        }\"\n-                + \"    }\"\n-                + \"}}\";\n-\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonValue config = new JsonValue(mapper.readValue(automaticBackupConfig, Map.class));\n-        EmbeddedOServerService embeddedOServerService = new EmbeddedOServerService();\n-        embeddedOServerService.activate(config);\n-        assertNotNull(embeddedOServerService.orientDBServer);\n-        OServerPlugin plugin = embeddedOServerService.orientDBServer.getPlugin(\"automaticBackup\");\n-        assertNotNull(plugin);\n-        embeddedOServerService.deactivate();\n-    }\n-}"
  },
  {
    "sha": "e64cd14a132bac8c6f92509e10e7532cf4ac287e",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueriesTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 56,
    "changes": 56,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueriesTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueriesTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueriesTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,56 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import org.forgerock.json.resource.BadRequestException;\n-import org.testng.annotations.Test;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-public class QueriesTest {\n-\n-    @Test\n-    public void setConfiguredQueriesDefaultQueryAllIds() throws BadRequestException {\n-        Map<String,String> queryStrings = new HashMap<String, String>();\n-        Queries queries = new Queries();\n-        queries.setConfiguredQueries(queryStrings);\n-        assertThat(queries.queryIdExists(\"query-all-ids\")).isTrue();\n-        assertThat(queries.findQueryInfo(\"test\", \"query-all-ids\", null).getQueryString())\n-                .isEqualTo(\"select _openidm_id from ${unquoted:_resource}\");\n-    }\n-    \n-    @Test\n-    public void setConfiguredQueriesOverrideQueryAllIds() throws BadRequestException {\n-        Map<String,String> queryStrings = new HashMap<String, String>();\n-        queryStrings.put(\"query-all-ids\", \"select _id from ${unquoted:_resource}\");\n-        Queries queries = new Queries();\n-        queries.setConfiguredQueries(queryStrings);\n-        assertThat(queries.queryIdExists(\"query-all-ids\")).isTrue();\n-        assertThat(queries.findQueryInfo(\"test\", \"query-all-ids\", null).getQueryString())\n-                .isEqualTo(\"select _id from ${unquoted:_resource}\");\n-    }\n-}\n\\ No newline at end of file"
  },
  {
    "sha": "7a73a087b92e08f4f1842c5e79622512dbf2831a",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfoTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 58,
    "changes": 58,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfoTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfoTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/QueryInfoTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,58 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import com.orientechnologies.orient.core.record.impl.ODocument;\n-import com.orientechnologies.orient.core.sql.query.OSQLSynchQuery;\n-\n-import org.forgerock.json.resource.BadRequestException;\n-\n-import org.testng.annotations.Test;\n-\n-public class QueryInfoTest {\n-\n-    @Test\n-    public void fullQueryInfo() throws BadRequestException {\n-        boolean usePrepared = true;\n-        String queryString = \"select * from managed/user\";\n-        OSQLSynchQuery<ODocument> preparedQuery = new OSQLSynchQuery<>(queryString);\n-        QueryInfo<OSQLSynchQuery<ODocument>> queryInfo = new QueryInfo<>(usePrepared, preparedQuery, queryString);\n-        assertThat(queryInfo.isUsePrepared()).isTrue();\n-        assertThat(queryInfo.getPreparedQuery()).isEqualTo(preparedQuery);\n-        assertThat(queryInfo.getQueryString()).isEqualTo(queryString);\n-    }\n-    \n-    @Test\n-    public void partialQueryInfo() throws BadRequestException {\n-        boolean usePrepared = false;\n-        String queryString = \"select ${_fields} from managed/user\";\n-        OSQLSynchQuery<ODocument> preparedQuery = null;\n-        QueryInfo<OSQLSynchQuery<ODocument>> queryInfo = new QueryInfo<>(usePrepared, preparedQuery, queryString);\n-        assertThat(queryInfo.isUsePrepared()).isFalse();\n-        assertThat(queryInfo.getPreparedQuery()).isEqualTo(preparedQuery);\n-        assertThat(queryInfo.getQueryString()).isEqualTo(queryString);\n-    }    \n-}\n\\ No newline at end of file"
  },
  {
    "sha": "100fdcc215b9fa3affccdf504851d4912bbb9d20",
    "filename": "openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandlerTest.java",
    "status": "removed",
    "additions": 0,
    "deletions": 117,
    "changes": 117,
    "blob_url": "https://github.com/WrenSecurity/wrenidm/blob/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandlerTest.java",
    "raw_url": "https://github.com/WrenSecurity/wrenidm/raw/081aa91908ad77d1b5d4a84b0dd0166f3fbca6af/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandlerTest.java",
    "contents_url": "https://api.github.com/repos/WrenSecurity/wrenidm/contents/openidm-repo-orientdb/src/test/java/org/forgerock/openidm/repo/orientdb/impl/query/TokenHandlerTest.java?ref=081aa91908ad77d1b5d4a84b0dd0166f3fbca6af",
    "patch": "@@ -1,117 +0,0 @@\n-/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n- *\n- * Copyright © 2011 ForgeRock AS. All rights reserved.\n- *\n- * The contents of this file are subject to the terms\n- * of the Common Development and Distribution License\n- * (the License). You may not use this file except in\n- * compliance with the License.\n- *\n- * You can obtain a copy of the License at\n- * http://forgerock.org/license/CDDLv1.0.html\n- * See the License for the specific language governing\n- * permission and limitations under the License.\n- *\n- * When distributing Covered Code, include this CDDL\n- * Header Notice in each file and include the License file\n- * at http://forgerock.org/license/CDDLv1.0.html\n- * If applicable, add the following below the CDDL Header,\n- * with the fields enclosed by brackets [] replaced by\n- * your own identifying information:\n- * \"Portions Copyrighted [year] [name of copyright owner]\"\n- */\n-package org.forgerock.openidm.repo.orientdb.impl.query;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.forgerock.json.resource.BadRequestException;\n-\n-import org.testng.annotations.Test;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-public class TokenHandlerTest {\n-\n-    TokenHandler tokenHandler = null;\n-    \n-    @Test\n-    public void initTokenHandler() {\n-        tokenHandler = new TokenHandler();\n-    }\n-    \n-    @Test(dependsOnMethods = {\"initTokenHandler\"})\n-    public void replaceTokensWithValues() throws BadRequestException {\n-        String queryString = \"select ${unquoted:_fields} from ${unquoted:_resource} where firstname = ${firstname} and lastname like '${unquoted:lastname}%'\";\n-        Map<String, String> params = new HashMap<>();\n-        params.put(\"_fields\", \"*\");\n-        params.put(\"_resource\", \"managed/user\");\n-        params.put(\"firstname\", \"John\");\n-        params.put(\"lastname\", \"D\");\n-        String result = tokenHandler.replaceTokensWithValues(queryString, params);\n-        assertThat(result).isEqualTo(\"select * from managed/user where firstname = 'John' and lastname like 'D%'\");\n-    }\n-    \n-    // Disabled as CREST 2.x supports param values only\n-    // see also OPENIDM-522\n-    /*\n-    @Test(dependsOnMethods = {\"initTokenHandler\"})\n-    public void replaceTokensWithListValues() throws BadRequestException {\n-        String queryString = \"select ${unquoted:_fields} from ${unquoted:_resource} where firstname = ${firstname} and lastname like '${unquoted:lastname}%'\";\n-\n-        List fieldList = Arrays.asList(\"firstname\", \"lastname\", \"email\");\n-        \n-        Map params = new HashMap();\n-        params.put(\"_fields\", fieldList);\n-        params.put(\"_resource\", \"managed/user\");\n-        params.put(\"firstname\", \"John\");\n-        params.put(\"lastname\", \"D\");\n-        String result = tokenHandler.replaceTokensWithValues(queryString, params);\n-        assertThat(result).isEqualTo(\"select firstname,lastname,email from managed/user where firstname = 'John' and lastname like 'D%'\");\n-    }\n-    */\n-\n-    @Test(dependsOnMethods = {\"initTokenHandler\"})\n-    public void replaceTokenWithDotNotationAbsolute() throws BadRequestException {\n-        String queryString = \"select ${dotnotation:jsonpath} from ${unquoted:_resource} where firstname = ${firstname} and lastname like '${unquoted:lastname}%'\";\n-        Map<String, String> params = new HashMap<>();\n-        params.put(\"jsonpath\", \"/sunset/date\");\n-        params.put(\"_resource\", \"managed/user\");\n-        params.put(\"firstname\", \"John\");\n-        params.put(\"lastname\", \"D\");\n-        String result = tokenHandler.replaceTokensWithValues(queryString, params);\n-        assertThat(result).isEqualTo(\"select sunset.date from managed/user where firstname = 'John' and lastname like 'D%'\");\n-    }\n-\n-    @Test(dependsOnMethods = {\"initTokenHandler\"})\n-    public void replaceTokenWithDotNotationRelative() throws BadRequestException {\n-        String queryString = \"select ${dotnotation:jsonpath} from ${unquoted:_resource} where firstname = ${firstname} and lastname like '${unquoted:lastname}%'\";\n-        Map<String, String> params = new HashMap<>();\n-        params.put(\"jsonpath\", \"sunset/date\");\n-        params.put(\"_resource\", \"managed/user\");\n-        params.put(\"firstname\", \"John\");\n-        params.put(\"lastname\", \"D\");\n-        String result = tokenHandler.replaceTokensWithValues(queryString, params);\n-        assertThat(result).isEqualTo(\"select sunset.date from managed/user where firstname = 'John' and lastname like 'D%'\");\n-    }\n-\n-    @Test(dependsOnMethods = {\"initTokenHandler\"}, expectedExceptions = BadRequestException.class )\n-    public void valueReplaceMissingToken() throws BadRequestException {\n-        String queryString = \"select ${unquoted:_fields} from ${unquoted:_resource} where firstname = ${firstname} and lastname like '${unquoted:lastname}%'\";\n-        Map<String, String> params = new HashMap<>();\n-        params.put(\"_fields\", \"*\");\n-        params.put(\"_resource\", \"managed/user\");\n-        // don't define firstname, should fail\n-        params.put(\"lastname\", \"D\");\n-        String result = tokenHandler.replaceTokensWithValues(queryString, params);\n-        assertThat(result).isEqualTo(\"select * from managed/user where firstname = 'John' and lastname like 'D%'\");\n-    }\n-    \n-    @Test(dependsOnMethods = {\"initTokenHandler\"})\n-    public void replaceTokensWithOrientToken() throws PrepareNotSupported {\n-        String queryString = \"select ${unquoted:_fields} from ${unquoted:_resource} where firstname = ${firstname} and lastname like ${lastname}\";\n-        String result = tokenHandler.replaceTokensWithOrientToken(queryString);\n-        assertThat(result).isEqualTo(\"select :_fields from :_resource where firstname = :firstname and lastname like :lastname\");\n-    }\n-}\n\\ No newline at end of file"
  }
]
