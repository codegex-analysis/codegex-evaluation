[
  {
    "sha": "18ce60af029a3586e3bce457812177cdf0dcfcb9",
    "filename": "README.adoc",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/README.adoc",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/README.adoc",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/README.adoc?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -11,7 +11,7 @@ image::media/jipsy-logo.png[]\n image:https://github.com/{project-owner}/{project-name}/workflows/Build/badge.svg[\"Build Status\", link=\"https://github.com/{project-owner}/{project-name}/actions\"]\n image:https://img.shields.io/maven-central/v/{project-group}/jipsy-processor.svg[Download, link=\"https://search.maven.org/search?q=jipsy-processor\"]\n \n----\n+'''\n \n Configurable Java Annotation Processor to simplify the use of the Service Provider Interface.\n "
  },
  {
    "sha": "7d06f080dfa0b0530f2a8456278fa8e8ae3cb85f",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractPersistence.java",
    "status": "modified",
    "additions": 18,
    "deletions": 24,
    "changes": 42,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractPersistence.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractPersistence.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractPersistence.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -18,11 +18,12 @@\n package org.kordamp.jipsy.processor;\n \n import java.io.File;\n-import java.io.FileFilter;\n import java.io.IOException;\n import java.io.Writer;\n-import java.text.SimpleDateFormat;\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.stream.Collectors;\n \n /**\n  * @author Andres Almiray\n@@ -32,7 +33,7 @@\n     protected final String path;\n     protected final Logger logger;\n \n-    public AbstractPersistence(String name, Logger logger, String path) {\n+    protected AbstractPersistence(String name, Logger logger, String path) {\n         this.name = name;\n         this.logger = logger;\n         this.path = path;\n@@ -53,16 +54,9 @@ public void writeLog() {\n     @Override\n     public void write(String name, String value) throws IOException {\n         logger.note(LogLocation.BOTH, \"Generating file '\" + path + name + \"'\");\n-        Writer writer = createWriter(name);\n-        try {\n+        try (Writer writer = createWriter(name)) {\n             writer.write(\"# Generated by \" + this.name + \"\\n\");\n             writer.write(value);\n-        } finally {\n-            try {\n-                writer.close();\n-            } catch (IOException e) {\n-                // Ignore\n-            }\n         }\n     }\n \n@@ -73,27 +67,27 @@ public void write(String name, String value) throws IOException {\n         if (dir == null) {\n             fileList = Collections.emptyList();\n         } else {\n-            fileList = listDiscoveredFiles(dir.listFiles(getFileFilter()));\n+            fileList = listDiscoveredFiles(dir.listFiles(SimpleFileFilter.INSTANCE));\n         }\n         return fileList;\n     }\n \n-    @Override\n-    public Collection<String> listDiscoveredFiles(File[] list) {\n+    /**\n+     * Convert the array of files into a collection of the the file names.\n+     *\n+     * @param list the files to convert\n+     * @return a collection containing the file names. Possibly an empty collection of the array langth is zero or the\n+     * array parameter {@code list} is {@code null}.\n+     */\n+    private Collection<String> listDiscoveredFiles(File[] list) {\n         if (list == null) {\n             return Collections.emptyList();\n         }\n \n-        List<String> result = new ArrayList<String>();\n-        for (File file : list) {\n-            String fileName = file.getName();\n-            logger.note(LogLocation.LOG_FILE, \"Discovered \" + fileName);\n-            result.add(fileName);\n-        }\n-        return result;\n+        return Arrays.stream(list).map(File::getName)\n+            .peek(fileName -> logger.note(LogLocation.LOG_FILE, \"Discovered \" + fileName))\n+            .collect(Collectors.toList());\n     }\n \n     protected abstract Writer createWriter(String name) throws IOException;\n-\n-    protected abstract FileFilter getFileFilter();\n }"
  },
  {
    "sha": "df50ace6aeb522853f516866602dd4e77ec21535",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourceInitializer.java",
    "status": "modified",
    "additions": 10,
    "deletions": 20,
    "changes": 30,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourceInitializer.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourceInitializer.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourceInitializer.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -20,19 +20,25 @@\n import javax.annotation.processing.Filer;\n import javax.tools.FileObject;\n import javax.tools.StandardLocation;\n-import java.io.BufferedReader;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n \n /**\n+ * Reads the content of a resource as part of the resource initialization process. Expressed in less abstract way it\n+ * read the content of the file {@code META-INF/services/...} or {@code META-INF/types/...} and returns it as a\n+ * character stream.\n+ * <p>\n+ * The reading uses the annotation processor APIs so that it will read the correct file even if that was generated by\n+ * some other annotation processor in an earlier round.\n+ *\n  * @author Andres Almiray\n  */\n public abstract class AbstractResourceInitializer implements Initializer {\n     protected final Filer filer;\n     protected final String path;\n     protected final Logger logger;\n \n-    public AbstractResourceInitializer(Logger logger, String path, Filer filer) {\n+    protected AbstractResourceInitializer(Logger logger, String path, Filer filer) {\n         this.logger = logger;\n         this.path = path;\n         this.filer = filer;\n@@ -43,12 +49,11 @@ public CharSequence initialData(String name) {\n         try {\n             FileObject resource = filer.getResource(StandardLocation.CLASS_OUTPUT, \"\", path + name);\n \n-            CharSequence result;\n             try {\n                 // Eclipse can't handle the getCharContent\n                 // See https://bugs.eclipse.org/bugs/show_bug.cgi?id=246089\n                 // 2008-09-12 RoelS: I've posted a patch file\n-                result = tryWithReader(resource);\n+                return resource.getCharContent(true);\n             } catch (FileNotFoundException e) {\n                 // Could happen\n                 return null;\n@@ -59,7 +64,7 @@ public CharSequence initialData(String name) {\n                 try {\n                     // Javac can't handle the openReader\n                     // Filed as a bug at bugs.sun.com and received a review ID: 1339738\n-                    result = resource.getCharContent(true);\n+                    return resource.getCharContent(true);\n                 } catch (FileNotFoundException e) {\n                     // Could happen\n                     return null;\n@@ -68,24 +73,9 @@ public CharSequence initialData(String name) {\n                     return null;\n                 }\n             }\n-            return result;\n         } catch (IOException e) {\n             logger.note(LogLocation.MESSAGER, \"getResource gave an IOException: \" + e.getMessage());\n         }\n         return null;\n     }\n-\n-    protected CharSequence tryWithReader(FileObject resource) throws IOException {\n-        StringBuilder sb = new StringBuilder();\n-        BufferedReader reader = new BufferedReader(resource.openReader(true));\n-        try {\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                sb.append(line).append(\"\\n\");\n-            }\n-        } finally {\n-            reader.close();\n-        }\n-        return sb;\n-    }\n }"
  },
  {
    "sha": "6e09e696893e84192e3430f87872da9edeee86e5",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourcePersistence.java",
    "status": "modified",
    "additions": 8,
    "deletions": 14,
    "changes": 22,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourcePersistence.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourcePersistence.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractResourcePersistence.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -32,7 +32,7 @@\n public abstract class AbstractResourcePersistence extends AbstractPersistence {\n     protected final Filer filer;\n \n-    public AbstractResourcePersistence(Filer filer, String name, Logger logger, String path) {\n+    protected AbstractResourcePersistence(Filer filer, String name, Logger logger, String path) {\n         super(name, logger, path);\n         this.filer = filer;\n     }\n@@ -47,25 +47,20 @@ public File determineOutputLocation() {\n         FileObject resource;\n         try {\n             resource = getResourceFile(\"locator\");\n-        } catch (FileNotFoundException e) {\n-            // Could happen\n-            return null;\n-        } catch (IOException e) {\n-            logger.note(LogLocation.MESSAGER, \"IOException while determining output location: \" + e.getMessage());\n-            return null;\n-        } catch (IllegalArgumentException e) {\n-            // Happens when the path is invalid. For instance absolute or relative to a path\n+        } catch (FileNotFoundException | IllegalArgumentException e) {\n+            // IllegalArgumentException happens when the path is invalid. For instance absolute or relative to a path\n             // not part of the class output folder.\n-            //\n             // Due to a bug in javac for Linux, this also occurs when no output path is specified\n             // for javac using the -d parameter.\n             // See http://forums.sun.com/thread.jspa?threadID=5240999&tstart=45\n             // and http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6647996\n-\n-//\t\t\tlogger.toConsole(\"IllegalArgumentException: \" + e.getMessage());\n+            return null;\n+        } catch (IOException e) {\n+            logger.note(LogLocation.MESSAGER, \"IOException while determining output location: \" + e.getMessage());\n             return null;\n         }\n \n+\n         URI uri = resource.toUri();\n         if (uri.isAbsolute()) {\n             return new File(uri).getParentFile();\n@@ -88,7 +83,6 @@ protected FileObject createResourceFile(String name) throws IOException {\n \n     @Override\n     protected Writer createWriter(String name) throws IOException {\n-        FileObject output = createResourceFile(name);\n-        return output.openWriter();\n+        return createResourceFile(name).openWriter();\n     }\n }"
  },
  {
    "sha": "f3d4e2aeb34ce4c4d1492a1d6ad8a5e8787c328c",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractSpiProcessor.java",
    "status": "modified",
    "additions": 225,
    "deletions": 87,
    "changes": 312,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractSpiProcessor.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractSpiProcessor.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/AbstractSpiProcessor.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -22,18 +22,27 @@\n import javax.annotation.processing.AbstractProcessor;\n import javax.annotation.processing.ProcessingEnvironment;\n import javax.annotation.processing.RoundEnvironment;\n-import javax.lang.model.element.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.QualifiedNameable;\n+import javax.lang.model.element.TypeElement;\n import javax.lang.model.type.DeclaredType;\n import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n import javax.lang.model.util.Types;\n-import javax.tools.Diagnostic;\n+import javax.tools.Diagnostic.Kind;\n import javax.tools.FileObject;\n import javax.tools.StandardLocation;\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n-import java.util.*;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n \n /**\n  * @author Andres Almiray\n@@ -42,6 +51,11 @@\n     protected static final Pattern RELEASE_PATTERN = Pattern.compile(\"^RELEASE_(\\\\d+)$\");\n     protected Options options;\n     protected Logger logger;\n+    private static final int MAX_SUPPORTED_VERSION = 8;\n+\n+    protected abstract Persistence getPersistence();\n+\n+    protected abstract <T extends ProvidedCollector> T getData();\n \n     @Override\n     public synchronized void init(ProcessingEnvironment environment) {\n@@ -50,10 +64,25 @@ public synchronized void init(ProcessingEnvironment environment) {\n         try {\n             initialize();\n         } catch (Exception e) {\n-            environment.getMessager().printMessage(Diagnostic.Kind.ERROR, ProcessorLogger.exceptionToString(e));\n+            environment.getMessager().printMessage(Kind.ERROR, ProcessorLogger.exceptionToString(e));\n         }\n     }\n \n+    @Override\n+    public SourceVersion getSupportedSourceVersion() {\n+        SourceVersion[] svs = SourceVersion.values();\n+        for (int i = svs.length - 1; i >= 0; i--) {\n+            String name = svs[i].name();\n+            Matcher m = RELEASE_PATTERN.matcher(name);\n+            if (m.matches()) {\n+                int release = Integer.parseInt(m.group(1));\n+                if (release <= MAX_SUPPORTED_VERSION) return svs[i];\n+            }\n+        }\n+\n+        return SourceVersion.RELEASE_6;\n+    }\n+\n     @Override\n     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n         if (options.disabled()) {\n@@ -77,16 +106,115 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment\n \n     protected abstract Class<? extends Annotation> getAnnotationClass();\n \n-    protected abstract void handleElement(Element e);\n+    protected abstract Stream<AnnotationValue> enrich(Stream<? extends AnnotationMirror> poor);\n+\n+    protected abstract CheckResult checkCurrentClass(Element currentClass);\n+\n+    /**\n+     * Register the provider implementing the interface {@code name} into the collection of services and their\n+     * implementations.\n+     *\n+     * @param name     the name of the service this provider implements\n+     * @param provider the provider that implements the interface\n+     */\n \n-    protected abstract void removeStaleData(RoundEnvironment roundEnv);\n+    private void register(String name, TypeElement provider) {\n+        getData().get(name).addProvider(createProperQualifiedName(provider));\n+    }\n+\n+    protected void handleElement(Element e) {\n+        CheckResult checkResult = checkCurrentClass(e);\n+        if (checkResult.isError()) {\n+            reportError(e, checkResult);\n+            return;\n+        }\n+        TypeElement te = (TypeElement) e;\n+\n+        enrich(findAnnotationMirrors(te, getAnnotationClass().getName()))\n+            .map(AbstractSpiProcessor::toElement)\n+            .filter(type -> {\n+                    CheckResult implementationResult = isImplementation(te, type);\n+                    return !(implementationResult.isError() && reportError(te, implementationResult));\n+                }\n+            )\n+            .map(this::createProperQualifiedName)\n+            .forEach(name -> register(name, te));\n+    }\n+\n+    private void removeStaleData(RoundEnvironment roundEnv) {\n+        roundEnv.getRootElements().stream()\n+            .filter(e -> e instanceof TypeElement)\n+            .map(e -> (TypeElement) e)\n+            .map(this::createProperQualifiedName)\n+            .forEach(getData()::removeProvider);\n+    }\n+\n+    private void writeData() {\n+        if (getData().isModified()) {\n+            logger.note(LogLocation.LOG_FILE, \"Writing output\");\n+            if (getData().values().isEmpty()) {\n+                try {\n+                    getPersistence().delete();\n+                } catch (IOException e) {\n+                    logger.warning(LogLocation.LOG_FILE, \"An error occurred while deleting data file\");\n+                }\n+            } else {\n+                for (Provided type : getData().values()) {\n+                    try {\n+                        getPersistence().write(type.getName(), type.toProviderNamesList());\n+                    } catch (IOException e) {\n+                        processingEnv.getMessager().printMessage(Kind.ERROR, e.getMessage());\n+                    }\n+                }\n+                getPersistence().writeLog();\n+            }\n+        }\n+    }\n+\n+    protected void initializeIfPossible(ProvidedCollector data, Persistence persistence) {\n+        persistence.tryFind().forEach(data::get);\n+        data.cache();\n+    }\n+\n+    /**\n+     * Send a non-mandatory warning message to the service output-\n+     *\n+     * @param message the warning message to be printed\n+     */\n+    private void reportWarning(String message) {\n+        processingEnv.getMessager().printMessage(Kind.WARNING, message);\n+    }\n \n-    protected abstract void writeData();\n+    /**\n+     * Send a mandatory warning message to the service output-\n+     *\n+     * @param message the warning message to be printed\n+     */\n+    private void reportMandatoryWarning(String message) {\n+        processingEnv.getMessager().printMessage(Kind.WARNING, message);\n+    }\n \n-    protected void warning(String message) {\n-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, message);\n+    /**\n+     * Report an error on a given element.\n+     *\n+     * @param element the element that the report is about\n+     * @param result the error message holding {@link CheckResult}\n+     * @return {@code true}\n+     */\n+    protected boolean reportError(Element element, CheckResult result) {\n+        processingEnv.getMessager().printMessage(Kind.ERROR, element.getSimpleName() + \" \" + result.getMessage(), element);\n+        return true;\n     }\n \n+    /**\n+     * General implementation of the initialization of the processor. It reads the options given to the processor from\n+     * the invoking tool. If the option  {@code spi_disabled} option is set and {@code true} then the method returns\n+     * without further processing.\n+     * <p>\n+     * If the processor is not disabled then it checks the the existence of some Javac annotation processing bug that\n+     * existed in certain version. If the annotation processor sees this type of behavior then it prints a warning and\n+     * continues.\n+     */\n     protected void initialize() {\n         options = new Options(ServiceProviderProcessor.NAME, processingEnv.getOptions());\n         if (options.disabled()) {\n@@ -97,131 +225,141 @@ protected void initialize() {\n         checkCompatibility();\n     }\n \n-    protected void checkCompatibility() {\n+    /**\n+     * Perform some compatibility checks and print some warning in case there is some issue.\n+     */\n+    private void checkCompatibility() {\n         logger.note(LogLocation.MESSAGER, \"Testing for compatibility options\");\n         try {\n             checkJavacOnLinux();\n         } catch (Exception e) {\n-            warning(ProcessorLogger.exceptionToString(e));\n+            reportWarning(ProcessorLogger.exceptionToString(e));\n         }\n         logger.note(LogLocation.MESSAGER, \"Testing complete\");\n     }\n \n-    protected void checkJavacOnLinux() {\n+    /**\n+     * Check if the bug 6647996 of Javac seem to manifest in this execution. If yes, it displays a warning about it and\n+     * how to fix.\n+     * <p>\n+     * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6647996 for further information.\n+     * <p>\n+     * If there is an exception during the test, then it is also printed.\n+     */\n+    private void checkJavacOnLinux() {\n         try {\n             FileObject resource = processingEnv.getFiler().getResource(StandardLocation.CLASS_OUTPUT, \"\", options.dir() + \"a/b\");\n-            if (resource.toUri().toString().equals(\"b\")) {\n-                warning(\"Output files will be placed in the root of the output folder.\\n  This is a known bug in the java compiler on Linux.\\n  Please use the -d compiler option to circumvent this problem.\\n  See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6647996 for more information.\");\n+            if (\"b\".equals(resource.toUri().toString())) {\n+                reportMandatoryWarning(\"Output files will be placed in the root of the output folder.\\n\" +\n+                    \"  This is a known bug in the java compiler on Linux.\\n\" +\n+                    \"  Please use the -d compiler option to circumvent this problem.\\n\" +\n+                    \"  See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6647996 for more information.\");\n             }\n         } catch (IOException e) {\n-            warning(\"IOException during testing Javac on Linux\");\n-        }\n-    }\n-\n-    protected void handleAnnotations(RoundEnvironment roundEnv) {\n-        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(getAnnotationClass());\n-        for (Element e : elements) {\n-            handleElement(e);\n+            reportWarning(\"IOException during testing Javac on Linux\");\n         }\n     }\n \n-    protected void reportError(TypeElement element, CheckResult result) {\n-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, element.getSimpleName() + \" \" + result.getMessage(), element);\n-    }\n-\n-    protected boolean hasPublicNoArgsConstructor(TypeElement currentClass) {\n-        List<ExecutableElement> constructors = ElementFilter.constructorsIn(currentClass.getEnclosedElements());\n-        for (ExecutableElement constructor : constructors) {\n-            if (hasModifier(constructor, Modifier.PUBLIC) && constructor.getParameters().isEmpty()) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    /**\n+     * Get all the elements, which are annotated by the type returned by {@link #getAnnotationClass()} implemented in\n+     * the subclass of this abstract class and execute the {@link #handleElement(Element)} for them.\n+     *\n+     * @param roundEnv the execution processor environment for the actual round\n+     */\n+    private void handleAnnotations(RoundEnvironment roundEnv) {\n+        roundEnv.getElementsAnnotatedWith(getAnnotationClass()).forEach(this::handleElement);\n     }\n \n     protected boolean hasModifier(Element element, Modifier modifier) {\n         return element.getModifiers().contains(modifier);\n     }\n \n-    protected boolean isStaticClass(TypeElement element) {\n+    /**\n+     * Checks that the class is either top level or a static inner class. Non-static inner classes cannot implement\n+     * services, because services need a public no-arg constructor. Non-static inner classes, however, has an implicit\n+     * reference to the outer class instance they belong to and they cannot be instantiated without that instance. This\n+     * is implemented in the JVM in a way that such classes have an extra first argument, which is a reference to the\n+     * enclosing class instance. That way a non-static inner class does not have a real no-arg constructor, because even\n+     * the no-arg constructor has a hidden argument.\n+     *\n+     * @param element the (class) element to check\n+     * @return true if the class is top level, or static inner class\n+     */\n+    protected boolean isStaticClass(Element element) {\n         return element.getEnclosingElement().getKind() != ElementKind.CLASS ||\n             hasModifier(element, Modifier.STATIC);\n     }\n \n-    protected boolean isAbstractClass(TypeElement element) {\n-        return element.getEnclosingElement().getKind() == ElementKind.CLASS &&\n-            hasModifier(element, Modifier.ABSTRACT);\n+    /**\n+     * Checks that a class is abstract.\n+     *\n+     * @param element the class that we need to check for being abstract\n+     * @return {@code true} if the class is an abstract class\n+     */\n+    protected boolean isAbstractClass(Element element) {\n+        return hasModifier(element, Modifier.ABSTRACT);\n     }\n \n+    /**\n+     * Checks that the class is really a service class that implements the interface declaring the service.\n+     *\n+     * @param currentClass the class that needs to be checked that it really implements the interface defining the\n+     *                     service\n+     * @param type         the service interface\n+     * @return {@linkplain CheckResult#OK} if the class implements the interface otherwise an error result\n+     */\n     protected CheckResult isImplementation(TypeElement currentClass, TypeElement type) {\n         if (isAssignable(currentClass.asType(), type.asType())) {\n             return CheckResult.OK;\n         }\n \n-        String message;\n-        if (type.getKind() == ElementKind.INTERFACE) {\n-            message = \"does not implement\";\n-        } else {\n-            message = \"does not extend\";\n-        }\n+        final String message = \"does not \" + (type.getKind() == ElementKind.INTERFACE ? \"implement\" : \"extend\");\n         return CheckResult.valueOf(message + \" \" + type.getQualifiedName());\n     }\n \n-    protected boolean isAssignable(TypeMirror currentClass, TypeMirror type) {\n+    /**\n+     * Checks that the class is really a service class that implements the interface declaring the service.\n+     *\n+     * @param currentClass the class that needs to be checked that it really implements the interface defining the\n+     *                     service\n+     * @param type         the service interface type\n+     * @return {@code true} if the class implements the interface otherwise {@code false}\n+     */\n+    private boolean isAssignable(TypeMirror currentClass, TypeMirror type) {\n         Types typeUtils = processingEnv.getTypeUtils();\n-        if (typeUtils.isAssignable(typeUtils.erasure(currentClass), typeUtils.erasure(type))) {\n-            return true;\n-        }\n-\n-        for (TypeMirror superType : typeUtils.directSupertypes(currentClass)) {\n-            if (isAssignable(superType, type)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected AnnotationValue findSingleValueMember(AnnotationMirror mirror, String memberName) {\n-        Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = mirror.getElementValues();\n-        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {\n-            if (entry.getKey().getSimpleName().contentEquals(memberName)) {\n-                return entry.getValue();\n-            }\n-        }\n-        throw new IllegalStateException(\"No value found in element\");\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    protected Collection<AnnotationValue> findCollectionValueMember(AnnotationMirror mirror, String memberName) {\n-        Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = mirror.getElementValues();\n-        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {\n-            if (entry.getKey().getSimpleName().contentEquals(memberName)) {\n-                return (Collection<AnnotationValue>) entry.getValue().getValue();\n-            }\n-        }\n-        throw new IllegalStateException(\"No value found in element\");\n+        return typeUtils.isAssignable(typeUtils.erasure(currentClass), typeUtils.erasure(type)) ||\n+            typeUtils.directSupertypes(currentClass).stream().anyMatch(superType -> isAssignable(superType, type));\n     }\n \n+    /**\n+     * Get the name of the type. This is the fully qualified name and it is the binary name. That is the name where the\n+     * character between the name of the enclosing and the subclass is {@code $} and not {@code .}\n+     * <p>\n+     * This is the name, which is listed in the {@code META-INF/services} files.\n+     *\n+     * @param type for which we need the name\n+     * @return the binary name of the type / class\n+     */\n     protected String createProperQualifiedName(TypeElement type) {\n         return processingEnv.getElementUtils().getBinaryName(type).toString();\n     }\n \n-    protected static List<AnnotationMirror> findAnnotationMirrors(TypeElement element, String lookingFor) {\n-        List<AnnotationMirror> annotationMirrors = new ArrayList<AnnotationMirror>();\n-        for (AnnotationMirror annotation : element.getAnnotationMirrors()) {\n-            if (annotationMirrorMatches(annotation, lookingFor)) {\n-                annotationMirrors.add(annotation);\n-            }\n-        }\n-        return annotationMirrors;\n+    protected static Stream<? extends AnnotationMirror> findAnnotationMirrors(TypeElement element, String lookingFor) {\n+        return element.getAnnotationMirrors().stream()\n+            .filter(annotation -> annotationMirrorMatches(annotation, lookingFor));\n     }\n \n+    /**\n+     * @param annotation the annotation of which the name to check\n+     * @param lookingFor the name we are looking for\n+     * @return {@code true} if the {@code annotation} has the name we are {@code lookingFor}.\n+     */\n     protected static boolean annotationMirrorMatches(AnnotationMirror annotation, String lookingFor) {\n-        Name qualifiedName = ((TypeElement) (annotation.getAnnotationType()).asElement()).getQualifiedName();\n+        Name qualifiedName = ((QualifiedNameable) (annotation.getAnnotationType()).asElement()).getQualifiedName();\n         return qualifiedName.contentEquals(lookingFor);\n     }\n \n     protected static TypeElement toElement(AnnotationValue value) {\n-        return (TypeElement) ((DeclaredType) ((TypeMirror) value.getValue())).asElement();\n+        return (TypeElement) ((DeclaredType) (value.getValue())).asElement();\n     }\n }"
  },
  {
    "sha": "f7ef7721f4a058213053061ec34f6a774c46133a",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/CheckResult.java",
    "status": "modified",
    "additions": 32,
    "deletions": 3,
    "changes": 35,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/CheckResult.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/CheckResult.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/CheckResult.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -35,16 +35,37 @@\n \n package org.kordamp.jipsy.processor;\n \n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Stores the result of a check.\n+ * <p>\n+ * The result can be {@linkplain CheckResult#OK OK} or some error. If the result is {@linkplain CheckResult#OK OK} then\n+ * there is no error.\n+ * <p>\n+ * The result also contains a message in case if is not {@linkplain CheckResult#OK OK}. If the result is {@linkplain\n+ * CheckResult#OK OK} then the message is {@code null}.\n+ */\n public final class CheckResult {\n+    /**\n+     * The single instance of the class that is not an error. It is guaranteed by the implementation that external code\n+     * out of this class cannot create an instance that is representing the OK state. It is legit to check {@code state\n+     * == CheckResult.OK} for error. This can also be checked calling {@linkplain CheckResult#isError()}, which is also\n+     * the preferred and recommended way.\n+     */\n     public static final CheckResult OK = new CheckResult(null);\n \n     private final boolean error;\n     private final String message;\n \n+    /**\n+     * Create a new result, for which {@linkplain #isError()} is {@code null} and contains the error message.\n+     *\n+     * @param message describes the error\n+     * @return the new result object\n+     */\n     public static CheckResult valueOf(String message) {\n-        if (message == null) {\n-            throw new NullPointerException(\"message\");\n-        }\n+        requireNonNull(message, \"message\");\n         return new CheckResult(message);\n     }\n \n@@ -53,10 +74,18 @@ private CheckResult(String message) {\n         this.message = message;\n     }\n \n+    /**\n+     * @return {@code true} if this is an error result, and {@code false} if this is not the {@linkplain CheckResult#OK\n+     * OK} instance of the class.\n+     */\n     public boolean isError() {\n         return error;\n     }\n \n+    /**\n+     *\n+     * @return the message that describes the result\n+     */\n     public String getMessage() {\n         return message;\n     }"
  },
  {
    "sha": "1ff17e303b18039dffcdb7020d4a5c2f34aa776f",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Initializer.java",
    "status": "modified",
    "additions": 6,
    "deletions": 0,
    "changes": 6,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Initializer.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Initializer.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Initializer.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -36,5 +36,11 @@\n package org.kordamp.jipsy.processor;\n \n public interface Initializer {\n+    /**\n+     * Read the content of the resource named and return the character stream content of the file.\n+     *\n+     * @param name the name of the file.\n+     * @return the content of the file\n+     */\n     CharSequence initialData(String name);\n }\n\\ No newline at end of file"
  },
  {
    "sha": "3bf41e1c85d81995c58871511e8925ba7492647c",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Options.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Options.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Options.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Options.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -43,7 +43,7 @@\n     public static final String SPI_LOG_OPTION = \"spi_log\";\n     public static final String SPI_VERBOSE_OPTION = \"spi_verbose\";\n \n-    private final List<String> warnings = new ArrayList<String>();\n+    private final List<String> warnings = new ArrayList<>();\n \n     private final boolean disabled;\n     private final boolean log;"
  },
  {
    "sha": "b880de18d55178f13988fd281bab1f70e3e65986",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Persistence.java",
    "status": "modified",
    "additions": 22,
    "deletions": 3,
    "changes": 25,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Persistence.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Persistence.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Persistence.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -26,13 +26,32 @@\n \n     Initializer getInitializer();\n \n+    /**\n+     * Write the value to the file named {@code name} and also a {@code # generated by...} line in front of it.\n+     *\n+     * @param name  the name of the file where to write\n+     * @param value the value to be written into the file\n+     * @throws IOException when the file cannot be written\n+     */\n     void write(String name, String value) throws IOException;\n \n+    /**\n+     * @return the directory where the output should be persisted. The actual location is determined looking for the\n+     * resource named {@code \"locator\"}.\n+     */\n     File determineOutputLocation();\n \n+    /**\n+     * Get the files from the output locations.\n+     *\n+     * @return the names of the file, which are in the output location and are not {@code .log} files.\n+     */\n     Collection<String> tryFind();\n \n-    Collection<String> listDiscoveredFiles(File[] list);\n-\n-    void delete() throws IOException ;\n+    /**\n+     * Delete the file that should contain the resource.\n+     *\n+     * @throws IOException if the deletion of the resource is not possible for some reason\n+     */\n+    void delete() throws IOException;\n }"
  },
  {
    "sha": "07542174024962ee95a18dae65a9ac6383f2767d",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProcessorLogger.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProcessorLogger.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProcessorLogger.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProcessorLogger.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -44,7 +44,7 @@\n     private final Messager messager;\n     private final Options options;\n \n-    private final StringBuffer logContent = new StringBuffer();\n+    private final StringBuilder logContent = new StringBuilder();\n \n     public ProcessorLogger(Messager messager, Options options) {\n         if (messager == null) {"
  },
  {
    "sha": "8ac8ac6ea4322a615de49117a504122474115584",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Provided.java",
    "status": "added",
    "additions": 170,
    "deletions": 0,
    "changes": 170,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Provided.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Provided.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/Provided.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -0,0 +1,170 @@\n+/*\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ * Copyright 2013 - 2021 Andres Almiray.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+\n+Copyright 2008-2020 TOPdesk, the Netherlands\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+*/\n+package org.kordamp.jipsy.processor;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class Provided {\n+    protected final Set<String> providers = new LinkedHashSet<>();\n+    protected final Logger logger;\n+    protected final String name;\n+\n+    protected Provided(Logger logger, String name) {\n+        requireNonNull(logger, \"logger\");\n+        requireNonNull(name, \"name\");\n+        this.logger = logger;\n+        logger.note(LogLocation.LOG_FILE, \"Creating \" + name);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Add a ne provider to the existing set of providers.\n+     *\n+     * @param provider the full name of the class implementing the service interface, a.k.a. the provider class\n+     */\n+    public void addProvider(String provider) {\n+        requireNonNull(provider, \"provider\");\n+        logger.note(LogLocation.LOG_FILE, \"Adding \" + provider + \" to \" + name);\n+        providers.add(provider);\n+    }\n+\n+    /**\n+     * Returns true if the service contains the specific provider\n+     *\n+     * @param provider the full name of the class implementing the service interface, a.k.a. the provider class\n+     * @return {@code true} iff the service contains the provider\n+     */\n+    public boolean contains(String provider) {\n+        return providers.contains(provider);\n+    }\n+\n+    /**\n+     * Remove a provider from the service.\n+     * <p>\n+     * This method is called for all the known services when a provider is removed. It is invoked for the services that\n+     * the provider does not implement. Therefore this is absolutely normal case that the caller calls this method and\n+     * the service does NOT have the given provider. In that case just do not log it. In the structure we do not\n+     * maintain the interfaces a provider implements. There is no need.\n+     *\n+     * @param provider the full name of the class implementing the service interface, a.k.a. the provider class\n+     * @return {@code true} if the provider was registered in the class and {@code false} otherwise\n+     */\n+    public boolean removeProvider(String provider) {\n+        if (providers.remove(provider)) {\n+            logger.note(LogLocation.LOG_FILE, \"Removing \" + provider + \" from \" + name);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the name of the service. This is the full name of the interface that represents the service.\n+     *\n+     * @return the name of the service.\n+     */\n+    public String getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Return the names of the service providers in a string as several lines, each line terminated with a {@code \\n}\n+     * character including the last line.\n+     * <p>\n+     * The names of the classes are sorted and they are joined together. This form is appropriate to be written into the\n+     * {@code META-INF/services/service.interface.full.name} file.\n+     *\n+     * @return the list of the service names in a string, each terminated with a {@code \\n}.\n+     */\n+    protected String toProviderNamesList(){\n+        StringBuilder sb = new StringBuilder();\n+        List<String> names = new ArrayList<>(providers);\n+        Collections.sort(names);\n+        for (String provider : names) {\n+            sb.append(provider).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Read a string and add the providers that are listed in the string.\n+     * <p>\n+     * The format of the string is the same as the file {@code META-INF/services/service.interface.full.name} file.\n+     * Empty lines an the part of the lines that follow the {@code #} comment character are ignored.\n+     *\n+     * @param input the content presumably read from a {@code INF/services/service.interface.full.name} file\n+     */\n+    public void fromProviderNamesList(String input){\n+        requireNonNull(input, \"input\");\n+        String[] lines = input.split(\"\\\\n\");\n+        for (String line : lines) {\n+            final String[] content = line.split(\"#\");\n+            if (content.length > 0) {\n+                String trimmed = content[0].trim();\n+                if (trimmed.length() > 0) {\n+                    addProvider(trimmed);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name + \"=\" + providers;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Provided service = (Provided) o;\n+\n+        return name.equals(service.name) &&\n+            providers.containsAll(service.providers) && service.providers.containsAll(providers);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = name.hashCode();\n+        result = 31 * result + providers.hashCode();\n+        return result;\n+    }\n+}"
  },
  {
    "sha": "0d5fb5dba442a4dda5bc94c933e8f94d65cba1a1",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProvidedCollector.java",
    "status": "added",
    "additions": 45,
    "deletions": 0,
    "changes": 45,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProvidedCollector.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProvidedCollector.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/ProvidedCollector.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ * Copyright 2013 - 2021 Andres Almiray.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+\n+Copyright 2008-2020 TOPdesk, the Netherlands\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+*/\n+package org.kordamp.jipsy.processor;\n+\n+import java.util.Collection;\n+\n+public interface ProvidedCollector {\n+    Collection<? extends Provided> values();\n+    boolean isModified();\n+    void cache();\n+    Provided get(String name);\n+    void removeProvider(String name);\n+}"
  },
  {
    "sha": "44b7078eab1e664218998f314a03defa017ca219",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/Service.java",
    "status": "modified",
    "additions": 20,
    "deletions": 91,
    "changes": 111,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/Service.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/Service.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/Service.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -35,98 +35,27 @@\n \n package org.kordamp.jipsy.processor.service;\n \n-import org.kordamp.jipsy.processor.LogLocation;\n import org.kordamp.jipsy.processor.Logger;\n-\n-import java.util.*;\n-\n-public final class Service {\n-    private final Logger logger;\n-    private final String serviceName;\n-    private final Set<String> providers = new HashSet<String>();\n-\n+import org.kordamp.jipsy.processor.Provided;\n+\n+/**\n+ * Textual representation of a service interface and the classes implementing it. The class maintains the name of the\n+ * service, which is the fully qualified name of the interface and the names of the classes that implement this\n+ * interface and are or should be listed in the {@code META-INF/services} resource directory.\n+ * <p>\n+ * The class is mutable and provides methods to add, remove providers to the service.\n+ * @author Andres Almiray\n+ */\n+public final class Service extends Provided {\n+\n+    /**\n+     * Create a new service object.\n+     *\n+     * @param logger is the logger used to log operations\n+     * @param name   the name of the interface. It is not used in this class, except that it can be queried calling\n+     *               {@link #getName()} and it is also used in {@link #equals(Object)}.\n+     */\n     public Service(Logger logger, String name) {\n-        if (logger == null) {\n-            throw new NullPointerException(\"logger\");\n-        }\n-        if (name == null) {\n-            throw new NullPointerException(\"name\");\n-        }\n-        this.logger = logger;\n-        logger.note(LogLocation.LOG_FILE, \"Creating \" + name);\n-        this.serviceName = name;\n-    }\n-\n-    public void addProvider(String provider) {\n-        if (provider == null) {\n-            throw new NullPointerException(\"provider\");\n-        }\n-        logger.note(LogLocation.LOG_FILE, \"Adding \" + provider + \" to \" + serviceName);\n-        providers.add(provider);\n-    }\n-\n-    public boolean contains(String provider) {\n-        return providers.contains(provider);\n-    }\n-\n-    public boolean removeProvider(String provider) {\n-        if (providers.remove(provider)) {\n-            logger.note(LogLocation.LOG_FILE, \"Removing \" + provider + \" from \" + serviceName);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public String getName() {\n-        return serviceName;\n-    }\n-\n-    public String toProviderNamesList() {\n-        StringBuilder sb = new StringBuilder();\n-        List<String> names = new ArrayList<String>(providers);\n-        Collections.sort(names);\n-        for (String provider : names) {\n-            sb.append(provider).append(\"\\n\");\n-        }\n-        return sb.toString();\n-    }\n-\n-    public void fromProviderNamesList(String input) {\n-        if (input == null) {\n-            throw new NullPointerException(\"input\");\n-        }\n-        String[] lines = input.split(\"\\\\n\");\n-        for (String line : lines) {\n-            String[] content = line.split(\"#\");\n-            if (content.length > 0) {\n-                String trimmed = content[0].trim();\n-                if (trimmed.length() > 0) {\n-                    addProvider(trimmed);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return serviceName + \"=\" + providers;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        Service service = (Service) o;\n-\n-        return serviceName.equals(service.serviceName) &&\n-            providers.containsAll(service.providers) && service.providers.containsAll(providers);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = serviceName.hashCode();\n-        result = 31 * result + providers.hashCode();\n-        return result;\n+        super(logger, name);\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "3e23175a74528b57aff60910ed927096be85f6a2",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceCollector.java",
    "status": "modified",
    "additions": 55,
    "deletions": 35,
    "changes": 90,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceCollector.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceCollector.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceCollector.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -38,14 +38,24 @@\n import org.kordamp.jipsy.processor.Initializer;\n import org.kordamp.jipsy.processor.LogLocation;\n import org.kordamp.jipsy.processor.Logger;\n+import org.kordamp.jipsy.processor.ProvidedCollector;\n \n import java.util.*;\n \n-public final class ServiceCollector {\n-    private final Map<String, Service> services = new LinkedHashMap<String, Service>();\n-    private final Map<String, Service> cached = new LinkedHashMap<String, Service>();\n+import static java.util.Objects.requireNonNull;\n \n-    private final List<String> removed = new ArrayList<String>();\n+/**\n+ * Maintain a list of services. You can query the services by the name and in case service is not in the list it will\n+ * be loaded from the {@code META-INF/services} directory files.\n+ * <p>\n+ * At any time the list of the services can be cached, which is a kind of snapshot and later you can query if there was\n+ * any modification to the list of the service.\n+ */\n+public final class ServiceCollector implements ProvidedCollector {\n+    private final Map<String, Service> services = new LinkedHashMap<>();\n+    private final Map<String, Service> cached = new LinkedHashMap<>();\n+\n+    private final List<String> removed = new ArrayList<>();\n     private final Initializer initializer;\n     private final Logger logger;\n \n@@ -54,53 +64,63 @@ public ServiceCollector(Initializer initializer, Logger logger) {\n         this.logger = logger;\n     }\n \n+    /**\n+     * Create a snapshot of the services into the cache.\n+     */\n     public void cache() {\n         this.cached.putAll(services);\n     }\n \n+    /**\n+     *\n+     * @return {@code true} if there was a modification since the service was cached/snapshot made.\n+     */\n     public boolean isModified() {\n-        if (cached.size() != services.size()) {\n-            return true;\n-        }\n-\n-        for (Map.Entry<String, Service> e : cached.entrySet()) {\n-            if (!services.containsKey(e.getKey())) {\n-                return true;\n-            }\n-            if (!e.getValue().equals(services.get(e.getKey()))) {\n-                return true;\n-            }\n-        }\n+        return cached.size() != services.size() ||\n+            cached.entrySet().stream().anyMatch(\n+                e -> !services.containsKey(e.getKey()) || !e.getValue().equals(services.get(e.getKey())));\n+    }\n \n-        return false;\n+    /**\n+     * Get a service for the name of the interface name. If the service is not in the list for this interface name then\n+     * load it looking at the accordingly named {@code META-INF/services/xxx} files.\n+     *\n+     * @param service the fully qualified name of the interface the service providers have to implement.\n+     * @return the service instance.\n+     */\n+    @Override\n+    public Service get(String service) {\n+        requireNonNull(service,\"service\");\n+        return services.computeIfAbsent(service, this::newService );\n     }\n \n-    public Service getService(String service) {\n-        if (service == null) {\n-            throw new NullPointerException(\"service\");\n-        }\n-        if (!services.containsKey(service)) {\n-            Service newService = new Service(logger, service);\n-            CharSequence initialData = initializer.initialData(service);\n-            if (initialData != null) {\n-                newService.fromProviderNamesList(initialData.toString());\n-                for (String provider : removed) {\n-                    newService.removeProvider(provider);\n-                }\n+    private Service newService(String name){\n+        final Service newService = new Service(logger, name);\n+        CharSequence initialData = initializer.initialData(name);\n+        if (initialData != null) {\n+            newService.fromProviderNamesList(initialData.toString());\n+            for (String provider : removed) {\n+                newService.removeProvider(provider);\n             }\n-            services.put(service, newService);\n         }\n-        return services.get(service);\n+        return newService;\n     }\n \n-    public Collection<Service> services() {\n+    /**\n+     * @return the collection of the services\n+     */\n+    @Override\n+    public Collection<Service> values() {\n         return Collections.unmodifiableMap(services).values();\n     }\n \n+    /**\n+     * Remove a provider from all the services that it provides.\n+     *\n+     * @param provider the fully qualified name of the class\n+     */\n     public void removeProvider(String provider) {\n-        if (provider == null) {\n-            throw new NullPointerException(\"provider\");\n-        }\n+        requireNonNull(provider,\"provider\");\n         logger.note(LogLocation.LOG_FILE, \"Removing \" + provider);\n         removed.add(provider);\n         for (Service service : services.values()) {"
  },
  {
    "sha": "2bf68b617f8cfd2dd12711b94382ba384eb8f4b8",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServicePersistence.java",
    "status": "modified",
    "additions": 0,
    "deletions": 7,
    "changes": 7,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServicePersistence.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServicePersistence.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServicePersistence.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -37,18 +37,11 @@\n \n import org.kordamp.jipsy.processor.AbstractResourcePersistence;\n import org.kordamp.jipsy.processor.Logger;\n-import org.kordamp.jipsy.processor.SimpleFileFilter;\n \n import javax.annotation.processing.Filer;\n-import java.io.FileFilter;\n \n public class ServicePersistence extends AbstractResourcePersistence {\n     public ServicePersistence(String name, String root, Filer filer, Logger logger) {\n         super(filer, name, logger, root + \"META-INF/services/\");\n     }\n-\n-    @Override\n-    protected FileFilter getFileFilter() {\n-        return SimpleFileFilter.INSTANCE;\n-    }\n }"
  },
  {
    "sha": "1da1ceb7a1c5d9f1f035af045f1d20f8ab9845f0",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceProviderProcessor.java",
    "status": "modified",
    "additions": 50,
    "deletions": 98,
    "changes": 148,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceProviderProcessor.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceProviderProcessor.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/service/ServiceProviderProcessor.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -36,49 +36,45 @@\n package org.kordamp.jipsy.processor.service;\n \n import org.kordamp.jipsy.annotations.ServiceProviderFor;\n-import org.kordamp.jipsy.processor.*;\n+import org.kordamp.jipsy.processor.AbstractSpiProcessor;\n+import org.kordamp.jipsy.processor.CheckResult;\n+import org.kordamp.jipsy.processor.Options;\n+import org.kordamp.jipsy.processor.Persistence;\n \n-import javax.annotation.processing.RoundEnvironment;\n import javax.annotation.processing.SupportedAnnotationTypes;\n import javax.annotation.processing.SupportedOptions;\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.*;\n-import javax.tools.Diagnostic.Kind;\n-import java.io.IOException;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.util.ElementFilter;\n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n+import java.util.Collection;\n+import java.util.stream.Stream;\n \n @SupportedAnnotationTypes(\"*\")\n @SupportedOptions({Options.SPI_DIR_OPTION, Options.SPI_LOG_OPTION, Options.SPI_VERBOSE_OPTION, Options.SPI_DISABLED_OPTION})\n public class ServiceProviderProcessor extends AbstractSpiProcessor {\n     public static final String NAME = ServiceProviderProcessor.class.getName()\n         + \" (\" + ServiceProviderProcessor.class.getPackage().getImplementationVersion() + \")\";\n \n-    private static final int MAX_SUPPORTED_VERSION = 8;\n-\n     private Persistence persistence;\n     private ServiceCollector data;\n \n     @Override\n-    protected Class<? extends Annotation> getAnnotationClass() {\n-        return ServiceProviderFor.class;\n+    protected ServiceCollector getData() {\n+        return data;\n     }\n \n     @Override\n-    public SourceVersion getSupportedSourceVersion() {\n-        SourceVersion[] svs = SourceVersion.values();\n-        for (int i = svs.length - 1; i >= 0; i--) {\n-            String name = svs[i].name();\n-            Matcher m = RELEASE_PATTERN.matcher(name);\n-            if (m.matches()) {\n-                int release = Integer.parseInt(m.group(1));\n-                if (release <= MAX_SUPPORTED_VERSION) return svs[i];\n-            }\n-        }\n+    protected Persistence getPersistence() {\n+        return persistence;\n+    }\n \n-        return SourceVersion.RELEASE_6;\n+    @Override\n+    protected Class<? extends Annotation> getAnnotationClass() {\n+        return ServiceProviderFor.class;\n     }\n \n     @Override\n@@ -88,72 +84,32 @@ protected void initialize() {\n         persistence = new ServicePersistence(NAME, options.dir(), processingEnv.getFiler(), logger);\n         data = new ServiceCollector(persistence.getInitializer(), logger);\n \n-        // Initialize if possible\n-        for (String serviceName : persistence.tryFind()) {\n-            data.getService(serviceName);\n-        }\n-        data.cache();\n+        initializeIfPossible(data, persistence);\n     }\n \n-    @Override\n-    protected void writeData() {\n-        if (data.isModified()) {\n-            if (data.services().isEmpty()) {\n-                logger.note(LogLocation.LOG_FILE, \"Writing output\");\n-                try {\n-                    persistence.delete();\n-                } catch (IOException e) {\n-                    logger.warning(LogLocation.LOG_FILE, \"An error occurred while deleting data file\");\n-                }\n-            } else {\n-                logger.note(LogLocation.LOG_FILE, \"Writing output\");\n-                for (Service service : data.services()) {\n-                    try {\n-                        persistence.write(service.getName(), service.toProviderNamesList());\n-                    } catch (IOException e) {\n-                        processingEnv.getMessager().printMessage(Kind.ERROR, e.getMessage());\n-                    }\n-                }\n-                persistence.writeLog();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void removeStaleData(RoundEnvironment roundEnv) {\n-        for (Element e : roundEnv.getRootElements()) {\n-            if (e instanceof TypeElement) {\n-                TypeElement currentClass = (TypeElement) e;\n-                data.removeProvider(createProperQualifiedName(currentClass));\n-            }\n-        }\n+    protected Stream<AnnotationValue> enrich(Stream<? extends AnnotationMirror> poor) {\n+        return poor.flatMap(mirror -> findCollectionValueMember(mirror).stream());\n     }\n \n-    @Override\n-    protected void handleElement(Element e) {\n-        if (!(e instanceof TypeElement)) {\n-            return;\n-        }\n-\n-        TypeElement currentClass = (TypeElement) e;\n-\n-        CheckResult checkResult = checkCurrentClass(currentClass);\n-        if (checkResult.isError()) {\n-            reportError(currentClass, checkResult);\n-            return;\n-        }\n-\n-        for (TypeElement service : findServices(currentClass)) {\n-            CheckResult implementationResult = isImplementation(currentClass, service);\n-            if (implementationResult.isError()) {\n-                reportError(currentClass, implementationResult);\n-            } else {\n-                register(createProperQualifiedName(service), currentClass);\n-            }\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    protected Collection<AnnotationValue> findCollectionValueMember(AnnotationMirror mirror) {\n+        return\n+            mirror.getElementValues().entrySet().stream()\n+                .filter(entry -> entry.getKey().getSimpleName().contentEquals(\"value\"))\n+                .findFirst()\n+                .map(entry -> (Collection<AnnotationValue>) entry.getValue().getValue())\n+                .orElseThrow(() -> new IllegalStateException(\"No value found in element\"));\n     }\n \n-    private CheckResult checkCurrentClass(TypeElement currentClass) {\n+    /**\n+     * Check that the type element {@code currentClass} meets all the requirements that are needed to be a provider.\n+     * First of all it is a class, and it is public, not a non-static inner class, has public no-arg constructor and it\n+     * is not abstract.\n+     *\n+     * @param currentClass the class to check\n+     * @return the result, which is {@linkplain CheckResult#OK} if there is no problem.\n+     */\n+    protected CheckResult checkCurrentClass(Element currentClass) {\n         if (currentClass.getKind() != ElementKind.CLASS) {\n             return CheckResult.valueOf(\"is not a class\");\n         }\n@@ -170,22 +126,18 @@ private CheckResult checkCurrentClass(TypeElement currentClass) {\n             return CheckResult.valueOf(\"has no public no-args constructor\");\n         }\n \n-        return CheckResult.OK;\n-    }\n-\n-    private List<TypeElement> findServices(TypeElement classElement) {\n-        List<TypeElement> services = new ArrayList<TypeElement>();\n-\n-        for (AnnotationMirror annotation : findAnnotationMirrors(classElement, getAnnotationClass().getName())) {\n-            for (AnnotationValue value : findCollectionValueMember(annotation, \"value\")) {\n-                services.add(toElement(value));\n-            }\n+        if (isAbstractClass(currentClass)) {\n+            return CheckResult.valueOf(\"is abstract\");\n         }\n-\n-        return services;\n+        return CheckResult.OK;\n     }\n \n-    private void register(String serviceName, TypeElement provider) {\n-        data.getService(serviceName).addProvider(createProperQualifiedName(provider));\n+    /**\n+     * @param currentClass the class that we check for the appropriate constructor\n+     * @return {@code true} if the class has {@code public} no-arg constructor\n+     */\n+    private boolean hasPublicNoArgsConstructor(Element currentClass) {\n+        return ElementFilter.constructorsIn(currentClass.getEnclosedElements()).stream().anyMatch(\n+            constructor -> hasModifier(constructor, Modifier.PUBLIC) && constructor.getParameters().isEmpty());\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "bfa270727b8939bd5700b2018f6f4ea3aa6a02e2",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/Type.java",
    "status": "modified",
    "additions": 16,
    "deletions": 76,
    "changes": 92,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/Type.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/Type.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/Type.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -17,87 +17,27 @@\n  */\n package org.kordamp.jipsy.processor.type;\n \n-import org.kordamp.jipsy.processor.LogLocation;\n import org.kordamp.jipsy.processor.Logger;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Set;\n+import org.kordamp.jipsy.processor.Provided;\n \n /**\n+ * Textual representation of a type interface and the classes implementing it. The class maintains the name of the\n+ * service, which is the fully qualified name of the interface and the names of the classes that implement this\n+ * interface and are or should be listed in the {@code META-INF/types} resource directory.\n+ * <p>\n+ * The class is mutable and provides methods to add, remove providers to the service.\n  * @author Andres Almiray\n  */\n-public final class Type {\n-    private final Logger logger;\n-    private final String typeName;\n-    private final Set<String> providers = new LinkedHashSet<>();\n-\n+public final class Type extends Provided {\n+\n+    /**\n+     * Create a new type object.\n+     *\n+     * @param logger is the logger used to log operations\n+     * @param name   the name of the interface. It is not used in this class, except that it can be queried calling\n+     *               {@link #getName()} and it is also used in {@link #equals(Object)}.\n+     */\n     public Type(Logger logger, String name) {\n-        if (logger == null) {\n-            throw new NullPointerException(\"logger\");\n-        }\n-        if (name == null) {\n-            throw new NullPointerException(\"name\");\n-        }\n-        this.logger = logger;\n-        logger.note(LogLocation.LOG_FILE, \"Creating \" + name);\n-        this.typeName = name;\n-    }\n-\n-    public void addProvider(String provider) {\n-        if (provider == null) {\n-            throw new NullPointerException(\"provider\");\n-        }\n-        logger.note(LogLocation.LOG_FILE, \"Adding \" + provider + \" to \" + typeName);\n-        providers.add(provider);\n-    }\n-\n-    public boolean contains(String provider) {\n-        return providers.contains(provider);\n-    }\n-\n-    public boolean removeProvider(String provider) {\n-        if (providers.remove(provider)) {\n-            logger.note(LogLocation.LOG_FILE, \"Removing \" + provider + \" from \" + typeName);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    public String getName() {\n-        return typeName;\n-    }\n-\n-    public String toProviderNamesList() {\n-        StringBuilder sb = new StringBuilder();\n-        List<String> names = new ArrayList<>(providers);\n-        Collections.sort(names);\n-        for (String provider : names) {\n-            sb.append(provider).append(\"\\n\");\n-        }\n-        return sb.toString();\n-    }\n-\n-    public void fromProviderNamesList(String input) {\n-        if (input == null) {\n-            throw new NullPointerException(\"input\");\n-        }\n-        String[] lines = input.split(\"\\\\n\");\n-        for (String line : lines) {\n-            String[] content = line.split(\"#\");\n-            if (content.length > 0) {\n-                String trimmed = content[0].trim();\n-                if (trimmed.length() > 0) {\n-                    addProvider(trimmed);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return typeName + \"=\" + providers;\n+        super(logger,name);\n     }\n }"
  },
  {
    "sha": "a17b674f05f732b3e423e91722cfbeb798dd5a58",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeCollector.java",
    "status": "modified",
    "additions": 6,
    "deletions": 3,
    "changes": 9,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeCollector.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeCollector.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeCollector.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -20,6 +20,7 @@\n import org.kordamp.jipsy.processor.Initializer;\n import org.kordamp.jipsy.processor.LogLocation;\n import org.kordamp.jipsy.processor.Logger;\n+import org.kordamp.jipsy.processor.ProvidedCollector;\n \n import java.util.ArrayList;\n import java.util.Collection;\n@@ -31,7 +32,7 @@\n /**\n  * @author Andres Almiray\n  */\n-public final class TypeCollector {\n+public final class TypeCollector implements ProvidedCollector {\n     private final Map<String, Type> types = new LinkedHashMap<>();\n     private final Map<String, Type> cached = new LinkedHashMap<>();\n \n@@ -65,7 +66,8 @@ public boolean isModified() {\n         return false;\n     }\n \n-    public Type getType(String type) {\n+    @Override\n+    public Type get(String type) {\n         if (type == null) {\n             throw new NullPointerException(\"type\");\n         }\n@@ -83,7 +85,8 @@ public Type getType(String type) {\n         return types.get(type);\n     }\n \n-    public Collection<Type> types() {\n+    @Override\n+    public Collection<Type> values() {\n         return Collections.unmodifiableMap(types).values();\n     }\n "
  },
  {
    "sha": "e3d46025849ae30634c9b346c0a37b807f11aac4",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypePersistence.java",
    "status": "modified",
    "additions": 0,
    "deletions": 7,
    "changes": 7,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypePersistence.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypePersistence.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypePersistence.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -19,10 +19,8 @@\n \n import org.kordamp.jipsy.processor.AbstractResourcePersistence;\n import org.kordamp.jipsy.processor.Logger;\n-import org.kordamp.jipsy.processor.SimpleFileFilter;\n \n import javax.annotation.processing.Filer;\n-import java.io.FileFilter;\n \n /**\n  * @author Andres Almiray\n@@ -31,9 +29,4 @@\n     public TypePersistence(String name, String root, Filer filer, Logger logger) {\n         super(filer, name, logger, root + \"META-INF/types/\");\n     }\n-\n-    @Override\n-    protected FileFilter getFileFilter() {\n-        return SimpleFileFilter.INSTANCE;\n-    }\n }"
  },
  {
    "sha": "b5b7c3123efc3be912f300235ca3a0ea21bcb331",
    "filename": "jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeProviderProcessor.java",
    "status": "modified",
    "additions": 28,
    "deletions": 97,
    "changes": 125,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeProviderProcessor.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeProviderProcessor.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-processor/src/main/java/org/kordamp/jipsy/processor/type/TypeProviderProcessor.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -20,25 +20,19 @@\n import org.kordamp.jipsy.annotations.TypeProviderFor;\n import org.kordamp.jipsy.processor.AbstractSpiProcessor;\n import org.kordamp.jipsy.processor.CheckResult;\n-import org.kordamp.jipsy.processor.LogLocation;\n import org.kordamp.jipsy.processor.Options;\n import org.kordamp.jipsy.processor.Persistence;\n \n-import javax.annotation.processing.RoundEnvironment;\n import javax.annotation.processing.SupportedAnnotationTypes;\n import javax.annotation.processing.SupportedOptions;\n-import javax.lang.model.SourceVersion;\n import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n import javax.lang.model.element.Element;\n import javax.lang.model.element.ElementKind;\n import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.TypeElement;\n-import javax.tools.Diagnostic.Kind;\n-import java.io.IOException;\n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n+import java.util.Map;\n+import java.util.stream.Stream;\n \n /**\n  * @author Andres Almiray\n@@ -49,29 +43,23 @@\n     public static final String NAME = TypeProviderProcessor.class.getName()\n         + \" (\" + TypeProviderProcessor.class.getPackage().getImplementationVersion() + \")\";\n \n-    private static final int MAX_SUPPORTED_VERSION = 8;\n \n     private Persistence persistence;\n     private TypeCollector data;\n \n     @Override\n-    protected Class<? extends Annotation> getAnnotationClass() {\n-        return TypeProviderFor.class;\n+    protected Persistence getPersistence() {\n+        return persistence;\n     }\n \n     @Override\n-    public SourceVersion getSupportedSourceVersion() {\n-        SourceVersion[] svs = SourceVersion.values();\n-        for (int i = svs.length - 1; i >= 0; i--) {\n-            String name = svs[i].name();\n-            Matcher m = RELEASE_PATTERN.matcher(name);\n-            if (m.matches()) {\n-                int release = Integer.parseInt(m.group(1));\n-                if (release <= MAX_SUPPORTED_VERSION) return svs[i];\n-            }\n-        }\n+    protected TypeCollector getData() {\n+        return data;\n+    }\n \n-        return SourceVersion.RELEASE_6;\n+    @Override\n+    protected Class<? extends Annotation> getAnnotationClass() {\n+        return TypeProviderFor.class;\n     }\n \n     @Override\n@@ -81,72 +69,29 @@ protected void initialize() {\n         persistence = new TypePersistence(NAME, options.dir(), processingEnv.getFiler(), logger);\n         data = new TypeCollector(persistence.getInitializer(), logger);\n \n-        // Initialize if possible\n-        for (String typeName : persistence.tryFind()) {\n-            data.getType(typeName);\n-        }\n-        data.cache();\n+        initializeIfPossible(data, persistence);\n     }\n \n-    @Override\n-    protected void writeData() {\n-        if (data.isModified()) {\n-            if (data.types().isEmpty()) {\n-                logger.note(LogLocation.LOG_FILE, \"Writing output\");\n-                try {\n-                    persistence.delete();\n-                } catch (IOException e) {\n-                    logger.warning(LogLocation.LOG_FILE, \"An error occurred while deleting data file\");\n-                }\n-            } else {\n-                logger.note(LogLocation.LOG_FILE, \"Writing output\");\n-                for (Type type : data.types()) {\n-                    try {\n-                        persistence.write(type.getName(), type.toProviderNamesList());\n-                    } catch (IOException e) {\n-                        processingEnv.getMessager().printMessage(Kind.ERROR, e.getMessage());\n-                    }\n-                }\n-                persistence.writeLog();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void removeStaleData(RoundEnvironment roundEnv) {\n-        for (Element e : roundEnv.getRootElements()) {\n-            if (e instanceof TypeElement) {\n-                TypeElement currentClass = (TypeElement) e;\n-                data.removeProvider(createProperQualifiedName(currentClass));\n-            }\n-        }\n+    protected Stream<AnnotationValue> enrich(Stream<? extends AnnotationMirror> poor) {\n+        return poor.map(this::findSingleValueMember);\n     }\n \n-    @Override\n-    protected void handleElement(Element e) {\n-        if (!(e instanceof TypeElement)) {\n-            return;\n-        }\n-\n-        TypeElement currentClass = (TypeElement) e;\n-\n-        CheckResult checkResult = checkCurrentClass(currentClass);\n-        if (checkResult.isError()) {\n-            reportError(currentClass, checkResult);\n-            return;\n-        }\n-\n-        for (TypeElement type : findTypes(currentClass)) {\n-            CheckResult implementationResult = isImplementation(currentClass, type);\n-            if (implementationResult.isError()) {\n-                reportError(currentClass, implementationResult);\n-            } else {\n-                register(createProperQualifiedName(type), currentClass);\n-            }\n-        }\n+    private AnnotationValue findSingleValueMember(AnnotationMirror mirror) {\n+        return mirror.getElementValues().entrySet().stream()\n+            .filter(entry -> entry.getKey().getSimpleName().contentEquals(\"value\"))\n+            .findFirst()\n+            .map(Map.Entry::getValue)\n+            .orElseThrow(() -> new IllegalStateException(\"No value found in element\"));\n     }\n \n-    private CheckResult checkCurrentClass(TypeElement currentClass) {\n+    /**\n+     * Check that the type element {@code currentClass} meets all the requirements that are needed to be a provider.\n+     * First of all it is a class, and it is public, and nothing else is checked in this case.\n+     *\n+     * @param currentClass the class to check\n+     * @return the result, which is {@linkplain CheckResult#OK} if there is no problem.\n+     */\n+    protected CheckResult checkCurrentClass(Element currentClass) {\n         if (currentClass.getKind() != ElementKind.CLASS || currentClass.getKind() != ElementKind.INTERFACE) {\n             return CheckResult.valueOf(\"is not a class nor an interface\");\n         }\n@@ -157,18 +102,4 @@ private CheckResult checkCurrentClass(TypeElement currentClass) {\n \n         return CheckResult.OK;\n     }\n-\n-    private List<TypeElement> findTypes(TypeElement classElement) {\n-        List<TypeElement> types = new ArrayList<>();\n-\n-        for (AnnotationMirror annotation : findAnnotationMirrors(classElement, getAnnotationClass().getName())) {\n-            types.add(toElement(findSingleValueMember(annotation, \"value\")));\n-        }\n-\n-        return types;\n-    }\n-\n-    private void register(String typeName, TypeElement provider) {\n-        data.getType(typeName).addProvider(createProperQualifiedName(provider));\n-    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "d55642edbe042b1c3be2a3cb74ac9196ca160b1f",
    "filename": "jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/OutputDir.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/OutputDir.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/OutputDir.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/OutputDir.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -50,7 +50,7 @@ private OutputDir() {\n         String fileName = System.getProperty(\"spi.output.dir\", \"target/test-temp\");\n         File file = new File(fileName);\n         if (!file.exists()) {\n-            file.mkdir();\n+            file.mkdirs();\n             file.deleteOnExit();\n         }\n         if (file.exists() && file.isDirectory()) {"
  },
  {
    "sha": "db3ddcfaa31934426c2d2576bf184237201a531b",
    "filename": "jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestDiagnosticListener.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestDiagnosticListener.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestDiagnosticListener.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestDiagnosticListener.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -45,7 +45,7 @@\n \n public class TestDiagnosticListener implements DiagnosticListener<JavaFileObject> {\n \n-    private final List<Diagnostic<JavaFileObject>> diagnostics = new ArrayList<Diagnostic<JavaFileObject>>();\n+    private final List<Diagnostic<JavaFileObject>> diagnostics = new ArrayList<>();\n \n     @Override\n     public void report(Diagnostic<? extends JavaFileObject> diagnostic) {"
  },
  {
    "sha": "c54d7c0602404324756d8b077c4ac3ba0f5a4965",
    "filename": "jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestJavaFileObject.java",
    "status": "modified",
    "additions": 3,
    "deletions": 4,
    "changes": 7,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestJavaFileObject.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestJavaFileObject.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestJavaFileObject.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -38,7 +38,6 @@\n import javax.tools.JavaFileObject;\n import javax.tools.SimpleJavaFileObject;\n import java.io.BufferedReader;\n-import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.net.URI;\n@@ -60,7 +59,7 @@ private TestJavaFileObject(String className, CharSequence programText) {\n     }\n \n     @Override\n-    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n         return programText;\n     }\n \n@@ -77,14 +76,14 @@ public static JavaFileObject create(String className, String content) {\n     }\n \n     public static Iterable<? extends JavaFileObject> read(FileType type, String... names) throws IOException {\n-        List<JavaFileObject> result = new ArrayList<JavaFileObject>();\n+        List<JavaFileObject> result = new ArrayList<>();\n         for (String name : names) {\n             result.add(new TestJavaFileObject(name, readFile(type, name)));\n         }\n         return result;\n     }\n \n-    private static CharSequence readFile(FileType type, String name) throws FileNotFoundException, IOException {\n+    private static CharSequence readFile(FileType type, String name) throws IOException {\n         BufferedReader reader = new BufferedReader(\n             new InputStreamReader(TestJavaFileObject.class.getClassLoader().getResourceAsStream(\n                 type.getLocation() + \"/\" + name + \".java\")));"
  },
  {
    "sha": "a27454a282082e78ab4ccdd723d7b2f7e736da20",
    "filename": "jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestLogger.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestLogger.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestLogger.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestLogger.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -45,7 +45,7 @@\n \n public class TestLogger implements Logger {\n \n-    private final List<TestLogger.Record> records = new ArrayList<TestLogger.Record>();\n+    private final List<TestLogger.Record> records = new ArrayList<>();\n \n     @Override\n     public String getFileContent() {"
  },
  {
    "sha": "2aebf1f6d69db8bef013cfd903003a6dcce74f19",
    "filename": "jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestMessager.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestMessager.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestMessager.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-test-support/src/main/java/org/kordamp/jipsy/processor/testutils/TestMessager.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -45,7 +45,7 @@\n \n public class TestMessager implements Messager {\n \n-    private final List<Message> messages = new ArrayList<Message>();\n+    private final List<Message> messages = new ArrayList<>();\n \n     @Override\n     public void printMessage(Kind kind, CharSequence msg) {"
  },
  {
    "sha": "a83d99716e8f606a94a5a2f102a6d166070937a6",
    "filename": "jipsy-tests/src/test/java/org/kordamp/jipsy/processor/CollectorTest.java",
    "status": "modified",
    "additions": 41,
    "deletions": 40,
    "changes": 81,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/CollectorTest.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/CollectorTest.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/CollectorTest.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -48,6 +48,7 @@\n import java.util.HashMap;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n \n public class CollectorTest extends NoOutputTestBase {\n@@ -58,7 +59,7 @@\n \n     @Before\n     public void loadFrameWork() {\n-        HashMap<String, String> map = new HashMap<String, String>();\n+        HashMap<String, String> map = new HashMap<>();\n         map.put(\"service1\", \"provider1\\n\");\n         map.put(\"service2\", \"provider1\\nprovider2\\n\");\n         map.put(\"service3\", \"provider1\\nprovider3\\n\");\n@@ -69,88 +70,88 @@ public void loadFrameWork() {\n \n     @Test(expected = NullPointerException.class)\n     public void testGetServiceNull() {\n-        collector.getService(null);\n+        collector.get(null);\n     }\n \n     @Test\n     public void testGetServiceExisting() {\n-        assertEquals(0, collector.services().size());\n-        collector.getService(\"service\");\n-        assertEquals(1, collector.services().size());\n+        assertEquals(0, collector.values().size());\n+        collector.get(\"service\");\n+        assertEquals(1, collector.values().size());\n         logger.reset();\n-        Service service = collector.getService(\"service\");\n+        Service service = collector.get(\"service\");\n         assertTrue(logger.records().isEmpty());\n         assertEquals(\"service\", service.getName());\n-        assertEquals(1, collector.services().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetServiceNew() {\n-        assertEquals(0, collector.services().size());\n+        assertEquals(0, collector.values().size());\n         logger.reset();\n-        assertEquals(\"service\", collector.getService(\"service\").getName());\n+        assertEquals(\"service\", collector.get(\"service\").getName());\n         assertEquals(1, logger.records().size());\n-        assertEquals(1, collector.services().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetServiceNewWithInitializer() {\n-        assertEquals(0, collector.services().size());\n-        Service service = collector.getService(\"service1\");\n+        assertEquals(0, collector.values().size());\n+        Service service = collector.get(\"service1\");\n         assertEquals(\"service1\", service.getName());\n         assertTrue(service.contains(\"provider1\"));\n-        assertEquals(1, collector.services().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetServiceNewWithBiggerInitializer() {\n-        assertEquals(0, collector.services().size());\n-        Service service = collector.getService(\"service2\");\n+        assertEquals(0, collector.values().size());\n+        Service service = collector.get(\"service2\");\n         assertEquals(\"service2\", service.getName());\n         assertTrue(service.contains(\"provider1\"));\n         assertTrue(service.contains(\"provider2\"));\n-        assertEquals(1, collector.services().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetServiceNewWithInitializerContainingRemovedElement() {\n-        assertEquals(0, collector.services().size());\n+        assertEquals(0, collector.values().size());\n         collector.removeProvider(\"provider1\");\n-        Service service = collector.getService(\"service1\");\n+        Service service = collector.get(\"service1\");\n         Assert.assertFalse(service.contains(\"provider1\"));\n-        assertEquals(1, collector.services().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testServicesEmpty() {\n-        Collection<Service> services = collector.services();\n+        Collection<Service> services = collector.values();\n         assertEquals(0, services.size());\n     }\n \n     @Test\n     public void testServicesOne() {\n-        Service service = collector.getService(\"service\");\n-        Collection<Service> services = collector.services();\n+        Service service = collector.get(\"service\");\n+        Collection<Service> services = collector.values();\n         assertEquals(1, services.size());\n         assertTrue(services.contains(service));\n     }\n \n     @Test\n     public void testServicesMore() {\n-        Service service1 = collector.getService(\"service1\");\n-        Service service2 = collector.getService(\"service2\");\n-        Collection<Service> services = collector.services();\n+        Service service1 = collector.get(\"service1\");\n+        Service service2 = collector.get(\"service2\");\n+        Collection<Service> services = collector.values();\n         assertEquals(2, services.size());\n         assertTrue(services.contains(service1));\n         assertTrue(services.contains(service2));\n     }\n \n     @Test\n     public void testServicesDuplicate() {\n-        Service service1 = collector.getService(\"service1\");\n-        Service service2 = collector.getService(\"service1\");\n-        assertTrue(service1 == service2);\n-        Collection<Service> services = collector.services();\n+        Service service1 = collector.get(\"service1\");\n+        Service service2 = collector.get(\"service1\");\n+        assertSame(service1, service2);\n+        Collection<Service> services = collector.values();\n         assertEquals(1, services.size());\n         assertTrue(services.contains(service1));\n     }\n@@ -169,34 +170,34 @@ public void testRemoveProviderWhenEmpty() {\n \n     @Test\n     public void testRemoveProviderWhenInNotOneService() {\n-        collector.getService(\"service1\");\n+        collector.get(\"service1\");\n         logger.reset();\n         collector.removeProvider(\"provider2\");\n         assertEquals(1, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInOneService() {\n-        collector.getService(\"service1\");\n+        collector.get(\"service1\");\n         logger.reset();\n         collector.removeProvider(\"provider1\");\n         assertEquals(2, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInTwoServices() {\n-        collector.getService(\"service1\");\n-        collector.getService(\"service2\");\n+        collector.get(\"service1\");\n+        collector.get(\"service2\");\n         logger.reset();\n         collector.removeProvider(\"provider1\");\n         assertEquals(3, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInSomeServices() {\n-        collector.getService(\"service1\");\n-        collector.getService(\"service2\");\n-        collector.getService(\"service3\");\n+        collector.get(\"service1\");\n+        collector.get(\"service2\");\n+        collector.get(\"service3\");\n         logger.reset();\n         collector.removeProvider(\"provider2\");\n         assertEquals(2, logger.records().size());\n@@ -209,20 +210,20 @@ public void testToStringEmpty() {\n \n     @Test\n     public void testToStringNonExistingService() {\n-        collector.getService(\"nonExistingService\");\n+        collector.get(\"nonExistingService\");\n         collector.toString();\n     }\n \n     @Test\n     public void testToStringExistingService() {\n-        collector.getService(\"service1\");\n+        collector.get(\"service1\");\n         collector.toString();\n     }\n \n     @Test\n     public void testToStringMoreExistingServices() {\n-        collector.getService(\"service1\");\n-        collector.getService(\"service2\");\n+        collector.get(\"service1\");\n+        collector.get(\"service2\");\n         collector.toString();\n     }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "fe8743f9b121eface07f5a2794edb67357be32b0",
    "filename": "jipsy-tests/src/test/java/org/kordamp/jipsy/processor/OptionsTest.java",
    "status": "modified",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/OptionsTest.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/OptionsTest.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/OptionsTest.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -54,7 +54,7 @@\n \n public class OptionsTest extends NoOutputTestBase {\n \n-    private JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+    private final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n \n     @Test\n     public void testDisabledDefault() {\n@@ -201,7 +201,7 @@ private void appendValue(StringBuilder message, String name, String value) {\n     }\n \n     private Options getOptions(String... parameters) {\n-        List<String> compilerOptions = new ArrayList<String>();\n+        List<String> compilerOptions = new ArrayList<>();\n         compilerOptions.addAll(Arrays.asList(parameters));\n         compilerOptions.addAll(OutputDir.getOptions());\n         CompilationTask task = compiler.getTask(null, null, null, compilerOptions, null, TestJavaFileObject.ONLY_HELLO_WORLD);"
  },
  {
    "sha": "d7d4be69ca82c858a1b00c01e354165ad9b311ef",
    "filename": "jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ProcessorLoggerTest.java",
    "status": "modified",
    "additions": 6,
    "deletions": 6,
    "changes": 12,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ProcessorLoggerTest.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ProcessorLoggerTest.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ProcessorLoggerTest.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -51,14 +51,14 @@\n     private static final String TEST_MESSAGE = \"%%test message%%\";\n \n     private final TestMessager messager = new TestMessager();\n-    private final Options optionsVerbose = new Options(null, Collections.singletonMap(Options.SPI_VERBOSE_OPTION, (String) null));\n-    private final Options optionsLog = new Options(null, Collections.singletonMap(Options.SPI_LOG_OPTION, (String) null));\n+    private final Options optionsVerbose = new Options(null, Collections.singletonMap(Options.SPI_VERBOSE_OPTION, null));\n+    private final Options optionsLog = new Options(null, Collections.singletonMap(Options.SPI_LOG_OPTION, null));\n     private final Options options = new Options(null, new HashMap<String, String>() {\n         private static final long serialVersionUID = 1L;\n \n         {\n-            put(Options.SPI_LOG_OPTION, (String) null);\n-            put(Options.SPI_VERBOSE_OPTION, (String) null);\n+            put(Options.SPI_LOG_OPTION, null);\n+            put(Options.SPI_VERBOSE_OPTION, null);\n         }\n     });\n \n@@ -84,7 +84,7 @@ public void testProcessLoggerOptionsNoWarnings() {\n \n     @Test\n     public void testProcessLoggerOptionsWithWarnings() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        Map<String, String> map = new HashMap<>();\n         map.put(Options.SPI_LOG_OPTION, \"true\");\n         map.put(Options.SPI_VERBOSE_OPTION, \"true\");\n         map.put(Options.SPI_DISABLED_OPTION, \"yes\");\n@@ -93,7 +93,7 @@ public void testProcessLoggerOptionsWithWarnings() {\n         ProcessorLogger logger = new ProcessorLogger(messager, o);\n \n         List<Message> messages = messager.messages();\n-        List<String> warnings = new ArrayList<String>(o.getWarnings());\n+        List<String> warnings = new ArrayList<>(o.getWarnings());\n         assertEquals(o.report(), messages.get(0).msg);\n         assertEquals(warnings.size() + 1, messages.size());\n "
  },
  {
    "sha": "b25aed858b08fc9621a02f37b31b5da45330af68",
    "filename": "jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ServiceTest.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ServiceTest.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ServiceTest.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/ServiceTest.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -46,7 +46,7 @@\n \n public class ServiceTest extends NoOutputTestBase {\n \n-    TestLogger logger = new TestLogger();\n+    final TestLogger logger = new TestLogger();\n \n     @Test(expected = NullPointerException.class)\n     public void testConstructorLoggerNull() {"
  },
  {
    "sha": "20c12d0c6a125d1c85fb9bbb875b314123a5d3d0",
    "filename": "jipsy-tests/src/test/java/org/kordamp/jipsy/processor/type/TypeCollectorTest.java",
    "status": "modified",
    "additions": 41,
    "deletions": 40,
    "changes": 81,
    "blob_url": "https://github.com/kordamp/jipsy/blob/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/type/TypeCollectorTest.java",
    "raw_url": "https://github.com/kordamp/jipsy/raw/0c49626a487020df60902bba62b7892c0cbc92b2/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/type/TypeCollectorTest.java",
    "contents_url": "https://api.github.com/repos/kordamp/jipsy/contents/jipsy-tests/src/test/java/org/kordamp/jipsy/processor/type/TypeCollectorTest.java?ref=0c49626a487020df60902bba62b7892c0cbc92b2",
    "patch": "@@ -28,6 +28,7 @@\n import java.util.HashMap;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n import static org.junit.Assert.assertTrue;\n \n public class TypeCollectorTest extends NoOutputTestBase {\n@@ -36,7 +37,7 @@\n \n     @Before\n     public void loadFrameWork() {\n-        HashMap<String, String> map = new HashMap<String, String>();\n+        HashMap<String, String> map = new HashMap<>();\n         map.put(\"type1\", \"provider1\\n\");\n         map.put(\"type2\", \"provider1\\nprovider2\\n\");\n         map.put(\"type3\", \"provider1\\nprovider3\\n\");\n@@ -47,88 +48,88 @@ public void loadFrameWork() {\n \n     @Test(expected = NullPointerException.class)\n     public void testGetTypeNull() {\n-        collector.getType(null);\n+        collector.get(null);\n     }\n \n     @Test\n     public void testGetTypeExisting() {\n-        assertEquals(0, collector.types().size());\n-        collector.getType(\"type\");\n-        assertEquals(1, collector.types().size());\n+        assertEquals(0, collector.values().size());\n+        collector.get(\"type\");\n+        assertEquals(1, collector.values().size());\n         logger.reset();\n-        Type type = collector.getType(\"type\");\n+        Type type = collector.get(\"type\");\n         assertTrue(logger.records().isEmpty());\n         assertEquals(\"type\", type.getName());\n-        assertEquals(1, collector.types().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetTypeNew() {\n-        assertEquals(0, collector.types().size());\n+        assertEquals(0, collector.values().size());\n         logger.reset();\n-        assertEquals(\"type\", collector.getType(\"type\").getName());\n+        assertEquals(\"type\", collector.get(\"type\").getName());\n         assertEquals(1, logger.records().size());\n-        assertEquals(1, collector.types().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetTypeNewWithInitializer() {\n-        assertEquals(0, collector.types().size());\n-        Type type = collector.getType(\"type1\");\n+        assertEquals(0, collector.values().size());\n+        Type type = collector.get(\"type1\");\n         assertEquals(\"type1\", type.getName());\n         assertTrue(type.contains(\"provider1\"));\n-        assertEquals(1, collector.types().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetTypeNewWithBiggerInitializer() {\n-        assertEquals(0, collector.types().size());\n-        Type type = collector.getType(\"type2\");\n+        assertEquals(0, collector.values().size());\n+        Type type = collector.get(\"type2\");\n         assertEquals(\"type2\", type.getName());\n         assertTrue(type.contains(\"provider1\"));\n         assertTrue(type.contains(\"provider2\"));\n-        assertEquals(1, collector.types().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testGetTypeNewWithInitializerContainingRemovedElement() {\n-        assertEquals(0, collector.types().size());\n+        assertEquals(0, collector.values().size());\n         collector.removeProvider(\"provider1\");\n-        Type type = collector.getType(\"type1\");\n+        Type type = collector.get(\"type1\");\n         Assert.assertFalse(type.contains(\"provider1\"));\n-        assertEquals(1, collector.types().size());\n+        assertEquals(1, collector.values().size());\n     }\n \n     @Test\n     public void testTypesEmpty() {\n-        Collection<Type> types = collector.types();\n+        Collection<Type> types = collector.values();\n         assertEquals(0, types.size());\n     }\n \n     @Test\n     public void testTypesOne() {\n-        Type type = collector.getType(\"type\");\n-        Collection<Type> types = collector.types();\n+        Type type = collector.get(\"type\");\n+        Collection<Type> types = collector.values();\n         assertEquals(1, types.size());\n         assertTrue(types.contains(type));\n     }\n \n     @Test\n     public void testTypesMore() {\n-        Type type1 = collector.getType(\"type1\");\n-        Type type2 = collector.getType(\"type2\");\n-        Collection<Type> types = collector.types();\n+        Type type1 = collector.get(\"type1\");\n+        Type type2 = collector.get(\"type2\");\n+        Collection<Type> types = collector.values();\n         assertEquals(2, types.size());\n         assertTrue(types.contains(type1));\n         assertTrue(types.contains(type2));\n     }\n \n     @Test\n     public void testTypesDuplicate() {\n-        Type type1 = collector.getType(\"type1\");\n-        Type type2 = collector.getType(\"type1\");\n-        assertTrue(type1 == type2);\n-        Collection<Type> types = collector.types();\n+        Type type1 = collector.get(\"type1\");\n+        Type type2 = collector.get(\"type1\");\n+        assertSame(type1, type2);\n+        Collection<Type> types = collector.values();\n         assertEquals(1, types.size());\n         assertTrue(types.contains(type1));\n     }\n@@ -147,34 +148,34 @@ public void testRemoveProviderWhenEmpty() {\n \n     @Test\n     public void testRemoveProviderWhenInNotOneType() {\n-        collector.getType(\"type1\");\n+        collector.get(\"type1\");\n         logger.reset();\n         collector.removeProvider(\"provider2\");\n         assertEquals(1, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInOneType() {\n-        collector.getType(\"type1\");\n+        collector.get(\"type1\");\n         logger.reset();\n         collector.removeProvider(\"provider1\");\n         assertEquals(2, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInTwoTypes() {\n-        collector.getType(\"type1\");\n-        collector.getType(\"type2\");\n+        collector.get(\"type1\");\n+        collector.get(\"type2\");\n         logger.reset();\n         collector.removeProvider(\"provider1\");\n         assertEquals(3, logger.records().size());\n     }\n \n     @Test\n     public void testRemoveProviderWhenInSomeTypes() {\n-        collector.getType(\"type1\");\n-        collector.getType(\"type2\");\n-        collector.getType(\"type3\");\n+        collector.get(\"type1\");\n+        collector.get(\"type2\");\n+        collector.get(\"type3\");\n         logger.reset();\n         collector.removeProvider(\"provider2\");\n         assertEquals(2, logger.records().size());\n@@ -187,20 +188,20 @@ public void testToStringEmpty() {\n \n     @Test\n     public void testToStringNonExistingType() {\n-        collector.getType(\"nonExistingType\");\n+        collector.get(\"nonExistingType\");\n         collector.toString();\n     }\n \n     @Test\n     public void testToStringExistingType() {\n-        collector.getType(\"type1\");\n+        collector.get(\"type1\");\n         collector.toString();\n     }\n \n     @Test\n     public void testToStringMoreExistingTypes() {\n-        collector.getType(\"type1\");\n-        collector.getType(\"type2\");\n+        collector.get(\"type1\");\n+        collector.get(\"type2\");\n         collector.toString();\n     }\n }\n\\ No newline at end of file"
  }
]
