[
  {
    "sha": "2e3cdc13aae010b077cab2861807c76fafbb233d",
    "filename": "src/qp/operators/BlockNestedJoin.java",
    "status": "renamed",
    "additions": 41,
    "deletions": 25,
    "changes": 66,
    "blob_url": "https://github.com/hcwong/cs3223/blob/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/operators/BlockNestedJoin.java",
    "raw_url": "https://github.com/hcwong/cs3223/raw/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/operators/BlockNestedJoin.java",
    "contents_url": "https://api.github.com/repos/hcwong/cs3223/contents/src/qp/operators/BlockNestedJoin.java?ref=3a7ebd079cbf07d26179816f4352f3d0b01d9d8f",
    "patch": "@@ -1,5 +1,5 @@\n /**\n- * Page Nested Join algorithm\n+ * Block Nested Join algorithm\n  **/\n \n package qp.operators;\n@@ -12,15 +12,15 @@\n import java.io.*;\n import java.util.ArrayList;\n \n-public class NestedJoin extends Join {\n+public class BlockNestedJoin extends Join {\n \n     static int filenum = 0;         // To get unique filenum for this operation\n     int batchsize;                  // Number of tuples per out batch\n     ArrayList<Integer> leftindex;   // Indices of the join attributes in left table\n     ArrayList<Integer> rightindex;  // Indices of the join attributes in right table\n     String rfname;                  // The file name where the right table is materialized\n     Batch outbatch;                 // Buffer page for output\n-    Batch leftbatch;                // Buffer page for left input stream\n+    Batch[] leftbatches;                // Buffer page for left input stream\n     Batch rightbatch;               // Buffer page for right input stream\n     ObjectInputStream in;           // File pointer to the right hand materialized file\n \n@@ -29,7 +29,7 @@\n     boolean eosl;                   // Whether end of stream (left table) is reached\n     boolean eosr;                   // Whether end of stream (right table) is reached\n \n-    public NestedJoin(Join jn) {\n+    public BlockNestedJoin(Join jn) {\n         super(jn.getLeft(), jn.getRight(), jn.getConditionList(), jn.getOpType());\n         schema = jn.getSchema();\n         jointype = jn.getJoinType();\n@@ -67,7 +67,7 @@ public boolean open() {\n         eosr = true;\n \n         /** Right hand side table is to be materialized\n-         ** for the Nested join to perform\n+         ** for the Block Nested join to perform\n          **/\n         if (!right.open()) {\n             return false;\n@@ -77,24 +77,21 @@ public boolean open() {\n              ** into a file\n              **/\n             filenum++;\n-            rfname = \"NJtemp-\" + String.valueOf(filenum);\n+            rfname = \"NJtemp-\" + filenum;\n             try {\n                 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(rfname));\n                 while ((rightpage = right.next()) != null) {\n                     out.writeObject(rightpage);\n                 }\n                 out.close();\n             } catch (IOException io) {\n-                System.out.println(\"NestedJoin: Error writing to temporary file\");\n+                System.out.println(\"BlockNestedJoin: Error writing to temporary file\");\n                 return false;\n             }\n             if (!right.close())\n                 return false;\n         }\n-        if (left.open())\n-            return true;\n-        else\n-            return false;\n+        return left.open();\n     }\n \n     /**\n@@ -108,45 +105,64 @@ public Batch next() {\n         }\n         outbatch = new Batch(batchsize);\n         while (!outbatch.isFull()) {\n-            if (lcurs == 0 && eosr == true) {\n+            if (lcurs == 0 && eosr) {\n                 /** new left page is to be fetched**/\n-                leftbatch = (Batch) left.next();\n-                if (leftbatch == null) {\n+                leftbatches = new Batch[numBuff - 2];\n+                leftbatches[0] = left.next();\n+                if (leftbatches[0] == null) {\n                     eosl = true;\n                     return outbatch;\n                 }\n+                for (i = 1; i < leftbatches.length; i++) {\n+                    leftbatches[i] = left.next();\n+                    if (leftbatches[i] == null) {\n+                        break;\n+                    }\n+                }\n                 /** Whenever a new left page came, we have to start the\n                  ** scanning of right table\n                  **/\n                 try {\n                     in = new ObjectInputStream(new FileInputStream(rfname));\n                     eosr = false;\n                 } catch (IOException io) {\n-                    System.err.println(\"NestedJoin:error in reading the file\");\n+                    System.err.println(\"BlockNestedJoin:error in reading the file\");\n                     System.exit(1);\n                 }\n \n             }\n-            while (eosr == false) {\n+            int leftTupleSize = 0;\n+            for (Batch leftBatch : leftbatches) {\n+                if (leftBatch == null) {\n+                    break;\n+                }\n+                leftTupleSize += leftBatch.size();\n+            }\n+            while (!eosr) {\n                 try {\n                     if (rcurs == 0 && lcurs == 0) {\n                         rightbatch = (Batch) in.readObject();\n                     }\n-                    for (i = lcurs; i < leftbatch.size(); ++i) {\n+                    for (i = lcurs; i < leftTupleSize; ++i) {\n+                        int leftBatchIndex = i / leftbatches[0].size();\n+                        int leftTupleIndex = i % leftbatches[0].size();\n+                        Tuple lefttuple = leftbatches[leftBatchIndex].get(leftTupleIndex);\n+\n                         for (j = rcurs; j < rightbatch.size(); ++j) {\n-                            Tuple lefttuple = leftbatch.get(i);\n                             Tuple righttuple = rightbatch.get(j);\n-                            if (lefttuple.checkJoin(righttuple, leftindex, rightindex)) {\n+\n+                            if (lefttuple.checkJoin(righttuple, leftindex, rightindex, conditionList)) {\n                                 Tuple outtuple = lefttuple.joinWith(righttuple);\n                                 outbatch.add(outtuple);\n+\n                                 if (outbatch.isFull()) {\n-                                    if (i == leftbatch.size() - 1 && j == rightbatch.size() - 1) {  //case 1\n+                                    if (i == leftTupleSize - 1 && j == rightbatch.size() - 1) {  //case 1\n                                         lcurs = 0;\n                                         rcurs = 0;\n-                                    } else if (i != leftbatch.size() - 1 && j == rightbatch.size() - 1) {  //case 2\n+                                    } else if (i != leftTupleSize - 1 && j == rightbatch.size() - 1) {  //case 2\n                                         lcurs = i + 1;\n                                         rcurs = 0;\n-                                    } else if (i == leftbatch.size() - 1 && j != rightbatch.size() - 1) {  //case 3\n+                                    } else if (i == leftTupleSize - 1 && j != rightbatch.size() - 1) {  //case 3\n                                         lcurs = i;\n                                         rcurs = j + 1;\n                                     } else {\n@@ -164,14 +180,14 @@ public Batch next() {\n                     try {\n                         in.close();\n                     } catch (IOException io) {\n-                        System.out.println(\"NestedJoin: Error in reading temporary file\");\n+                        System.out.println(\"BlockNestedJoin: Error in reading temporary file\");\n                     }\n                     eosr = true;\n                 } catch (ClassNotFoundException c) {\n-                    System.out.println(\"NestedJoin: Error in deserialising temporary file \");\n+                    System.out.println(\"BlockNestedJoin: Error in deserialising temporary file \");\n                     System.exit(1);\n                 } catch (IOException io) {\n-                    System.out.println(\"NestedJoin: Error in reading temporary file\");\n+                    System.out.println(\"BlockNestedJoin: Error in reading temporary file\");\n                     System.exit(1);\n                 }\n             }",
    "previous_filename": "src/qp/operators/NestedJoin.java"
  },
  {
    "sha": "b3da3d677d21a9bf208198905161ee1357a83f88",
    "filename": "src/qp/operators/Scan.java",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/hcwong/cs3223/blob/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/operators/Scan.java",
    "raw_url": "https://github.com/hcwong/cs3223/raw/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/operators/Scan.java",
    "contents_url": "https://api.github.com/repos/hcwong/cs3223/contents/src/qp/operators/Scan.java?ref=3a7ebd079cbf07d26179816f4352f3d0b01d9d8f",
    "patch": "@@ -48,6 +48,7 @@ public boolean open() {\n         try {\n             in = new ObjectInputStream(new FileInputStream(filename));\n         } catch (Exception e) {\n+            e.printStackTrace();\n             System.err.println(\" Error reading \" + filename);\n             return false;\n         }\n@@ -78,6 +79,7 @@ public Batch next() {\n                 eos = true;\n                 return tuples;\n             } catch (IOException e) {\n+                e.printStackTrace();\n                 System.err.println(\"Scan:Error reading \" + filename);\n                 System.exit(1);\n             }"
  },
  {
    "sha": "7ccc0ffd9b9b740b5c7880721936a90e6be07f0a",
    "filename": "src/qp/optimizer/RandomOptimizer.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/hcwong/cs3223/blob/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/optimizer/RandomOptimizer.java",
    "raw_url": "https://github.com/hcwong/cs3223/raw/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/optimizer/RandomOptimizer.java",
    "contents_url": "https://api.github.com/repos/hcwong/cs3223/contents/src/qp/optimizer/RandomOptimizer.java?ref=3a7ebd079cbf07d26179816f4352f3d0b01d9d8f",
    "patch": "@@ -50,7 +50,7 @@ public static Operator makeExecPlan(Operator node) {\n             int numbuff = BufferManager.getBuffersPerJoin();\n             switch (joinType) {\n                 case JoinType.NESTEDJOIN:\n-                    NestedJoin nj = new NestedJoin((Join) node);\n+                    BlockNestedJoin nj = new BlockNestedJoin((Join) node);\n                     nj.setLeft(left);\n                     nj.setRight(right);\n                     nj.setNumBuff(numbuff);"
  },
  {
    "sha": "75578f14bbe39c3044aa6b5f485ac3cf3cc7deeb",
    "filename": "src/qp/utils/Tuple.java",
    "status": "modified",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/hcwong/cs3223/blob/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/utils/Tuple.java",
    "raw_url": "https://github.com/hcwong/cs3223/raw/3a7ebd079cbf07d26179816f4352f3d0b01d9d8f/src/qp/utils/Tuple.java",
    "contents_url": "https://api.github.com/repos/hcwong/cs3223/contents/src/qp/utils/Tuple.java?ref=3a7ebd079cbf07d26179816f4352f3d0b01d9d8f",
    "patch": "@@ -60,6 +60,57 @@ public boolean checkJoin(Tuple right, ArrayList<Integer> leftindex, ArrayList<In\n         return true;\n     }\n \n+    public boolean checkJoin(Tuple right,\n+                             ArrayList<Integer> leftindex,\n+                             ArrayList<Integer> rightindex,\n+                             ArrayList<Condition> conditions\n+    ) {\n+        if (leftindex.size() != rightindex.size())\n+            return false;\n+        for (int i = 0; i < leftindex.size(); ++i) {\n+            Object leftData = dataAt(leftindex.get(i));\n+            Object rightData = right.dataAt(rightindex.get(i));\n+            Condition cond = conditions.get(i);\n+\n+            switch(cond.getExprType()) {\n+            case Condition.LESSTHAN:\n+                if (compareTuples(this, right, i, i) >= 0) {\n+                    return false;\n+                }\n+                break;\n+            case Condition.GREATERTHAN:\n+                if (compareTuples(this, right, i, i) <= 0) {\n+                    return false;\n+                }\n+                break;\n+            case Condition.LTOE:\n+                if (compareTuples(this, right, i, i) > 0) {\n+                    return false;\n+                }\n+                break;\n+            case Condition.GTOE:\n+                if (compareTuples(this, right, i, i) < 0) {\n+                    return false;\n+                }\n+                break;\n+            case Condition.EQUAL:\n+                if (!leftData.equals(rightData)) {\n+                    return false;\n+                }\n+                break;\n+            case Condition.NOTEQUAL:\n+                if (leftData.equals(rightData)) {\n+                    return false;\n+                }\n+                break;\n+            default:\n+                System.out.println(\"Nested Loop: Switch statement cannot recognise case\");\n+                System.exit(1);\n+            }\n+        }\n+        return true;\n+    }\n+\n     /**\n      * Joining two tuples without duplicate column elimination\n      **/"
  }
]
