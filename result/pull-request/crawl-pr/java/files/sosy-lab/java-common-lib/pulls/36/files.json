[
  {
    "sha": "9372276b5a195333ac23625e6df8b93e0ef1995c",
    "filename": "src/org/sosy_lab/common/collect/PathCopyingPersistentTreeMap.java",
    "status": "modified",
    "additions": 85,
    "deletions": 29,
    "changes": 114,
    "blob_url": "https://github.com/sosy-lab/java-common-lib/blob/9e2bd175b3cf0907b6ab05815a500d8eadc5884d/src/org/sosy_lab/common/collect/PathCopyingPersistentTreeMap.java",
    "raw_url": "https://github.com/sosy-lab/java-common-lib/raw/9e2bd175b3cf0907b6ab05815a500d8eadc5884d/src/org/sosy_lab/common/collect/PathCopyingPersistentTreeMap.java",
    "contents_url": "https://api.github.com/repos/sosy-lab/java-common-lib/contents/src/org/sosy_lab/common/collect/PathCopyingPersistentTreeMap.java?ref=9e2bd175b3cf0907b6ab05815a500d8eadc5884d",
    "patch": "@@ -73,7 +73,7 @@\n public final class PathCopyingPersistentTreeMap<K extends Comparable<? super K>, V>\n     extends AbstractImmutableSortedMap<K, V> implements PersistentSortedMap<K, V>, Serializable {\n \n-  private static final long serialVersionUID = 1041711151457528188L;\n+  private static final long serialVersionUID = -5708332286565509457L;\n \n   @SuppressWarnings(\"unused\")\n   @SuppressFBWarnings(\n@@ -160,10 +160,40 @@ static int countNodes(@Nullable Node<?, ?> n) {\n     }\n   }\n \n+  @Immutable(containerOf = {\"K\", \"V\"})\n+  private static final class ContainerOfNodeWithDiffs<K, V> {\n+    private final Node<K, V> node;\n+    private final int sizeDiff;\n+    private final int hashDiff;\n+\n+    private ContainerOfNodeWithDiffs(Node<K, V> node, int sizeDiff, int hashDiff) {\n+      this.node = node;\n+      this.sizeDiff = sizeDiff;\n+      this.hashDiff = hashDiff;\n+    }\n+\n+    static <V, K extends Comparable<? super K>> ContainerOfNodeWithDiffs<K, V> of(\n+        Node<K, V> node, int sizeDiff, int hashDiff) {\n+      return new ContainerOfNodeWithDiffs<>(node, sizeDiff, hashDiff);\n+    }\n+\n+    Node<K, V> getNode() {\n+      return node;\n+    }\n+\n+    int getSizeDiff() {\n+      return sizeDiff;\n+    }\n+\n+    int getHashDiff() {\n+      return hashDiff;\n+    }\n+  }\n+\n   // static creation methods\n \n   private static final PathCopyingPersistentTreeMap<?, ?> EMPTY_MAP =\n-      new PathCopyingPersistentTreeMap<String, Object>(null);\n+      new PathCopyingPersistentTreeMap<String, Object>(null, 0, 0);\n \n   @SuppressWarnings(\"unchecked\")\n   public static <K extends Comparable<? super K>, V> PersistentSortedMap<K, V> of() {\n@@ -232,10 +262,13 @@ static int countNodes(@Nullable Node<?, ?> n) {\n   @LazyInit\n   private transient @Nullable NavigableSet<Entry<K, V>> entrySet;\n \n-  @LazyInit private transient int size;\n+  private final int size;\n+  private final int hashCode;\n \n-  private PathCopyingPersistentTreeMap(@Nullable Node<K, V> pRoot) {\n+  private PathCopyingPersistentTreeMap(@Nullable Node<K, V> pRoot, int pSize, int pHashCode) {\n     root = pRoot;\n+    size = pSize;\n+    hashCode = pHashCode;\n   }\n \n   // private utility methods\n@@ -508,54 +541,70 @@ void checkAssertions() {\n   /**\n    * Create a map instance with a given root node.\n    *\n-   * @param newRoot A node or null (meaning the empty tree).\n+   * @param pRoot Container of a node or null (meaning the empty tree) with size and hash changes.\n    * @return A map instance with the given tree.\n    */\n   @SuppressWarnings(\"ReferenceEquality\") // cannot use equals() for check whether tree is the same\n-  private PersistentSortedMap<K, V> mapFromTree(@Var Node<K, V> newRoot) {\n+  private PersistentSortedMap<K, V> mapFromTree(ContainerOfNodeWithDiffs<K, V> pRoot) {\n+    @Var Node<K, V> newRoot = pRoot.getNode();\n     if (newRoot == root) {\n       return this;\n     } else if (newRoot == null) {\n       return of();\n     } else {\n       // Root is always black.\n       newRoot = newRoot.withColor(Node.BLACK);\n-      return new PathCopyingPersistentTreeMap<>(newRoot);\n+      return new PathCopyingPersistentTreeMap<>(\n+          newRoot, size + pRoot.getSizeDiff(), hashCode + pRoot.getHashDiff());\n     }\n   }\n \n   @Override\n   public PersistentSortedMap<K, V> putAndCopy(K key, V value) {\n-    return mapFromTree(putAndCopy0(checkNotNull(key), value, root));\n+    return mapFromTree(putAndCopy0(checkNotNull(key), value, root, 0, 0));\n   }\n \n-  private static <K extends Comparable<? super K>, V> Node<K, V> putAndCopy0(\n-      K key, V value, @Var Node<K, V> current) {\n+  private static <K extends Comparable<? super K>, V> ContainerOfNodeWithDiffs<K, V> putAndCopy0(\n+      K key, V value, @Var Node<K, V> current, @Var int sizeDiff, @Var int hashDiff) {\n     // Inserting is easy:\n     // We find the place where to insert,\n     // and afterwards fix the invariants by some rotations or re-colorings.\n \n     if (current == null) {\n-      return new Node<>(key, value);\n+      Node<K, V> node = new Node<>(key, value);\n+      sizeDiff = sizeDiff + 1;\n+      hashDiff = hashDiff + node.hashCode();\n+      return ContainerOfNodeWithDiffs.of(node, sizeDiff, hashDiff);\n     }\n \n     int comp = key.compareTo(current.getKey());\n     if (comp < 0) {\n       // key < current.data\n-      Node<K, V> newLeft = putAndCopy0(key, value, current.left);\n+      ContainerOfNodeWithDiffs<K, V> containerOfNodeWithDiffs =\n+          putAndCopy0(key, value, current.left, sizeDiff, hashDiff);\n+      sizeDiff = containerOfNodeWithDiffs.getSizeDiff();\n+      hashDiff = containerOfNodeWithDiffs.getHashDiff();\n+      Node<K, V> newLeft = containerOfNodeWithDiffs.getNode();\n       current = current.withLeftChild(newLeft);\n \n     } else if (comp > 0) {\n       // key > current.data\n-      Node<K, V> newRight = putAndCopy0(key, value, current.right);\n+      ContainerOfNodeWithDiffs<K, V> containerOfNodeWithDiffs =\n+          putAndCopy0(key, value, current.right, sizeDiff, hashDiff);\n+      sizeDiff = containerOfNodeWithDiffs.getSizeDiff();\n+      hashDiff = containerOfNodeWithDiffs.getHashDiff();\n+      Node<K, V> newRight = containerOfNodeWithDiffs.getNode();\n       current = current.withRightChild(newRight);\n \n     } else {\n+      // replace current node with a new one\n+      hashDiff = hashDiff - current.hashCode();\n       current = new Node<>(key, value, current.left, current.right, current.getColor());\n+      hashDiff = hashDiff + current.hashCode();\n     }\n \n     // restore invariants\n-    return restoreInvariants(current);\n+    return ContainerOfNodeWithDiffs.of(restoreInvariants(current), sizeDiff, hashDiff);\n   }\n \n   @SuppressWarnings(\"unchecked\")\n@@ -564,12 +613,12 @@ void checkAssertions() {\n     if (isEmpty()) {\n       return this;\n     }\n-    return mapFromTree(removeAndCopy0((K) checkNotNull(key), root));\n+    return mapFromTree(removeAndCopy0((K) checkNotNull(key), root, 0, 0));\n   }\n \n   @Nullable\n-  private static <K extends Comparable<? super K>, V> Node<K, V> removeAndCopy0(\n-      K key, @Var Node<K, V> current) {\n+  private static <K extends Comparable<? super K>, V> ContainerOfNodeWithDiffs<K, V> removeAndCopy0(\n+      K key, @Var Node<K, V> current, @Var int sizeDiff, @Var int hashDiff) {\n     // Removing a node is more difficult.\n     // We can remove a leaf if it is red.\n     // So we try to always have a red node while going downwards.\n@@ -588,7 +637,7 @@ void checkAssertions() {\n       // key < current.data\n       if (current.left == null) {\n         // Target key is not in map.\n-        return current;\n+        return ContainerOfNodeWithDiffs.of(current, sizeDiff, hashDiff);\n       }\n \n       // Go down leftwards, keeping a red node.\n@@ -599,14 +648,18 @@ void checkAssertions() {\n       }\n \n       // recursive descent\n-      Node<K, V> newLeft = removeAndCopy0(key, current.left);\n+      ContainerOfNodeWithDiffs<K, V> containerOfNodeWithDiffs =\n+          removeAndCopy0(key, current.left, sizeDiff, hashDiff);\n+      sizeDiff = containerOfNodeWithDiffs.getSizeDiff();\n+      hashDiff = containerOfNodeWithDiffs.getHashDiff();\n+      Node<K, V> newLeft = containerOfNodeWithDiffs.getNode();\n       current = current.withLeftChild(newLeft);\n \n     } else {\n       // key >= current.data\n       if ((comp > 0) && (current.right == null)) {\n         // Target key is not in map.\n-        return current;\n+        return ContainerOfNodeWithDiffs.of(current, sizeDiff, hashDiff);\n       }\n \n       if (Node.isRed(current.left)) {\n@@ -621,7 +674,9 @@ void checkAssertions() {\n       if ((comp == 0) && (current.right == null)) {\n         assert current.left == null;\n         // We can delete the node easily, it's a leaf.\n-        return null;\n+        hashDiff = hashDiff - current.hashCode();\n+        sizeDiff = sizeDiff - 1;\n+        return ContainerOfNodeWithDiffs.of(null, sizeDiff, hashDiff);\n       }\n \n       if (!Node.isRed(current.right) && !Node.isRed(current.right.left)) {\n@@ -637,7 +692,8 @@ void checkAssertions() {\n         // We have to delete current, but is has children.\n         // We replace current with the smallest node in the right subtree (the \"successor\"),\n         // and delete that (leaf) node there.\n-\n+        hashDiff = hashDiff - current.hashCode();\n+        sizeDiff = sizeDiff - 1;\n         @Var Node<K, V> successor = current.right;\n         while (successor.left != null) {\n           successor = successor.left;\n@@ -658,12 +714,16 @@ void checkAssertions() {\n         // key > current.data\n         // Go down rightwards.\n \n-        Node<K, V> newRight = removeAndCopy0(key, current.right);\n+        ContainerOfNodeWithDiffs<K, V> containerOfNodeWithDiffs =\n+            removeAndCopy0(key, current.right, sizeDiff, hashDiff);\n+        sizeDiff = containerOfNodeWithDiffs.getSizeDiff();\n+        hashDiff = containerOfNodeWithDiffs.getHashDiff();\n+        Node<K, V> newRight = containerOfNodeWithDiffs.getNode();\n         current = current.withRightChild(newRight);\n       }\n     }\n \n-    return restoreInvariants(current);\n+    return ContainerOfNodeWithDiffs.of(restoreInvariants(current), sizeDiff, hashDiff);\n   }\n \n   /**\n@@ -798,9 +858,8 @@ public boolean equals(Object pObj) {\n   }\n \n   @Override\n-  @SuppressWarnings(\"RedundantOverride\") // to document that using super.hashCode is intended\n   public int hashCode() {\n-    return super.hashCode();\n+    return hashCode;\n   }\n \n   @Override\n@@ -847,9 +906,6 @@ public boolean isEmpty() {\n \n   @Override\n   public int size() {\n-    if (size <= 0) {\n-      size = Node.countNodes(root);\n-    }\n     return size;\n   }\n "
  }
]
