[
  {
    "sha": "38b2959031139a7a0f76318cfdcd623e9a0724a3",
    "filename": "Makefile",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/Makefile",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/Makefile",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/Makefile?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -1,7 +1,7 @@\n \n # Java compiler options to target specific JVM versions to allow\n # backwards compatibility.\n-JAVA_TARGET = -target 1.7 -source 1.7\n+JAVA_TARGET = -target 1.8 -source 1.8\n \n ifeq ($(strip $(BUILD_DIR)),)\n \tBUILD_DIR = ./"
  },
  {
    "sha": "f55f96f6e9051d453591022a6d3bbff08ddffdae",
    "filename": "ModelInterface/ModelGUI2/queries/CostCurveQueryBuilder.java",
    "status": "modified",
    "additions": 104,
    "deletions": 0,
    "changes": 104,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/CostCurveQueryBuilder.java",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/CostCurveQueryBuilder.java",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/ModelInterface/ModelGUI2/queries/CostCurveQueryBuilder.java?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -31,6 +31,7 @@\n \n import ModelInterface.ModelGUI2.xmldb.XMLDB;\n import ModelInterface.common.DataPair;\n+import ModelInterface.ModelGUI2.xmldb.QueryRow;\n \n import javax.swing.JList;\n import javax.swing.JButton;\n@@ -40,6 +41,7 @@\n import javax.swing.ListSelectionModel;\n \n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.Iterator;\n@@ -50,6 +52,7 @@\n import java.util.EventListener;\n \n import org.basex.query.value.node.ANode;\n+import org.basex.query.value.type.NodeType;\n import org.basex.api.dom.BXNode;\n import org.basex.api.dom.BXElem;\n \n@@ -324,4 +327,105 @@ public Map addToDataTree(ANode currNode, Map dataTree, DataPair<String, String>\n \t\t} \n \t\treturn tempMap;\n \t}\n+\tpublic void addToDataTree(ANode currNode, ListIterator<QueryRow> parentPath, boolean isGlobal) throws Exception {\n+        QueryRow currRow = null;\n+        if(parentPath.hasNext()) {\n+            currRow = parentPath.next();\n+            if(currRow.id != null && currRow.id.is(currNode)) {\n+                // The rest of this path is the same as the last node proccessed.\n+                return;\n+            } else {\n+                currRow = new QueryRow(currNode);\n+                parentPath.set(currRow);\n+            }\n+        } else {\n+            currRow = new QueryRow(currNode);\n+            parentPath.add(currRow);\n+        }\n+        BXNode currDOM = BXNode.get(currNode);\n+\n+\t\t// cache node properties since these may need to go back to the database which could\n+\t\t// be expensive\n+\t\tString nodeName = currDOM.getNodeName();\n+\t\t// run functions can not utilize an attribute map cache since they rely on getNodeHandle\n+\t\t// which is not available in those kinds of queries\n+\t\tMap<String, String> attrMap = XMLDB.getAttrMapWithCache(currDOM);\n+\n+\t\t// set the type as the node name if it does not have a type attribute\n+\t\tString type = attrMap.get(\"type\");\n+\t\tif(type == null) {\n+\t\t\ttype = nodeName;\n+\t\t}\n+\n+\t\t// try to find the axis values at the current node\n+\t\tboolean setNodeLevel = false;\n+\t\tboolean setYearLevel = false;\n+\t\tif(nodeName.equals(qg.nodeLevel.getKey())) {\n+\t\t\tsetNodeLevel = true;\n+            currRow.key = qg.axis1Name;\n+\t\t\tif(qg.nodeLevel.getKey().equals(\"UndiscountedCost\") || qg.nodeLevel.getKey().equals(\"DiscountedCost\")) {\n+\t\t\t\tif(isGlobal) {\n+\t\t\t\t\tcurrRow.value = \"Global\";\n+\t\t\t\t} else {\n+\t\t\t\t\tcurrRow.value = attrMap.get(\"name\");\n+\t\t\t\t}\n+\t\t\t} else if(isGlobal) {\n+                currRow.value = \"Global\";\n+\t\t\t} else {\n+                currRow.value = currDOM.getFirstChild().getFirstChild().getNodeValue();\n+\t\t\t}\n+\n+\t\t}\n+\t\tif(nodeName.equals(qg.yearLevel.getKey())) {\n+\t\t\tsetYearLevel = true;\n+            if(setNodeLevel) {\n+                currRow = new QueryRow(currNode);\n+                if(parentPath.hasNext()) {\n+                    parentPath.next();\n+                    parentPath.set(currRow);\n+                } else {\n+                    parentPath.add(currRow);\n+                }\n+            }\n+            currRow.key = qg.axis2Name;\n+\t\t\tif(qg.nodeLevel.getKey().equals(\"UndiscountedCost\") || qg.nodeLevel.getKey().equals(\"DiscountedCost\")) {\n+                currRow.value = qg.nodeLevel.getKey();\n+\t\t} else {\n+            if(qg.axis2Name.equals(\"Year\")) {\n+                currRow.value = currDOM.getFirstChild().getFirstChild().getNodeValue();\n+            } else {\n+                currRow.value = currDOM.getFirstChild().getNextSibling().getFirstChild().getNodeValue();\n+            }\n+\t\t}\n+\n+\t\t}\n+\t\t// if we should not collapse this node then pick out the attributes which\n+\t\t// check if we need to collapse this level\n+\t\tif(!setNodeLevel && !setYearLevel && !attrMap.isEmpty()) {\n+            // TODO: add the ability to use showAttrMap\n+\t\t\tString attr = XMLDB.getAllAttr(attrMap, showAttrList);\n+            if(attr != \"\") {\n+                currRow.key = nodeName;\n+                currRow.value = attr;\n+            }\n+        }\n+        ANode parentNode = currNode.parent();\n+\t\tif(parentNode.nodeType() != NodeType.DOCUMENT_NODE) {\n+            // recursively process parents\n+            addToDataTree(parentNode, parentPath, isGlobal);\n+        } else {\n+            // We are at the top of the nesting and the stop point for recursion\n+            // Generally there is nothing more to do however we need to correct\n+            // for the special case there the distance from a query result to the\n+            // top changes (the length of parentPath is changing).  We need to ensure\n+            // there are no more items left on the list (except for Units).  This\n+            // situation is not ideal as it defeats out caching strategy.\n+            while(parentPath.hasNext()) {\n+                QueryRow extraRow = parentPath.next();\n+                if(extraRow.key == null || !extraRow.key.equals(\"Units\")) {\n+                    parentPath.remove();\n+                }\n+            }\n+        }\n+    }\n }"
  },
  {
    "sha": "ca41b424f3bffce0a220ec970c76aa71284cb2f4",
    "filename": "ModelInterface/ModelGUI2/queries/QueryBuilder.java",
    "status": "modified",
    "additions": 5,
    "deletions": 0,
    "changes": 5,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/QueryBuilder.java",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/QueryBuilder.java",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/ModelInterface/ModelGUI2/queries/QueryBuilder.java?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -30,6 +30,7 @@\n package ModelInterface.ModelGUI2.queries;\n \n import ModelInterface.common.DataPair;\n+import ModelInterface.ModelGUI2.xmldb.QueryRow;\n \n import javax.swing.JButton;\n import javax.swing.JLabel;\n@@ -38,6 +39,7 @@\n import java.util.Vector;\n import java.util.EventListener;\n import java.util.List;\n+import java.util.ListIterator;\n \n public abstract class QueryBuilder implements java.io.Serializable {\n \n@@ -90,4 +92,7 @@ void setQueryGenerator(QueryGenerator qgIn) {\n \tpublic Map addToDataTree(ANode currNode, Map dataTree, DataPair<String, String> axisValue, boolean isGlobal) throws Exception {\n \t\treturn qg.defaultAddToDataTree(currNode, dataTree, axisValue, isGlobal);\n \t}\n+\tpublic void addToDataTree(ANode currNode, ListIterator<QueryRow> parentPath, boolean isGlobal) throws Exception {\n+        qg.defaultAddToDataTree(currNode, parentPath, isGlobal);\n+    }\n }"
  },
  {
    "sha": "602dd388713d4c3a76e11d2d1a393ec5a1b900a8",
    "filename": "ModelInterface/ModelGUI2/queries/QueryGenerator.java",
    "status": "modified",
    "additions": 8,
    "deletions": 1,
    "changes": 9,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/QueryGenerator.java",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/queries/QueryGenerator.java",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/ModelInterface/ModelGUI2/queries/QueryGenerator.java?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -883,6 +883,13 @@ Map defaultAddToDataTree(ANode currNode, Map dataTree, DataPair<String, String>\n         }\n \t\treturn tempMap;\n \t}\n+\tpublic void addToDataTree(ANode currNode, ListIterator<QueryRow> parentPath, boolean isGlobal) throws Exception {\n+\t\tif(qb != null) {\n+\t\t\tqb.addToDataTree(currNode, parentPath, isGlobal);\n+\t\t} else {\n+\t\t\tdefaultAddToDataTree(currNode, parentPath, isGlobal);\n+\t\t}\n+    }\n \tpublic void defaultAddToDataTree(ANode currNode, ListIterator<QueryRow> parentPath, boolean isGlobal) throws Exception {\n         QueryRow currRow = null;\n         if(parentPath.hasNext()) {\n@@ -972,7 +979,7 @@ public void defaultAddToDataTree(ANode currNode, ListIterator<QueryRow> parentPa\n             }\n         }\n         ANode parentNode = currNode.parent();\n-\t\tif(parentNode.nodeType() != NodeType.DOC) {\n+\t\tif(parentNode.nodeType() != NodeType.DOCUMENT_NODE) {\n             // recursively process parents\n             defaultAddToDataTree(parentNode, parentPath, isGlobal);\n         } else {"
  },
  {
    "sha": "ccb078c16cc7b15e0a5aa0a8676ab00524a98657",
    "filename": "ModelInterface/ModelGUI2/xmldb/RunMIQuery.java",
    "status": "modified",
    "additions": 37,
    "deletions": 18,
    "changes": 55,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/xmldb/RunMIQuery.java",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/xmldb/RunMIQuery.java",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/ModelInterface/ModelGUI2/xmldb/RunMIQuery.java?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -43,9 +43,11 @@\n import org.basex.query.iter.Iter;\n import org.basex.query.value.*;\n import org.basex.query.value.item.*;\n+import org.basex.query.value.array.XQArray;\n import org.basex.query.value.seq.StrSeq;\n import org.basex.query.value.seq.Empty;\n import org.basex.query.value.node.*;\n+import org.basex.query.value.map.XQMap;\n import org.basex.api.dom.BXNode;\n import org.basex.util.list.StringList;\n \n@@ -118,12 +120,8 @@ public void write(int b) {\n                 throw new Exception(\"Could not find scenarios to run.\");\n             }\n             QueryProcessor queryProc = xmldb.createQuery(qg, scenariosToRun.toArray(), regions);\n-            ValueBuilder vb = new ValueBuilder();\n-            FElem elem = new FElem(\"csv\");\n-            vb.add(elem);\n-            buildTable(queryProc, qg, elem);\n-            return vb.value();\n-            //return res.value();\n+            boolean isGlobal = regions.length > 0 ? regions[0].equals(\"Global\") : false;\n+            return buildTable(queryProc, qg, isGlobal);\n         } catch(Exception e) {\n             e.printStackTrace();\n             throw new QueryException(e);\n@@ -136,19 +134,23 @@ public void write(int b) {\n             System.setErr(stderr);\n         }\n     }\n-    private void buildTable(QueryProcessor queryProc, QueryGenerator qg, FElem outputDoc) throws Exception {\n+    private XQMap buildTable(QueryProcessor queryProc, QueryGenerator qg, boolean isGlobal) throws Exception {\n         System.out.println(\"In Function: \"+System.currentTimeMillis());\n         // TODO: replicate these checks, currently just assuming they are all false\n         boolean sumAll = false;\n         boolean isTotal = false;\n-        boolean isGlobal = false;\n \n+        XQMap output = XQMap.EMPTY;\n+        ValueBuilder records = new ValueBuilder(queryContext);\n         Iter res = queryProc.iter();\n         ANode tempNode;\n         final LinkedList<QueryRow>parentPath = new LinkedList<QueryRow>();\n+        LinkedList<Value> header = new LinkedList();\n+        Value[] row = null;\n+        boolean isFirstRow = true;\n         while((tempNode = (ANode)res.next()) != null) {\n             BXNode domNode = BXNode.get(tempNode);\n-            qg.defaultAddToDataTree(tempNode.parent(), parentPath.listIterator(0), isGlobal);\n+            qg.addToDataTree(tempNode.parent(), parentPath.listIterator(0), isGlobal);\n \n             if(!parentPath.peekLast().key.equals(\"Units\")) {\n                 QueryRow unitsRow = new QueryRow(null);\n@@ -158,27 +160,44 @@ private void buildTable(QueryProcessor queryProc, QueryGenerator qg, FElem outpu\n             String currUnits = XMLDB.getAttrMap(BXNode.get(tempNode.parent())).get(\"unit\");\n             parentPath.peekLast().value = currUnits == null ? \"None Specified\" : currUnits;\n \n-            FElem row = new FElem(\"record\");\n+            if(isFirstRow) {\n+                for(Iterator<QueryRow> it = parentPath.descendingIterator(); it.hasNext(); ) {\n+                    QueryRow currRow = it.next();\n+                    if(!(currRow.key == null && currRow.value == null )) {\n+                        header.add(Str.get(currRow.key));\n+                    }\n+                }\n+                header.add(Str.get(\"value\"));\n+                row = new Value[header.size()];\n+                isFirstRow = false;\n+            }\n+\n             boolean skip = false;\n+            int colIndex = 0;\n             for(Iterator<QueryRow> it = parentPath.descendingIterator(); it.hasNext(); ) {\n                 QueryRow currRow = it.next();\n                 if(!(currRow.key == null && currRow.value == null )) {\n-                    FElem col = new FElem(currRow.key);\n-                    col.add(currRow.value);\n-                    row.add(col);\n+                    row[colIndex++] = Str.get(currRow.value);\n                     // skip this data since a rewrite list set the value\n                     // to an empty string indicating the user wanted to\n                     // delete it\n-                    skip = skip || currRow.value.equals(\"\");\n+                    skip = skip || (!currRow.key.equals(\"Units\") && currRow.value.equals(\"\"));\n                 }\n             }\n             if(!skip) {\n-                FElem valueCol = new FElem(\"value\");\n-                valueCol.add(domNode.getNodeValue());\n-                row.add(valueCol);\n-                outputDoc.add(row);\n+                row[colIndex] = Str.get(domNode.getNodeValue());\n+                records.add(XQArray.from(row));\n             }\n         }\n+        // the xquery wants the header as an array under the \"names\" key\n+        output = output.put(Str.get(\"names\"),\n+                XQArray.from(header.toArray(new Value[0])),\n+                queryContext.root.info);\n+        // and it wants the data as a sequence of arrays under the \"records\" key\n+        output = output.put(Str.get(\"records\"),\n+                records.value(),\n+                queryContext.root.info);\n         System.out.println(\"After Function: \"+System.currentTimeMillis());\n+        return output;\n     }\n }"
  },
  {
    "sha": "73ba25d86450a9cac9bb77a0cfbe045e16de263a",
    "filename": "ModelInterface/ModelGUI2/xmldb/XMLDB.java",
    "status": "modified",
    "additions": 2,
    "deletions": 1,
    "changes": 3,
    "blob_url": "https://github.com/JGCRI/modelinterface/blob/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/xmldb/XMLDB.java",
    "raw_url": "https://github.com/JGCRI/modelinterface/raw/5f837a01c0b3acfa4f797339b1928d9aefd2af8e/ModelInterface/ModelGUI2/xmldb/XMLDB.java",
    "contents_url": "https://api.github.com/repos/JGCRI/modelinterface/contents/ModelInterface/ModelGUI2/xmldb/XMLDB.java?ref=5f837a01c0b3acfa4f797339b1928d9aefd2af8e",
    "patch": "@@ -61,6 +61,7 @@\n import org.basex.query.value.node.DBNode;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n+import org.basex.io.IOFile;\n import org.basex.io.out.PrintOutput;\n import org.basex.io.serial.Serializer;\n \n@@ -249,7 +250,7 @@ public boolean exportDoc(final String aDocName, final File aLocation) {\n                 System.err.println(aDocName+\" matched \"+docPre.length+\" docs; != 1\");\n                 return false;\n             }\n-            final PrintOutput out = new PrintOutput(aLocation.getPath());\n+            final PrintOutput out = new PrintOutput(new IOFile(aLocation));\n             final Serializer outputter = Serializer.get(out);\n             outputter.serialize(new DBNode(context.data(), docPre[0]));\n             outputter.close();"
  }
]
