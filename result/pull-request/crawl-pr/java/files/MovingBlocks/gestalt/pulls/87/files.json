[
  {
    "sha": "5279eeab4cc2bf565fffc16e848317b7b9d25452",
    "filename": "gestalt-asset-core/build.gradle",
    "status": "modified",
    "additions": 18,
    "deletions": 2,
    "changes": 20,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/build.gradle",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/build.gradle",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/build.gradle?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -28,17 +28,33 @@ apply plugin: 'maven-publish'\n dependencies {\n     implementation project(\":gestalt-util\")\n     implementation project(\":gestalt-module\")\n+    implementation project(\":gestalt-inject\")\n+    annotationProcessor project(\":gestalt-inject-java\")\n+    \n \n+    implementation \"com.google.guava:guava:$guava_version\"\n     implementation \"org.slf4j:slf4j-api:$slf4j_version\"\n     implementation \"com.android.support:support-annotations:$android_annotation_version\"\n-    implementation \"net.jcip:jcip-annotations:$jcip_annotation_version\"\n+    api \"net.jcip:jcip-annotations:$jcip_annotation_version\"\n \n+    testAnnotationProcessor project(\":gestalt-inject-java\")\n     testImplementation \"junit:junit:$junit_version\"\n     testImplementation \"ch.qos.logback:logback-classic:$logback_version\"\n     testImplementation \"org.mockito:mockito-core:$mockito_version\"\n \n }\n \n+\n+compileJava {\n+    inputs.files sourceSets.main.resources.srcDirs\n+    options.compilerArgs = [\"-Aresource=${sourceSets.main.resources.srcDirs.join(File.pathSeparator)}\"]\n+}\n+compileTestJava {\n+    inputs.files sourceSets.test.resources.srcDirs\n+    options.compilerArgs = [\"-Aresource=${sourceSets.test.resources.srcDirs.join(File.pathSeparator)}\"]\n+}\n+\n+\n description = 'Provides support for assets - binary resources that can be loaded from modules or procedurally generated at runtime.'\n \n sourceCompatibility = 1.8\n@@ -81,4 +97,4 @@ publishing {\n             artifact javadocJar\n         }\n     }\n-}\n\\ No newline at end of file\n+}"
  },
  {
    "sha": "88e432dcb1dd9ce9fe3dacd3e2067b14c3810acc",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AbstractFragmentDataProducer.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AbstractFragmentDataProducer.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AbstractFragmentDataProducer.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AbstractFragmentDataProducer.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -22,8 +22,8 @@\n import com.google.common.collect.Collections2;\n import com.google.common.collect.ImmutableSet;\n \n+import org.terasology.context.annotation.API;\n import org.terasology.gestalt.assets.management.AssetManager;\n-import org.terasology.gestalt.module.sandbox.API;\n import org.terasology.gestalt.naming.Name;\n \n import java.io.IOException;"
  },
  {
    "sha": "3495aaa138a4672a4a5d14f9653e4341f3ec72fa",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/Asset.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/Asset.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/Asset.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/Asset.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -20,7 +20,7 @@\n \n import net.jcip.annotations.ThreadSafe;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;\n \n import java.util.Optional;\n "
  },
  {
    "sha": "be96e6588da0a898c32a12375e65a80f33f97f1f",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetData.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetData.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetData.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetData.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,7 +16,7 @@\n \n package org.terasology.gestalt.assets;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;\n \n /**\n  * AssetData is the implementation agnostic data for an asset - typically it isn't dependant on either the source format"
  },
  {
    "sha": "521893e9adc65d6fc54a5bd2d17712b7bf27ebc1",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetDataProducer.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetDataProducer.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetDataProducer.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetDataProducer.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,7 +16,7 @@\n \n package org.terasology.gestalt.assets;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;\n import org.terasology.gestalt.naming.Name;\n \n import java.io.IOException;"
  },
  {
    "sha": "9bb596ffadfca9341200ba532363ace204086fe0",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetFactory.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetFactory.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetFactory.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetFactory.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,7 +16,7 @@\n \n package org.terasology.gestalt.assets;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;\n \n /**\n  * AssetFactorys are used to load AssetData into new assets."
  },
  {
    "sha": "074c121701f501364eecc76143ba6e843144f97d",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetType.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetType.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetType.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/AssetType.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -34,7 +34,7 @@\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;\n import org.terasology.gestalt.naming.Name;\n import org.terasology.gestalt.util.reflection.GenericsUtil;\n "
  },
  {
    "sha": "c76296893faab303c3b27069b52a98b59917af69",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/ResourceUrn.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/ResourceUrn.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/ResourceUrn.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/ResourceUrn.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -20,8 +20,8 @@\n import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n \n+import org.terasology.context.annotation.API;\n import org.terasology.gestalt.assets.exceptions.InvalidUrnException;\n-import org.terasology.gestalt.module.sandbox.API;\n import org.terasology.gestalt.naming.Name;\n \n import java.util.regex.Matcher;"
  },
  {
    "sha": "4e9332b19ca40f19fd7e3f59c1bc7cf93370ad9b",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/exceptions/package-info.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/exceptions/package-info.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/exceptions/package-info.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/exceptions/package-info.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -20,4 +20,4 @@\n @API\n package org.terasology.gestalt.assets.exceptions;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;"
  },
  {
    "sha": "65884deec07b8c13cf28d436d96be033fc826ea2",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/format/package-info.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/format/package-info.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/format/package-info.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/format/package-info.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -24,4 +24,4 @@\n @API\n package org.terasology.gestalt.assets.format;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;"
  },
  {
    "sha": "584f683e59cc7d3ac518657abdc3e0059d6f0dd1",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/AssetManager.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/AssetManager.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/AssetManager.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/AssetManager.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -21,11 +21,11 @@\n \n import net.jcip.annotations.ThreadSafe;\n \n+import org.terasology.context.annotation.API;\n import org.terasology.gestalt.assets.Asset;\n import org.terasology.gestalt.assets.AssetData;\n import org.terasology.gestalt.assets.AssetType;\n import org.terasology.gestalt.assets.ResourceUrn;\n-import org.terasology.gestalt.module.sandbox.API;\n import org.terasology.gestalt.naming.Name;\n \n import java.util.Collections;"
  },
  {
    "sha": "ddc164db82a4016ffec29b519bf66df703eed16f",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/MapAssetTypeManager.java",
    "status": "modified",
    "additions": 13,
    "deletions": 8,
    "changes": 21,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/MapAssetTypeManager.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/MapAssetTypeManager.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/management/MapAssetTypeManager.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -17,17 +17,13 @@\n package org.terasology.gestalt.assets.management;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicate;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.MapMaker;\n import com.google.common.collect.Multimaps;\n-\n import net.jcip.annotations.ThreadSafe;\n-\n-import org.reflections.ReflectionUtils;\n import org.terasology.gestalt.assets.Asset;\n import org.terasology.gestalt.assets.AssetData;\n import org.terasology.gestalt.assets.AssetFactory;\n@@ -52,6 +48,17 @@\n     private final ListMultimap<Class<? extends Asset>, Class<? extends Asset>> subtypes =\n             Multimaps.synchronizedListMultimap(ArrayListMultimap.<Class<? extends Asset>, Class<? extends Asset>>create());\n \n+    private static Iterable<Class<?>> getAllSuperClasses(Class<?> from, Class<?> to) {\n+        Preconditions.checkArgument(to.isAssignableFrom(from), \"%s should be subtype of %s\", from, to);\n+        List<Class<?>> subtypes = Lists.newArrayList();\n+        Class<?> current = from;\n+        while (current != to) {\n+            subtypes.add(current);\n+            current = current.getSuperclass();\n+        }\n+        return subtypes;\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends Asset<U>, U extends AssetData> Optional<AssetType<T, U>> getAssetType(Class<T> type) {\n@@ -109,7 +116,7 @@ public synchronized void addAssetType(AssetType<?, ?> assetType) {\n         Preconditions.checkState(assetTypes.get(assetType.getAssetClass()) == null, \"Asset type already registered for - \" + assetType.getAssetClass().getSimpleName());\n \n         assetTypes.put(assetType.getAssetClass(), assetType);\n-        for (Class<?> parentType : ReflectionUtils.getAllSuperTypes(assetType.getAssetClass(), (Predicate<Class<?>>) input -> Asset.class.isAssignableFrom(input) && input != Asset.class)) {\n+        for (Class<?> parentType : getAllSuperClasses(assetType.getAssetClass(), Asset.class)) {\n             subtypes.put((Class<? extends Asset>) parentType, assetType.getAssetClass());\n             (subtypes.get((Class<? extends Asset>) parentType)).sort(Comparator.comparing(Class::getSimpleName));\n \n@@ -128,7 +135,7 @@ public synchronized void addAssetType(AssetType<?, ?> assetType) {\n         AssetType<?, ?> assetType = assetTypes.remove(type);\n         if (assetType != null) {\n             assetType.close();\n-            for (Class<?> parentType : ReflectionUtils.getAllSuperTypes(type, (Predicate<Class<?>>) input -> Asset.class.isAssignableFrom(input) && input != Asset.class)) {\n+            for (Class<?> parentType : getAllSuperClasses(type, Asset.class)) {\n                 subtypes.remove(parentType, type);\n             }\n         }\n@@ -145,6 +152,4 @@ public synchronized void clear() {\n         assetTypes.clear();\n         subtypes.clear();\n     }\n-\n-\n }"
  },
  {
    "sha": "355ae2f1b73606bebe6e557e0cfa3122448e0133",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDataProducer.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDataProducer.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDataProducer.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDataProducer.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,8 +16,9 @@\n \n package org.terasology.gestalt.assets.module.annotations;\n \n+import org.terasology.context.annotation.API;\n+import org.terasology.context.annotation.Index;\n import org.terasology.gestalt.assets.module.ModuleAwareAssetTypeManagerImpl;\n-import org.terasology.gestalt.module.sandbox.API;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n@@ -40,5 +41,6 @@\n @API\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.TYPE)\n+@Index\n public @interface RegisterAssetDataProducer {\n }"
  },
  {
    "sha": "d83857cc5d3ed934ebda380344efb0c04ac276f1",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDeltaFileFormat.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDeltaFileFormat.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDeltaFileFormat.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetDeltaFileFormat.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,8 +16,9 @@\n \n package org.terasology.gestalt.assets.module.annotations;\n \n+import org.terasology.context.annotation.API;\n+import org.terasology.context.annotation.Index;\n import org.terasology.gestalt.assets.module.ModuleAwareAssetTypeManagerImpl;\n-import org.terasology.gestalt.module.sandbox.API;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n@@ -41,5 +42,6 @@\n @API\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.TYPE)\n+@Index\n public @interface RegisterAssetDeltaFileFormat {\n }"
  },
  {
    "sha": "152cd194559cb249aeb7a5337e09755f881cfb67",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetFileFormat.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetFileFormat.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetFileFormat.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetFileFormat.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,8 +16,9 @@\n \n package org.terasology.gestalt.assets.module.annotations;\n \n+import org.terasology.context.annotation.API;\n+import org.terasology.context.annotation.Index;\n import org.terasology.gestalt.assets.module.ModuleAwareAssetTypeManagerImpl;\n-import org.terasology.gestalt.module.sandbox.API;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n@@ -36,5 +37,6 @@\n @API\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.TYPE)\n+@Index\n public @interface RegisterAssetFileFormat {\n }"
  },
  {
    "sha": "469fae3d2eb84062ccd98f602463c3aaa4d96c36",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetSupplementalFileFormat.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetSupplementalFileFormat.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetSupplementalFileFormat.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetSupplementalFileFormat.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,8 +16,9 @@\n \n package org.terasology.gestalt.assets.module.annotations;\n \n+import org.terasology.context.annotation.API;\n+import org.terasology.context.annotation.Index;\n import org.terasology.gestalt.assets.module.ModuleAwareAssetTypeManagerImpl;\n-import org.terasology.gestalt.module.sandbox.API;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n@@ -42,5 +43,6 @@\n @API\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.TYPE)\n+@Index\n public @interface RegisterAssetSupplementalFileFormat {\n }"
  },
  {
    "sha": "c4d44caa4fb37a5da7c8db02662362ae1a955f60",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetType.java",
    "status": "modified",
    "additions": 3,
    "deletions": 1,
    "changes": 4,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetType.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetType.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/RegisterAssetType.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -16,9 +16,10 @@\n \n package org.terasology.gestalt.assets.module.annotations;\n \n+import org.terasology.context.annotation.API;\n+import org.terasology.context.annotation.Index;\n import org.terasology.gestalt.assets.AssetFactory;\n import org.terasology.gestalt.assets.module.ModuleAwareAssetTypeManagerImpl;\n-import org.terasology.gestalt.module.sandbox.API;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n@@ -41,6 +42,7 @@\n @API\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.TYPE)\n+@Index\n public @interface RegisterAssetType {\n     /**\n      * @return The subdirectory where assets of this type will be discovered. Can be omitted for asset types that are not loaded from files."
  },
  {
    "sha": "6ae857953dd075ec9840b227b36c781e8cd0a6f8",
    "filename": "gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/package-info.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/package-info.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/package-info.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/main/java/org/terasology/gestalt/assets/module/annotations/package-info.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -20,4 +20,4 @@\n @API\n package org.terasology.gestalt.assets.module.annotations;\n \n-import org.terasology.gestalt.module.sandbox.API;\n+import org.terasology.context.annotation.API;"
  },
  {
    "sha": "4fc3c25b6a32941ef5ca1fd36fa630359f1779bb",
    "filename": "gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/TestModulesUtil.java",
    "status": "modified",
    "additions": 5,
    "deletions": 5,
    "changes": 10,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/TestModulesUtil.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/TestModulesUtil.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/TestModulesUtil.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -17,7 +17,7 @@\n package org.terasology.gestalt.assets.module;\n \n import com.google.common.collect.Lists;\n-\n+import org.terasology.gestalt.di.DefaultBeanContext;\n import org.terasology.gestalt.module.ModuleEnvironment;\n import org.terasology.gestalt.module.ModuleFactory;\n import org.terasology.gestalt.module.sandbox.PermitAllPermissionProviderFactory;\n@@ -55,11 +55,11 @@ private TestModulesUtil() {\n \n     public static ModuleEnvironment createFullEnvironment() {\n         ModuleFactory factory = new ModuleFactory();\n-        return new ModuleEnvironment(VIRTUAL_MODULES.stream().map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n+        return new ModuleEnvironment(new DefaultBeanContext(), VIRTUAL_MODULES.stream().map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n     }\n \n     public static ModuleEnvironment createEmptyEnvironment() {\n-        return new ModuleEnvironment(Collections.emptyList(), new PermitAllPermissionProviderFactory());\n+        return new ModuleEnvironment(new DefaultBeanContext(), Collections.emptyList(), new PermitAllPermissionProviderFactory());\n     }\n \n     public static ModuleEnvironment createEnvironment() {\n@@ -72,11 +72,11 @@ public static ModuleEnvironment createEnvironment(String... modules) {\n \n     public static ModuleEnvironment createEnvironment(List<String> modules) {\n         ModuleFactory factory = new ModuleFactory();\n-        return new ModuleEnvironment(modules.stream().map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n+        return new ModuleEnvironment(new DefaultBeanContext(), modules.stream().map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n     }\n \n     public static ModuleEnvironment createEnvironment(Name... modules) {\n         ModuleFactory factory = new ModuleFactory();\n-        return new ModuleEnvironment(Arrays.stream(modules).map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n+        return new ModuleEnvironment(new DefaultBeanContext(), Arrays.stream(modules).map(x -> factory.createPackageModule(VIRTUAL_MODULE_ROOT + \".\" + x)).collect(Collectors.toList()), new PermitAllPermissionProviderFactory());\n     }\n }"
  },
  {
    "sha": "4708cb900d250cf0bc105bd2b1bed484c26243ba",
    "filename": "gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/autoreload/ModuleEnvironmentWatcherTest.java",
    "status": "modified",
    "additions": 5,
    "deletions": 6,
    "changes": 11,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/autoreload/ModuleEnvironmentWatcherTest.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/autoreload/ModuleEnvironmentWatcherTest.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-asset-core/src/test/java/org/terasology/gestalt/assets/module/autoreload/ModuleEnvironmentWatcherTest.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -17,13 +17,13 @@\n package org.terasology.gestalt.assets.module.autoreload;\n \n import com.google.common.collect.SetMultimap;\n-\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.terasology.gestalt.assets.AssetType;\n import org.terasology.gestalt.assets.ResourceUrn;\n import org.terasology.gestalt.assets.format.producer.FileChangeSubscriber;\n+import org.terasology.gestalt.di.DefaultBeanContext;\n import org.terasology.gestalt.module.Module;\n import org.terasology.gestalt.module.ModuleEnvironment;\n import org.terasology.gestalt.module.ModuleFactory;\n@@ -33,6 +33,9 @@\n import org.terasology.gestalt.naming.Name;\n import org.terasology.gestalt.naming.Version;\n import org.terasology.gestalt.util.io.FilesUtil;\n+import virtualModules.test.stubs.text.Text;\n+import virtualModules.test.stubs.text.TextData;\n+import virtualModules.test.stubs.text.TextFactory;\n \n import java.io.IOException;\n import java.io.Writer;\n@@ -41,10 +44,6 @@\n import java.util.Collections;\n import java.util.Optional;\n \n-import virtualModules.test.stubs.text.Text;\n-import virtualModules.test.stubs.text.TextData;\n-import virtualModules.test.stubs.text.TextFactory;\n-\n import static org.junit.Assert.assertTrue;\n \n public class ModuleEnvironmentWatcherTest {\n@@ -56,7 +55,7 @@ public void test() throws IOException {\n         Path tempDirectory = Files.createTempDirectory(\"gestalt-test\");\n         ModuleMetadata metadata = new ModuleMetadata(new Name(\"test\"), Version.DEFAULT);\n         Module module = new ModuleFactory().createDirectoryModule(metadata, tempDirectory.toFile());\n-        ModuleEnvironment environment = new ModuleEnvironment(Collections.singletonList(module), new PermitAllPermissionProviderFactory());\n+        ModuleEnvironment environment = new ModuleEnvironment(new DefaultBeanContext(), Collections.singletonList(module), new PermitAllPermissionProviderFactory());\n         ModuleEnvironmentWatcher watcher = new ModuleEnvironmentWatcher(environment);\n         FileChangeSubscriber subscriber = new FileChangeSubscriber() {\n             @Override"
  },
  {
    "sha": "5252e5dce3f3ff554255792add8a75738de25933",
    "filename": "gestalt-di/build.gradle",
    "status": "added",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/build.gradle",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/build.gradle",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/build.gradle?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,77 @@\n+apply plugin: 'java-library'\n+apply plugin: 'maven-publish'\n+\n+sourceCompatibility = 1.8\n+targetCompatibility = 1.8\n+\n+task gatherJarModules(dependsOn: [':testpack:moduleA:jar', ':testpack:moduleB:jar', ':testpack:moduleC:jar', ':testpack:moduleD:jar'], type: Copy)\n+\n+// Primary dependencies definition\n+dependencies {\n+    testAnnotationProcessor project(\":gestalt-inject-java\")\n+\n+    implementation \"com.google.guava:guava:$guava_version\"\n+    api project(\":gestalt-inject\")\n+\n+    testImplementation \"junit:junit:$junit_version\"\n+    testImplementation \"ch.qos.logback:logback-classic:$logback_version\"\n+    testImplementation \"org.mockito:mockito-core:$mockito_version\"\n+\n+    testImplementation project(\":gestalt-module\")\n+    testImplementation project(\":testpack:testpack-api\")\n+    testImplementation project(\":gestalt-entity-system\")\n+\n+}\n+\n+\n+\n+gatherJarModules {\n+    from '../testpack/moduleA/build/libs/'\n+    from '../testpack/moduleB/build/libs/'\n+    from '../testpack/moduleC/build/libs/'\n+    from '../testpack/moduleD/build/libs/'\n+    from '../testpack/moduleF/build/libs/'\n+    into 'test-modules'\n+    include('*.jar')\n+}\n+\n+test.dependsOn gatherJarModules\n+\n+\n+/***\n+ * Publishing\n+ ***/\n+\n+task sourceJar(type: Jar, dependsOn: classes) {\n+    classifier 'sources'\n+    from sourceSets.main.allSource\n+}\n+\n+task javadocJar(type: Jar, dependsOn: javadoc) {\n+    classifier = 'javadoc'\n+    from javadoc.destinationDir\n+}\n+\n+publishing {\n+    repositories {\n+        maven {\n+            credentials {\n+                username project.gestaltMavenRepoUsername\n+                password project.gestaltMavenRepoPassword\n+            }\n+            name 'TerasologyTestRepo'\n+            url project.version.endsWith('SNAPSHOT') ? project.snapshotPublishRepo : project.releasePublishRepo\n+        }\n+    }\n+    publications {\n+        mavenAssetCore(MavenPublication) {\n+            artifactId = project.name\n+            version = project.version\n+\n+            from components.java\n+\n+            artifact sourceJar\n+            artifact javadocJar\n+        }\n+    }\n+}"
  },
  {
    "sha": "8e876c435a810e666f0f493648fa89e72729ea85",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanContext.java",
    "status": "added",
    "additions": 136,
    "deletions": 0,
    "changes": 136,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanContext.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanContext.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanContext.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import org.terasology.gestalt.di.injection.Qualifier;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * A context contains information about resolving an instance and a collection of objects that are bound\n+ * to this context.\n+ */\n+public interface BeanContext extends AutoCloseable {\n+\n+    /**\n+     * The containing context that this context is parented to\n+     * @return bean context\n+     */\n+    Optional<BeanContext> getParent();\n+\n+    /**\n+     * resolve and inject into fields annotated by {@link javax.inject.Inject} for the object provided in instance.\n+     *\n+     * returns an empty optional if the target object is not processed by gestalt-inject-java\n+     *\n+     * @param instance the objects to inject into\n+     * @param <T>\n+     * @throws org.terasology.context.exception.BeanNotFoundException if a bean definition is not resolved for the injected target\n+     * @return the instance\n+     */\n+    <T> T inject(T instance);\n+\n+    /**\n+     * resolve object by its {@link BeanKey}\n+     * @param identifier An identifier that drives the lookup of the target\n+     * @param <T>\n+     * @return the resolved object\n+     */\n+    <T> T getBean(BeanKey<T> identifier);\n+\n+    /**\n+     * resolve object by its {@link Class}\n+     * @param clazz target class for the lookup\n+     * @param <T>\n+     * @return the resolved object\n+     */\n+    <T> T getBean(Class<T> clazz);\n+\n+    /**\n+     * resolve object by its {@link Class} and {@link Qualifier}\n+     * @param clazz target class for the lookup\n+     * @param qualifier the qualifier to filter by\n+     * @param <T>\n+     * @return the resolved object\n+     */\n+    <T> T getBean(Class<T> clazz, Qualifier qualifier);\n+\n+    /**\n+     * resolve multiple target by {@link BeanKey}.\n+     *\n+     * @param identifier target identifier for the lookup\n+     * @param <T>\n+     * @return multiple resolved object\n+     */\n+    <T> List<T> getBeans(BeanKey<T> identifier);\n+\n+    /**\n+     * resolve multiple target by {@link Class}.\n+     *\n+     * @param clazz target class for the lookup\n+     * @param <T>\n+     * @return multiple resolved object\n+     */\n+    <T> List<T> getBeans(Class<T> clazz);\n+\n+    /**\n+     * resolve multiple target by {@link Class} and {@link Qualifier}.\n+     *\n+     * @param clazz target class for the lookup\n+     * @param qualifier the qualifier to filer by\n+     * @param <T>\n+     * @return multiple resolved object\n+     */\n+    <T> List<T> getBeans(Class<T> clazz, Qualifier qualifier);\n+\n+    /**\n+     * tries to resolve a target object from its identifier. returns an empty optional if\n+     * a bean is not found.\n+     *\n+     * @param identifier an identifier that drives the lookup of the target\n+     * @param <T>\n+     * @return an instance of a given target\n+     */\n+    <T> Optional<T> findBean(BeanKey<T> identifier);\n+\n+    /**\n+     * tries to resolve a target object from its class. returns an empty optional if\n+     * a bean is not found.\n+     *\n+     * @param clazz lookup by class\n+     * @param <T> target\n+     * @return the resolved object\n+     */\n+    <T> Optional<T> findBean(Class<T> clazz);\n+\n+    /**\n+     * tries to resolve a target object from its {@link Class} and {@link Qualifier}. returns an empty optional if\n+     * a bean is not found.\n+     *\n+     * @param clazz     lookup by class\n+     * @param qualifier qualifier to filer multiple implementations by\n+     * @param <T>       target\n+     * @return the resolved object\n+     */\n+    <T> Optional<T> findBean(Class<T> clazz, Qualifier qualifier);\n+\n+    /**\n+     * a new context that is a child of this context\n+     * @return a child {@link BeanContext}\n+     */\n+    BeanContext getNestedContainer();\n+\n+    /**\n+     *  a new context that is a child of this context and a list of {@link ServiceRegistry} that describe the child {@link BeanContext}\n+     * @param registries that define the context\n+     * @return a child {@link BeanContext}\n+     */\n+    BeanContext getNestedContainer(ServiceRegistry... registries);\n+\n+    /**\n+     * the environment that drives the context\n+     * @return the environment\n+     */\n+    BeanEnvironment getEnvironment();\n+}"
  },
  {
    "sha": "9cbe73932d903304ad40b84934ae51a434fb3701",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanEnvironment.java",
    "status": "added",
    "additions": 314,
    "deletions": 0,
    "changes": 314,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanEnvironment.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanEnvironment.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanEnvironment.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,314 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Range;\n+import org.terasology.context.BeanDefinition;\n+import org.terasology.context.SoftServiceLoader;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A internal environment that has internal information that is shared between multiple context.\n+ */\n+public class BeanEnvironment {\n+\n+    public static final ClassLoader BaseClassLoader = BeanEnvironment.class.getClassLoader();\n+    private final Map<ClassLoader, ClassLookup> beanLookup = new HashMap<>();\n+\n+    public BeanEnvironment() {\n+        loadDefinitions(BeanEnvironment.BaseClassLoader);\n+    }\n+\n+    public void loadDefinitions(ClassLoader loader) {\n+        loadDefinitions(loader, true);\n+    }\n+\n+    public void loadDefinitions(ClassLoader loader, boolean loadsFromParent) {\n+        if (beanLookup.containsKey(loader)) {\n+            return;\n+        }\n+        beanLookup.computeIfAbsent(loader, (ld) -> {\n+            SoftServiceLoader<BeanDefinition> definitions = new SoftServiceLoader<>(BeanDefinition.class, ld, loadsFromParent);\n+            ClassLookup lookup = new ClassLookup();\n+\n+            List<ClassRef<?>> namespaceIndex = new ArrayList<>();\n+            Map<Class<?>, BeanDefinition<?>> definitionLookup = Maps.newHashMap();\n+            Multimap<Class<?>, ClassRef> interfaceIndex = HashMultimap.create();\n+            for (BeanDefinition<?> definition : definitions) {\n+                // exclude objects that are from a different classloader\n+                if (definition.targetClass().getClassLoader() != loader) {\n+                    continue;\n+                }\n+                namespaceIndex.add(new ClassRef<>(definition));\n+                definitionLookup.put(definition.targetClass(), definition);\n+                for (Class<?> clazzInterface : definition.targetClass().getInterfaces()) {\n+                    interfaceIndex.put(clazzInterface, new ClassRef<>(definition));\n+                }\n+            }\n+            namespaceIndex.sort((Comparator<ClassRef>) (a1, a2) -> a1.prefix.compareTo(a2.prefix));\n+            lookup.namespaceIndex = namespaceIndex.toArray(new ClassRef[0]);\n+            lookup.interfaceIndex = interfaceIndex.asMap().entrySet().stream().collect(\n+                    Collectors.toMap(k -> k.getKey(), v -> {\n+                        ClassRef[] result = v.getValue().toArray(new ClassRef[0]);\n+                        Arrays.sort(result, (classRef, t1) -> classRef.prefix.compareTo(t1.prefix));\n+                        return result;\n+                    })\n+            );\n+            lookup.definitions = definitionLookup;\n+\n+            return lookup;\n+        });\n+    }\n+\n+    public Iterable<ClassLoader> definitions() {\n+        return beanLookup.keySet();\n+    }\n+\n+    public boolean containsClass(Class<?> clazz) {\n+        final ClassLookup lookup = beanLookup.get(clazz.getClassLoader());\n+        return lookup.definitions.containsKey(clazz);\n+    }\n+\n+    private Optional<Range<Integer>> findPrefixBounds(String prefix, ClassRef<?>[] input) {\n+        if (input.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        if (Strings.isNullOrEmpty(prefix)) {\n+            return Optional.of(Range.closed(0, input.length - 1));\n+        }\n+\n+        int startPoint = 0;\n+        int endpoint = input.length - 1;\n+        while (true) {\n+            String stringToTest = input[startPoint + (endpoint - startPoint) / 2].prefix;\n+            if (stringToTest.startsWith(prefix)) {\n+                break;\n+            }\n+            if (startPoint == endpoint) {\n+                return Optional.empty();\n+            }\n+            if (stringToTest.compareTo(prefix) > 0) {\n+                endpoint = startPoint + ((endpoint - startPoint) / 2);\n+            }\n+            if (stringToTest.compareTo(prefix) < 0) {\n+                if (input[endpoint].prefix.compareTo(prefix) < 0) {\n+                    return Optional.empty();\n+                }\n+                startPoint = startPoint + ((endpoint - startPoint) / 2);\n+            }\n+        }\n+\n+        while (!input[endpoint].prefix.startsWith(prefix)) {\n+            if (endpoint < startPoint) {\n+                return Optional.empty();\n+            }\n+            endpoint--;\n+        }\n+\n+        while (!input[startPoint].prefix.startsWith(prefix)) {\n+            if (endpoint < startPoint) {\n+                return Optional.empty();\n+            }\n+            startPoint++;\n+        }\n+\n+        return Optional.of(Range.closed(startPoint, endpoint));\n+    }\n+\n+    /**\n+     * Filter bean Definitions by class that implements a targetInterface with a given classloader that is already loaded into the enviroment\n+     *\n+     * @param loader          target class loader\n+     * @param targetInterface target inerface\n+     * @param <T>\n+     * @return A collection of BeanDefinition\n+     */\n+    public <T> Iterable<BeanDefinition<? extends T>> byInterface(ClassLoader loader, Class<T> targetInterface) {\n+        final ClassLookup lookup = beanLookup.get(loader);\n+        if (!lookup.interfaceIndex.containsKey(targetInterface)) {\n+            return Collections::emptyIterator;\n+        }\n+        return Arrays.stream(lookup.interfaceIndex.get(targetInterface)).map(k -> (BeanDefinition<? extends T>) k.definition).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Filter {@link BeanDefinition} by class that implements a targetInterface\n+     *\n+     * @param targetInterface the target interface\n+     * @param <T>\n+     * @return a collection of BeanDefinition\n+     */\n+    public <T> Iterable<BeanDefinition<? extends T>> byInterface(Class<T> targetInterface) {\n+        return Iterables.concat(beanLookup.keySet().stream().map(k -> byInterface(k, targetInterface)).collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Filter bean Definitions by class that implements a targetAnnotation with a given classloader that is already loaded into the enviroment\n+     *\n+     * @param loader           target class loader\n+     * @param targetAnnotation target inerface\n+     * @return A collection of BeanDefinition\n+     */\n+    public Iterable<BeanDefinition<?>> byAnnotation(ClassLoader loader, Class<?> targetAnnotation) {\n+        final ClassLookup lookup = beanLookup.get(loader);\n+        if (!lookup.annotationIndex.containsKey(targetAnnotation)) {\n+            return Collections::emptyIterator;\n+        }\n+        return Arrays.stream(lookup.annotationIndex.get(targetAnnotation))\n+                .map(k -> (BeanDefinition<?>) k.definition)\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Filter {@link BeanDefinition} by class that implements a targetAnnotation\n+     *\n+     * @param targetAnnotation the target interface\n+     * @return a collection of BeanDefinition\n+     */\n+    public Iterable<BeanDefinition<?>> byAnnotation(Class<?> targetAnnotation) {\n+        return Iterables.concat(beanLookup.keySet().stream()\n+                .map(k -> byAnnotation(k, targetAnnotation))\n+                .collect(Collectors.toList()));\n+    }\n+\n+    /**\n+     * Filter {@link BeanDefinition} by a target classloader, part of a prefix and a target interface.\n+     *\n+     * @param loader\n+     * @param prefix\n+     * @param targetInterface\n+     * @param <T>\n+     * @return\n+     */\n+    public <T> Iterable<BeanDefinition<?>> byPrefixAndInterface(ClassLoader loader, String prefix, Class<T> targetInterface) {\n+        final ClassLookup lookup = beanLookup.get(loader);\n+        ClassRef<?>[] targetClasses = lookup.interfaceIndex.get(targetInterface);\n+        Optional<Range<Integer>> range = findPrefixBounds(prefix, targetClasses);\n+        if (range.isPresent()) {\n+            Range<Integer> itr = range.get();\n+            return () -> new Iterator<BeanDefinition<?>>() {\n+                private int index = itr.lowerEndpoint();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index <= itr.upperEndpoint();\n+                }\n+\n+                @Override\n+                public BeanDefinition<?> next() {\n+                    BeanDefinition<?> def = targetClasses[index].definition;\n+                    index++;\n+                    return def;\n+                }\n+            };\n+        }\n+        return Collections::emptyIterator;\n+    }\n+\n+    public Iterable<BeanDefinition<?>> byPrefix(String prefix) {\n+        return Iterables.concat(beanLookup.keySet().stream().map(k -> byPrefix(k, prefix)).collect(Collectors.toList()));\n+    }\n+\n+    public Iterable<BeanDefinition<?>> byPrefix(ClassLoader loader, String prefix) {\n+        final ClassLookup lookup = beanLookup.get(loader);\n+\n+        Optional<Range<Integer>> range = findPrefixBounds(prefix, lookup.namespaceIndex);\n+        if (range.isPresent()) {\n+            Range<Integer> itr = range.get();\n+            return () -> new Iterator<BeanDefinition<?>>() {\n+                private int index = itr.lowerEndpoint();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index <= itr.upperEndpoint();\n+                }\n+\n+                @Override\n+                public BeanDefinition<?> next() {\n+                    BeanDefinition<?> def = lookup.namespaceIndex[index].definition;\n+                    index++;\n+                    return def;\n+                }\n+            };\n+        }\n+        return Collections::emptyIterator;\n+    }\n+\n+    public boolean releaseDefinitions(ClassLoader loader) {\n+        if (!beanLookup.containsKey(loader)) {\n+            return false;\n+        }\n+        beanLookup.remove(loader);\n+        return true;\n+    }\n+\n+    public Iterable<ClassLoader> classLoaders() {\n+        return beanLookup.keySet();\n+    }\n+\n+    public <T> BeanDefinition<?> getDefinition(Class<T> beanType) {\n+        final ClassLookup lookup = beanLookup.get(beanType.getClassLoader());\n+        return lookup.definitions.get(beanType);\n+    }\n+\n+    private static class ClassRef<T> {\n+        public final Class<T> target;\n+        public final String prefix;\n+        public final BeanDefinition<T> definition;\n+\n+        public ClassRef(BeanDefinition<T> definition) {\n+            this.target = definition.targetClass();\n+            this.prefix = target.getName();\n+            this.definition = definition;\n+        }\n+\n+        public ClassRef(Class<T> target) {\n+            this.target = target;\n+            this.prefix = target.getName();\n+            this.definition = null;\n+        }\n+\n+        public ClassRef(String prefix) {\n+            target = null;\n+            this.definition = null;\n+            this.prefix = prefix;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            ClassRef<?> that = (ClassRef<?>) o;\n+            return Objects.equals(target, that.target);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(target);\n+        }\n+    }\n+\n+    private static class ClassLookup {\n+        private ClassRef<?>[] namespaceIndex;\n+        private Map<Class<?>, ClassRef<?>[]> interfaceIndex;\n+        private Map<Class<?>, BeanDefinition<?>> definitions;\n+        private Map<Class<?>, ClassRef<?>[]> annotationIndex;\n+    }\n+}"
  },
  {
    "sha": "92a8b6d561e18600b7d8922af85ee6c2fa226316",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanIntercept.java",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanIntercept.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanIntercept.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanIntercept.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,11 @@\n+package org.terasology.gestalt.di;\n+\n+import org.terasology.context.AnnotationMetadata;\n+\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public interface BeanIntercept<R> {\n+    Optional<R> single(BeanKey key, AnnotationMetadata annotation);\n+    Optional<Stream<R>> collection(BeanKey key, AnnotationMetadata annotation);\n+}"
  },
  {
    "sha": "0c6fb8fc95123b49dfcb89f7be19c50c9f4414a8",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanKey.java",
    "status": "added",
    "additions": 126,
    "deletions": 0,
    "changes": 126,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanKey.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanKey.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanKey.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import org.terasology.context.AnnotationMetadata;\n+import org.terasology.context.BeanDefinition;\n+import org.terasology.context.EmptyAnnotationMetadata;\n+import org.terasology.gestalt.di.injection.Qualifier;\n+\n+import javax.annotation.Nonnull;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+/**\n+ * A key that is used to look up a Bean.\n+ * @param <T>\n+ */\n+public class BeanKey<T> implements Serializable, CharSequence {\n+    protected Class<? extends T> baseType;\n+    protected Class<T> implementingType;\n+    protected Class[] typeArguments;\n+    protected Qualifier<T> qualifier;\n+    protected AnnotationMetadata annotation = EmptyAnnotationMetadata.EMPTY_ARGUMENT;\n+    private int hashCode;\n+\n+    private void updateHash() {\n+        int result = 1;\n+        if (baseType == implementingType) {\n+            result = result * 31 + baseType.hashCode();\n+        } else {\n+            result = result * 31 + baseType.hashCode();\n+            result = result * 31 + implementingType.hashCode();\n+        }\n+        if (qualifier != null) {\n+            result = result * 31 + qualifier.hashCode();\n+        }\n+        this.hashCode = 31 * result + Arrays.hashCode(this.typeArguments);\n+    }\n+\n+    public BeanKey(Class<T> root) {\n+        this.baseType = root;\n+        this.implementingType = root;\n+        updateHash();\n+    }\n+\n+    public BeanKey<T> use(Class<T> target) {\n+        this.implementingType = target;\n+        updateHash();\n+        return this;\n+    }\n+\n+    public BeanKey<T> qualifiedBy(Qualifier<T> qualifier){\n+        this.qualifier = qualifier;\n+        updateHash();\n+        return this;\n+    }\n+\n+    public BeanKey<T> byArguments(Class... typeArguments) {\n+        this.typeArguments = typeArguments;\n+        updateHash();\n+        return this;\n+    }\n+\n+    public BeanKey<T> withAnnotations(AnnotationMetadata annotation) {\n+        this.annotation = annotation;\n+        return this;\n+    }\n+\n+    BeanKey(BeanDefinition<T> definition, Qualifier<T> qualifier) {\n+        this(definition.targetClass(), qualifier, definition.getTypeArgument());\n+    }\n+\n+    public BeanKey(Class<T> implementingBean, Class<? extends T> beanType, Qualifier<T> qualifier, Class... typeArguments) {\n+        this.baseType = beanType;\n+        this.implementingType = implementingBean;\n+        this.qualifier = qualifier;\n+        this.typeArguments = (typeArguments == null || typeArguments.length == 0) ? null : typeArguments;\n+        updateHash();\n+    }\n+\n+    public BeanKey(Class<T> beanType, Qualifier<T> qualifier, Class... typeArguments) {\n+        this(beanType, beanType, qualifier, typeArguments);\n+    }\n+\n+    public Class<? extends T> getBaseType() {\n+        return baseType;\n+    }\n+\n+    @Override\n+    @Nonnull\n+    public String toString() {\n+        return baseType.getName();\n+    }\n+\n+    @Override\n+    public int length() {\n+        return toString().length();\n+    }\n+\n+    @Override\n+    public char charAt(int i) {\n+        return toString().charAt(i);\n+    }\n+\n+    @Override\n+    public CharSequence subSequence(int i, int i1) {\n+        return toString().subSequence(i, i1);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        BeanKey<?> beanKey = (BeanKey<?>) o;\n+        return hashCode == beanKey.hashCode &&\n+            Objects.equals(implementingType, beanKey.implementingType) &&\n+            Objects.equals(baseType, beanKey.baseType) &&\n+            Arrays.equals(typeArguments, beanKey.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+}"
  },
  {
    "sha": "b7aee39fb99db98d8b669792828692610d6bc411",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanScanner.java",
    "status": "added",
    "additions": 10,
    "deletions": 0,
    "changes": 10,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanScanner.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanScanner.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanScanner.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+/**\n+ * A scanner interface that is used against {@link BeanEnvironment} to resolve definitions\n+ */\n+public interface BeanScanner {\n+    void apply(ServiceRegistry registry, BeanEnvironment environment);\n+}"
  },
  {
    "sha": "00f6b326d149d2edb980e828db2e9f84157e0d15",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/BeanUtilities.java",
    "status": "added",
    "additions": 55,
    "deletions": 0,
    "changes": 55,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanUtilities.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanUtilities.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/BeanUtilities.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import org.terasology.context.AnnotationMetadata;\n+import org.terasology.context.AnnotationValue;\n+import org.terasology.context.Argument;\n+import org.terasology.context.annotation.Scoped;\n+import org.terasology.context.annotation.Transient;\n+import org.terasology.gestalt.di.injection.Qualifier;\n+import org.terasology.gestalt.di.injection.Qualifiers;\n+\n+import javax.inject.Singleton;\n+import java.lang.annotation.Annotation;\n+\n+/**\n+ * A set of utilities that helps with examining {@link AnnotationMetadata}\n+ */\n+public final class BeanUtilities {\n+    private BeanUtilities() {\n+\n+    }\n+\n+    public static <T> BeanKey<? extends T> resolveBeanKey(Class<T> implClass, Class<? extends T> clazz, Argument<?> argument) {\n+        Qualifier<T> qualifier = Qualifiers.resolveQualifier(argument.getAnnotation());\n+        return new BeanKey(implClass, clazz, qualifier);\n+    }\n+\n+    public static <T> BeanKey<T> resolveBeanKey(Class<T> clazz, Argument<?> argument) {\n+        Qualifier<T> qualifier = Qualifiers.resolveQualifier(argument.getAnnotation());\n+        return new BeanKey(clazz, qualifier);\n+    }\n+\n+    public static Lifetime resolveLifetime(AnnotationMetadata metadata) {\n+        if (metadata.hasAnnotation(Singleton.class)) {\n+            return Lifetime.Singleton;\n+        } else if (metadata.hasAnnotation(Scoped.class)) {\n+            return Lifetime.Scoped;\n+        } else if (metadata.hasAnnotation(Transient.class)) {\n+            return Lifetime.Transient;\n+        }\n+\n+        if (metadata.hasStereotype(javax.inject.Qualifier.class)) {\n+            AnnotationValue<Annotation> ann = metadata.getAnnotationsByStereotype(javax.inject.Qualifier.class).stream().findFirst().get();\n+            if (ann.hasAnnotation(Singleton.class)) {\n+                return Lifetime.Singleton;\n+            } else if (ann.hasAnnotation(Scoped.class)) {\n+                return Lifetime.Scoped;\n+            } else if (ann.hasAnnotation(Transient.class)) {\n+                return Lifetime.Transient;\n+            }\n+        }\n+        return Lifetime.Transient;\n+    }\n+}"
  },
  {
    "sha": "e3a3e2752220de19e03c591fdc428c82e3d254f9",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanContext.java",
    "status": "added",
    "additions": 348,
    "deletions": 0,
    "changes": 348,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanContext.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanContext.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanContext.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,348 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import org.terasology.context.AbstractBeanDefinition;\n+import org.terasology.context.BeanDefinition;\n+import org.terasology.context.EmptyAnnotationMetadata;\n+import org.terasology.context.exception.BeanNotFoundException;\n+import org.terasology.gestalt.di.exceptions.BeanResolutionException;\n+import org.terasology.gestalt.di.injection.Qualifier;\n+import org.terasology.gestalt.di.instance.BeanProvider;\n+import org.terasology.gestalt.di.instance.ClassProvider;\n+import org.terasology.gestalt.di.instance.SupplierProvider;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class DefaultBeanContext implements AutoCloseable, BeanContext {\n+    protected final Map<BeanKey, Object> boundObjects = new HashMap<>();\n+    protected final Map<BeanKey, BeanProvider<?>> providers = new HashMap<>();\n+    protected final Multimap<Qualifier, BeanIntercept> beanInterceptMapping = HashMultimap.create();\n+    private final Multimap<Qualifier, BeanKey> qualifierMapping = HashMultimap.create();\n+    private final Multimap<Class, BeanKey> interfaceMapping = HashMultimap.create();\n+\n+    private final BeanContext parent;\n+    private final BeanEnvironment environment;\n+\n+    public DefaultBeanContext(BeanContext root, ServiceRegistry... registries) {\n+        this(root, new BeanEnvironment(), registries);\n+    }\n+\n+    public DefaultBeanContext(ServiceRegistry... registries) {\n+        this(null, new BeanEnvironment(), registries);\n+    }\n+\n+    public DefaultBeanContext(BeanContext parent, BeanEnvironment environment, ServiceRegistry... registries) {\n+        Preconditions.checkArgument(parent != this, \"bean context can't reference itself\");\n+        this.parent = parent;\n+        this.environment = environment;\n+        for (ServiceRegistry registry : registries) {\n+            this.bindRegistry(registry);\n+        }\n+    }\n+\n+    static <T> Optional<T> bindBean(DefaultBeanContext context, BeanKey identifier, Supplier<Optional<T>> supplier) {\n+        if (context.boundObjects.containsKey(identifier)) {\n+            return Optional.of((T) context.boundObjects.get(identifier));\n+        }\n+        Optional<T> result = supplier.get();\n+        result.ifPresent(t -> context.boundObjects.put(identifier, t));\n+        return result;\n+    }\n+\n+    private void bindRegistry(ServiceRegistry registry) {\n+        for (ClassLoader loader : registry.classLoaders) {\n+            this.environment.loadDefinitions(loader);\n+        }\n+        for (BeanScanner scanner : registry.scanners) {\n+            scanner.apply(registry, environment);\n+        }\n+        for (ServiceRegistry.InstanceExpression<?> expression : registry.instanceExpressions) {\n+            bindExpression(expression);\n+        }\n+        this.beanInterceptMapping.putAll(registry.intercepts);\n+\n+        // register self as a singleton instance that is scoped to current context\n+        bindExpression(new ServiceRegistry.InstanceExpression<>(BeanContext.class).lifetime(Lifetime.Singleton).use(() -> this));\n+    }\n+\n+    private <T> void bindExpression(ServiceRegistry.InstanceExpression<T> expression) {\n+        BeanKey<?> key = new BeanKey(expression.target)\n+                .use(expression.root)\n+                .qualifiedBy(expression.qualifier);\n+        if (expression.target == expression.root) {\n+            for (Class impl : expression.target.getInterfaces()) {\n+                interfaceMapping.put(impl, key);\n+            }\n+        } else {\n+            interfaceMapping.put(expression.root, key);\n+        }\n+        if (expression.qualifier != null) {\n+            qualifierMapping.put(expression.qualifier, key);\n+        }\n+\n+        if (expression.supplier == null) {\n+            providers.put(key, new ClassProvider(environment, expression.lifetime, expression.target));\n+        } else {\n+            providers.put(key, new SupplierProvider(environment, expression.lifetime, expression.target, expression.supplier));\n+        }\n+    }\n+\n+    @Override\n+    public <T> T inject(T instance) {\n+        BeanDefinition<T> definition = (BeanDefinition<T>) environment.getDefinition(instance.getClass());\n+        if (definition instanceof AbstractBeanDefinition) {\n+            return definition.inject(instance, new DefaultBeanResolution(this, environment)).get();\n+        }\n+        throw new BeanNotFoundException(\"unable to resolve BeanDefintion: \" + instance.getClass());\n+    }\n+\n+    @Override\n+    public <T> T getBean(BeanKey<T> identifier) {\n+        Optional<T> result = findBean(identifier);\n+        return result.orElseThrow(() -> new BeanResolutionException(identifier));\n+    }\n+\n+    @Override\n+    public <T> Optional<T> findBean(BeanKey<T> identifier) {\n+        Optional<BeanContext> cntx = Optional.of(this);\n+        while (cntx.isPresent()) {\n+            BeanContext beanContext = cntx.get();\n+            if (beanContext instanceof DefaultBeanContext) {\n+                DefaultBeanContext defContext = ((DefaultBeanContext) beanContext);\n+                Optional<T> target = defContext.internalResolve(identifier, this);\n+                if (target.isPresent()) {\n+                    return target;\n+                }\n+            }\n+            cntx = cntx.get().getParent();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private Optional<BeanKey> findConcreteBeanKey(BeanKey identifier) {\n+        List<BeanKey> beanKeys = getBeanKeys(identifier).collect(Collectors.toList());\n+        if(beanKeys.size() > 1){\n+            throw new BeanResolutionException(beanKeys);\n+        }\n+        return beanKeys.stream().findFirst();\n+    }\n+\n+    private Stream<BeanKey> getBeanKeys(BeanKey identifier) {\n+        Collection<BeanKey> result = null;\n+        if (providers.containsKey(identifier)) {\n+            return Stream.of(identifier);\n+        }\n+\n+        if (identifier.qualifier != null) {\n+            result = Sets.newHashSet(qualifierMapping.get(identifier.qualifier));\n+        }\n+\n+        if (identifier.baseType.isInterface()) {\n+            if (result != null) {\n+                Collection<BeanKey> implementing = interfaceMapping.get(identifier.baseType);\n+                if (implementing != null) {\n+                    result.retainAll(implementing);\n+                }\n+            } else {\n+                result = Sets.newHashSet(interfaceMapping.get(identifier.baseType));\n+            }\n+        } else if (identifier.baseType == identifier.implementingType) {\n+            Collection<BeanKey> implementing = interfaceMapping.get(identifier.baseType);\n+            for (Class implType : identifier.baseType.getInterfaces()) {\n+                Collection<BeanKey> temp = interfaceMapping.get(implType);\n+                if (temp == null || temp.size() == 0) {\n+                    continue;\n+                }\n+                implementing.addAll(temp.stream().filter(k -> k.baseType == identifier.baseType).collect(Collectors.toSet()));\n+            }\n+            if (result != null && implementing != null) {\n+                result.retainAll(implementing);\n+            } else if (implementing != null) {\n+                result = implementing;\n+            }\n+        } else {\n+            Collection<BeanKey> implementing = interfaceMapping.get(identifier.implementingType);\n+            if (result != null && implementing != null) {\n+                result.retainAll(implementing);\n+            } else if (implementing != null) {\n+                result = implementing.stream().filter(k -> k.baseType == identifier.baseType).collect(Collectors.toSet());\n+            }\n+        }\n+        if (result == null) {\n+            return Stream.of();\n+        }\n+        return result.stream();\n+    }\n+\n+    /**\n+     * @param identifier\n+     * @param targetContext the context that the object is being resolve to\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> Optional<T> internalResolve(BeanKey identifier, DefaultBeanContext targetContext) {\n+        Optional<BeanKey> key = findConcreteBeanKey(identifier);\n+\n+        if(identifier.annotation !=  EmptyAnnotationMetadata.EMPTY_ARGUMENT) {\n+            Collection<BeanIntercept> intercept = targetContext.beanInterceptMapping.get(identifier.qualifier);\n+            if (intercept != null) {\n+                for(BeanIntercept inter: intercept) {\n+                    Optional<T> result = inter.single(identifier, identifier.annotation);\n+                    if(result.isPresent()) {\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (key.isPresent()) {\n+            BeanProvider<T> provider = (BeanProvider<T>) providers.get(key.get());\n+            switch (provider.getLifetime()) {\n+                case Transient:\n+                    return provider.get(key.get(), this, targetContext);\n+                case Singleton:\n+                    return DefaultBeanContext.bindBean(this, key.get(), () -> provider.get(key.get(), this, targetContext));\n+                case Scoped:\n+                case ScopedToChildren:\n+                    if (provider.getLifetime() == Lifetime.ScopedToChildren && targetContext == this) {\n+                        return Optional.empty();\n+                    }\n+                    return DefaultBeanContext.bindBean(targetContext, key.get(), () -> provider.get(key.get(), this, targetContext));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    public <T> T getBean(Class<T> clazz) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz);\n+        return getBean(identifier);\n+    }\n+\n+    @Override\n+    public <T> Optional<T> findBean(Class<T> clazz) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz);\n+        return findBean(identifier);\n+    }\n+\n+    @Override\n+    public <T> T getBean(Class<T> clazz, Qualifier qualifier) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz)\n+            .qualifiedBy(qualifier);\n+        return getBean(identifier);\n+    }\n+\n+    @Override\n+    public <T> List<T> getBeans(BeanKey<T> identifier) {\n+        Optional<BeanContext> cntx = Optional.of(this);\n+        Stream<T> all = Stream.of();\n+        while (cntx.isPresent()) {\n+            BeanContext beanContext = cntx.get();\n+            if (beanContext instanceof DefaultBeanContext) {\n+                DefaultBeanContext defContext = ((DefaultBeanContext) beanContext);\n+                Stream<T> target = defContext.internalMultipleResolve(identifier, this);\n+                all = Stream.concat(all, target);\n+            }\n+            cntx = cntx.get().getParent();\n+        }\n+        return all.collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public <T> List<T> getBeans(Class<T> clazz) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz);\n+        return getBeans(identifier);\n+    }\n+\n+    @Override\n+    public <T> List<T> getBeans(Class<T> clazz, Qualifier qualifier) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz)\n+                .qualifiedBy(qualifier);\n+        return getBeans(identifier);\n+    }\n+\n+    private <T> Stream<T> internalMultipleResolve(BeanKey identifier, DefaultBeanContext targetContext) {\n+        return getBeanKeys(identifier)\n+                .map(key -> {\n+                    Collection<BeanIntercept> intercepts = targetContext.beanInterceptMapping.get(identifier.qualifier);\n+                    for(BeanIntercept intercept: intercepts) {\n+                        Optional<T> result = intercept.single(identifier, identifier.annotation);\n+                        if(result.isPresent()) {\n+                            return result;\n+                        }\n+                    }\n+\n+                    BeanProvider<T> provider = (BeanProvider<T>) providers.get(key);\n+                    switch (provider.getLifetime()) {\n+                        case Transient:\n+                            return provider.get(key, this, targetContext);\n+                        case Singleton:\n+                            return DefaultBeanContext.bindBean(this, key, () -> provider.get(key, this, targetContext));\n+                        case Scoped:\n+                        case ScopedToChildren:\n+                            if (provider.getLifetime() == Lifetime.ScopedToChildren && targetContext == this) {\n+                                return Optional.empty();\n+                            }\n+                            return DefaultBeanContext.bindBean(targetContext, key, () -> provider.get(key, this, targetContext));\n+                    }\n+                    return Optional.empty();\n+                })\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .map(b -> (T) b);\n+    }\n+\n+    @Override\n+    public <T> Optional<T> findBean(Class<T> clazz, Qualifier qualifier) {\n+        BeanKey<T> identifier = new BeanKey<>(clazz)\n+                .qualifiedBy(qualifier);\n+        return findBean(identifier);\n+    }\n+\n+\n+    @Override\n+    public BeanContext getNestedContainer() {\n+        return new DefaultBeanContext(this, environment);\n+    }\n+\n+    @Override\n+    public BeanContext getNestedContainer(ServiceRegistry... registries) {\n+        return new DefaultBeanContext(this, environment, registries);\n+    }\n+\n+    @Override\n+    public BeanEnvironment getEnvironment() {\n+        return environment;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        for (Object o : this.boundObjects.values()) {\n+            if (o instanceof AutoCloseable) {\n+                try {\n+                    ((AutoCloseable) o).close();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    throw e;\n+                }\n+            }\n+        }\n+    }\n+\n+    public Optional<BeanContext> getParent() {\n+        return Optional.ofNullable(parent);\n+    }\n+}"
  },
  {
    "sha": "94c1e485d5144838b3087bfd177b9473373c04eb",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanResolution.java",
    "status": "added",
    "additions": 60,
    "deletions": 0,
    "changes": 60,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanResolution.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanResolution.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/DefaultBeanResolution.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+import org.terasology.context.Argument;\n+import org.terasology.context.BeanResolution;\n+import org.terasology.context.SingleGenericArgument;\n+\n+import javax.inject.Provider;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default Bean Resolution for resolving dependencies against {@link org.terasology.context.BeanDefinition}\n+ *\n+ * Depdencies are resolved against {@link BeanContext} and provided to {@link org.terasology.context.BeanDefinition} when building dependency\n+ */\n+public class DefaultBeanResolution implements BeanResolution {\n+    private final BeanContext beanContext;\n+    private final BeanEnvironment environment;\n+\n+    public DefaultBeanResolution(BeanContext context, BeanEnvironment environment) {\n+        this.beanContext = context;\n+        this.environment = environment;\n+    }\n+\n+    @Override\n+    public <T> Optional<T> resolveConstructorArgument(Class<T> target, Argument<T> argument) {\n+        return getBean(target, argument);\n+    }\n+\n+    @Override\n+    public <T> Optional<T> resolveParameterArgument(Class<T> target, Argument<T> argument) {\n+        return getBean(target, argument);\n+    }\n+\n+    private <T> Optional<T> getBean(Class<T> target, Argument<T> argument) {\n+        if (argument instanceof SingleGenericArgument) {\n+            BeanKey<T> key = BeanUtilities.resolveBeanKey(argument.getType(), argument)\n+                    .withAnnotations(argument.getAnnotation());\n+            if (target.isAssignableFrom(Provider.class)) {\n+                return (Optional<T>) Optional.of((Provider<T>) () -> beanContext.getBean(key));\n+            } else if (target.isAssignableFrom(List.class)) {\n+                return (Optional<T>) Optional.ofNullable(beanContext.getBeans(key));\n+            } else if (target.isAssignableFrom(Collection.class)) {\n+                return (Optional<T>) Optional.ofNullable(beanContext.getBeans(key));\n+            } else if (target.isAssignableFrom(Set.class)) {\n+                return (Optional<T>) Optional.ofNullable(beanContext.getBeans(key).stream().collect(Collectors.toSet()));\n+            }\n+            throw new UnsupportedOperationException(\"Cannot resolve field with type \"+ target);\n+        } else {\n+            BeanKey<T> key = BeanUtilities.resolveBeanKey(target, argument)\n+                    .withAnnotations(argument.getAnnotation());\n+            return beanContext.findBean(key);\n+        }\n+    }\n+}"
  },
  {
    "sha": "5c5c22379417048f1d61b7ead8b86e00b5047d25",
    "filename": "gestalt-di/src/main/java/org/terasology/gestalt/di/Lifetime.java",
    "status": "added",
    "additions": 18,
    "deletions": 0,
    "changes": 18,
    "blob_url": "https://github.com/MovingBlocks/gestalt/blob/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/Lifetime.java",
    "raw_url": "https://github.com/MovingBlocks/gestalt/raw/65ece5925ab6bcddb0ee314b64012efa1e2a8eea/gestalt-di/src/main/java/org/terasology/gestalt/di/Lifetime.java",
    "contents_url": "https://api.github.com/repos/MovingBlocks/gestalt/contents/gestalt-di/src/main/java/org/terasology/gestalt/di/Lifetime.java?ref=65ece5925ab6bcddb0ee314b64012efa1e2a8eea",
    "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2021 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.gestalt.di;\n+\n+/**\n+ * lifetime scope drives how persistent a bean will and how it will be reused between different scopes. a child scope that redfined a bean will shadow its parents even if a\n+ * parent scope has a singleton objects.\n+ * <p>- Scoped --&gt; A single instance is defined for every nested scope. (A --&gt; B --&gt; C) a scoped instanced defined at B will create a new single instance in C and B</p>\n+ * <p>- ScopedToChildren --&gt; A new instance is defined for every nested scope except the one its defined in.   (A --&gt; B --&gt; C --&gt; D) a scoped instanced defined at B will create a new single instance in C and D</p>\n+ * <p>- Singleton --&gt; A single instance is defined and visible to all children.</p>\n+ * <p>- Transient --&gt; A new object is always returned if requested. </p>\n+ */\n+public enum Lifetime {\n+    Scoped,\n+    ScopedToChildren,\n+    Singleton,\n+    Transient\n+}"
  }
]
