[
  {
    "sha": "5008ddfcf53c02e82d7eee2e57c38e5672ef89f6",
    "filename": ".DS_Store",
    "status": "added",
    "additions": 0,
    "deletions": 0,
    "changes": 0,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/.DS_Store",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/.DS_Store",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/.DS_Store?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578"
  },
  {
    "sha": "881cef0c48663b5116457d469ce581372349a140",
    "filename": "Backend.java",
    "status": "modified",
    "additions": 235,
    "deletions": 236,
    "changes": 471,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Backend.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Backend.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/Backend.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -1,13 +1,8 @@\n // --==   Backend   ==--\n // Name: Jacob Ranheim\n // Email: jranheim@wisc.edu\n-<<<<<<< HEAD\n // Team: KG blue\n // Role: Backend Developer\n-=======\n-// Team: blue\n-// Group: KG\n->>>>>>> 1a9c071fd6942a5a75370d49c071e1c056b73187\n // TA: Keren Chen\n // Lecturer: Gary Dahl\n // Notes to Grader:\n@@ -25,265 +20,269 @@\n \n public class Backend implements BackendInterface {\n \n-        //genres to sort by\n-        private List<String> genres =  new ArrayList<String>();\n-        //ratings to sort by\n-        private List<String> ratings = new ArrayList<String>();\n-        //list of all movies and list of each movies genres\n-        private List<List<String>> allGenres = new ArrayList<List<String>>();\n-        //all movies in data set\n-        private List<MovieInterface> movies = new ArrayList<MovieInterface>();\n-        //names of genres to be used as keys\n-        private List<String> keyGenres = new ArrayList<String>();\n-        //list of genres of movies for hash\n-        private List<List<MovieInterface>> keyMovies = new ArrayList<List<MovieInterface>>();\n-        //list of all movies found from genre and rating search\n-\tprivate List<MovieInterface> searchMovies = new ArrayList<MovieInterface>();\n-\t//HashTableMap containing key(genres) and value(movies)\n-\tprivate HashTableMap m = new HashTableMap();\n+    //genres to sort by\n+    private List<String> genres =  new ArrayList<String>();\n+    //ratings to sort by\n+    private List<String> ratings = new ArrayList<String>();\n+    //list of all movies and list of each movies genres\n+    private List<List<String>> allGenres = new ArrayList<List<String>>();\n+    //all movies in data set\n+    private List<MovieInterface> movies = new ArrayList<MovieInterface>();\n+    //names of genres to be used as keys\n+    private List<String> keyGenres = new ArrayList<String>();\n+    //list of genres of movies for hash\n+    private List<List<MovieInterface>> keyMovies = new ArrayList<List<MovieInterface>>();\n+    //list of all movies found from genre and rating search\n+    private List<MovieInterface> searchMovies = new ArrayList<MovieInterface>();\n+    //HashTableMap containing key(genres) and value(movies)\n+    private HashTableMap m = new HashTableMap();\n+    // list of all movies with genre AND rating\n+    private List<MovieInterface> searchGR = new ArrayList<MovieInterface>();\n \n-\t/**\n-         * construstor to get list of movies, and initialize hash table with movies\n-         * using genre as a key and a list of movies containing that genre as the value\n-         *\n-         * @param k - file path to make string reader to pass to data wrangler to get list of movies\n-         */\n-\tpublic Backend(String k) throws FileNotFoundException, IOException{\n-\t\n-\t\tString data = \"\";\n+    /**\n+     * construstor to get list of movies, and initialize hash table with movies\n+     * using genre as a key and a list of movies containing that genre as the value\n+     *\n+     * @param k - file path to make string reader to pass to data wrangler to get list of movies\n+     */\n+    public Backend(String k) throws FileNotFoundException, IOException{\n \n-\t\ttry{\n-\t\t\tFile file = new File(k);\n-      \t\t\tScanner myReader = new Scanner(file);\n-\t\t\n-\t\t\twhile (myReader.hasNextLine()) {\n-        \t\t\tdata += myReader.nextLine();\n-      \t\t\t}\t\n-      \t\t\tmyReader.close();\n+        String data = \"\";\n \n-\t\t} catch (FileNotFoundException e) {\n-      \t\t\tSystem.out.println(\"An error occurred.\");\n-      \t\t\te.printStackTrace(); \n- \t\t}\n+        try{\n+            File file = new File(k);\n+            Scanner myReader = new Scanner(file);\n \n-\t\tStringReader sr = new StringReader(data);\n+            while (myReader.hasNextLine()) {\n+                data += myReader.nextLine();\n+            }\n+            myReader.close();\n \n-\t\t//change to data wrangler class for project\n-\t\tMovieDataReaderDummy reader = new MovieDataReaderDummy();\n-                movies = reader.readDataSet(sr);\n-\t\t//get first movie to list\n-\t\tfor(int i = 0; i < movies.size(); i++){\n-\t\t\t//add movies genres to a list of each movie genre\n-                        allGenres.add(movies.get(i).getGenres());\n-\t\t\t//get each genre for each movie\n-                        for(int j = 0; j < allGenres.get(i).size(); j++){\n-                                String genre = allGenres.get(i).get(j);\n-\t\t\t\t//if genre is not already a key add it and list of movies for value\n-                                if(!(keyGenres.contains(genre))){\n-                                        keyGenres.add(genre);\n-                                        List<MovieInterface> g = new ArrayList<MovieInterface>();\n-                                        keyMovies.add(g);\n-                                        int index = keyMovies.indexOf(g);\n-                                        keyMovies.get(index).add(movies.get(i));\n-                                }\n-\t\t\t\t//genre already in key, add movie to list for value\n-                                else{\n-                                        int index = keyGenres.indexOf(genre);\n-                                        keyMovies.get(index).add(movies.get(i));\n-                                }\n-                        }\n-                }\n-\t\t//add key and value to hash table for each genre\n-                for(int i = 0; i < keyGenres.size(); i++){\n-                        m.put(keyGenres.get(i), keyMovies.get(i));\n-                }\n-\t}\n-\n-\t/**\n-\t * construstor to get list of movies, and initialize hash table with movies\n-\t * using genre as a key and a list of movies containing that genre as the value\n-\t *\n-\t * @param s - string reader to pass to data wrangler to get list of movies\n-\t */\n-        public Backend(StringReader s) throws FileNotFoundException, IOException {\n-\t\t//change to data wrangler for project\n-\t\tMovieDataReaderDummy reader = new MovieDataReaderDummy();\n-                movies = reader.readDataSet(s);\n-\t\t//get first movie to list\n-                for(int i = 0; i < movies.size(); i++){\n-\t\t\t//add movies genres to a list of each movie genre\n-                        allGenres.add(movies.get(i).getGenres());\n-\t\t\t//get each genre for each movie\n-                        for(int j = 0; j < allGenres.get(i).size(); j++){\n-                                String genre = allGenres.get(i).get(j);\n-\t\t\t\t//if genre is not already a key add it and list of movies for value\n-                                if(!(keyGenres.contains(genre))){\n-                                        keyGenres.add(genre);\n-                                        List<MovieInterface> g = new ArrayList<MovieInterface>();\n-\t\t\t\t\tkeyMovies.add(g);\n-\t\t\t\t\tint index = keyMovies.indexOf(g);\n-\t\t\t\t\tkeyMovies.get(index).add(movies.get(i));\n-                                }\n-\t\t\t\t//genre already in key, add movie to list for value\n-\t\t\t\telse{\n-\t\t\t\t\tint index = keyGenres.indexOf(genre);\n-\t\t\t\t\tkeyMovies.get(index).add(movies.get(i));\n-\t\t\t\t}\n-                        }\n-                }\n-                //add key and value to hash table for each genre\n-\t\tfor(int i = 0; i < keyGenres.size(); i++){\n-\t\t\tm.put(keyGenres.get(i), keyMovies.get(i));\n-\t\t}\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"An error occurred.\");\n+            e.printStackTrace();\n         }\n \n-\t/**\n-\t * add genre to the list of genres to search for\n-\t */\n-\t@Override\n-        public void addGenre(String genre){\n-                genres.add(genre);\n-        }\n-\t\n-\t/**\n-\t * add rating to the list of ratings to search for\n-\t */\n-\t@Override\n-        public void addAvgRating(String rating){\n-                ratings.add(rating);\n-        }\n+        StringReader sr = new StringReader(data);\n \n-\t/**\n-\t * remove genre in list of genres to search for\n-\t */\n-\t@Override\n-        public void removeGenre(String genre){\n-                if(genres.indexOf(genre) < 0){\n-\t\t\tSystem.out.println(\"genre not in list\");\n+        //change to data wrangler class for project\n+        MovieDataReaderDummy reader = new MovieDataReaderDummy();\n+        movies = reader.readDataSet(sr);\n+        //get first movie to list\n+        for(int i = 0; i < movies.size(); i++){\n+            //add movies genres to a list of each movie genre\n+            allGenres.add(movies.get(i).getGenres());\n+            //get each genre for each movie\n+            for(int j = 0; j < allGenres.get(i).size(); j++){\n+                String genre = allGenres.get(i).get(j);\n+                //if genre is not already a key add it and list of movies for value\n+                if(!(keyGenres.contains(genre))){\n+                    keyGenres.add(genre);\n+                    List<MovieInterface> g = new ArrayList<MovieInterface>();\n+                    keyMovies.add(g);\n+                    int index = keyMovies.indexOf(g);\n+                    keyMovies.get(index).add(movies.get(i));\n                 }\n+                //genre already in key, add movie to list for value\n                 else{\n-                        int index = genres.indexOf(genre);\n-                        genres.remove(index);\n+                    int index = keyGenres.indexOf(genre);\n+                    keyMovies.get(index).add(movies.get(i));\n                 }\n+            }\n+        }\n+        //add key and value to hash table for each genre\n+        for(int i = 0; i < keyGenres.size(); i++){\n+            m.put(keyGenres.get(i), keyMovies.get(i));\n         }\n+    }\n \n-\t/**\n-\t * remove rating in list of ratings to search for\n-\t */\n-\t@Override\n-        public void removeAvgRating(String rating){\n-                 if(rating.indexOf(rating) < 0){\n-                        System.out.println(\"rating not in list\");\n+    /**\n+     * construstor to get list of movies, and initialize hash table with movies\n+     * using genre as a key and a list of movies containing that genre as the value\n+     *\n+     * @param s - string reader to pass to data wrangler to get list of movies\n+     */\n+    public Backend(StringReader s) throws FileNotFoundException, IOException {\n+        //change to data wrangler for project\n+        MovieDataReaderDummy reader = new MovieDataReaderDummy();\n+        movies = reader.readDataSet(s);\n+        //get first movie to list\n+        for(int i = 0; i < movies.size(); i++){\n+            //add movies genres to a list of each movie genre\n+            allGenres.add(movies.get(i).getGenres());\n+            //get each genre for each movie\n+            for(int j = 0; j < allGenres.get(i).size(); j++){\n+                String genre = allGenres.get(i).get(j);\n+                //if genre is not already a key add it and list of movies for value\n+                if(!(keyGenres.contains(genre))){\n+                    keyGenres.add(genre);\n+                    List<MovieInterface> g = new ArrayList<MovieInterface>();\n+                    keyMovies.add(g);\n+                    int index = keyMovies.indexOf(g);\n+                    keyMovies.get(index).add(movies.get(i));\n                 }\n+                //genre already in key, add movie to list for value\n                 else{\n-                        int index = ratings.indexOf(rating);\n-                        ratings.remove(index);\n+                    int index = keyGenres.indexOf(genre);\n+                    keyMovies.get(index).add(movies.get(i));\n                 }\n+            }\n         }\n-\n-\t/**\n-\t * get and return list of genres that user has inputted to search\n-\t *\n-\t * @return list of genres in the search\n-\t */\n-\t@Override\n-        public List<String> getGenres(){\n-                return genres;\n+        //add key and value to hash table for each genre\n+        for(int i = 0; i < keyGenres.size(); i++){\n+            m.put(keyGenres.get(i), keyMovies.get(i));\n         }\n+    }\n+\n+    /**\n+     * add genre to the list of genres to search for\n+     */\n+    @Override\n+    public void addGenre(String genre){\n+        genres.add(genre);\n+    }\n+\n+    /**\n+     * add rating to the list of ratings to search for\n+     */\n+    @Override\n+    public void addAvgRating(String rating){\n+        ratings.add(rating);\n+    }\n \n-\t/**\n-         * get and return list of ratings that user has inputted to search\n-         *\n-         * @return list of ratings  in the search\n-         */\n-\t@Override\n-        public List<String> getAvgRatings(){\n-                return ratings;\n+    /**\n+     * remove genre in list of genres to search for\n+     */\n+    @Override\n+    public void removeGenre(String genre){\n+        if(genres.indexOf(genre) < 0){\n+            System.out.println(\"genre not in list\");\n         }\n-\t\n-\t/**\n-\t * sort movies from hashtable to find the number of movies in the \n-\t * hash table that have the selected genre and rating\n-\t *\n-\t * @return number of movies found in the search for genre and rating\n-\t */\n-\t@Override\n-        public int getNumberOfMovies(){\n-\t\tif(genres.size() == 0){\n-\t\t\treturn 0;\n-\t\t}\n-\t\telse{\n+        else{\n+            int index = genres.indexOf(genre);\n+            genres.remove(index);\n+        }\n+    }\n \n-\t\t\t//get all movies with selected genre\n-\t\t\tfor(int i = 0; i < keyGenres.size(); i++){\n-\t\t\t\tList<MovieInterface> movie;\n-\t\t\t\t//if the selected genre is in the key, get the genre\n-\t\t\t\tif(genres.contains(keyGenres.get(i))){\n-\t\t\t\t\tmovie = (List<MovieInterface>) m.get(keyGenres.get(i));\n-\t\t\t\t\t//look through movies with genre and see if movie is already in search\n-\t\t\t\t\tfor(int j = 0; j < movie.size(); j++){\n-\t\t\t\t\t\tif(!searchMovies.contains(movie.get(j))){\n-\t\t\t\t\t\t\tsearchMovies.add(movie.get(j));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t//iterate through movies with selected genre\n-\t\t\tfor(int i = 0; i < searchMovies.size(); i++){\n-\t\t\t\t//iterate through selected ratings\n-\t\t\t\tfor(int j = 0; j < ratings.size(); j++){\n-\t\t\t\t\tif(ratings.size() == 0){\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\tFloat rating = searchMovies.get(i).getAvgVote();\n-\t\t\t\t\t//check if movie rating is high enough\n-\t\t\t\t\tint n = Integer.parseInt(ratings.get(j));\n-\t\t\t\t\tif((rating - n) < 0){\n-\t\t\t\t\t\tsearchMovies.remove(i);\n-\t\t\t\t\t}\t\n-\t\t\t\t}\n-\t\t\t}\t\t\t\n-\t\t\t//sort movies by rating\n-\t\t\tCollections.sort(searchMovies);\t\t\n-\t\t\treturn searchMovies.size();\n-\t\t}\n+    /**\n+     * remove rating in list of ratings to search for\n+     */\n+    @Override\n+    public void removeAvgRating(String rating){\n+        if(rating.indexOf(rating) < 0){\n+            System.out.println(\"rating not in list\");\n+        }\n+        else{\n+            int index = ratings.indexOf(rating);\n+            ratings.remove(index);\n         }\n+    }\n+\n+    /**\n+     * get and return list of genres that user has inputted to search\n+     *\n+     * @return list of genres in the search\n+     */\n+    @Override\n+    public List<String> getGenres(){\n+        return genres;\n+    }\n \n-\t/**\n-\t * get all the genres in the hash table\n-\t *\n-\t * @return list of all genres in hash table\n-\t */\n-\t@Override\n-        public List<String> getAllGenres(){\n-                return keyGenres;\n+    /**\n+     * get and return list of ratings that user has inputted to search\n+     *\n+     * @return list of ratings  in the search\n+     */\n+    @Override\n+    public List<String> getAvgRatings(){\n+        return ratings;\n+    }\n+\n+    /**\n+     * sort movies from hashtable to find the number of movies in the\n+     * hash table that have the selected genre and rating\n+     *\n+     * @return number of movies found in the search for genre and rating\n+     */\n+    @Override\n+    public int getNumberOfMovies(){\n+\n+        if(genres.size() == 0){\n+            return 0;\n         }\n \n-\t/**\n-\t * get three movies of genre and rating starting at index given\n-\t *\n-\t * @param startingIndex - index to start list of returned movies of\n-\t * @return list of at most three movies containing genre and rating\n-\t * \t   starting at index \n-\t */\n-\t@Override\n-        public List<MovieInterface> getThreeMovies(int startingIndex){\n-\t\tint size = getNumberOfMovies();\t\t\n-\t\tList<MovieInterface> threeMovies = new ArrayList<MovieInterface>();\n+        else{\n+            //get all movies with selected genre\n+            for(int i = 0; i < keyGenres.size(); i++){\n+                List<MovieInterface> movie;\n+                //if the selected genre is in the key, get the genre\n+                if(genres.contains(keyGenres.get(i))){\n+                    movie = (List<MovieInterface>) m.get(keyGenres.get(i));\n+                    //look through movies with genre and see if movie is already in search\n+                    for(int j = 0; j < movie.size(); j++){\n+                        if(!searchMovies.contains(movie.get(j))){\n+                            searchMovies.add(movie.get(j));\n+                        }\n+                    }\n+                }\n+            }\n+            //iterate through movies with selected genre\n+            for(int i = 0; i < searchMovies.size(); i++){\n+                if(ratings.size() == 0){\n+                    searchGR = searchMovies;\n+                    break;\n+                }\n \n-\t\tfor(int i = 0; i < 3; i++){\n-\t\t\t//if starting index and i greater than number of movies searched,\n-\t\t\t//list is over and return list\n-\t\t\tif(startingIndex + i >= size){\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\t\tthreeMovies.add(searchMovies.get(startingIndex + i));\n-\t\t}\n+                //iterate through selected ratings\n \n-\t\treturn threeMovies;\n+                for(int j = 0; j < ratings.size(); j++){\n+                    Float rating = searchMovies.get(i).getAvgVote();\n+                    //check if movie rating is high enough\n+                    int n = Integer.parseInt(ratings.get(j));\n+                    if((n - rating) <= 0 && (n - rating > -1) && !searchGR.contains(searchMovies.get(i))){\n+                        searchGR.add(searchMovies.get(i));\n+                    }\n+                }\n+            }\n+            //sort movies by rating\n+            Collections.sort(searchGR);\n+            //System.out.println(searchMovies.get(0).getTitle());\n+            return searchGR.size();\n         }\n+    }\n \n-}\n+    /**\n+     * get all the genres in the hash table\n+     *\n+     * @return list of all genres in hash table\n+     */\n+    @Override\n+    public List<String> getAllGenres(){\n+        return keyGenres;\n+    }\n+\n+    /**\n+     * get three movies of genre and rating starting at index given\n+     *\n+     * @param startingIndex - index to start list of returned movies of\n+     * @return list of at most three movies containing genre and rating\n+     * \t   starting at index\n+     */\n+    @Override\n+    public List<MovieInterface> getThreeMovies(int startingIndex){\n+        int size = getNumberOfMovies();\n+        List<MovieInterface> threeMovies = new ArrayList<MovieInterface>();\n+\n+        for(int i = 0; i < 3; i++){\n+            //if starting index and i greater than number of movies searched,\n+            //list is over and return list\n+            if(startingIndex + i >= size){\n+                break;\n+            }\n+            threeMovies.add(searchGR.get(startingIndex + i));\n+        }\n \n+        return threeMovies;\n+    }\n \n+}\n\\ No newline at end of file"
  },
  {
    "sha": "3401182e400e0f72e545fd85adf34c0bc808c00c",
    "filename": "BackendInterface.java",
    "status": "modified",
    "additions": 10,
    "deletions": 10,
    "changes": 20,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/BackendInterface.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/BackendInterface.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/BackendInterface.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -8,14 +8,14 @@\n //        in spring 2021.\n public interface BackendInterface {\n \n-\tpublic void addGenre(String genre);\n-\tpublic void addAvgRating(String rating);\n-\tpublic void removeGenre(String genre);\n-\tpublic void removeAvgRating(String rating);\n-\tpublic List<String> getGenres();\n-\tpublic List<String> getAvgRatings();\n-\tpublic int getNumberOfMovies();\n-\tpublic List<String> getAllGenres();\n-\tpublic List<MovieInterface> getThreeMovies(int startingIndex);\n+    public void addGenre(String genre);\n+    public void addAvgRating(String rating);\n+    public void removeGenre(String genre);\n+    public void removeAvgRating(String rating);\n+    public List<String> getGenres();\n+    public List<String> getAvgRatings();\n+    public int getNumberOfMovies();\n+    public List<String> getAllGenres();\n+    public List<MovieInterface> getThreeMovies(int startingIndex);\n \n-}\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "589acec2686a1c631d67cc77c18cdb9f097f915d",
    "filename": "Frontend.java",
    "status": "modified",
    "additions": 81,
    "deletions": 44,
    "changes": 125,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Frontend.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Frontend.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/Frontend.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -1,60 +1,97 @@\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.PrintStream;\n import java.util.Scanner;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.zip.DataFormatException;\n \n /**\n- * This class instantiates a Frontend that the user can interact with to \n+ * This class instantiates a Frontend that the user can interact with to\n  * browse a movie collection and search by certain variables.\n  */\n public class Frontend {\n \n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws IOException, DataFormatException {\n         Scanner input = new Scanner(System.in);\n-        enterBaseMode();\n-        \n+        Backend backend = new Backend(\"src/movies.csv\");\n+        enterBaseMode(backend);\n+\n     }\n-/**\n- * This method is the Base Mode of the Movie Mapper, which is what the user sees \n- * on startup and also how they see the list of top three movies.\n- */    \n-    public void enterBaseMode() {\n-          System.out.println(\"Welcome to the Movie Mapper! To see movies within a specific genre(s), you can input 'g' to enter Genre Selection Mode. To see movies with a specific average user rating, you can input 'r' to enter Ratings Selection Mode. To quit the Movie Mapper, you can input 'x'.\");\n-          \n-          // Display top3movies here.\n-          \n-          // Scan for user input.\n-          String str = scan.nextLine();\n-          if ((str.equals(\"g\")) {\n-              enterGenreMode();\n-          } else if ((str.equals(\"r\")) {\n-              enterRatingsMode();\n-          } else if ((str.equals(\"x\")) {\n-              return;\n-          } else {\n-              System.out.println(\"Invalid input. Please try again.\");\n-              enterBaseMode(); \n-          }\n+    // Class constructor\n+    public Frontend() {\n+        List<MovieInterface> movieResults = new ArrayList<MovieInterface>();\n     }\n \n-/**\n- * This method is the Genre Selection Mode of the Movie Mapper, which is what the user sees \n- * after inputting 'g' to the console. Here the user can sort the top 3 movies by genre. If \n- * multiple genres are selected, only movies belonging to BOTH genres are shown.\n- */     \n-    public void enterGenreMode() {\n-    \n-    \n+\n+    /**\n+     * This method is the Base Mode of the Movie Mapper, which is what the user sees\n+     * on startup and also how they see the list of top three movies.\n+     */\n+    public static void enterBaseMode(Backend backend) {\n+        System.out.println(\"Welcome to the Movie Mapper! To see movies within a specific genre(s), you can input 'g' to enter Genre Selection Mode. To see movies with a specific average user rating, you can input 'r' to enter Ratings Selection Mode. To quit the Movie Mapper, you can input 'x'.\");\n+\n+        backend.getThreeMovies(0);\n+        Scanner s1 = new Scanner(System.in);\n+        // Scan for user input.\n+        String str = s1.nextLine();\n+        if ((str.equals(\"g\"))) {\n+            enterGenreMode(backend);\n+        } else if ((str.equals(\"r\"))) {\n+            enterRatingsMode(backend);\n+        } else if ((str.equals(\"x\"))) {\n+            return;\n+        } else {\n+            System.out.println(\"Invalid input. Please try again.\");\n+            enterBaseMode(backend);\n+        }\n     }\n-    \n-/**\n- * This method is the Ratings Selection Mode of the Movie Mapper, which is what the user sees \n- * after inputting 'r' to the console. Here the user can sort the top 3 movies by average rating. If \n- * multiple ratings are selected, movies of any selected rating can be shown.\n- */     \n-    public void enterRatingsMode() {\n-    \n-    \n-    }    \n-    \n \n+    /**\n+     * This method is the Genre Selection Mode of the Movie Mapper, which is what the user sees\n+     * after inputting 'g' to the console. Here the user can sort the top 3 movies by genre. If\n+     * multiple genres are selected, only movies belonging to BOTH genres are shown.\n+     */\n+    public static void enterGenreMode(Backend backend) {\n+        System.out.println(\"Below is a list of genres to narrow down your movie search. Input the number next to the genre you'd like to select to select/deselect it. The number next to currently selected genres will appear with parenthesis on both sides of the number. You may choose multiple genres to narrow down your search to movies belonging to ALL selected genres. To return to the previous screen, you may input 'x'.\");\n+        List<String> selG = backend.getAllGenres();\n+        for(int i = 0; i < selG.size(); i++)  {\n+            System.out.println(i+1 +\" \" + selG.get(i));\n+        }\n+        Scanner s1 = new Scanner(System.in);\n+        String str = s1.nextLine();\n+        if ((str.equals(\"x\"))) {\n+            enterBaseMode(backend);\n+        }\n+\n+        try{\n+            int i = Integer.parseInt(str);\n+            if(i <= selG.size() && i > 0)  {\n+                String genre = selG.get(i-1);\n+                backend.addGenre(genre);\n+                List<MovieInterface> mov = backend.getThreeMovies(0);\n+                for(int k = 0; k < mov.size(); k++)  {\n+                    System.out.println(mov.get(k).getTitle() + \" Rating \" + mov.get(k).getAvgVote());\n+                }\n+            }\n+            else { System.out.println(i + \" is not an acceptable value!\");}\n+        }\n+        catch (NumberFormatException e) {\n+            System.out.println(\"Value provided is not a number!\");\n+        }\n+    }\n+\n+    /**\n+     * This method is the Ratings Selection Mode of the Movie Mapper, which is what the user sees\n+     * after inputting 'r' to the console. Here the user can sort the top 3 movies by average rating. If\n+     * multiple ratings are selected, movies of any selected rating can be shown.\n+     */\n+    public static void enterRatingsMode(Backend backend) {\n+        System.out.println(\"Below is a list of ratings to narrow down your movie search. Input the number that is next to the rating you'd like to select to select/deselect it. The number next to currently selected ratings will appear with parenthesis on both sides of the number. You may choose multiple ratings to narrow down your search to movies belonging to ANY selected ratings. To return to the previous screen, you may input 'x'.\");\n+        Scanner s1 = new Scanner(System.in);\n+        String str = s1.nextLine();\n+        if ((str.equals(\"x\"))) {\n+            enterBaseMode(backend);\n+        }\n+    }\n }\n\\ No newline at end of file"
  },
  {
    "sha": "f9471c4459ffdfdf6e07af4a47e7e64f058cf2f3",
    "filename": "HashNode.java",
    "status": "modified",
    "additions": 30,
    "deletions": 30,
    "changes": 60,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/HashNode.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/HashNode.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/HashNode.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -9,36 +9,36 @@\n import java.util.LinkedList;\n \n public class  HashNode<KeyType, ValueType>{\n-\t\n-        KeyType key;\n-        ValueType value;\n-\t/**\n-\t * Contructor to set key and value of node \n-\t *\n-\t * @param k - key to be put in node\n-\t * @param v - value to be put in node\n-\t */\n-        public HashNode(KeyType k, ValueType v){\n \n-                key = k;\n-                value = v;\n-        }\n+    KeyType key;\n+    ValueType value;\n+    /**\n+     * Contructor to set key and value of node\n+     *\n+     * @param k - key to be put in node\n+     * @param v - value to be put in node\n+     */\n+    public HashNode(KeyType k, ValueType v){\n \n-\t/**\n-\t * get the key of the node\n-\t *\n-\t * @return key\n-\t */\n-\tpublic KeyType getKey(){\n-\t\treturn key;\n-\t}\n+        key = k;\n+        value = v;\n+    }\n \n-\t/**\n-         * get the node of the node\n-         *\n-         * @return node\n-         */\n-\tpublic ValueType getValue(){\n-\t\treturn value;\n-\t}\n-}\n+    /**\n+     * get the key of the node\n+     *\n+     * @return key\n+     */\n+    public KeyType getKey(){\n+        return key;\n+    }\n+\n+    /**\n+     * get the node of the node\n+     *\n+     * @return node\n+     */\n+    public ValueType getValue(){\n+        return value;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "c6bfcbea97a54943b41e93178b7aaafb6378f001",
    "filename": "HashTableMap.java",
    "status": "modified",
    "additions": 208,
    "deletions": 208,
    "changes": 416,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/HashTableMap.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/HashTableMap.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/HashTableMap.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -12,216 +12,216 @@\n \n public class HashTableMap <KeyType, ValueType> implements MapADT <KeyType, ValueType>{\n \n-\t// number of key value pairs\n-        private int size;\n-\t// number of buckets in array\n-\tprivate int numBuckets;\n-        // array of buckets containing key pairs\n-\tprivate LinkedList<HashNode>[] buckets;\n-\t// array2 used during resize\n-\tprivate LinkedList<HashNode>[] buckets2;\n-\t\n-\t/**\n-\t * Contructor with hash table size capacity, set size\n-\t * to 0, and numBuckets to capacity\n-\t *\n-\t * @param capacity - initial capacity of hash table \n-\t */\n-\tpublic HashTableMap(int capacity){\n-\t\t\n-\t\tbuckets = (LinkedList<HashNode>[]) new LinkedList[capacity];\n-\n-                numBuckets = capacity;\n-\t\tsize = 0;\n-\t\t\n-\t\t//put linked list in each index of array\n-\t\tfor(int i = 0; i<capacity; i++){\n-\t\t\tbuckets[i] = new LinkedList<HashNode>();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Contructor with default hash table size 10, set size \n-\t * to 0, and numBuckets to default size 10\n-\t *\n-\t */\n-\tpublic HashTableMap(){\n-\t\n-\t\tbuckets = (LinkedList<HashNode>[]) new LinkedList[10];\n-\n-       \t        numBuckets = 10;\n-               \tsize = 0;\n-\t\t\n-\t\t//put linked list in each index of array\n-               \tfor(int i = 0; i<10; i++){\n-                       \tbuckets[i] = new LinkedList<HashNode>();\n-               \t}\n+    // number of key value pairs\n+    private int size;\n+    // number of buckets in array\n+    private int numBuckets;\n+    // array of buckets containing key pairs\n+    private LinkedList<HashNode>[] buckets;\n+    // array2 used during resize\n+    private LinkedList<HashNode>[] buckets2;\n+\n+    /**\n+     * Contructor with hash table size capacity, set size\n+     * to 0, and numBuckets to capacity\n+     *\n+     * @param capacity - initial capacity of hash table\n+     */\n+    public HashTableMap(int capacity){\n+\n+        buckets = (LinkedList<HashNode>[]) new LinkedList[capacity];\n+\n+        numBuckets = capacity;\n+        size = 0;\n+\n+        //put linked list in each index of array\n+        for(int i = 0; i<capacity; i++){\n+            buckets[i] = new LinkedList<HashNode>();\n+        }\n+    }\n+\n+    /**\n+     * Contructor with default hash table size 10, set size\n+     * to 0, and numBuckets to default size 10\n+     *\n+     */\n+    public HashTableMap(){\n+\n+        buckets = (LinkedList<HashNode>[]) new LinkedList[10];\n+\n+        numBuckets = 10;\n+        size = 0;\n+\n+        //put linked list in each index of array\n+        for(int i = 0; i<10; i++){\n+            buckets[i] = new LinkedList<HashNode>();\n+        }\n+    }\n+\n+    /**\n+     * add a node with key and value passed in from params,\n+     * find index to put node into from key.hashCode(),\n+     * place node into array index linked list and return true,\n+     * if key already exists in the array return false\n+     *\n+     * @param key - key to be put into node\n+     * @param value - value to be put into node\n+     */\n+    public boolean put(KeyType key, ValueType value){\n+        //check load factor to see if resize is needed\n+        if(((double)size/numBuckets) >= .85){\n+            resize();\n+        }\n+        //find index associated with the key\n+        int index = Math.abs(key.hashCode()) % numBuckets;\n+\n+        HashNode node = new HashNode(key, value);\n+\n+        if(containsKey(key)){\n+            return false;\n+        }\n+        else{\n+            buckets[index].add(node);\n+            size++;\n+            //check load factor to see if resize is needed\n+            if(((double)size/numBuckets) >= .85){\n+                resize();\n+            }\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * resize the array by double the capacity of the array, and rehash\n+     * the key value pairs in the array to their new indexes\n+     */\n+    public void resize(){\n+        //double new capacity of array\n+        numBuckets = numBuckets * 2;\n+        //temporary array to resize\n+        buckets2 = (LinkedList<HashNode>[]) new LinkedList[numBuckets];\n+        //put linked list each index of new array\n+        for(int i = 0; i<numBuckets; i++){\n+            buckets2[i] = new LinkedList<HashNode>();\n+        }\n+        //rehash key/value pairs from old array to new array\n+        for(int i = 0; i<numBuckets/2; i++){\n+            for(int j = 0; j<buckets[i].size(); j++){\n+                KeyType k = (KeyType) buckets[i].get(j).getKey();\n+                int index = Math.abs(k.hashCode()) % numBuckets;\n+                buckets2[index].add(buckets[i].get(j));\n+            }\n         }\n-\t\n-\t/**\n-\t * add a node with key and value passed in from params,\n-\t * find index to put node into from key.hashCode(),\n-\t * place node into array index linked list and return true,\n-\t * if key already exists in the array return false\n-\t *\n-\t * @param key - key to be put into node\n-\t * @param value - value to be put into node\n-\t */\n-\tpublic boolean put(KeyType key, ValueType value){\n-\t\t//check load factor to see if resize is needed\n-\t\tif(((double)size/numBuckets) >= .85){\n-\t\t\tresize();\n-\t\t}\n-\t\t//find index associated with the key\n-\t\tint index = Math.abs(key.hashCode()) % numBuckets;\t\t\t\n-\t\t\t\n-\t\tHashNode node = new HashNode(key, value);\n-\n-\t\tif(containsKey(key)){\n-\t\t\treturn false;\n-\t\t}\n-\t\telse{\n-\t\t\tbuckets[index].add(node);\n-\t\t\tsize++;\n-\t\t\t//check load factor to see if resize is needed\n-\t\t\tif(((double)size/numBuckets) >= .85){\n-\t\t\t\tresize();\n-\t\t\t}\n-\t\t\treturn true;\t\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * resize the array by double the capacity of the array, and rehash\n-\t * the key value pairs in the array to their new indexes\n-\t */\n-\tpublic void resize(){\n-\t\t//double new capacity of array\n-\t\tnumBuckets = numBuckets * 2;\n-\t\t//temporary array to resize\n-\t\tbuckets2 = (LinkedList<HashNode>[]) new LinkedList[numBuckets];\n-\t\t//put linked list each index of new array\n-\t\tfor(int i = 0; i<numBuckets; i++){\n-                        buckets2[i] = new LinkedList<HashNode>();\n+        //reassign old array with the resized new array\n+        buckets = buckets2;\n+    }\n+\n+    /**\n+     * get a node from the key passed into the method and return the value\n+     * associated with that node, if key not in array throw NoSuchElementException\n+     * and return null\n+     *\n+     * @param key - key associated with the node to get\n+     * @return value associated with the node passed in through param key,\n+     * otherwise return null and throw NoSuchElementException if key is\n+     * not in the array\n+     */\n+    public ValueType get(KeyType key) throws NoSuchElementException{\n+\n+        if(key == null){\n+            throw new NoSuchElementException(\"key is null\");\n+        }\n+\n+        else if(containsKey(key) == false){\n+            throw new NoSuchElementException(\"key is not in array\");\n+        }\n+        // search through linked list  at index of key for the node\n+        else{\n+            int index = Math.abs(key.hashCode()) % numBuckets;\n+\n+            for(int i=0; i<buckets[index].size(); i++){\n+\n+                if(buckets[index].get(i).getKey().equals(key)){\n+                    return (ValueType) buckets[index].get(i).getValue();\n                 }\n-\t\t//rehash key/value pairs from old array to new array\n-\t\tfor(int i = 0; i<numBuckets/2; i++){\n-\t\t\tfor(int j = 0; j<buckets[i].size(); j++){\n-\t\t\t\tKeyType k = (KeyType) buckets[i].get(j).getKey();\n-\t\t\t\tint index = Math.abs(k.hashCode()) % numBuckets;\n-\t\t\t\tbuckets2[index].add(buckets[i].get(j));\n-\t\t\t}\n-\t\t}\n-\t\t//reassign old array with the resized new array\n-\t\tbuckets = buckets2;\n-\t}\n-\n-\t/**\n-\t * get a node from the key passed into the method and return the value\n-\t * associated with that node, if key not in array throw NoSuchElementException\n-\t * and return null\n-\t *\n-\t * @param key - key associated with the node to get\n-\t * @return value associated with the node passed in through param key,\n-\t * otherwise return null and throw NoSuchElementException if key is\n-\t * not in the array\n-\t */\n-\tpublic ValueType get(KeyType key) throws NoSuchElementException{\n-\t\t\n-\t\tif(key == null){\n-\t\t\tthrow new NoSuchElementException(\"key is null\");\n-\t\t}\n-\t\n-\t\telse if(containsKey(key) == false){\n-\t\t\t throw new NoSuchElementException(\"key is not in array\");\n-\t\t}\n-\t\t// search through linked list  at index of key for the node\n-\t\telse{\n-\t\t\tint index = Math.abs(key.hashCode()) % numBuckets;\n-\t\t\t\n-\t\t\tfor(int i=0; i<buckets[index].size(); i++){\n-\n-\t                        if(buckets[index].get(i).getKey().equals(key)){\n-               \t\t                return (ValueType) buckets[index].get(i).getValue();\n-                       \t\t}\n-                \t}\t\n-\t\t\tthrow new NoSuchElementException(\"key is not in array\");\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * get and return number of key pairs \n-\t *\n-\t * @return number of key pairs\n-\t */\n-\tpublic int size(){\n-\t\treturn size;\n-\t}\n-\n-\t/**\n-\t * get and return number of buckets in array\n-\t *\n-\t * @return number of buckets in array\n-\t */\t\n-\tpublic int numBuckets(){\n-                return numBuckets;\n+            }\n+            throw new NoSuchElementException(\"key is not in array\");\n         }\n+    }\n+\n+    /**\n+     * get and return number of key pairs\n+     *\n+     * @return number of key pairs\n+     */\n+    public int size(){\n+        return size;\n+    }\n+\n+    /**\n+     * get and return number of buckets in array\n+     *\n+     * @return number of buckets in array\n+     */\n+    public int numBuckets(){\n+        return numBuckets;\n+    }\n \n-\t/**\n-\t * check if key is in array\n-\t *\n-\t * @param key - key passed into to check if key is already in array\n-\t * @return true if the array contains the key\n-\t */\n-\tpublic boolean containsKey(KeyType key){\n-\t\t// find index associated with key\n-\t\tint index = Math.abs(key.hashCode()) % numBuckets;\n-\t\t// search for key in linked list at index of key\n-                for(int i=0; i<buckets[index].size(); i++){\n-\n-                        if(buckets[index].get(i).getKey().equals(key)){\n-                                return true;\n-                        }\n-                 }\n-\t\t return false;\n-\t}\n-\t\n-\t/**\n-\t * remove node with key associated from param key and return value \n-\t * of that node\n-\t *\n-\t * @param key - key passed into to remove node\n-\t * @return value accoiated with node removed (or null if key does not\n-\t * match a node in the array\n-\t */\n-\tpublic ValueType remove(KeyType key){\n-\t\tif(containsKey(key) == false){\n-\t\t\treturn null;\n-\t\t}\n-\t\t//search for node to be removed at index of key\n-\t\telse{\n-\t\t\tint index = Math.abs(key.hashCode()) % numBuckets;\n-\t\t\tfor(int i=0; i<buckets[index].size(); i++){\n-\n-                        \tif(buckets[index].get(i).getKey().equals(key)){\n-\t\t\t\t\t// store value in node of matching key to be removed\n-\t\t\t\t\tValueType v = (ValueType) buckets[index].get(i).getValue();\n-\t\t\t\t\tbuckets[index].remove(i);\n-\t\t\t\t\tsize--;\n-\t\t\t\t\treturn v;\n-\t\t\t\t}\t\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\t/**\n-\t * remove all nodes in the array\n-\t */\n-\tpublic void clear(){\n-\t\t\n-\t\tfor(int i = 0; i<numBuckets; i++){\n-        \t\t buckets[i].clear();         \n+    /**\n+     * check if key is in array\n+     *\n+     * @param key - key passed into to check if key is already in array\n+     * @return true if the array contains the key\n+     */\n+    public boolean containsKey(KeyType key){\n+        // find index associated with key\n+        int index = Math.abs(key.hashCode()) % numBuckets;\n+        // search for key in linked list at index of key\n+        for(int i=0; i<buckets[index].size(); i++){\n+\n+            if(buckets[index].get(i).getKey().equals(key)){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * remove node with key associated from param key and return value\n+     * of that node\n+     *\n+     * @param key - key passed into to remove node\n+     * @return value accoiated with node removed (or null if key does not\n+     * match a node in the array\n+     */\n+    public ValueType remove(KeyType key){\n+        if(containsKey(key) == false){\n+            return null;\n+        }\n+        //search for node to be removed at index of key\n+        else{\n+            int index = Math.abs(key.hashCode()) % numBuckets;\n+            for(int i=0; i<buckets[index].size(); i++){\n+\n+                if(buckets[index].get(i).getKey().equals(key)){\n+                    // store value in node of matching key to be removed\n+                    ValueType v = (ValueType) buckets[index].get(i).getValue();\n+                    buckets[index].remove(i);\n+                    size--;\n+                    return v;\n                 }\n-\t\tsize = 0;\n-\t}\n-}\n+            }\n+            return null;\n+        }\n+    }\n+    /**\n+     * remove all nodes in the array\n+     */\n+    public void clear(){\n+\n+        for(int i = 0; i<numBuckets; i++){\n+            buckets[i].clear();\n+        }\n+        size = 0;\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "82f994b3ab2fa72a37f773fdf5bc90dd2b0afd1c",
    "filename": "MDRInterface.java",
    "status": "added",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MDRInterface.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MDRInterface.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/MDRInterface.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -0,0 +1,16 @@\n+import java.util.List;\n+import java.util.zip.DataFormatException;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+// --== CS400 File Header Information ==--\n+// Author: CS400 Course Staff\n+// Email: heimerl@cs.wisc.edu / dahl@cs.wisc.edu\n+// Notes: This interface is part of the starter archive for Projecct One\n+//        in spring 2021.\n+public interface MDRInterface {\n+\n+    public List<MovieInterface> readDataSet(Reader inputFileReader) throws FileNotFoundException, IOException, DataFormatException;\n+\n+}"
  },
  {
    "sha": "ca0a73bb8dc1973fe5a85e3afad54bb8190406e8",
    "filename": "MapADT.java",
    "status": "modified",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MapADT.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MapADT.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/MapADT.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -1,12 +1,12 @@\n import java.util.NoSuchElementException;\n \n public interface MapADT<KeyType, ValueType> {\n-\t\n-\tpublic boolean put(KeyType key, ValueType value);\n-\tpublic ValueType get(KeyType key) throws NoSuchElementException;\n-\tpublic int size();\n-\tpublic boolean containsKey(KeyType key);\n-\tpublic ValueType remove(KeyType key);\n-\tpublic void clear();\n-\t\n+\n+    public boolean put(KeyType key, ValueType value);\n+    public ValueType get(KeyType key) throws NoSuchElementException;\n+    public int size();\n+    public boolean containsKey(KeyType key);\n+    public ValueType remove(KeyType key);\n+    public void clear();\n+\n }"
  },
  {
    "sha": "f5ca4549c7d8f03e75ee2661681cdea53c2a810c",
    "filename": "Movie.java",
    "status": "added",
    "additions": 41,
    "deletions": 0,
    "changes": 41,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Movie.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Movie.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/Movie.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -0,0 +1,41 @@\n+import java.util.List;\n+\n+public class Movie implements MovieInterface  {\n+        String title;\n+        Integer year;\n+        List<String> genres;\n+        String dir;\n+        String des;\n+        float vote;\n+\n+public Movie(String t, Integer y, List<String> g, String di, String de, float v)  {\n+        this.title = t;\n+        this.year = y;\n+        this.genres = g;\n+        this.dir = di;\n+        this.des = de;\n+        this.vote = v;\n+        }\n+\n+@Override\n+public String getTitle()  { return title; }\n+@Override\n+public Integer getYear(){ return year; }\n+@Override\n+public List<String> getGenres(){ return genres; }\n+@Override\n+public String getDirector(){ return dir; }\n+@Override\n+public String getDescription(){ return des; }\n+@Override\n+public Float getAvgVote(){ return vote; };\n+\n+// from super interface Comparable\n+public int compareTo(MovieInterface otherMovie)  {\n+        System.out.println(this.getAvgVote() + \" \" + otherMovie.getAvgVote());\n+        if(this.getTitle().equals(otherMovie.getTitle()))  return 0;\n+        else if(this.getAvgVote() < otherMovie.getAvgVote()) return 1;\n+        else return -1;\n+}\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "22ad7c9bb381c53c9f4ab374cfd1972701e1d30b",
    "filename": "MovieDataReaderDummy.java",
    "status": "added",
    "additions": 157,
    "deletions": 0,
    "changes": 157,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MovieDataReaderDummy.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MovieDataReaderDummy.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/MovieDataReaderDummy.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -0,0 +1,157 @@\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+// --== CS400 File Header Information ==--\n+// Author: CS400 Course Staff\n+// Email: heimerl@cs.wisc.edu / dahl@cs.wisc.edu\n+// Notes: This dummy class is part of the starter archive for Project One\n+//        in spring 2021. You can extend it to work on your Project One Final\n+//        App.\n+public class MovieDataReaderDummy implements MDRInterface {\n+\n+    /**\n+     * Method that reades movie data in CSV format from the Redaer provided. The dummy implementations\n+     * will always return the same 3 sets of movies.\n+     */\n+    @Override\n+    public List<MovieInterface> readDataSet(Reader inputFileReader) throws FileNotFoundException, IOException {\n+        ArrayList<MovieInterface> movies = new ArrayList<MovieInterface>();\n+        movies.add(new MovieInterface() {\n+\n+            @Override\n+            public String getTitle() {\n+                return \"Plan 9 from Outer Spacce\";\n+            }\n+\n+            @Override\n+            public Integer getYear() {\n+                return 1959;\n+            }\n+\n+            @Override\n+            public List<String> getGenres() {\n+                return Arrays.asList(new String[] { \"Action\", \"Comedy\" });\n+            }\n+\n+            @Override\n+            public String getDirector() {\n+                return \"Ed Wood\";\n+            }\n+\n+            @Override\n+            public String getDescription() {\n+                return \"Residents of California's San Fernando Valley are under attack by flying saucers from outer space.\";\n+            }\n+\n+            @Override\n+            public Float getAvgVote() {\n+                return 5.3f;\n+            }\n+\n+            @Override\n+            public int compareTo(MovieInterface otherMovie) {\n+                if (this.getTitle().equals(otherMovie.getTitle())) {\n+                    return 0;\n+                    // sort by rating\n+                } else if (this.getAvgVote() < otherMovie.getAvgVote()) {\n+                    return +1;\n+                } else {\n+                    return -1;\n+                }\n+            }\n+        });\n+        movies.add(new MovieInterface() {\n+\n+            @Override\n+            public String getTitle() {\n+                return \"B\";\n+            }\n+\n+            @Override\n+            public Integer getYear() {\n+                return 2000;\n+            }\n+\n+            @Override\n+            public List<String> getGenres() {\n+                return Arrays.asList(new String[] { \"Action\", \"Horror\", \"Comedy\" });\n+            }\n+\n+            @Override\n+            public String getDirector() {\n+                return \"Jake\";\n+            }\n+\n+            @Override\n+            public String getDescription() {\n+                return \"Scary\";\n+            }\n+\n+            @Override\n+            public Float getAvgVote() {\n+                return 6.0f;\n+            }\n+\n+            @Override\n+            public int compareTo(MovieInterface otherMovie) {\n+                if (this.getTitle().equals(otherMovie.getTitle())) {\n+                    return 0;\n+                    // sort by rating\n+                } else if (this.getAvgVote() < otherMovie.getAvgVote()) {\n+                    return +1;\n+                } else {\n+                    return -1;\n+                }\n+            }\n+        });\n+        movies.add(new MovieInterface() {\n+\n+            @Override\n+            public String getTitle() {\n+                return \"C\";\n+            }\n+\n+            @Override\n+            public Integer getYear() {\n+                return 2001;\n+            }\n+\n+            @Override\n+            public List<String> getGenres() {\n+                return Arrays.asList(new String[] { \"Action\", \"Drama\" });\n+            }\n+\n+            @Override\n+            public String getDirector() {\n+                return \"Sam\";\n+            }\n+\n+            @Override\n+            public String getDescription() {\n+                return \"Residents of California's San Fernando Valley are under attack by flying saucers from outer space.\";\n+            }\n+\n+            @Override\n+            public Float getAvgVote() {\n+                return 9.9f;\n+            }\n+\n+            @Override\n+            public int compareTo(MovieInterface otherMovie) {\n+                if (this.getTitle().equals(otherMovie.getTitle())) {\n+                    return 0;\n+                    // sort by rating\n+                } else if (this.getAvgVote() < otherMovie.getAvgVote()) {\n+                    return +1;\n+                } else {\n+                    return -1;\n+                }\n+            }\n+        });\n+        return movies;\n+    }\n+}"
  },
  {
    "sha": "1a959b0ecf72295ff7dc06c73a009e4a4338edac",
    "filename": "MovieInterface.java",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MovieInterface.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/MovieInterface.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/MovieInterface.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -0,0 +1,20 @@\n+import java.util.List;\n+\n+// --== CS400 File Header Information ==--\n+// Author: CS400 Course Staff\n+// Email: heimerl@cs.wisc.edu / dahl@cs.wisc.edu\n+// Notes: This interface is part of the starter archive for Projecct One\n+//        in spring 2021.\n+public interface MovieInterface extends Comparable<MovieInterface> {\n+\n+    public String getTitle();\n+    public Integer getYear();\n+    public List<String> getGenres();\n+    public String getDirector();\n+    public String getDescription();\n+    public Float getAvgVote();\n+\n+    // from super interface Comparable\n+    public int compareTo(MovieInterface otherMovie);\n+\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "58bae328eb5af25413413cc2c18a12c712e84bb2",
    "filename": "Test.java",
    "status": "added",
    "additions": 30,
    "deletions": 0,
    "changes": 30,
    "blob_url": "https://github.com/jbenus/Project-1-Repository/blob/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Test.java",
    "raw_url": "https://github.com/jbenus/Project-1-Repository/raw/74dd9722117a848eb445fb3b6e8265d3c6fb7578/Test.java",
    "contents_url": "https://api.github.com/repos/jbenus/Project-1-Repository/contents/Test.java?ref=74dd9722117a848eb445fb3b6e8265d3c6fb7578",
    "patch": "@@ -0,0 +1,30 @@\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Scanner;\n+import java.util.zip.DataFormatException;\n+import java.io.FileReader;\n+import java.io.StringReader;\n+import java.io.File;\n+\n+\n+public class Test {\n+    public static void main(String[] args) {\n+        //System.out.println(\"Testing Backend: \" + testBackend());\n+        Frontend f = new Frontend();\n+\n+    }\n+\n+    private static void testMake()  {\n+        System.out.println(\"make working\");\n+    }\n+     private static boolean testBackend() {\n+        Backend b;\n+        try {\n+            b = new Backend(\"src/movies.csv\");\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+         return true;\n+    }\n+}"
  }
]
