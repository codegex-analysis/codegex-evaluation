[
  {
    "sha": "3cbde316a4a49009dd3145b7f50465532bae3be5",
    "filename": "README.md",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/README.md",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/README.md",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/README.md?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -11,7 +11,7 @@\n - [X] ***Урок №3.*** Коллекции, списки, связанные списки и итераторы.\n - [X] ***Урок №4.*** Стеки и очереди.\n - [X] ***Урок №5.*** Рекурсия.\n-- [ ] ***Урок №6.*** Деревья.\n+- [X] ***Урок №6.*** Деревья.\n - [ ] ***Урок №7.*** Графы.\n - [ ] ***Урок №8.*** Хуш-таблицы.\n \n@@ -23,8 +23,8 @@\n :heavy_check_mark: ***Задача №3.***\t - Задание выполнено. -    \n :heavy_check_mark: ***Задача №4.***\t - Задание выполнено. -    \n :heavy_check_mark: ***Задача №5.***\t - Задание выполнено. -    \n-:clock2: ***Задача №6.***\t - выполняется -    \n-:lock: ***Задача №7.***\t - закрыт -    \n+:heavy_check_mark: ***Задача №6.***\t - Задание выполнено. -    \n+:clock2: ***Задача №7.***\t - выполняется -    \n :lock: ***Задача №8.***\t - закрыт -\n       \n ---   "
  },
  {
    "sha": "1ccf76f2f6188c42ee30467ffd5d05e47168b708",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyHeap.java",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyHeap.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyHeap.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyHeap.java?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -0,0 +1,65 @@\n+package ru.geekbrains.javaalgoritms.lesson6;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 6\n+ * Created 01.03.2021\n+ * v 1.0\n+ */\n+public class MyHeap {\n+    private static int heapSize;\n+\n+    public static void sort(int[] arr) {\n+        buildHeap(arr);\n+        while (heapSize>1){\n+            svap(arr, 0, heapSize-1);\n+            heapSize--;\n+            heapify(arr, 0);\n+        }\n+    }\n+\n+    public static void buildHeap(int[] arr) {\n+        heapSize = arr.length;\n+        for (int i = arr.length / 2; i >= 0; i--) {\n+            heapify(arr, i);\n+        }\n+\n+    }\n+\n+    public static void heapify(int[] arr, int i) {\n+        int l = left(i);\n+        int r = right(i);\n+        int largest = i;\n+        if (l < heapSize && arr[i] < arr[l]) {\n+            largest = l;\n+        }\n+        if (r < heapSize && arr[largest] < arr[r]) {\n+            largest = r;\n+        }\n+        if (i != largest) {\n+            svap(arr, i, largest);\n+            heapify(arr, largest);\n+        }\n+    }\n+\n+    public static int left(int i) {\n+        return 2 * i + 1;\n+    }\n+\n+    public static int right(int i) {\n+        return 2 * i + 2;\n+    }\n+\n+    public static void svap(int[] arr, int i, int j){\n+        int temp = arr[i];\n+        arr[i] = arr[j];\n+        arr[j] = temp;\n+    }\n+\n+\n+}"
  },
  {
    "sha": "ab1df58ad68495e8e96a1da700ada13049d0fb0d",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyTree.java",
    "status": "added",
    "additions": 236,
    "deletions": 0,
    "changes": 236,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyTree.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyTree.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson6/MyTree.java?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -0,0 +1,236 @@\n+package ru.geekbrains.javaalgoritms.lesson6;\n+\n+import java.util.Stack;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 6\n+ * Created 01.03.2021\n+ * v 1.0\n+ */\n+public class MyTree {\n+    private Node rootNode;                              // корневой узел дерева\n+    private Node rightmostNode;                         // самый правый узел (лист) - максимальное значение\n+    private Node leftmostNode;                          // самый левый узел (лист) - минимальное значение\n+    private int count;                                  // общее количество узлов (для признака балансировки)\n+    private int levels;                                 // количество уровней дерева (для признака балансировки)\n+\n+    public MyTree() {                                    // Конструктор создает пустое дерево с корневым узлом равным null\n+        rootNode = null;                                 // присваиваем значение null корневому элементу\n+        rightmostNode = null;                            // присваиваем значение null максимальному элементу\n+        leftmostNode = null;                             // присваиваем значение null минимальному элементу\n+    }\n+\n+    // метод быстро возвращает максимальный элемент дерева\n+    public Node getMax() {\n+        return rightmostNode;\n+    }\n+\n+    // резервный метод именно поиска максимального и минимального значения\n+    // согласно задания реализовать поиск максимума ( в дальнейшем проверю скорость)\n+    // реализован на базе основного свойства бинарного дерева поиска (правый наследник всегда больше)\n+    public Node findMax() {\n+        Node currentNode = rootNode;\n+        while (currentNode.getRightChild() != null) {\n+            currentNode = currentNode.getRightChild();\n+        }\n+        return currentNode;\n+    }\n+\n+    // метод быстро возвращает минимальный элемент дерева\n+    public Node getMin() {\n+        return leftmostNode;\n+    }\n+\n+    // резервный метод именно поиска минимального значения\n+    // согласно задания реализовать \"поиск\" минимума ( в дальнейшем проверю скорость)\n+    // реализован на базе основного свойства бинарного дерева поиска (левый наследник всегда меньше)\n+    public Node findMin() {\n+        Node currentNode = rootNode;\n+        while (currentNode.getLeftChild() != null) {\n+            currentNode = currentNode.getLeftChild();\n+        }\n+        return currentNode;\n+    }\n+\n+    // Задание 6.3\n+    // Метод осуществляет поиск узла по значению\n+    public Node findNodeByValue(int findValue) {\n+        Node currentNode = rootNode;                       // назначаем тек. элементу корневой узел (начинаем поиск)\n+        while (currentNode.getValue() != findValue) {      // цикла поиска будет прерван если элемент будет найден\n+            if (findValue < currentNode.getValue()) {      // искомое значение меньше - движение влево?\n+                currentNode = currentNode.getLeftChild();  // делаем текущий левого потомка\n+            } else {                                       // искомое значение больше или равно движение вправо\n+                currentNode = currentNode.getRightChild(); // делаем текущий правого потомка\n+            }\n+            if (currentNode == null) {                     // потомков больше нет.\n+                return null;                               // прерываем цикл возвращаем null\n+            }\n+        }\n+        return currentNode;                                // если программа дошла сюда то возвращаем найденный элемент\n+    }\n+\n+    // Задание 6.3\n+    // Метод осуществляет вставку нового узла в дерево (с использование поля родителя)\n+    public boolean insertNode(int newValue) {\n+        Node newNode = new Node();                         // создаем новый узел\n+        newNode.setValue(newValue);                        // записываем данные в узел\n+        if (rootNode == null) {                            // если корневой узел пустой (дерево пустое)\n+            newNode.setParent(null);                       // присваиваем ссылку на текущий узел минимальному элементу\n+            rootNode = newNode;                            // присваиваем корневому узлу ссылку на текущий узел\n+            rightmostNode = newNode;                       // присваиваем ссылку на текущий узел максимальному элементу\n+            leftmostNode = newNode;                        // присваиваем ссылку на текущий узел минимальному элементу\n+            count++;                                       // обновляем значение счетчика элементов\n+            levels++;                                      // обновляем значение уровня дерева\n+            return true;\n+        } else {                                           // если корневой узел существует тогда\n+            Node currentNode = rootNode;                   // делаем корневой элемент текущим и\n+            if (newValue < leftmostNode.getValue()) {      // записываем значение минимального элемента для\n+                leftmostNode = newNode;                    // быстрого доступа\n+                levels++;\n+            }\n+            if (newValue > rightmostNode.getValue()) {     // записываем значение максимального элемента для\n+                rightmostNode = newNode;                   // быстрого доступа\n+                levels++;\n+            }\n+            while (true) {                                        // создаем бесконечный цикл\n+                if (newValue == currentNode.getValue()) {         // если такой элемент в дереве уже есть,\n+                    return false;                                 // просто выходим из метода, возвращаем \"неудача\"\n+                } else if (newValue < currentNode.getValue()) {   // если новое значение меньше движемся влево\n+                    if (currentNode.getLeftChild() == null) {     // если был достигнут конец ветви (листа)\n+                        currentNode.setLeftChild(newNode);        // тогда делаем новый элемент левым потомком\n+                        newNode.setParent(currentNode);           // новому узлу назначаем родителя\n+                        count++;\n+                        return true;                              // выходим из метода, возвращаем \"успех\"\n+                    }\n+                    currentNode = currentNode.getLeftChild();     // иначе движемся влево\n+                } else {                                          // если новое значение больше движемся вправо\n+                    if (currentNode.getRightChild() == null) {    // если был достигнут конец ветви (листа),\n+                        currentNode.setRightChild(newNode);       // тогда делаем новый элемент правым потомком\n+                        newNode.setParent(currentNode);           // новому узлу назначаем родителя\n+                        count++;\n+                        return true;                              // выходим из метода, возвращаем \"успех\"\n+                    }\n+                    currentNode = currentNode.getRightChild();\n+                }\n+            }\n+        }\n+    }\n+\n+    //Задание 6.4\n+    // метод простой визуализации дерева в консоли\n+    // сканирующий поуровнево обход сверху вниз\n+    public void simplePrintTree() {\n+        Stack extStack = new Stack();                           // внешний стек для значений дерева\n+        Stack intStack = new Stack();                           // внутренний стек для задания потомков элемента\n+        boolean isLvlEmpty = false;                             // флаг - признак пустого уровня\n+        System.out.println(\"--(start)-------- Simple Print Tree -------------------\");\n+        extStack.push(rootNode);\n+        while (!isLvlEmpty) {\n+            isLvlEmpty = true;\n+            while (!extStack.isEmpty()) {                       // если внешний стек не пустой\n+                Node temp = (Node) extStack.pop();              // забираем из стека верхний элемент\n+                if (temp != null) {                             // если элемент не пустой\n+                    System.out.print(\"{\" + temp.getValue() + \"}\"); // выдаем его значение в консоль\n+                    intStack.push(temp.getLeftChild());         // добавляем во внутренний стек, левого наследника\n+                    intStack.push(temp.getRightChild());        // добавляем во внутренний стек, правого наследника\n+                    if (!(temp.getLeftChild() == null &&        // проверяем если хотя-бы один наследник\n+                            temp.getRightChild() == null))      // тогда устанавливаем маркер что следующий уровень\n+                        isLvlEmpty = false;                     // не пустой и нужен еще виток\n+                } else {                                        // - если элемент пустой\n+                    System.out.print(\"{_}\");                    // выводим специальный символ \"заглушку\" на его месте\n+                    intStack.push(null);                   // добавляем во внутренний стек, пустого левого наследника\n+                    intStack.push(null);                   // добавляем во внутренний стек, пустого правого наследника\n+                }                                               // чтобы зарезервировать место под пустой элемент уровнем ниже\n+            }\n+            System.out.println();                               // формируем перевод строки и переходим на след. уровень\n+            while (!intStack.isEmpty())                         // перемещаем из внутреннего стека во внешний все\n+                extStack.push(intStack.pop());                  // найденные и зарезервированные элементы след. уровня\n+        }\n+        System.out.println(\"--(stop)-------- Simple Print Tree -------------------\");\n+    }\n+\n+    // Задание 6.5\n+    // Удаление узла по значению (ключу) с использованием поля родителя\n+    public boolean deleteNode(int value) {\n+        // предварительная задача -  найти удаляемый узел\n+        Node currentNode = findNodeByValue(value);\n+        if (currentNode == null)\n+            return false;                                 // если узел не найден выходим из метода возвращаем \"неудача\"\n+        //ситуация Первая - узел это Лист (потомков нет)\n+        if (currentNode.getLeftChild() == null &&\n+                currentNode.getRightChild() == null) {\n+            if (currentNode == rootNode) {\n+                rootNode = null;                                   // если узел - корень, то дерево очищается\n+                count = 0;\n+                levels = 0;\n+            } else {\n+                if (currentNode.getParent().getLeftChild() == currentNode)\n+                    currentNode.getParent().setLeftChild(null);    // иначе - левый узел отсоединяется, от родителя\n+                if (currentNode.getParent().getRightChild() == currentNode)\n+                    currentNode.getParent().setRightChild(null);   // иначе - правый узел отсоединяется, от родителя\n+                count--;\n+                if (currentNode == rightmostNode) rightmostNode = currentNode.getParent();\n+                if (currentNode == leftmostNode) leftmostNode = currentNode.getParent();\n+            }\n+            // ситуация вторая  - у удаляемого узла нет правого потомка тогда узел просто заменяется левым поддеревом\n+        } else if (currentNode.getRightChild() == null) {\n+            if (currentNode == rootNode) {                         // опять же если это корень дерева\n+                rootNode = currentNode.getLeftChild();\n+                levels--;\n+            } else if (currentNode.getParent().getLeftChild() == currentNode)\n+                currentNode.getParent().setLeftChild(currentNode.getLeftChild());\n+            else\n+                currentNode.getParent().setRightChild(currentNode.getLeftChild());\n+            count--;\n+            // ситуация третья - у удаляемого узла нет левого потомка\n+        } else if (currentNode.getLeftChild() == null) {\n+            if (currentNode == rootNode){                           // опять же если это корень дерева\n+                rootNode = currentNode.getRightChild();\n+                levels--;\n+            } else if (currentNode.getParent().getLeftChild() == currentNode){\n+                currentNode.getParent().setLeftChild(currentNode.getRightChild());\n+            } else {\n+                currentNode.getParent().setRightChild(currentNode.getRightChild());\n+            }\n+            count--;\n+            // ситуация четвертая - у узла есть два потомка, необходимо найти и заменить узел приемником\n+        } else {\n+            Node heir = receiveHeir(currentNode);                   // поиск преемника для удаляемого узла\n+            if (currentNode == rootNode) {                          // опять же если это корень дерева\n+                rootNode = heir;\n+                levels--;\n+            }\n+            else if (currentNode.getParent().getLeftChild() == currentNode)\n+                currentNode.getParent().setLeftChild(heir);\n+            else\n+                currentNode.getParent().setRightChild(heir);\n+            count--;\n+        }\n+        return true;\n+    }\n+\n+    // вспомогательный метод поиска приемника\n+    private Node receiveHeir(Node node) {\n+\n+        Node heirNode = node;\n+        Node currentNode = node.getRightChild();                           // Переход к правому потомку\n+        while (currentNode != null)                                        // Пока узел есть (перебираемся по левым потомкам)\n+        {                                                                  // потомка делаем текущим узлом\n+            heirNode = currentNode;\n+            currentNode = currentNode.getLeftChild();\n+        }\n+                                                                            // Если преемник не является\n+        if (heirNode != node.getRightChild())                               // правым потомком,\n+        {                                                                   // создать связи между узлами\n+            heirNode.getParent().setLeftChild(heirNode.getRightChild());\n+            heirNode.setRightChild(node.getRightChild());\n+        }\n+        return heirNode;                                                    // возвращаем приемника\n+    }\n+}"
  },
  {
    "sha": "15e37a958a5d54117d0d12fea869788360f7c8e5",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson6/Node.java",
    "status": "added",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Node.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Node.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Node.java?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -0,0 +1,64 @@\n+package ru.geekbrains.javaalgoritms.lesson6;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 6\n+ * Created 04.03.2021\n+ * v 1.0\n+ */\n+public class Node {\n+\n+    private int value;         // ключ узла\n+    private Node leftChild;    // ссылка на левый узел потомок\n+    private Node rightChild;   // ссылка на правый узел потомок\n+    private Node parent;       // ссылка на родительский узел (запрета на использование подобного подхода нет,\n+    // применение в алгоритмах приводится в работе О.В. СЕНЮКОВА СБАЛАНСИРОВАННЫЕ ДЕРЕВЬЯ ПОИСКА\n+    // МГУ факультет ВМК 2014 ( для выполнения ДЗ использован дополнительный материал)\n+\n+    public Node getParent() {\n+        return this.parent;\n+    }\n+\n+    public void setParent(Node node) {\n+        this.parent = node;\n+    }\n+\n+    public int getValue() {\n+        return this.value;\n+    }\n+\n+    public void setValue(final int value) {\n+        this.value = value;\n+    }\n+\n+    public Node getLeftChild() {\n+        return this.leftChild;\n+    }\n+\n+    public void setLeftChild(final Node leftChild) {\n+        this.leftChild = leftChild;\n+    }\n+\n+    public Node getRightChild() {\n+        return this.rightChild;\n+    }\n+\n+    public void setRightChild(final Node rightChild) {\n+        this.rightChild = rightChild;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Node{\" +\n+                \"Значение: \" + value +\n+                \", Родительский узел \" +(parent != null ? parent.getValue() : parent) +\n+                \", Узел левого потомка: \" + (leftChild != null ? leftChild.getValue() : leftChild) +\n+                \", Узел правого потомка: \" + (rightChild != null ? rightChild.getValue(): rightChild) +\n+                '}';\n+    }\n+}"
  },
  {
    "sha": "7e2616efb2fe577362c7cfc5b25cd501d0875e2f",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson6/README.md",
    "status": "added",
    "additions": 39,
    "deletions": 0,
    "changes": 39,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/README.md",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/README.md",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson6/README.md?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -0,0 +1,39 @@\n+### GeekBrains_Course_JavaAlgorithms_HW_Lesson_6\n+---\n+### Домашняя работа к занятию №6\n+Студента GeekBrains ***Веремеенко Дмитрия***    \n+Факультет: ***Android-разработки***    \n+Курс: ***Алгоритмы Java***\n+### Задание:\n+---\n+- [X] ***Задача №6.1***\tПриведите пример использования древовидной структуры.\n+- [X] ***Задача №6.2***\tРеализуйте класс узла дерева и базовый шаблон дерева с базовыми методами.\n+- [X] ***Задача №6.3***\tРеализуйте методы поиска и вставки узла в дерево.\n+- [X] ***Задача №6.4***\tРеализуйте базовые методы обхода дерева и метода дисплей. Реализуйте поиск максимума и минимума.    \n+- [X] ***Задача №6.5***\tРеализуйте метод удаления узла и выполните оценку времени базовых методов дерева с помощью \n+  System.nanoTime().\n+- [X] ***Задача №6.6***\tРеализуйте на основе массива из задания 2.1 алгоритм пирамидальной сортировки с реализацией \n+  бинарной пирамиды. Выполните оценку алгоритма пирамидальной сортировки с помощью System.nanoTime() и сравните с \n+  предыдущими алгоритмами сортировки.\n+- [X] ***Задача №6.7***\tПриведите пример сбалансированного дерева и его применения.\n+  \n+\n+### Отчет о выполнении:\n+---    \n+:heavy_check_mark: ***Задача №6.1.*** Задание выполнено. Ответ приведен в теле программы класса Std_HW_Lesson6.          \n+:heavy_check_mark: ***Задача №6.2.*** Задание выполнено. Класс myTree - дерево, Node - узел. В узле, в отличие от примеров\n+рассмотренных на занятии, использован необязательное дополнительное поле объекта node parent, содержащее ссылку на родителя.\n+Организованы все необходимые сеттеры и геттеры.    \n+:heavy_check_mark: ***Задача №6.3.*** Задание выполнено. Методы реализованы. Замер времени произведен в тестировании работы\n+основных функций класса myTree в main. Результаты выведены в консоль.    \n+:heavy_check_mark: ***Задача №6.4.*** Задание выполнено. Реализован прямой обход. Вместо метода дисплей реализован \n+метод simplePrintTree(), в перспективе, если будет время можно будет доработать его для еще более наглядного отображения\n+структуры дерева (со стрелосчками и т.п.)    \n+:heavy_check_mark: ***Задача №6.5.*** Задание выполнено. Метод реализован. Обкатаны разные ситуации, замер времени\n+произведен. Результаты в консоли.         \n+:heavy_check_mark: ***Задача №6.6.*** Задание выполнено. MyHeap реализована (как на занятии, вродебы ничего лишнего).   \n+:heavy_check_mark: ***Задача №6.7.*** Задание выполнено. Приведены 3 схемы сбалансированного дерева в конце кода класса Std_HW_Lesson6.   \n+      \n+---   \n+\n+*StDimensiy 05.03.2021*"
  },
  {
    "sha": "7515b97ccdbf990172a546c6d2aa2c9d5ae9daab",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson6/Std_HW_Lesson6.java",
    "status": "added",
    "additions": 142,
    "deletions": 0,
    "changes": 142,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Std_HW_Lesson6.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/7b6996b57157f8e3bac87b118594dbe811d412a1/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Std_HW_Lesson6.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson6/Std_HW_Lesson6.java?ref=7b6996b57157f8e3bac87b118594dbe811d412a1",
    "patch": "@@ -0,0 +1,142 @@\n+package ru.geekbrains.javaalgoritms.lesson6;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.TreeMap;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 6\n+ * Created 01.03.2021\n+ * v 1.0\n+ */\n+public class Std_HW_Lesson6 {\n+    //6.1. Приведите пример использования древовидной структуры.\n+    // Ответ: Древовидная структура, являясь одним из способов представления иерархической структуры, широко используется\n+    // в теории управления, в статистике, в связи, в информатике, да много где еще.\n+    // пример в связи - структура локальных вычислительных сетей (од на из топологий);\n+    // в статистике  - древовидная структура электронных мониторинговых систем;\n+    // в управлении  - организационная структура структурного подразделения;\n+    // в информатике (программирование) частный случай иерархической структуры данных  - двоичное дерево, пирамида (куча).\n+\n+    public static void main(String[] args) {\n+        Random random = new Random();\n+        MyTree tree = new MyTree();\n+        // добавляем некоторое количество уникальных узлов в дерево (замеряем время операции):\n+        long timeStart = System.nanoTime();\n+        System.out.println(\"Добавляем узел с ключом 4 ...\" + tree.insertNode(4));\n+        System.out.println(\"Добавляем узел с ключом 9 ...\" + tree.insertNode(9));\n+        System.out.println(\"Добавляем узел с ключом 12 ...\" + tree.insertNode(12));\n+        System.out.println(\"Добавляем узел с ключом 5 ...\" + tree.insertNode(5));\n+        System.out.println(\"Добавляем узел с ключом 8 ...\" + tree.insertNode(8));\n+        System.out.println(\"Добавляем узел с ключом 2 ...\" + tree.insertNode(2));\n+        System.out.println(\"Добавляем узел с ключом 1 ...\" + tree.insertNode(1));\n+        System.out.println(\"Добавляем узел с ключом 7 ...\" + tree.insertNode(7));\n+        System.out.println(\"Добавляем узел с ключом 3 ...\" + tree.insertNode(3));\n+        System.out.println(\"Добавляем узел с ключом 6 ...\" + tree.insertNode(6));\n+        long timeStop = System.nanoTime();\n+        System.out.println(\"Вставка 10 элементов в дерево заняла: \" + (timeStop - timeStart) + \" ns\");\n+        System.out.println(\"В среднем, время добавления одного элемента: \" + (timeStop - timeStart) / 10 + \" ns\");\n+        System.out.println(\"Пытаемся добавить несколько значений с ключами уже существующими в дереве\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\"Добавляем узел с ключом 7 ...\" + tree.insertNode(7));\n+        System.out.println(\"Добавляем узел с ключом 3 ...\" + tree.insertNode(3));\n+        System.out.println(\"Добавляем узел с ключом 6 ...\" + tree.insertNode(6));\n+        timeStop = System.nanoTime();\n+        System.out.println(\"Попытка добавить 3 элемента с неуникальными ключами в дерево заняла: \" + (timeStop - timeStart) + \" ns\");\n+        System.out.println(\"В среднем, время действия одного элемента: \" + (timeStop - timeStart) / 10 + \" ns\");\n+        System.out.println(\"Добавляем еще 10 элементов в разнобой, с уникальным и неуникальным ключом (случайно)\");\n+        timeStart = System.nanoTime();\n+        for (int i = 0; i < 10; i++) {\n+            int rnd = random.nextInt(20);\n+            System.out.println(\"Добавляем узел с ключом \" + rnd + \" ...\" + tree.insertNode(rnd));\n+        }\n+        timeStop = System.nanoTime();\n+        System.out.println(\"Попытка добавить 10 элемента со случайными ключами в дерево заняла: \" + (timeStop - timeStart) + \" ns\");\n+        System.out.println(\"В среднем, время действия одного элемента: \" + (timeStop - timeStart) / 10 + \" ns\");\n+\n+        // простое отображение дерева решил сделать через переопределение toString:\n+        tree.simplePrintTree();\n+\n+        // находим узел по значению и выводим его в консоли\n+        int rnd = random.nextInt(20);\n+        System.out.println(\"Пытаемся найти элемент с индексом \" + rnd);\n+        timeStart = System.nanoTime();\n+        Node foundNode = tree.findNodeByValue(rnd);\n+        if (foundNode != null) {\n+            System.out.println(\"Элемент с индексом \" + rnd);\n+            System.out.println(\"Узел найден :\" + foundNode);\n+        } else {\n+            System.out.println(\"Элемент с индексом не найден\" + rnd);\n+            System.out.println(\"Значение, которое вернул метод:\" + foundNode);\n+        }\n+        timeStop = System.nanoTime();\n+        System.out.println(\"Попытка найти элемент со случайным ключом равным \" + rnd + \" заняла: \" + (timeStop - timeStart) + \" ns\");\n+\n+        // удаляем один, ранее найденный, узел и выводим оставшееся дерево в консоли\n+        System.out.println(\"Пытаемся удалить элемент с индексом \" + rnd);\n+        timeStart = System.nanoTime();\n+        tree.deleteNode(rnd);\n+        timeStop = System.nanoTime();\n+        System.out.println(\"Попытка удалить элемент со случайным ключом равным \" + rnd + \" заняла: \" + (timeStop - timeStart) + \" ns\");\n+        // состояние дерева после удаления элемента\n+        tree.simplePrintTree();\n+\n+        //6.4  ...поиск максимума и минимума.\n+        System.out.println(\"\\n Задание 6.4 выполнение.\");\n+        System.out.println(\"Поиск максимума\");\n+        timeStop = System.nanoTime();\n+        System.out.println(\"      максимальное значение \" + tree.getMax());\n+        System.out.println(\"      - Получение максимального значения заняло: \" + (timeStop - timeStart) + \" ns\");\n+        System.out.println(\"  Альтернативное решение: именно поиск максимума\");\n+        timeStop = System.nanoTime();\n+        System.out.println(\"      максимальное значение \" + tree.findMax());\n+        System.out.println(\"      - Поиск максимального значения занял: \" + (timeStop - timeStart) + \" ns\");\n+\n+        System.out.println(\"Поиск минимума\");\n+        timeStop = System.nanoTime();\n+        System.out.println(\"  Минимальное значение\" + tree.getMin());\n+        System.out.println(\"      - Получение минимального значения заняло: \" + (timeStop - timeStart) + \" ns\");\n+        System.out.println(\"  Альтернативное решение: именно поиск минимума\");\n+        timeStop = System.nanoTime();\n+        System.out.println(\"      Минимальное значение\" + tree.findMin());\n+        System.out.println(\"      - Поиск минимального значения занял: \" + (timeStop - timeStart) + \" ns\");\n+\n+        //6.6  ...алгоритм пирамидальной сортировки с реализацией бинарной пирамиды.\n+        System.out.println(\"\\n Задание 6.6 выполнение.\");\n+        int[] arrTest = new int[10];\n+        for (int i = 0; i < arrTest.length; i++) {\n+            arrTest[i] = random.nextInt(10);\n+        }\n+        System.out.println(\"Не сортированный (исходный массив) :\" + Arrays.toString(arrTest));\n+        timeStart = System.nanoTime();\n+        MyHeap myHeap = new MyHeap();\n+        myHeap.sort(arrTest);\n+        System.out.println(\"Сортировка \" + arrTest.length + \" элементов заняла: \" + (System.nanoTime() - timeStart) + \" ns\");\n+        System.out.println(\"Результат myHeap сортировки массива:\" + Arrays.toString(arrTest));\n+\n+    }\n+\n+\n+    //6.7 Приведите пример сбалансированного дерева и его применения.\n+    // Ответ:\n+    //\n+    //\n+    // несколько схем идеально сбалансированных деревьев:\n+    //                  0                       0             0\n+    //                /   \\                   /   \\\n+    //              0       0                 0   0\n+    //            /   \\   /   \\\n+    //            0   0   0   0\n+    //                          \\\n+    //                          0\n+\n+    public static int rnd(int max) {\n+        return (int) (Math.random() * ++max);\n+    }\n+}"
  }
]
