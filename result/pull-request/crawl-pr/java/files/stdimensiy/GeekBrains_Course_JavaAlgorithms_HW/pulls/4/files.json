[
  {
    "sha": "01fe650c340d5a5ac65aca03e384176fb113f1a2",
    "filename": "README.md",
    "status": "modified",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/README.md",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/README.md",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/README.md?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -9,7 +9,7 @@\n - [X] ***Урок №1.*** Алгоритмы и структуры данных.\n - [X] ***Урок №2.*** Массивы и сортировка.\n - [X] ***Урок №3.*** Коллекции, списки, связанные списки и итераторы.\n-- [ ] ***Урок №4.*** Стеки и очереди.\n+- [X] ***Урок №4.*** Стеки и очереди.\n - [ ] ***Урок №5.*** Рекурсия.\n - [ ] ***Урок №6.*** Деревья.\n - [ ] ***Урок №7.*** Графы.\n@@ -21,8 +21,8 @@\n :heavy_check_mark: ***Задача №1.***\t - Задание выполнено. -        \n :heavy_check_mark: ***Задача №2.***\t - Задание выполнено. -    \n :heavy_check_mark: ***Задача №3.***\t - Задание выполнено. -    \n-:clock2: ***Задача №4.***\t - выполняется -    \n-:lock: ***Задача №5.***\t - закрыт -    \n+:heavy_check_mark: ***Задача №4.***\t - Задание выполнено. -    \n+:clock2: ***Задача №5.***\t - выполняется -    \n :lock: ***Задача №6.***\t - закрыт -    \n :lock: ***Задача №7.***\t - закрыт -    \n :lock: ***Задача №8.***\t - закрыт -"
  },
  {
    "sha": "5113bb970689a8d6fd6d4b1b5ba72a83f3f13ecf",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/Cat.java",
    "status": "added",
    "additions": 93,
    "deletions": 0,
    "changes": 93,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Cat.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Cat.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Cat.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,93 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class Cat implements Comparable{\n+    private static int count;\n+    private String name;\n+    private double weight;\n+    private int age;\n+\n+    public Cat(String name) {\n+        this.name = name;\n+        count++;\n+    }\n+\n+    public Cat(String name, double weight, int age) {\n+        this.name = name;\n+        this.weight = weight;\n+        this.age = age;\n+        count++;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Cat{\" +\n+                \"name='\" + name + '\\'' +\n+                \", weight=\" + weight +\n+                \", age=\" + age +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+\n+        if (obj == null)\n+            return false;\n+\n+        if ( !(obj instanceof Cat) )\n+            return false;\n+\n+        Cat cat = (Cat) obj;\n+\n+        return this.name == cat.name && this.age == cat.age;\n+    }\n+\n+    public static int getCount() {\n+        return count;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public double getWeight() {\n+        return weight;\n+    }\n+\n+    public void setWeight(double weight) {\n+        this.weight = weight;\n+    }\n+\n+    public int getAge() {\n+        return age;\n+    }\n+\n+    public void setAge(int age) {\n+        this.age = age;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int compareTo(Object o) {\n+        Cat obj = (Cat) o;\n+        if(this.age == obj.age)\n+            return 0;\n+        else\n+            return this.age > obj.age ? 1 : -1;\n+    }\n+}"
  },
  {
    "sha": "12ff77787b665ccccc8931430888ad6dc4a5a9ac",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrDeque.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrDeque.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrDeque.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrDeque.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,114 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+\n+public class MyArrDeque<T> {\n+    private int maxSize;            //максимальный размер очереди\n+    private T[] queue;              //хранилище элементов очереди (в виде массива)\n+    private int front;              //указатель первого элемента в очереди (голова)\n+    private int rear;               //указатель последнего элемента в очереди (хвост)\n+    private int count;              //текущее количество элементов в очереди\n+\n+    public MyArrDeque(int maxSize) {\n+        this.maxSize = maxSize;\n+        this.count = 0;\n+        this.front = 0;\n+        this.rear = -1;\n+        this.queue = (T[]) new Object[maxSize];\n+    }\n+\n+    // метод аналогичен обычному offer в очереди. Добавляет один элемент в конец очереди\n+    public boolean offerLast(T element) {\n+        if (this.count < this.maxSize) {\n+            if (this.rear == this.maxSize - 1) this.rear = -1;\n+            this.queue[++this.rear] = element;\n+            this.count++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // метод добавляет один элемент в НАЧАЛО очереди\n+    public boolean offerFirst(T element) {\n+        if (this.count < this.maxSize) {\n+            if (this.front == 0) this.front = maxSize;\n+            this.queue[--this.front] = element;\n+            this.count++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // метод позволяет \"посмотреть\" получить первый элемент из головы очереди без удаления самого элемента.\n+    public T peekFirst() {\n+        if (count == 0) return null;\n+        return this.queue[this.front];\n+    }\n+\n+    // метод позволяет \"посмотреть\" получить первый \"сзади\" элемент из хвоста очереди без удаления самого элемента.\n+    public T peekLast() {\n+        if (count == 0) return null;\n+        return this.queue[this.rear];\n+    }\n+\n+    // метод позволяет получить первый элемент из головы очереди и удалить его\n+    // фактического удаления я не делаю ине трачу на это процессорное время, фактически смещается только маркер\n+    // тем самым значение в ячейке массива остается, но больше в наборе не принимает участие и при первой же\n+    // возможности затирается другим элементом.\n+    public T pollFirst() {\n+        if (count == 0) return null;\n+        int tempIndex = this.front++;\n+        this.count--;\n+        if (this.front == maxSize && count != 0) this.front = 0;\n+        if (this.front == maxSize && count == 0) this.front = -1;\n+        return this.queue[tempIndex];\n+    }\n+\n+    // метод позволяет получить первый элемент из хвоста очереди и удалить его\n+    // ротнцип действия похож на poolFirst();\n+    public T pollLast() {\n+        if (count == 0) return null;\n+        int tempIndex = this.rear--;\n+        this.count--;\n+        if (this.rear == -1 && count != 0) this.rear = this.maxSize - 1;\n+        if (this.rear == -1 && count == 0) this.rear = -1;\n+        return this.queue[tempIndex];\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public boolean isFull() {\n+        return count == maxSize;\n+    }\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.count == 0)\n+            return \"[]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int x = 0, y = this.front; x < this.count; x++) {\n+            if (y == maxSize) y = 0;\n+            T t = queue[y++];\n+            sb.append(t);\n+            if (x < this.count - 1) sb.append(\", \");\n+        }\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "649d740ea5a1e3e7341fd0c157dca3305212073e",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrQueue.java",
    "status": "added",
    "additions": 77,
    "deletions": 0,
    "changes": 77,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrQueue.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrQueue.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrQueue.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,77 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class MyArrQueue<T> {\n+    private int maxSize;            //максимальный размер очереди\n+    private T[] queue;              //хранилище элементов очереди (в виде массива)\n+    private int front;              //указатель первого элемента в очереди (голова)\n+    private int rear;               //указатель последнего элемента в очереди (хвост)\n+    private int count;              //текущее количество элементов в очереди\n+\n+    public MyArrQueue(int maxSize) {\n+        this.maxSize = maxSize;\n+        this.count = 0;\n+        this.front = 0;\n+        this.rear = -1;\n+        this.queue = (T[]) new Object[maxSize];\n+    }\n+\n+    public boolean offer(T element) {\n+        if (this.count < this.maxSize) {\n+            if (this.rear == this.maxSize) this.rear = -1;\n+            this.queue[++this.rear] = element;\n+            this.count++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public T poll() {\n+        if (this.front == -1) return null;\n+        this.count--;\n+        if (this.front == this.maxSize) this.front = -1;\n+        return this.queue[++this.front];\n+    }\n+\n+    public T peek() {\n+        if (this.front == -1) return null;\n+        return this.queue[this.front];\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public boolean isFull() {\n+        return count == maxSize;\n+    }\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.count == 0)\n+            return \"[]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int x = 0, y = this.front; x < this.count; x++) {\n+            if (y == maxSize) y = 0;\n+            T t = queue[y++];\n+            sb.append(t);\n+            if (x < this.count - 1) sb.append(\", \");\n+        }\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "8c7b4d30a12036ea13e4ee159d75910ef13dcabe",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrStack.java",
    "status": "added",
    "additions": 72,
    "deletions": 0,
    "changes": 72,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrStack.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrStack.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyArrStack.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,72 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+import ru.geekbrains.javaalgoritms.lesson3.Cat;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class MyArrStack<T> {\n+    private int maxSize;\n+    private T[] stack;\n+    private int top;\n+\n+    public MyArrStack(int maxSize) {\n+        this.maxSize = maxSize;\n+        this.stack = (T[]) new Object[maxSize];\n+        this.top = -1;\n+    }\n+\n+    public T push(T element) {\n+        this.stack[++this.top] = element;\n+        return element;\n+    }\n+\n+    public T peek() {\n+        return this.stack[this.top];\n+    }\n+\n+    public T pop() {\n+        return this.stack[this.top--];\n+    }\n+\n+    public boolean isEmpty() {\n+        return top == -1;\n+    }\n+\n+    public boolean isFull() {\n+        return top == maxSize - 1;\n+    }\n+\n+    public int size() {\n+        return top + 1;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.top == -1)\n+            return \"[]\";\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int x = 0; x < stack.length; x++) {\n+            T t = stack[x];\n+            if (t == null) {\n+                break;\n+            } else {\n+                sb.append(t);\n+                if (x < stack.length - 1 && stack[x + 1] != null) sb.append(\", \");\n+            }\n+        }\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "1392c3a66bf54297a04fb7a8c70be8e0ab408da1",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjDeque.java",
    "status": "added",
    "additions": 108,
    "deletions": 0,
    "changes": 108,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjDeque.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjDeque.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjDeque.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,108 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+\n+public class MyObjDeque<T> {\n+    private UnidirectionElement<T> front;\n+    private UnidirectionElement<T> rear;\n+    private int count;                     //текущее количество элементов в деке\n+\n+    public MyObjDeque() {\n+        this.count = 0;\n+        this.front = null;\n+        this.rear = null;\n+    }\n+\n+    // метод аналогичен обычному offer в очереди. Добавляет один элемент в конец очереди\n+    public UnidirectionElement<T> offerLast(T newElem) {\n+        UnidirectionElement<T> element = new UnidirectionElement<>(newElem);\n+        if (this.count == 0) {\n+            element.setNext(this.front);     // элемент запоминает что перед ним никого нет\n+            element.setPrevious(this.rear);     // элемент запоминает что за ним никого нет\n+            this.front = element;\n+            this.rear = element;\n+        } else {\n+            this.rear.setPrevious(element); // новый элемент говорит старому - я буду за вами.\n+            element.setNext(this.rear);     // новый запоминает старого у себя в памяти как следующий перед ним элемент\n+            element.setPrevious(null);      // новый запоминает что за ним никого нет\n+            this.rear = element;            // и становит ся за ним, становясь маркером последнего\n+        }\n+        count++;\n+        return element;\n+    }\n+\n+    // метод аналогичен обычному offer в очереди. Но добавляет один элемент в начало очереди\n+    public UnidirectionElement<T> offerFirst(T newElem) {\n+        UnidirectionElement<T> element = new UnidirectionElement<>(newElem);\n+        if (this.count == 0) {\n+            element.setNext(this.front);        // элемент запоминает что перед ним никого нет\n+            element.setPrevious(this.rear);     // элемент запоминает что за ним никого нет\n+            this.front = element;\n+            this.rear = element;\n+        } else {\n+            this.front.setNext(element);        // новый элемент говорит старому - я перед тобой пойду, возражений ведь нет???....\n+            element.setPrevious(this.front);    // новый запоминает старого у себя в памяти как идущий за ним элемент\n+            element.setNext(null);              // новый запоминает что перед ним никого нет\n+            this.front = element;               // и становится перед ним, становясь маркером первого в очереди элемента\n+        }\n+        count++;\n+        return element;\n+    }\n+\n+    public UnidirectionElement<T> pollFirst() {\n+        UnidirectionElement<T> tempElem = this.front;\n+        this.front = this.front.getPrevious();\n+        if (this.count > 0) this.count--;\n+        return tempElem;\n+    }\n+\n+    public UnidirectionElement<T> pollLast() {\n+        UnidirectionElement<T> tempElem = this.rear;\n+        this.rear = this.rear.getNext();\n+        if (this.count > 0) this.count--;\n+        return tempElem;\n+    }\n+\n+    // метод позволяет \"посмотреть\" получить первый элемент из головы очереди без удаления самого элемента.\n+    public UnidirectionElement<T> peekFirst() {\n+        return this.front;\n+    }\n+\n+    // метод позволяет \"посмотреть\" получить последний элемент из хвоста очереди без удаления самого элемента.\n+    public UnidirectionElement<T> peekLast() {\n+        return this.rear;\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.count == 0) return \"[]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        UnidirectionElement<T> tempElem = this.front;\n+        sb.append(tempElem);\n+        while (tempElem.getPrevious() != null) {\n+            tempElem = tempElem.getPrevious();\n+            sb.append(\", \");\n+            sb.append(tempElem);\n+        }\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "c3c3dcb94dcf9fdcfc5d9b313436ac303836739e",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjQueue.java",
    "status": "added",
    "additions": 76,
    "deletions": 0,
    "changes": 76,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjQueue.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjQueue.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjQueue.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,76 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class MyObjQueue<T> {\n+    private UnidirectionElement<T> front;\n+    private UnidirectionElement<T> rear;\n+    private int count;              //текущее количество элементов в очереди\n+\n+    public MyObjQueue() {\n+        this.count = 0;\n+        this.front = null;\n+        this.rear = null;\n+    }\n+\n+    public UnidirectionElement<T> offer(T newElem) {\n+        UnidirectionElement<T> element = new UnidirectionElement<>(newElem);\n+        if (this.front == null) {\n+            //element.setNext(this.front);\n+            //element.setPrevious(this.rear);\n+            this.front = element;\n+            this.rear = element;\n+        } else {\n+            this.rear.setPrevious(element);\n+            //element.setNext(this.rear);\n+            //element.setPrevious(null);\n+            this.rear = element;\n+        }\n+        count++;\n+        return element;\n+    }\n+\n+    public UnidirectionElement<T> poll() {\n+        UnidirectionElement<T> tempElem = this.front;\n+        this.front = this.front.getPrevious();\n+        count--;\n+        return tempElem;\n+    }\n+\n+    public UnidirectionElement<T> peek() {\n+        return this.front;\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.count == 0)\n+            return \"[]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        UnidirectionElement<T> tempElem = this.front;\n+        sb.append(tempElem);\n+        while (tempElem.getPrevious() != null){\n+            tempElem = tempElem.getPrevious();\n+            sb.append(\", \");\n+            sb.append(tempElem);\n+        }\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "26945025e8eb3c8c1afce6a788b7bfc8c3758d19",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjStack.java",
    "status": "added",
    "additions": 63,
    "deletions": 0,
    "changes": 63,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjStack.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjStack.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/MyObjStack.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,63 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+\n+public class MyObjStack<T> {\n+    private UnidirectionElement<T> top;\n+    private int count;\n+\n+    public MyObjStack() {\n+        this.top = null;\n+    }\n+\n+    public UnidirectionElement<T> push(T newElem) {\n+        UnidirectionElement<T> element = new UnidirectionElement<>(newElem);\n+        element.setNext(this.top);\n+        this.top = element;\n+        count++;\n+        return element;\n+    }\n+\n+    public UnidirectionElement<T> peek() {\n+        return this.top;\n+    }\n+\n+    public UnidirectionElement<T> pop() {\n+        UnidirectionElement<T> temp = this.top;\n+        this.top = this.top.getNext();\n+        if (count != 0) count--;\n+        return temp;\n+    }\n+\n+    public boolean isEmpty() {\n+        return count == 0;\n+    }\n+\n+    public int size() {\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this.top == null) return \"[]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        UnidirectionElement<T> temptop = this.top;\n+        do {\n+            sb.append(temptop);\n+            if (temptop.getNext() != null) sb.append(\", \");\n+            temptop = temptop.getNext();\n+        } while (temptop != null);\n+        return sb.append(']').toString();\n+    }\n+}"
  },
  {
    "sha": "9e29a98e2ca5a8dcd5827de0f9a2284af3698632",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/README.md",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/README.md",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/README.md",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/README.md?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,51 @@\n+### GeekBrains_Course_JavaAlgorithms_HW_Lesson_4\n+---\n+### Домашняя работа к занятию №4\n+Студента GeekBrains ***Веремеенко Дмитрия***    \n+Факультет: ***Android-разработки***    \n+Курс: ***Алгоритмы Java***\n+### Задание:\n+---\n+- [X] ***Задача №4.1***\tНа основе данных объектного списка из задания 3.4 реализуйте простой стек и его базовые методы.\n+  Оцените время выполнения операций с помощью базового метода System.nanoTime().\n+- [X] ***Задача №4.2***\tНа основе данных объектного списка из задания 3.4 реализуйте простую очередь и его базовые методы.\n+  Реализуйте вспомогательные методы.\n+  Оцените время выполнения операций с помощью базового метода System.nanoTime().\n+- [X] ***Задача №4.3***\tНа основе данных объектного списка из задания 3.4 реализуйте простой дек и его базовые методы.\n+  Оцените время выполнения операций с помощью базового метода System.nanoTime().\n+- [X] ***Задача №4.4***\tРеализуйте приоритетную очередь на основе ссылочных типов данных, например, integer.\n+  Оцените время выполнения операций с помощью базового метода System.nanoTime().    \n+- [X] ***Задача №4.5***\tНа основе данных из задания 4.1 и 4.2, реализуйте стек и очередь на базе связанного списка.\n+  Оцените время выполнения операций с помощью базового метода System.nanoTime().    \n+  \n+\n+### Отчет о выполнении:\n+---    \n+:heavy_check_mark: ***Задача №4.1.*** Задание выполнено. Реализован стек на базе библиотеки util (как на занятии) и \n+реализован \"ручками\" стек на базе массива (класс MyArrStack), укомплектован основными методами push(), peek() и pop().\n+Все основные методы запущены по 3 раза в main, произведен замер времени выполнения, результаты сведены в таблицу 4.1.      \n+:heavy_check_mark: ***Задача №4.2.*** Задание выполнено. Реализована простая очередь на базе библиотеки Util (как на занятии)\n+реализована \"ручками\" очередь на базе массива (класс MyArrQueue), укомплектован основными методами offer(), peek() и poll().\n+Для тестирования очереди заполнены объектами собственного класса Cat. Протестировано все, работает. \n+Все основные методы запущены по 3 раза в main, произведен замер времени выполнения, результаты сведены в таблицу 4.1.\n+Разработаны дополнительные методы isEmpty(), isFull(), size() и переопределил везде где нужно метод toString().\n+Данными методами укомплектованы все коллекции разработанные в рамках данного домашнего задания. Исключение составляет \n+метод isFull для стека, дека и очереди реализованных на базе линкованных списков, ибо в них я не ограничивал размер \n+(посчитал что ненужно).    \n+:heavy_check_mark: ***Задача №4.3.*** Задание выполнено. Реализована простая двунаправленная очередь \"дек\" на базе \n+библиотеки Util (как на занятии) и реализована \"ручками\" двунаправленная очередь на базе массива (класс MyArrDeque),\n+укомплектована основными методами offerFirst(), offerLast(), peekFirst(), peekLast(), pollFirst() и pollLast().\n+Для тестирования деки заполнены объектами собственного класса Cat. Протестировано все, работает.\n+Все основные методы запущены по 3 раза в main, произведен замер времени выполнения, результаты сведены в таблицу 4.1.   \n+:heavy_check_mark: ***Задача №4.4.*** Задание выполнено. Приоритетная очередь реализована на базе стандартного решения\n+из библиотеки util, но применена для собственных объектов (клас Cat) разработанных для предыдущих ДЗ. В результате для \n+обеспечения работоспособности такой очереди пришлось модифицировать класс Cat и имплементировать ему интерфейс Comparable,\n+ну и соответственно написать логику сравнения. В итоге приоритетом для элементов данного класса в данном ДЗ определен возраст кота.\n+Все основные методы запущены по 3 раза в main, произведен замер времени выполнения, результаты сведены в таблицу 4.1.   \n+:heavy_check_mark: ***Задача №4.5.*** Задание выполнено. Реализованы собственные решения организующие стек (класс MyObjStack),\n+очередь (класс MyObjQueue) и дек (класс MyObjDeque) со всеми основными и вспомогательными методами рассмотренными в ДЗ и на занятии.\n+Все основные методы запущены по 3 раза в main, произведен замер времени выполнения, результаты сведены в таблицу 4.1.    \n+      \n+---   \n+\n+*StDimensiy 27.02.2021*"
  },
  {
    "sha": "5d12b61df0cd645af8d11f3502fb2b1c6f088c0e",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/Std_HW_Lesson4.java",
    "status": "added",
    "additions": 417,
    "deletions": 0,
    "changes": 417,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Std_HW_Lesson4.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Std_HW_Lesson4.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/Std_HW_Lesson4.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,417 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+import java.util.*;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class Std_HW_Lesson4 {\n+    /* как я понял общую концепцию задания.\n+    /  1. необходимо создать самостоятельно (реализовать) стек, очередь, дек и приоритетную очередь причем сделать это на базе массивов.\n+    /  2. все самостоятельные реализации стека и очередей укомплектовать стандартными для данных коллекций методами\n+    /  3. отдельно создать стек и очередь реализованные не на базе массива а на базе коллекции объектов.\n+    /  4. ориентируясь на материал урока подключить и подготовить реализацию вышеперечисленных коллекций средствами библиотеки утиль.\n+    /  5. выполнить поочередно все стандартные методы для каждой реализации и сравнить результаты замера времени.\n+    /  грубо говоря берем добавление элемента закидываем в стек (на базе массива),. в очередь, в дек и в приоритетную очередь, результаты замера\n+    /  времени выводим в таблицу или просто сравниваем, повторяем для других операций.\n+\n+    /  Оговорки принятые для данного домашнего задания.\n+    /  Вероятно автор курса ошибся ссылаясь на пункт предыдущего ДЗ 3.4 где требовалась реализация двунаправленного списка\n+    /  так как материал урока содержит однонаправленный список и обращение к его реализации. да и по логике понятно, что нам необходим\n+    /  однонаправленный линкованный список. Поэтому пункт обращения к 3.4. игнорирован и заменен на пункт 3.3.\n+    /  пункт 3.4. принят только в части соблюдения требований заполнения списка объектами своего класса ( в моем случае котами) */\n+\n+    //приступаем.\n+    //создаем набор стеков базового (util), собственного на базе массива и собственного на базе объектов\n+    private static final Stack<Cat> stackUtilCat = new Stack<>();                        // методы push(), pop(), peek() - реализованы в базовом классе\n+    private static final MyArrStack<Cat> myArrStack = new MyArrStack<>(8);\n+    private static final MyObjStack<Cat> myObjStack = new MyObjStack<>();\n+    //создаем очередь базового исполнения библиотеки util\n+    private static final Queue<Cat> queueUtilCat = new LinkedList<>();                    // методы offer(), peek(), poll() - реализованы в базовом классе\n+    private static final MyArrQueue<Cat> myArrQueue = new MyArrQueue<>(8);         // взяты за основу и реализованы в собственных\n+    private static final MyObjQueue<Cat> myObjQueue = new MyObjQueue<>();                 // в собственных версиях очереди\n+    //создаем дек базового исполнения библиотеки util\n+    private static final Deque<Cat> dequeUtilCat = new ArrayDeque<>(8);        // методы offerFirst(), offerLast(), peekFirst()\n+    private static final MyArrDeque<Cat> myArrDeque = new MyArrDeque<>(8);         // peekLast(), poolFirst(), poolLast() - взяты за основу\n+    private static final MyObjDeque<Cat> myObjDeque = new MyObjDeque<>();                 // и реализованы в собственных версиях дека\n+    //создаем приоритетную очередь базового исполнения библиотеки util\n+    private static final PriorityQueue<Cat> priorityQueueUtilCat = new PriorityQueue<>(); // Приоритетная очередь объявления и инициирована для собственного класса Сат\n+    // для оформления\n+    private static String tw_StUt_NP = \"      ....   \";                                   // пустая вставка для таблицы\n+\n+    private static long timeStart;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Домашнее задание №4\");\n+\n+        //*** НАЧАЛО МОДУЛЯ РАБОТЫ СО СТЕКАМИ\n+        //СТЕКИ ------------  модуль работы с основными методами трех стеков, базовым (util) и двумя собственными\n+        //\n+        // ТЕСТИРОВАНИЕ СТЕКА ИЗ БИБЛИОТЕКИ UTIL\n+        // Процедура наполнения стека данными (для тестирования закидываем в каждый вид стека по 3 одинаковых объекта\n+        System.out.println();\n+        System.out.println(\"Тестирование стека Stack библиотеки Util\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода push()\" + stackUtilCat.push(new Cat(\"Барсик\")));\n+        System.out.println(\" - Результат работы метода push()\" + stackUtilCat.push(new Cat(\"Мурзик\")));\n+        System.out.println(\" - Результат работы метода push()\" + stackUtilCat.push(new Cat(\"Дурсик\")));\n+        String tw_StUt_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всего стека встроенным методом toString\n+        System.out.println(\" ---> Стек stackUtilCat (базовый)  заполнен: \" + stackUtilCat);\n+        // Процедура - \"посмотреть\" (peek) на верхний элемент стека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + stackUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + stackUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + stackUtilCat.peek());\n+        String tw_StUt_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) верхний элемент стека (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pop()\" + stackUtilCat.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + stackUtilCat.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + stackUtilCat.pop());\n+        String tw_StUt_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всего стека встроенным методом toString\n+        System.out.println(\"---> Стек stackUtilCat (базовый) итог. вар.: \" + stackUtilCat);\n+\n+        // ТЕСТИРОВАНИЕ собственного СТЕКА MyArrStack реализованного на базе массива\n+        System.out.println();\n+        System.out.println(\"Тестирование стека MyArrStack реализованного на базе массива\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода push()\" + myArrStack.push(new Cat(\"Барсик\")));\n+        System.out.println(\" - Результат работы метода push()\" + myArrStack.push(new Cat(\"Мурзик\")));\n+        System.out.println(\" - Результат работы метода push()\" + myArrStack.push(new Cat(\"Дурсик\")));\n+        String tw_StMA_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всего стека встроенным методом toString\n+        System.out.println(\" ---> Стек myArrStack (реализация через массив) заполнен: \" + myArrStack);\n+        // Процедура - \"посмотреть\" (peek) на верхний элемент стека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + myArrStack.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myArrStack.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myArrStack.peek());\n+        String tw_StMA_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) верхний элемент стека (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pop()\" + myArrStack.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + myArrStack.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + myArrStack.pop());\n+        String tw_StMA_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всего стека встроенным методом toString\n+        System.out.println(\"---> Стек myArrStack (реализация через массив) итог. вар.: \" + myArrStack);\n+\n+        // ТЕСТИРОВАНИЕ собственного СТЕКА MyObjStack реализованного на базе коллекции объектов (линкованного списка)\n+        System.out.println();\n+        System.out.println(\"Тестирование стека MyObjStack реализованного на базе коллекции объектов (линкованного списка)\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода push()\" + myObjStack.push(new Cat(\"Барсик\")));\n+        System.out.println(\" - Результат работы метода push()\" + myObjStack.push(new Cat(\"Мурзик\")));\n+        System.out.println(\" - Результат работы метода push()\" + myObjStack.push(new Cat(\"Дурсик\")));\n+        String tw_StMO_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всего стека встроенным методом toString\n+        System.out.println(\" ---> Стек MyObjStack реализованного на базе коллекции объектов заполнен: \" + myObjStack);\n+        // Процедура - \"посмотреть\" (peek) на верхний элемент стека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + myObjStack.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myObjStack.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myObjStack.peek());\n+        String tw_StMO_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) верхний элемент стека (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pop()\" + myObjStack.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + myObjStack.pop());\n+        System.out.println(\" - Результат работы метода pop()\" + myObjStack.pop());\n+        String tw_StMO_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всего стека встроенным методом toString\n+        System.out.println(\"---> Стек MyObjStack реализованного на базе коллекции объектов итог. вар.: \" + myObjStack);\n+        //СТЕКИ ------------  модуль работы с основными методами трех стеков базовым (util) и двумя собственными\n+        //*** Конец МОДУЛЯ РАБОТЫ СО СТЕКАМИ\n+\n+        //*** НАЧАЛО МОДУЛЯ РАБОТЫ С ОЧЕРЕДЯМИ\n+        //ОЧЕРЕДИ ------------  модуль работы с основными методами трех очередей, базовой (util) и двумя собственными\n+        //\n+        // ТЕСТИРОВАНИЕ ОЧЕРЕДИ ИЗ БИБЛИОТЕКИ UTIL\n+        // Процедура наполнения стека данными (для теста закидываем в каждый вид очереди по 3 одинаковых объекта\n+        System.out.println();\n+        System.out.println(\"Тестирование очереди Queue библиотеки Util\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offer()\" + (queueUtilCat.offer(new Cat(\"Барсик\")) ? \" true - элемент \" + new Cat(\"Барсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (queueUtilCat.offer(new Cat(\"Мурзик\")) ? \" true - элемент \" + new Cat(\"Мурзик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (queueUtilCat.offer(new Cat(\"Дурсик\")) ? \" true - элемент \" + new Cat(\"Дурсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_QuUt_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всей очереди встроенным методом toString\n+        System.out.println(\" ---> Очередь (по представлению toString) для queueUtilCat (базовый) заполнена: \" + queueUtilCat);\n+        // Процедура - \"посмотреть\" (peek) на фронтальный элемент очереди (выход) (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + queueUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + queueUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + queueUtilCat.peek());\n+        String tw_QuUt_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) фронтальный элемент очереди (выход) и стереть его\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода poll()\" + queueUtilCat.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + queueUtilCat.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + queueUtilCat.poll());\n+        String tw_QuUt_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всей очереди встроенным методом toString\n+        System.out.println(\"---> Очередь queueUtilCat после всех модификаций итог. вар.: \" + queueUtilCat);\n+\n+        // ТЕСТИРОВАНИЕ собственной ОЧЕРЕДИ MyArrQueue реализованной на базе массива\n+        System.out.println();\n+        System.out.println(\"Тестирование очереди myArrQueue реализованного на базе массива\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offer()\" + (myArrQueue.offer(new Cat(\"Барсик\")) ? \" true - элемент \" + new Cat(\"Барсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (myArrQueue.offer(new Cat(\"Мурзик\")) ? \" true - элемент \" + new Cat(\"Мурзик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (myArrQueue.offer(new Cat(\"Дурсик\")) ? \" true - элемент \" + new Cat(\"Дурсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_QuMA_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всей очереди встроенным методом toString\n+        System.out.println(\" ---> Очередь (по представлению toString) для myArrQueue заполнена: \" + myArrQueue);\n+        // Процедура - \"посмотреть\" (peek) на фронтальный элемент очереди (выход) (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + myArrQueue.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myArrQueue.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myArrQueue.peek());\n+        String tw_QuMA_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) фронтальный элемент очереди (выход) и стереть его\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода poll()\" + myArrQueue.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + myArrQueue.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + myArrQueue.poll());\n+        String tw_QuMA_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всей очереди встроенным методом toString\n+        System.out.println(\"---> Очередь myArrQueue итог. вар.: \" + myArrQueue);\n+\n+        // ТЕСТИРОВАНИЕ собственной ОЧЕРЕДИ MyObjQueue реализованного на базе коллекции объектов (линкованного списка)\n+        System.out.println();\n+        System.out.println(\"Тестирование очереди MyObjQueue реализованного на базе коллекции объектов (линкованного списка)\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offer()\" + myObjQueue.offer(new Cat(\"Барсик\")));\n+        System.out.println(\" - Результат работы метода offer()\" + myObjQueue.offer(new Cat(\"Мурзик\")));\n+        System.out.println(\" - Результат работы метода offer()\" + myObjQueue.offer(new Cat(\"Дурсик\")));\n+        String tw_QuMO_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всей очереди встроенным методом toString\n+        System.out.println(\" ---> Очередь (по представлению toString) для myObjQueue заполнена: \" + myObjQueue);\n+        // Процедура - \"посмотреть\" (peek) на фронтальный элемент очереди (выход) (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + myObjQueue.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myObjQueue.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + myObjQueue.peek());\n+        String tw_QuMO_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) фронтальный элемент очереди (выход) и стереть его\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода poll()\" + myObjQueue.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + myObjQueue.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + myObjQueue.poll());\n+        String tw_QuMO_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всй очереди встроенным методом toString\n+        System.out.println(\"---> Очередь myObjQueue итог. вар.: \" + myObjQueue);\n+        //\n+        //ОЧЕРЕДИ ------------  модуль работы с основными методами трех реализаций очереди базовой (util) и двумя собственными\n+        //*** Конец МОДУЛЯ РАБОТЫ С ОЧЕРЕДЯМИ\n+\n+        //*** НАЧАЛО МОДУЛЯ РАБОТЫ С ДВУНАПРАВЛЕННЫМИ ОЧЕРЕДЯМИ (ДЕКАМИ)\n+        //ДЕКИ ------------  модуль работы с основными методами трех реализаций двунаправленной очередей, базовой (util) и двух собственных\n+        //\n+        // ТЕСТИРОВАНИЕ ДЕКИ ИЗ БИБЛИОТЕКИ UTIL\n+        // Процедура наполнения ДЕКи данными (для теста закидываем в каждый метод и вид по 3 одинаковых объекта (метода)\n+        System.out.println();\n+        System.out.println(\"Тестирование очереди Queue библиотеки Util\");\n+        // добавляем элементы в хвост очереди (как обычно)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerLast()\" + (dequeUtilCat.offerLast(new Cat(\"Барсик\")) ? \" true - элемент \" + new Cat(\"Барсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerLast()\" + (dequeUtilCat.offerLast(new Cat(\"Мурзик\")) ? \" true - элемент \" + new Cat(\"Мурзик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerLast()\" + (dequeUtilCat.offerLast(new Cat(\"Дурсик\")) ? \" true - элемент \" + new Cat(\"Дурсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_DeUt_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // добавляем элементы в голову очереди (вот это уже особенность)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (dequeUtilCat.offerFirst(new Cat(\"Мурка\")) ? \" true - элемент \" + new Cat(\"Мурка\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (dequeUtilCat.offerFirst(new Cat(\"Алиса\")) ? \" true - элемент \" + new Cat(\"Алиса\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (dequeUtilCat.offerFirst(new Cat(\"Джина\")) ? \" true - элемент \" + new Cat(\"Джина\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_DeUt_Pl = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всей очереди встроенным методом toString\n+        System.out.println(\" ---> Очередь (по представлению toString) для dequeUtilCat (базовый)  заполнена: \" + dequeUtilCat);\n+        // Процедура - \"посмотреть\" (peekFirst) на элемент головы дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekFirst()\" + dequeUtilCat.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + dequeUtilCat.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + dequeUtilCat.peekFirst());\n+        String tw_DeUt_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"посмотреть\" (peekLast) на элемент хвоста дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekLast()\" + dequeUtilCat.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + dequeUtilCat.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + dequeUtilCat.peekLast());\n+        String tw_DeUt_Pk = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) верхний элемент из головы очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollFirst()\" + dequeUtilCat.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + dequeUtilCat.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + dequeUtilCat.pollFirst());\n+        String tw_DeUt_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) крайний элемент из хвоста очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollLast()\" + dequeUtilCat.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + dequeUtilCat.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + dequeUtilCat.pollLast());\n+        String tw_DeUt_Pd = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всй очереди встроенным методом toString\n+        System.out.println(\"---> Очередь dequeUtilCat итог. вар.: \" + dequeUtilCat);\n+\n+        // ТЕСТИРОВАНИЕ  собственной ДЕКИ MyArrDeque реализованной на базе массива\n+        System.out.println();\n+        System.out.println(\"Тестирование собственной реализации двунаправленной очереди myArrDeque на базе массива\");\n+        // добавляем элементы в хвост очереди ( как обычно)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerLast()\" + (myArrDeque.offerLast(new Cat(\"Барсик\")) ? \" true - элемент \" + new Cat(\"Барсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerLast()\" + (myArrDeque.offerLast(new Cat(\"Мурзик\")) ? \" true - элемент \" + new Cat(\"Мурзик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerLast()\" + (myArrDeque.offerLast(new Cat(\"Дурсик\")) ? \" true - элемент \" + new Cat(\"Дурсик\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_DeMA_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // добавляем элементы в голову очереди (вот это уже особенность)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (myArrDeque.offerFirst(new Cat(\"Мурка\")) ? \" true - элемент \" + new Cat(\"Мурка\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (myArrDeque.offerFirst(new Cat(\"Алиса\")) ? \" true - элемент \" + new Cat(\"Алиса\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + (myArrDeque.offerFirst(new Cat(\"Джина\")) ? \" true - элемент \" + new Cat(\"Джина\") + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_DeMA_Pl = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всей очереди встроенным методом toString\n+        System.out.println(\" ---> Дека (по представлению toString) для myArrDeque заполнена: \" + myArrDeque);\n+        // Процедура - \"посмотреть\" (peekFirst) на элемент головы дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myArrDeque.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myArrDeque.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myArrDeque.peekFirst());\n+        String tw_DeMA_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"посмотреть\" (peekLast) на элемент хвоста дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekLast()\" + myArrDeque.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + myArrDeque.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + myArrDeque.peekLast());\n+        String tw_DeMA_Pk = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) верхний элемент из головы очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myArrDeque.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myArrDeque.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myArrDeque.pollFirst());\n+        String tw_DeMA_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) крайний элемент из хвоста очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollLast()\" + myArrDeque.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + myArrDeque.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + myArrDeque.pollLast());\n+        String tw_DeMA_Pd = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всй очереди (дек) встроенным методом toString\n+        System.out.println(\"---> Дека myArrDeque итог. вар.: \" + myArrDeque);\n+\n+        // ТЕСТИРОВАНИЕ  собственной ДЕКи MyObjDeque реализованной на базе списка линкованных элементов\n+        System.out.println();\n+        System.out.println(\"Тестирование собственной реализации двунаправленной очереди myArrDeque на базе массива\");\n+        // добавляем элементы в хвост очереди ( как обычно)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerLast()\" + myObjDeque.offerLast(new Cat(\"Барсик\")));\n+        System.out.println(\" - Результат работы метода offerLast()\" + myObjDeque.offerLast(new Cat(\"Мурзик\")));\n+        System.out.println(\" - Результат работы метода offerLast()\" + myObjDeque.offerLast(new Cat(\"Дурсик\")));\n+        String tw_DeMO_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // добавляем элементы в голову очереди (вот это уже особенность)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offerFirst()\" + myObjDeque.offerFirst(new Cat(\"Мурка\")));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + myObjDeque.offerFirst(new Cat(\"Алиса\")));\n+        System.out.println(\" - Результат работы метода offerFirst()\" + myObjDeque.offerFirst(new Cat(\"Джина\")));\n+        String tw_DeMO_Pl = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния деки встроенным методом toString\n+        System.out.println(\" ---> Дека (по представлению toString) для myObjDeque заполнена: \" + myObjDeque);\n+        // Процедура - \"посмотреть\" (peekFirst) на элемент головы дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myObjDeque.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myObjDeque.peekFirst());\n+        System.out.println(\" - Результат работы метода peekFirst()\" + myObjDeque.peekFirst());\n+        String tw_DeMO_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"посмотреть\" (peekLast) на элемент хвоста дека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peekLast()\" + myObjDeque.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + myObjDeque.peekLast());\n+        System.out.println(\" - Результат работы метода peekLast()\" + myObjDeque.peekLast());\n+        String tw_DeMO_Pk = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) верхний элемент из головы очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myObjDeque.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myObjDeque.pollFirst());\n+        System.out.println(\" - Результат работы метода pollFirst()\" + myObjDeque.pollFirst());\n+        String tw_DeMO_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pollFirst) крайний элемент из хвоста очереди (дека) (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода pollLast()\" + myObjDeque.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + myObjDeque.pollLast());\n+        System.out.println(\" - Результат работы метода pollLast()\" + myObjDeque.pollLast());\n+        String tw_DeMO_Pd = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всего дека, после манипуляций, переопределенным методом toString\n+        System.out.println(\"---> Дека myObjDeque итог. вар.: \" + myObjDeque);\n+        //ДЕКИ ------------  модуль работы с основными методами трех реализаций двунаправленных очередей базовой (util) и двумя собственными\n+        //*** Конец МОДУЛЯ РАБОТЫ С ДЕКАМИ\n+\n+        //*** НАЧАЛО МОДУЛЯ РАБОТЫ С ПРИОРИТЕТНЫМИ ОЧЕРЕДЯМИ\n+        //ПРИОРИТЕТНЫЕ ОЧЕРЕДИ---  модуль работы с основными методами приоритетной очереди\n+        //\n+        // ТЕСТИРОВАНИЕ ПРИОРИТЕТНОЙ ОЧЕРЕДИ ИЗ БИБЛИОТЕКИ UTIL\n+        // Процедура наполнения ОЧЕРЕДИ данными (для теста закидываем в каждый метод и вид по 3 одинаковых объекта (метода)\n+        // для решения данной задачи создана приоритетная очередь элементов собственного класса Cat. Класс для этих целей пришлось\n+        //слегка модифицировать. Тестирование выполнено, в финальной версии ДЗ оставлены только запросы результаты которых\n+        // идут в результирующую таблицу замера времени выполнения методлов.\n+        //*** небольшая оговорка, приоритетность элементов класса Cat определена по возрасту кота. (для тренировки)\n+        System.out.println();\n+        System.out.println(\"Тестирование очереди Queue библиотеки Util\");\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода offer()\" + (priorityQueueUtilCat.offer(new Cat(\"Барсик\", 2.7, 5)) ? \" true - элемент \" + new Cat(\"Барсик\", 2.7, 5) + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (priorityQueueUtilCat.offer(new Cat(\"Мурзик\", 2.8, 3)) ? \" true - элемент \" + new Cat(\"Мурзик\", 2.8, 3) + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        System.out.println(\" - Результат работы метода offer()\" + (priorityQueueUtilCat.offer(new Cat(\"Дурсик\", 2.9, 6)) ? \" true - элемент \" + new Cat(\"Дурсик\", 2.9, 6) + \" добавлен в очередь.\" : \"Ошибка! Элемент не добавлен в очередь.\"));\n+        String tw_PqUt_Pu = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение промежуточного состояния всего стека встроенным методом toString\n+        System.out.println(\" ---> Очередь (по представлению toString) для queueUtilCat (базовый)  заполнена: \" + priorityQueueUtilCat);\n+        // Процедура - \"посмотреть\" (peek) на верхний элемент стека (возвращает значение элемента и НЕ стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода peek()\" + priorityQueueUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + priorityQueueUtilCat.peek());\n+        System.out.println(\" - Результат работы метода peek()\" + priorityQueueUtilCat.peek());\n+        String tw_PqUt_Pe = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Процедура - \"снять\" (pop) верхний элемент стека (возвращает значение элемента и стирает его)\n+        timeStart = System.nanoTime();\n+        System.out.println(\" - Результат работы метода poll()\" + priorityQueueUtilCat.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + priorityQueueUtilCat.poll());\n+        System.out.println(\" - Результат работы метода poll()\" + priorityQueueUtilCat.poll());\n+        String tw_PqUt_Po = String.format(\"%1$10d\", System.nanoTime() - timeStart);\n+        // Отображение итогового состояния всего стека встроенным методом toString\n+        System.out.println(\"---> Очередь queueUtilCat итог. вар.: \" + priorityQueueUtilCat);\n+\n+        // вывод сводного результата среднего времени выполнения однотипных основных операций для стека, очереди, дека и приоритетной очереди\n+        System.out.println();\n+        System.out.println(\"------------------------------------------------------------------------------------------------------------------- Таблица 4.1 ---\");\n+        System.out.println(\"- Type  - Действие: методы для разных коллекций     -     Stack       ---      Queue      ---      Deque      ---  PriorityQueue  -\");\n+        System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------\");\n+        System.out.println(\"- Util  - Добавить: push(), offer() или offerLast() - \" + tw_StUt_Pu + \" ns   ---  \" + tw_QuUt_Pu + \" ns  ---  \" + tw_DeUt_Pu + \" ns  ---  \" + tw_PqUt_Pu + \" ns  -\");\n+        System.out.println(\"- Util  - Добавить: offerFirst()                    - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeUt_Pl + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyArr - Добавить: push(), offer() или offerLast() - \" + tw_StMA_Pu + \" ns   ---  \" + tw_QuMA_Pu + \" ns  ---  \" + tw_DeMA_Pu + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyArr - Добавить: offerFirst()                    - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMA_Pl + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyObj - Добавить: push(), offer() или offerLast() - \" + tw_StMO_Pu + \" ns   ---  \" + tw_QuMO_Pu + \" ns  ---  \" + tw_DeMO_Pu + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyObj - Добавить: offerFirst()                    - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMO_Pl + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------\");\n+        System.out.println(\"- Util  - Получить не удалять: peek(), peekLast()   - \" + tw_StUt_Pe + \" ns   ---  \" + tw_QuUt_Pe + \" ns  ---  \" + tw_DeUt_Pe + \" ns  ---  \" + tw_PqUt_Pe + \" ns  -\");\n+        System.out.println(\"- Util  - Получить не удалять: peekFirst()          - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeUt_Pk + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyArr - Получить не удалять: peek(), peekLast()   - \" + tw_StMA_Pe + \" ns   ---  \" + tw_QuMA_Pe + \" ns  ---  \" + tw_DeMA_Pe + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyArr - Получить не удалять: peekFirst()          - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMA_Pk + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyObj - Получить не удалять: peek(), peekLast()   - \" + tw_StMO_Pe + \" ns   ---  \" + tw_QuMO_Pe + \" ns  ---  \" + tw_DeMO_Pe + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyObj - Получить не удалять: peekFirst()          - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMO_Pk + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------\");\n+        System.out.println(\"- Util  - Получ./удал.: pop(), poll() ,pollFirst()  - \" + tw_StUt_Po + \" ns   ---  \" + tw_QuUt_Po + \" ns  ---  \" + tw_DeUt_Po + \" ns  ---  \" + tw_PqUt_Po + \" ns  -\");\n+        System.out.println(\"- Util  - Получить и удалить: pollLast()            - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeUt_Pd + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyArr - Получ./удал.: pop(), poll() ,pollFirst()  - \" + tw_StMA_Po + \" ns   ---  \" + tw_QuMA_Po + \" ns  ---  \" + tw_DeMA_Po + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyArr - Получить и удалить: pollLast()            - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMA_Pd + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"- MyObj - Получ./удал.: pop(), poll() ,pollFirst()  - \" + tw_StMO_Po + \" ns   ---  \" + tw_QuMO_Po + \" ns  ---  \" + tw_DeMO_Po + \" ns  ---  -не проведен-  -\");\n+        System.out.println(\"- MyObj -  Получить и удалить: pollLast()           - \" + tw_StUt_NP + \"   ---  \" + tw_StUt_NP + \"  ---  \" + tw_DeMO_Pd + \" ns  ---  \" + tw_StUt_NP + \"  -\");\n+        System.out.println(\"-----------------------------------------------------------------------------------------------------------------------------------\");\n+    }\n+\n+}"
  },
  {
    "sha": "8fa789702b2839d9d6915d8f8deebb6d87979da3",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionElement.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionElement.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionElement.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionElement.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,47 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class UnidirectionElement<T> {\n+    private final T unidirectionElement;\n+    private UnidirectionElement<T> next;\n+    private UnidirectionElement<T> previous;\n+\n+    public UnidirectionElement(T unidirectionElement) {\n+        this.unidirectionElement = unidirectionElement;\n+    }\n+\n+    public UnidirectionElement<T> getNext() {\n+        return this.next;\n+    }\n+\n+    public UnidirectionElement<T> getPrevious() {\n+        return this.previous;\n+    }\n+\n+    public void setNext(UnidirectionElement<T> next) {\n+        this.next = next;\n+    }\n+\n+    public void setPrevious(UnidirectionElement<T> previous) {\n+        this.previous = previous;\n+    }\n+\n+    public T getValue() {\n+        return unidirectionElement;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return unidirectionElement.toString();\n+    }\n+}"
  },
  {
    "sha": "dffd47011a1a435b540223579a2539637406469d",
    "filename": "src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionList.java",
    "status": "added",
    "additions": 114,
    "deletions": 0,
    "changes": 114,
    "blob_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/blob/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionList.java",
    "raw_url": "https://github.com/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/raw/944d064cfbdd9dec19d69d84d88b041bc2f02709/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionList.java",
    "contents_url": "https://api.github.com/repos/stdimensiy/GeekBrains_Course_JavaAlgorithms_HW/contents/src/main/java/ru/geekbrains/javaalgoritms/lesson4/UnidirectionList.java?ref=944d064cfbdd9dec19d69d84d88b041bc2f02709",
    "patch": "@@ -0,0 +1,114 @@\n+package ru.geekbrains.javaalgoritms.lesson4;\n+\n+/**\n+ * Сourse: java algorithms\n+ * Faculty of Geek University Android Development\n+ *\n+ * @Author Student Dmitry Veremeenko aka StDimensiy\n+ * Group 24.12.2020\n+ * <p>\n+ * HomeWork for lesson 4\n+ * Created 26.02.2021\n+ * v 1.0\n+ */\n+public class UnidirectionList<T> {\n+    // Реализация очень простого односвязного линкованного списка (коллекции)\n+    // для ДЗ в классе дерализованы следующие методы:\n+    // - isEmpty() проверяет пустой или не пустой список.\n+    // - add() добавляет новый элемент в начало списка (передаваемый параметра - объект)\n+    // - remove() предоставляет объект из начала списка и удаляет его.\n+    // - remove(индекс элемента) предоставляет объект по его текущему индексу в списке и удаляет его.\n+    // - removeAll() зачищает список, удаляя все элементы.\n+    // - getFirst() быстро предоставляет первый элемент списка или null если список пустой.\n+    // - get(индекс) предоставляет элемент списка по индексу (и не удаляет его).\n+    // - contains(объект) ищет в списке искомое значение и возвращает индекс позиции где элемент найден, или -1 если нет.\n+    // - toString() переопределен для быстрого и относительно красивого отображения содержимого коллекции\n+    private UnidirectionElement<T> first; //поле класса отвечающее за хранение первого элемента\n+\n+    // конструктор инициализирующий пустой список\n+    public UnidirectionList() {\n+        this.first = null;\n+    }\n+\n+    // метод возвращающий результат проверки пустой список или нет\n+    public boolean isEmpty() {\n+        return (this.first == null);\n+    }\n+\n+    // метод осуществляющий включение элемента в список\n+    public void add(T newElem) {\n+        UnidirectionElement<T> element = new UnidirectionElement<>(newElem);\n+        element.setNext(this.first);\n+        this.first = element;\n+    }\n+\n+    // метод осуществляющий исключение элемента из списка\n+    public UnidirectionElement<T> remove() {\n+        UnidirectionElement<T> tempElement = this.first;\n+        this.first = tempElement.getNext();\n+        return tempElement;\n+    }\n+\n+    // метод осуществляющий исключение элемента из списка по индексу\n+    public UnidirectionElement<T> remove(int index) {\n+        UnidirectionElement<T> previousElement = null;\n+        UnidirectionElement<T> currentElement = first;\n+        while (currentElement.getNext() != null && index > 0) {\n+            index--;\n+            previousElement = currentElement;\n+            currentElement = currentElement.getNext();\n+        }\n+        previousElement.setNext(currentElement.getNext());\n+        return currentElement;\n+    }\n+\n+    // метод осуществляющий исключение всех элементов списка\n+    public void removeAll() {\n+        this.first = null;\n+    }\n+\n+    //метод возвращает первый элемент коллекции\n+    public UnidirectionElement<T> getFirst() {\n+        return first;\n+    }\n+\n+    //метод возвращает элемент коллекции по его текущему индексу в ней (счет ведется от 0 как в массивах)\n+    public UnidirectionElement<T> get(int index) {\n+        UnidirectionElement<T> currentElement = first;\n+        while (currentElement.getNext() != null && index > 0) {\n+            index--;\n+            currentElement = currentElement.getNext();\n+        }\n+        return currentElement;\n+    }\n+\n+    //метод возвращает индекс текущего положения искомого элемента в списке или -1 если не нашел.\n+    public int conteins(T element) {\n+        UnidirectionElement<T> currentElement = first;\n+        int count = -1;\n+        while (currentElement.getNext() != null) {\n+            count++;\n+            if (currentElement.getValue().equals(element)) {\n+                return count;\n+            }\n+            currentElement = currentElement.getNext();\n+        }\n+        return -1;\n+    }\n+\n+    //метод быстрого вывода на печать всех элементов списка\n+    @Override\n+    public String toString() {\n+        if (isEmpty()) return \"[] Список пуст\";\n+        String resultString = \"[\";\n+        UnidirectionElement<T> currentElem = this.first;\n+        do {\n+            resultString = resultString + currentElem;\n+            currentElem = currentElem.getNext();\n+            if (currentElem != null) resultString += \", \\n \";\n+        } while (currentElem != null);\n+        resultString += \"] \";\n+        return resultString;\n+    }\n+\n+}"
  }
]
