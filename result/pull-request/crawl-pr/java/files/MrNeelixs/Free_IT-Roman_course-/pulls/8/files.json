[
  {
    "sha": "9eff7fc73eed6e4f3dcdbb2b459478fa0fa97ec2",
    "filename": "src/main/helper/helper",
    "status": "added",
    "additions": 194,
    "deletions": 0,
    "changes": 194,
    "blob_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/blob/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/helper/helper",
    "raw_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/raw/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/helper/helper",
    "contents_url": "https://api.github.com/repos/MrNeelixs/Free_IT-Roman_course-/contents/src/main/helper/helper?ref=e44ed79ab0c53fa3c48fafe9046240eb97151061",
    "patch": "@@ -0,0 +1,194 @@\n+                        Класс Math\n+Класс Math содержит методы, связанные с геометрией и тригонометрией и\n+прочей математики. Методы реализованы как static, поэтому можно сразу вызывать\n+через Math.methodName() без создания экземпляра класса.\n+*****************************************************************************************\n+abs(x) – модуль аргумента.\n+ceil(x) – округление в большую строну.\n+cos(x) – косинус.\n+exp(x) – экспонента.\n+floor(x) – округление в меньшую сторону.\n+log(x) – логарифм.\n+max(x, y) – максимальное значение из данных аргументов.\n+min(x, y) – минимальное значение.\n+pow(x, y) – возведение в степень.\n+random() – случайное число от 0 до 1.\n+round(x) – округление к ближайшему целому.\n+sin(x) – синус.\n+sqrt(x) – квадратный корень.\n+tan(x) – тангенс.\n+valueOf(): Для преобразования обычного числа в число с произвольной точностью\n+           (называемое большим числом)\n+При работе с большими числами нельзя использовать привычные\n+математические операции с помощью + или * и т.п. Вместо них следует использовать\n+специальные методы add() (сложение), multiply() (умножение), divide() (деление) и\n+т.д.\n+*************************************************************************************\n+                                Класс Arrays\n+static int binarySearch(int[] a, int key) – производит поиск в массиве\n+                                            указанного значения бинарным способом. Если массив не является\n+                                            отсортированным, результаты поиска неопределены.\n+static boolean equals(int[] a, int[] a2) – сравнивает два массива.\n+\n+static void fill(int[] a, int val) –       назначает указанное значение всем элементам\n+                                           массива. После массива могут быть указаны еще два параметра: номер первого и\n+                                           номер последнего элемента, которым присваиваются значения.\n+\n+static void sort(int[] a) –                сортирует массив. Также можно отсортировать\n+                                           фрагмент массива, указав, вторым и третьим входными параметрами номера\n+                                           первого и последнего элемента, сортируемой части.\n+\n+****************************************************************************************************\n+                                    Классы-обертки\n+Следует отметить одну особенность объектов данных классов – значения в\n+объектах не могут меняться. Т.е. если создан объект типа Integer со значением 5,\n+изменить это значение не возможно. Если следует менять значение, необходимо\n+создавать новый объект.\n+\n+double doubleValue() – возвращает вещественное удвоенной точности.\n+float floatValue() – возвращает вещественное.\n+int intValue() – возвращает целое число.\n+long longValue() – возвращает длинное целое.\n+short shortValue() – возвращает короткое целое.\n+\n+static int parseInt(String str) функция для перевода из строкового в числовой\n+                                тип. Функция является статической, и возвращает значение примитивного типа.\n+\n+static String toBinaryString(int i)\n+static String toHexString(int i)       функций для перевода числа в строку с указанной системой счисления:\n+static String toOctalString(int i)\n+\n+******************************************************************************************************\n+                                    Дата и время\n+Когда объект, содержащий дату создан, можно получить значение любого из ее параметров, используя следующий метод:\n+\n+public int get(int field)  Данному методу на вход передается константа, задающая, какой параметр\n+                           необходимо получить. Имеются следующие константы:\n+\n+static int DATE – функция вернет день месяца\n+static int DAY_OF_MONTH – аналогично предыдущему.\n+static int DAY_OF_WEEK – функция вернет день недели.\n+static int DAY_OF_YEAR – функция вернет номер этого дня в данном году.\n+static int HOUR – функция вернет час.\n+static int HOUR_OF_DAY – функция вернет час.\n+static int MILLISECOND – функция вернет миллисекунды, в данной секунде.\n+static int MINUTE – функция вернет секунды.\n+static int MONTH – функция вернет месяц.\n+static int SECOND – функция вернет секунды.\n+static int WEEK_OF_MONTH – функция вернет номер недели.\n+static int WEEK_OF_YEAR – функция вернет номер недели в году.\n+static int YEAR – функция вернет номер года.\n+\n+void set(int field, int value) – первый параметр – одна из вышеописанных констант,\n+                                 второй – значение соответствующего элемента даты.\n+\n+void setTime(Date date) – берет данные из объекта Date.\n+void setTimeInMillis(long millis) – получает дату в виде длинного целого (в\n+                                    миллисекундах от исходной).\n+Методы для сравнения дат:\n+\n+boolean after(Object when)\n+boolean before(Object when)\n+\n+*******************************************************************************************************\n+                                    Строки\n+String не может быть изменен – вместо этого, при попытке изменения\n+переменной String, создается новый объект String и просто заменяется ссылка.\n+1. использование строк в многопоточных средах (String является\n+потокобезопасным (thread-safe) )\n+2. использование String Pool (это коллекция ссылок на String объекты,\n+используется для оптимизации памяти)\n+3. использование строк в качестве ключей в HashMap (ключ\n+рекомендуется делать неизменяемым)\n+\n+String str1 = str.substring(5);   Функция substring отрезает фрагмент строки, начиная с указанной позиции.\n+\n+char charAt(int index)          возвращает символ, находящийся вуказанной позиции.\n+\n+int compareTo(String anotherString)   сравнивает строку с другой строкой (сравнивается именно текст, содержащийся в\n+                                      строках)\n+\n+int compareToIgnoreCase(String str)   то же самое, но без учета регистра\n+\n+String concat(String str)               возвращает объект строки, содержащий\n+                                        сумму данной строки, и переданной как\n+                                        аргумент.\n+\n+boolean contentEquals(StringBuffer sb)  сравнивает содержимое объекта String и\n+                                        StringBuffer\n+\n+static String copyValueOf(char[] data) возвращает объект строки, содержащей переданные методу символы\n+\n+static String copyValueOf(char[] data,int offset, int count)    возвращает объект строки, содержащий\n+                                                                символы из переданного массива, начиная с\n+                                                                символа, заданного вторым параметром, и\n+                                                                количество, заданное третьим параметром.\n+\n+boolean endsWith(String suffix)                             проверяет, завершается ли строка заданным\n+                                                            суффиксом (совпадает ли конец строки с\n+                                                            переданной)\n+\n+boolean equals(Object anObject) с                           равнивает строку с объектом\n+\n+boolean equalsIgnoreCase(String anotherString)              сравнивает строки, игнорируя регистр\n+\n+byte[] getBytes()                                           возвращает строку в виде массива байтов (в\n+                                                            качестве входного параметра указывается\n+                                                            название требуемой кодировки)\n+\n+void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)  копирует элементы из данной строки в\n+                                                                   массив, заданный третьим параметром\n+\n+int hashCode()                      возвращает хеш-код строки.\n+\n+int indexOf(int ch)                 ищет в строке переданный символ и\n+                                    возвращает позицию первого совпадения.\n+                                    Может иметь два параметра, тогда вторым\n+                                    указывается номер, с которого надо начинать\n+                                    поиск. Вместо символа может быть также\n+                                    строка.\n+\n+int lastIndexOf(int ch)             аналогично предыдущему, но поиск выполняется с конца.\n+\n+int length()                        возвращает длину строки.\n+\n+boolean regionMatches(boolean ignoreCase, int toffset, String other,int ooffset, int len)\n+\n+                                                    проверяет, совпадают ли заданные\n+                                                    фрагменты строк. Первый параметр может\n+                                                     отсутствовать\n+\n+String replace(char oldChar, char newChar)          возвращает строку, где все символы,\n+                                                    совпадающие с первым, заменены вторым\n+\n+boolean startsWith(String prefix)                   проверяет, начинается ли строка с данного\n+                                                    префикса (совпадает ли начало строки с\n+                                                    переданной)\n+\n+String substring(int beginIndex)                    возвращает строку, содержащую фрагмент\n+                                                    данной строки. Может иметь два параметра:\n+                                                    номер первого символа и номер последнего\n+                                                    символа (второй может отсутствовать)\n+\n+char[] toCharArray()                                возвращает массив символов, содержащий данную строку.\n+\n+String toLowerCase()                                возвращает строку, содержащую копию\n+                                                    данной, приведенную к нижнему регистру\n+String toUpperCase()                                аналогично, но к верхнему регистру\n+\n+String trim()                                       возвращает строку с удаленными начальными\n+                                                    и конечными пробелами\n+\n+static String valueOf(boolean b)                    возвращает строковое представление\n+                                                    булевского аргумента (аргумент может быть\n+                                                    любого примитивного типа)\n+\n+Метод trim() —                                      возвращает копию строки с пропущенными начальными и конечными пробелами\n+\n+Метод split                                         в Java разделяет строку на подстроки, используя разделитель, который определяется с помощью регулярного выражения.\n+\n+Метод replaceAll() —                                заменяет каждую подстроку данной строки, которая соответствует заданному регулярному выражению, с данной заменой,\n+                                                    другими словами — метод позволяет заменить слово в строке.\n+\n+********************************************************************************************************\n+"
  },
  {
    "sha": "8abbc37f4333fa7735024cba17df40a555d841ae",
    "filename": "src/main/java/lesson_3/Task_18.java",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/blob/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_18.java",
    "raw_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/raw/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_18.java",
    "contents_url": "https://api.github.com/repos/MrNeelixs/Free_IT-Roman_course-/contents/src/main/java/lesson_3/Task_18.java?ref=e44ed79ab0c53fa3c48fafe9046240eb97151061",
    "patch": "@@ -0,0 +1,20 @@\n+/*\n+Найти в строке не только запятые, но и другие знаки препинания. Подсчитать\n+общее их количество.\n+ */\n+public class Task_18 {\n+    public void CountingPunctuation(String text) {\n+        int n = 0;\n+        char symbol;\n+        for (int i = 0; i < text.length(); i++) {\n+            symbol = text.charAt(i);\n+            if ((symbol == '.' || symbol == ',' || symbol == ';')\n+                    || (symbol == '-' || symbol == ':' || symbol == '\"')\n+                    || (symbol == '?' || symbol == '!')\n+                    || (symbol == '(' || symbol == ')')) {\n+                n++;\n+            }\n+        }\n+        System.out.println(\"У нас есть \" + n + \" знака препинания\");\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "edeab5a59dc3f5844f8465442273f5f4d0f746c4",
    "filename": "src/main/java/lesson_3/Task_19.java",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/blob/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_19.java",
    "raw_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/raw/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_19.java",
    "contents_url": "https://api.github.com/repos/MrNeelixs/Free_IT-Roman_course-/contents/src/main/java/lesson_3/Task_19.java?ref=e44ed79ab0c53fa3c48fafe9046240eb97151061",
    "patch": "@@ -0,0 +1,15 @@\n+/*\n+Имеется строка с текстом. Подсчитать количество слов в тексте. Желательно\n+учесть, что слова могут разделяться несколькими пробелами, в начале и конце\n+текста также могут быть пробелы, но могут и отсутствовать.\n+ */\n+public class Task_19 {\n+    public void showWordCount(String text) {\n+        // Метод trim() — возвращает копию строки с пропущенными начальными и конечными пробелами\n+        text = text.trim();\n+        String[] words = text.split(\"[\\\\s,.:!?-]+\"); //возвращает копию данной строки без знаков препинания и пробелов.\n+        for (String w : words) {\n+        }\n+        System.out.println(\"Текст состоит из \" + words.length + \" слов.\");\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "76a35cadcfd94fc07facdda068b3194d0ceb8e5f",
    "filename": "src/main/java/lesson_3/Task_20.java",
    "status": "added",
    "additions": 20,
    "deletions": 0,
    "changes": 20,
    "blob_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/blob/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_20.java",
    "raw_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/raw/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_20.java",
    "contents_url": "https://api.github.com/repos/MrNeelixs/Free_IT-Roman_course-/contents/src/main/java/lesson_3/Task_20.java?ref=e44ed79ab0c53fa3c48fafe9046240eb97151061",
    "patch": "@@ -0,0 +1,20 @@\n+/*\n+Имеется строка с текстом. Вывести текст, составленный из последних букв\n+всех слов.\n+ */\n+public class Task_20 {\n+    public void showTask_20(String text) {\n+        // С помощю replaceAll избовляемся от знаков припенпния.\n+        text = text.trim();\n+        text = text.replaceAll(\"[?!.,:;-]\", \"\");\n+        String[] words = text.split(\" \");  //возвращает массив строк.\n+        StringBuilder newText = new StringBuilder();\n+        for (String word : words) {\n+            //  append <---- обновляет значение объекта c помощю\n+            //  charAt возвращает символ, расположенный по указанному индексу строки последний символю\n+            newText.append(word.charAt(word.length() - 1));\n+        }\n+\n+        System.out.println(\"Новый текст из последних символов ---> \" + newText);\n+    }\n+}\n\\ No newline at end of file"
  },
  {
    "sha": "d385bca62e96da1ad9627c3acf1f6bdf24244b4b",
    "filename": "src/main/java/lesson_3/Task_21.java",
    "status": "added",
    "additions": 47,
    "deletions": 0,
    "changes": 47,
    "blob_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/blob/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_21.java",
    "raw_url": "https://github.com/MrNeelixs/Free_IT-Roman_course-/raw/e44ed79ab0c53fa3c48fafe9046240eb97151061/src/main/java/lesson_3/Task_21.java",
    "contents_url": "https://api.github.com/repos/MrNeelixs/Free_IT-Roman_course-/contents/src/main/java/lesson_3/Task_21.java?ref=e44ed79ab0c53fa3c48fafe9046240eb97151061",
    "patch": "@@ -0,0 +1,47 @@\n+/*\n+Напишите три цикла выполняющих многократное сложение строк, один с\n+помощью оператора сложения и String, другой с помощью StringBuilder и метода\n+append, а также аналогино для StringBuffer. Сравните скорость их выполнения.\n+ */\n+public class Task_21 {\n+    public void showTask_21(String text) {\n+        System.out.println(\"1.Слаживаем с помощю цикла For : \");\n+        showAddString(text);\n+        System.out.println();\n+        System.out.println(\"2.Слаживаем с помощю StringBuilder метод append : \");\n+        showBuilderAppend(text);\n+        System.out.println();\n+        System.out.println(\"3.Слаживаем с помощю StringBuffer  метод append : \");\n+        showBufferAppend(text);\n+\n+    }\n+\n+    public void showAddString(String text) {\n+        long time = System.nanoTime();\n+        for (int i = 1; i <= 2; i++) {\n+            text += text;\n+        }\n+        System.out.println(\"Обедененый текст : \" + text);\n+        time = System.nanoTime() - time;\n+        System.out.printf(\"Метот выполнен за %,9.3f ms\\n\", time / 1_000_000.0);\n+    }\n+\n+    public void showBuilderAppend(String text) {\n+        long time = System.nanoTime();\n+        StringBuilder builder = new StringBuilder(\"Обедененый текст : \");\n+        builder.append(text).append(text).append(text);\n+        System.out.println(builder);\n+        time = System.nanoTime() - time;\n+        System.out.printf(\"Метот выполнен за %,9.3f ms\\n\", time / 1_000_000.0);\n+\n+    }\n+\n+    public void showBufferAppend(String text) {\n+        long time = System.nanoTime();\n+        StringBuffer stringBuffer = new StringBuffer(\"Обедененый текст : \");\n+        stringBuffer.append(text).append(text).append(text);\n+        System.out.println(stringBuffer);\n+        time = System.nanoTime() - time;\n+        System.out.printf(\"Метот выполнен за %,9.3f ms\\n\", time / 1_000_000.0);\n+    }\n+}\n\\ No newline at end of file"
  }
]
