[
  {
    "sha": "0791eb611233fd0a88d27bd1c318668f09f11c1f",
    "filename": "build.gradle",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/build.gradle",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/build.gradle",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/build.gradle?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -639,9 +639,10 @@ task javadocs(type: Javadoc) {\n     description = \"Generate main pravega javadoc\"\n \n     // Include names of any project that is to be included in the javadoc distribution\n-    ext.projects = [':client']\n+    ext.projects = [':client', ':serializers', ':serializers:json', ':serializers:avro', ':serializers:protobuf']\n+\n     options.links(\"http://docs.oracle.com/javase/10/docs/api/\");\n-    title = \"Pravega API\"\n+    title = \"Schema Registry API\"\n     destinationDir = file(\"${buildDir}/javadocs\")\n     source = files(projects.collect {\n         project(it).sourceSets.main.allJava"
  },
  {
    "sha": "a8c124b6b47688935589d446c3c83717cfcc11f7",
    "filename": "documentation/src/docs/contributing.md",
    "status": "added",
    "additions": 16,
    "deletions": 0,
    "changes": 16,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/contributing.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/contributing.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/contributing.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,16 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Contributing to Pravega\n+\n+* [Contributions guidelines](https://github.com/pravega/pravega/wiki/Contributing)\n+* [Issue triaging and labeling](https://github.com/pravega/pravega/wiki/Issues-Triaging-and-Labeling)\n+* [Review process](https://github.com/pravega/pravega/wiki/Pull-Request-and-Reviews)\n+\n+Happy hacking!"
  },
  {
    "sha": "7e92cb06d2e2c97c85254275f1a1102e7232e3cf",
    "filename": "documentation/src/docs/getting-started.md",
    "status": "added",
    "additions": 130,
    "deletions": 0,
    "changes": 130,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/getting-started.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/getting-started.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/getting-started.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,130 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Getting Started\n+\n+Schema registry service allows you to manage and serve your schemas for the data in pravega streams. \n+Best way to get started with schema registry is to see it in action in a pravega application. \n+This document assumes you are familiar with and know how to use pravega SDK to write and read data into pravega.  \n+\n+## Schema Registry Service\n+\n+Before we deploy schema registry service, make sure you have pravega setup. Please refer to pravega's [getting-started](https://github.com/pravega/pravega/blob/master/documentation/src/docs/getting-started.md) to run pravega in standalone mode.\n+\n+**Verify the following prerequisite**\n+\n+```\n+Java 8 or higher\n+```\n+\n+Once you have started pravega in standalone mode, it is time to run schema registry service. \n+\n+**Download Schema Registry**\n+\n+Download the Schema registry release from the [Github Releases](https://github.com/pravega/schema-registry/releases).\n+\n+You can also choose to clone and build schema registry service. \n+```\n+git clone https://github.com/pravega/schema-registry.git\n+```\n+After you clone the schema registry repository run `./gradlew distribution` and `cd build/distribution`. \n+\n+Uncompress the distribution and you are ready to start the schema registry service. \n+```\n+$ tar xfvz schema-registry-<version>.tgz\n+```\n+\n+```\n+$ cd schema-registry-<version>\n+```\n+Note: the default configuration assumes schema registry service can access pravega running on tcp://localhost:9090. However, if you wish to point to a different pravega deployment, edit `conf/schema-registry.config.properties` and change pravega connection related configurations starting with pravega controller's url. \n+```\n+schemaRegistry.store.pravega.controller.connect.uri=${CONTROLLER_URL}\n+```\n+\n+**Running schema registry service without Pravega**\n+You can also run schema-registry without Pravega by changing the store type in configuration file `conf/schema-registry.config.properties` to `InMemory`.\n+```\n+schemaRegistry.store.type.name=InMemory\n+``` \n+The above will run schema registry in a standalone mode where all schemas will only be stored in the process's memory and will be lost whenever the process is stopped. This configuration should only be used for testing and demo purposes and never used in production. \n+\n+Once you have configured schema registry, you can start the service by running following command\n+```\n+$ bin/schema-registry\n+\n+```\n+This will bring up schema registry service which start a REST endpoint listening on port 9092. Now you are ready to manage and serve your schemas for your pravega streams. \n+\n+## Running a sample Pravega Application with schema registry\n+\n+Schema registry integrates with pravega applications using the Serializer interface. Schema registry provides serializers modules which can be used in your application to use schemas registered with schema registry service.\n+Include following maven dependency in your application:\n+```\n+ <dependency>\n+        <groupId>io.pravega</groupId>\n+            <artifactId>schemaregistry-serializers</artifactId>\n+            <version>0.2.0</version>\n+ </dependency>\n+```\n+\n+Then you use schema registry serializers by instantiating them in your application and using them with pravega writer and reader SDK.\n+\n+```\n+    // 1. Create schema registry client configuration with the registry service url:\n+    SchemaRegistryClientConfig config = SchemaRegistryClientConfig.builder()\n+\t        .schemaRegistryUri(registryUri).build();\n+    \n+\t// 2. Create serializer config where you can optionally tell the SDK to automatically create a new schema group and register the schema before using it. \n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+\t        .groupId(groupId).registryConfig(config)\n+                .createGroup(SerializationFormat.Avro).registerSchema(true)                \n+                .build();\n+    \n+\t// 3. Instantiate serializer with the Schema to use. \n+    Serializer<User> serializer = SerializerFactory.avroSerializer(serializerConfig, AvroSchema.of(User.class));\n+    \n+\t// 4. Use serializer with Pravega Writers. \n+    EventStreamWriter<User> writer = clientFactory.createEventWriter(\n+\t        stream, serializer, EventWriterConfig.builder().build());\n+    writer.writeEvent(new User(\"test\", 1000)).join();\n+\n+    // 5. Similarly create deserializer \n+    Serializer<User> deserializer = SerializerFactory.avroDeserializer(\n+\t                serializerConfig, AvroSchema.of(User.class));\n+\t\n+\t// 5.1 You can also create generic deserializer which deserializes your data into a generic object\n+\t// (for example: GenericRecord for avro, DynamicMessage for Protobuf and JsonNode for json)\n+    Serializer<Object> genericDeserializer = SerializerFactory.avroGenericDeserializer(serializerConfig);\n+\n+\t// 6. instantiate pravega reader and use schema registry deserializer. \n+    readerGroupManager.createReaderGroup(rg, ReaderGroupConfig.builder()\n+\t             .stream(NameUtils.getScopedStreamName(scope, stream)).build());\n+    EventStreamReader<User> reader = clientFactory.createReader(\n+\t                \"r1\", rg, deserializer, ReaderConfig.builder().build());\n+    EventRead<User> event = reader.readNextEvent(1000);\n+```\n+\n+We have developed a few samples to introduce the developer on how to use schema registry with pravega applications: [Pravega Schema Registry Samples](https://github.com/pravega/pravega-samples/tree/master/schema-registry-examples).\n+\n+**Download the Pravega-Samples git repo**\n+\n+```\n+$ git clone https://github.com/pravega/pravega-samples\n+$ cd pravega-samples/schema-registry-examples\n+```\n+\n+**Generate the scripts to run the applications**\n+\n+```\n+$ ../gradlew install\n+$ cd schema-registry-examples/build/install/pravega-schema-registry-examples\n+```\n+\n+For instructions on how to run individual samples and look at the instructions [here](https://github.com/pravega/pravega-samples/blob/master/schema-registry-examples/README.md). "
  },
  {
    "sha": "a784282856f1a379b85d9d1bce5333891333bb07",
    "filename": "documentation/src/docs/installation-guide.md",
    "status": "added",
    "additions": 50,
    "deletions": 0,
    "changes": 50,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/installation-guide.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/installation-guide.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/installation-guide.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,50 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+\n+\n+Prepare your environment \n+Schema Registry uses Pravega to store the schemas durably. Following steps assumes you have pravega deployed and running. \n+\n+### Helm Chart\n+-----------------------------\n+\n+Schema registry also includes Helm Charts to deploy Schema Registry service on a Kubernetes cluster.\n+Detailed instructions can be found [here](https://github.com/pravega/schema-registry/blob/master/charts/schema-registry/README.md)\n+\n+```\n+helm install <release-name> charts/schema-registry\n+```\n+The charts can be configured to change the number of replicas, supply TLS configuration, controller uri and other schema regsitry configurations. \n+\n+### Running Schema Registry Service in standalone mode\n+-----------------------------\n+\n+You can download released versions of schema registry from the [github release page](https://github.com/pravega/schema-registry/releases).\n+\n+Alternatively, you can also clone the master and install and run the Schema Registry Service locally using following commands:\n+```\n+1. ./gradlew install\n+2. cd server/build/distributions/\n+```\n+\n+It is prerequisite to run pravega, which the schema registry services uses as its durable storage. \n+However, for testing/demo purposes it is also possible to run schema registry without a pravega deployment too, but it will not provide any durability and all schemas will be lost as soon as the service is stopped.\n+  \n+After downloading/installing the schema registry, \n+```\n+3. uncompress schema-registry-<version>.tar or schema-registry-<version>.zip\n+4. cd schema-registry-<version>\n+5. change CONTROLLER_URL in conf/schema-registry.config.properties\n+6. ./bin/schema-registry\n+```\n+The above will start the schema registry server listening on port 9092. \n+\n+To run schema registry without pravega, in the conf/schema-registry.config.properties change the STORE_TYPE to `InMemory`. \n+"
  },
  {
    "sha": "ca817e4fdc6c9e436230c56a0db424dd3b79417e",
    "filename": "documentation/src/docs/javadoc.md",
    "status": "added",
    "additions": 15,
    "deletions": 0,
    "changes": 15,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/javadoc.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/javadoc.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/javadoc.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,15 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Java API Reference\n+\n+### **Clients**\n+\n+### **Serializers**\n+"
  },
  {
    "sha": "a459a0a72689e9229486480e670bbdbc4756b94b",
    "filename": "documentation/src/docs/overview.md",
    "status": "added",
    "additions": 65,
    "deletions": 0,
    "changes": 65,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/overview.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/overview.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/overview.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,65 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+# Schema Registry Overview\n+\n+Pravega Schema Registry is the latest service offering from Pravega family. The registry service is designed to store and manage schemas for the unstructured data stored in Pravega streams. The service is designed to not be limited to the data stored in Pravega and can serve as a general purpose management solution for storing and evolving schemas in wide variety of streaming and non streaming use cases.\n+\n+It provides RESTful interface to store and manage schemas under schema groups. Schema groups are named groups under which schemas are registered and the service manages their versioned. Users can safely evolve their schemas within the context of the schema group based on desired schema compatibility policy configured at a group level. The service has built in support for popular serialization formats in Avro, Profobuf and JSON schemas, however, users can also store and manage schemas from any serialization system. The service allows users to specify desired compatibility policies for evolution of their schemas but these are employed only for the natively supported serialization systems.\n+\n+Along with schemas, users can also use schema registry service to store additional encoding information about their data in pravega. The service exposes APIs to allow users to register additional codec information which includes the name of the encoding scheme used and any additional properties in form of key value pairs of strings. Encoding information would typically correspond to different compression or encryption used while encoding the serialized data at rest. The service generates unique identifiers for schemas and codec information pairs that users may use to tag their data with. \n+\n+\n+Please refer to following wiki pages for installation and usage samples. \n+\n+## Releases\n+\n+The latest Pravega releases can be found on the [Github Release](https://github.com/pravega/pravega/releases) project page.\n+\n+## Running Schema Registry\n+\n+Prerequesites: Pravega. Make sure you have pravega deployed and running. \n+\n+Schema registry can be run in standalone or in a distributed mode. The installation and deployment of Schema Registry is covered in the [Running Schema Registry](installation-guide.md) guide.\n+\n+## Schema registry components\n+There are three main components involved in schema registry.\n+1.    Schema Registry Service – The service exposes a RESTful endpoint and uses pravega key value tables to durably store and evolve schemas.\n+2.    Java Client - This provides APIs to users to manage their schema groups and schemas. It uses a jersey rest client to talk to schema registry service.  \n+3.    Serializers - Schema registry aware Serializers that can be used in Pravega's EventStreamWriter and EventStreamReader. It comes with serializers for avro protobuf and json and support for providing custom serializer implementation too.  \n+\n+## Schema Registry REST APIs\n+Schema registry REST API documentation can be found [here](rest-documentation.md). \n+Sample curl commands for REST APIs can be found [here](rest-usage.md). \n+\n+## Using Schema Registry in Pravega Applications \n+\n+Examples of Pravega applications using schema registry serializers can be found [here](pravega-applications.md)\n+\n+## Pravega Security, Role-based access control and TLS\n+\n+Just like pravega, Schema Registry also supports encryption of all communication channels and pluggable role-based access control. \n+Please refer [here](security.md) for more details on authentication and authorization.\n+\n+## Support\n+\n+Don’t hesitate to ask! Contact the developers and community on the [Slack](https://pravega-io.slack.com/) or email at security@pravega.io if you need any help.\n+Please open an issue in [Github Issues](https://github.com/pravega/pravega/issues) if you find a bug.\n+\n+## Contributing\n+\n+Become one of the **contributors!** We thrive to build a welcoming and open\n+community for anyone who wants to use the system or contribute to it.\n+Please check the [Pravega Contributions Guidelines](contributing.md) to quickly understand on how to contribute to Pravega? \n+\n+## About\n+\n+Pravega is 100% open source and community-driven. All components are available\n+under [Apache 2 License](https://www.apache.org/licenses/LICENSE-2.0.html) on\n+GitHub."
  },
  {
    "sha": "a5b8d08c13fe3f60c9b26cea3a3f379b12215bb9",
    "filename": "documentation/src/docs/pravega-applications.md",
    "status": "added",
    "additions": 512,
    "deletions": 0,
    "changes": 512,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/pravega-applications.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/pravega-applications.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/pravega-applications.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,512 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+\n+### Usage in pravega applications\n+Schema registry repository comes with schema registry serializers that can be used in pravega applications when instantiating Pravega Event Writers or Readers. Schema Registry comes with serializers for different serialization formats like avro protobuf and json.\n+ \n+These serializers hide away all the interaction and stamping of data with schema registry generated encoding identifiers.\n+All the interaction with schema registry service is transparent to the user. They merely need to provide the schema registry URL and instantiate a serializer.\n+\n+### Maven dependency\n+Schema registry is available on maven central repository. In your application's pom file add a dependency on one of schema registry serializers. It comes in four flavours - avro, protobuf, json and a serializers artifact that has all of the above and support for custom formats. \n+The artifacts are available in both fat and lean jar options. For fat jars add the classifier `all`. \n+```\n+all:\n+ <dependency>\n+        <groupId>io.pravega</groupId>\n+            <artifactId>schemaregistry-serializers</artifactId>\n+            <version>0.1.0</version>\n+ </dependency>\n+\n+json only:\n+ <dependency>\n+        <groupId>io.pravega</groupId>\n+            <artifactId>schemaregistry-serializers-json</artifactId>\n+            <version>0.1.0</version>\n+ </dependency>\n+\n+avro only:\n+ <dependency>\n+        <groupId>io.pravega</groupId>\n+            <artifactId>schemaregistry-serializers-avro</artifactId>\n+            <version>0.1.0</version>\n+ </dependency>\n+\n+protobuf only:\n+ <dependency>\n+        <groupId>io.pravega</groupId>\n+            <artifactId>schemaregistry-serializers-protobuf</artifactId>\n+            <version>0.1.0</version>\n+ </dependency>\n+```\n+\n+### Sample \n+For trying out schema registry in pravega application, you may check out schema registry samples available with [pravega samples](https://github.com/pravega/pravega-samples). \n+\n+The following example demonstrates how schema registry avro serializer can be used with pravega clients to read and write avro data into pravega stream. \n+Here, `User` is an avro generated java class. This is the object that will be written into and read from pravega streams. \n+\n+SchemaRegistry's SerializerFactory provides avro serializers and deserializers that are instantiated with AvroSchema for User class. \n+The following is an example of detailed configuration that tells the SerializerFactory to automatically create the schema registry `Group` and automatically register the supplied schema before using it. The defaults for these are to not create the group and not add schema automatically. \n+\n+```\n+\n+    \n+    // create serializer and deserializer\n+    SchemaRegistryClientConfig config = SchemaRegistryClientConfig.builder()\n+\t        .schemaRegistryUri(registryUri).build();\n+    \n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+\t        .groupId(groupId).registryConfig(config)\n+                .createGroup(SerializationFormat.Avro).registerSchema(true)                \n+                .build();\n+    \n+    Serializer<User> serializer = SerializerFactory\n+\t        .avroSerializer(serializerConfig, AvroSchema.of(User.class));\n+    // writer \n+    EventStreamWriter<User> writer = clientFactory.createEventWriter(\n+\t        stream, serializer, EventWriterConfig.builder().build());\n+    writer.writeEvent(new User(\"test\", 1000)).join();\n+\n+    // reader\n+    readerGroupManager.createReaderGroup(rg, ReaderGroupConfig.builder()\n+\t             .stream(NameUtils.getScopedStreamName(scope, stream)).build());\n+\n+    // to use the writer schema, replace `AvroSchema.of(User.class)` with `null`\n+    Serializer<User> deserializer = SerializerFactory.avroDeserializer(\n+\t                serializerConfig, AvroSchema.of(User.class));\n+\n+    EventStreamReader<User> reader = clientFactory.createReader(\n+\t                \"r1\", rg, deserializer, ReaderConfig.builder().build());\n+    EventRead<User> event = reader.readNextEvent(1000);\n+```\n+\n+### Programmatic usage of Schema Registry \n+We will focus on the programatic usage of schema registry in this document. REST api documentation is available [here](https://github.com/pravega/schema-registry/wiki/REST-documentation).\n+\n+### Schema registry client \n+Instantiate schema registry client:\n+```\n+    SchemaRegistryClientConfig config = SchemaRegistryClientConfig.builder()\n+\t                                   .schemaRegistryUri(registryUri).build();\n+    SchemaRegistryClient client = SchemaRegistryClientFactory.createRegistryClient(config);\n+```\n+\n+### Serializers \n+Data path apis can also be invoked using REST clients but are typically meaningful while using schema registry supplied serializers. The invocation of data path apis is transparent to the user using these serializers. \n+\n+To instantiate serializers, users will supply a serializer configuration and the schema to use. \n+Example serializer config:\n+```        \n+    // with registry client config \n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+                                    .groupId(groupId)\n+                                    .registryConfig(config)\n+                                    .build();\n+\n+    // with registry client\n+    SerializerConfig serializerConfig2 = SerializerConfig.builder()\n+                                    .groupId(groupId)\n+                                    .registryClient(client)\n+                                    .build();\n+```\n+\n+Instantiating a serializer is as simple as calling the appropriate factory method with the config and schema. \n+example serializer:\n+```\n+    // avro\n+    Serializer<User> serializer = SerializerFactory.avroSerializer(\n+\t            serializerConfig, AvroSchema.of(User.class));\n+\n+    // protobuf \n+    ProtobufSchema<Protobuf.User> schema = ProtobufSchema.of(\n+\t                Protobuf.User.class);\n+    Serializer<Protobuf.User> serializer = SerializerFactory.protobufSerializer(\n+\t                serializerConfig, schema);\n+\n+    // json\n+    Serializer<MyUser> serializer = SerializerFactory.jsonSerializer(\n+\t                serializerConfig, JSONSchema.of(MyUser.class));\n+```\n+\n+\n+### Add group \n+As first step, the user needs to create schema group. Then it can add schemas and codecs to the group. Or use data path apis by instantiating Serializers to encode and decode user objects. \n+Create Group can be created in two ways programmatically:\n+-    Instantiate Registry Client and call addGroup api on it\n+```\n+        client.addGroup(groupId, serializationFormat, schemaValidationRules, \n+\t\t                true, Collections.emptyMap());\n+```\n+-    Set `createGroup` in SerializerConfig\n+```\n+   SerializerConfig serializerConfig = SerializerConfig.builder()\n+                        .groupId(groupId)\n+                        .createGroup(SerializationFormat.Avro)\n+                        .registryConfig(config)\n+                        .build();\n+\n+   SerializerConfig serializerConfig = SerializerConfig.builder()\n+                        .groupId(groupId)\n+                        .createGroup(SerializationFormat.Avro, Compatibility.backward(), true)\n+                        .registryConfig(config)\n+                        .build();\n+\n+```\n+\n+### Add Schema\n+Similar to add group, addSchema can also be performed in two ways programmatically:\n+-    Call addSchema api on schema registry client\n+```\n+        SchemaInfo schemaInfo = new SchemaInfo(\"User\", SerializationFormat.Avro, \n+                schema.toString().getBytes(Charsets.UTF_8), ImmutableMap.of());\n+\n+        VersionInfo version = client.addSchema(group, schemaInfo);\n+\n+```\n+-    Set registerSchema in serializer config and use it with a schema while instantiating a serializer. The schema will be auto registered \n+by the serializer factory before instantiating the serializer.  \n+```\n+        SerializerConfig serializerConfig = SerializerConfig.builder()\n+                    .groupId(groupId)\n+                    .registerSchema(true)\n+                    .registryConfig(config)\n+                    .build();\n+```\n+\n+### Schema container objects\n+The serializer factory accepts schemas encapsulated under an implemetation of schema container interface. We provide implementation for `AvroSchema`, `ProtobufSchema` and `JSONSchema` with the serializers. For custom serialization format, users need to wrap their schema under a SchemaContainer object that is capable of converting the schema object to `SchemaInfo` object as defined by schema registry client. \n+\n+All three of AvroSchema, ProtobufSchema and JSONSchema can be used for both typed and generic schema objects.\n+```\n+    // avro\n+    AvroSchema<User> schema = AvroSchema.of(User.class);\n+    AvroSchema<Object> schema = AvroSchema.of(avroSchemaObj);\n+\n+    // protobuf \n+    ProtobufSchema<Protobuf.Message1> schema = ProtobufSchema.of(\n+\t            Protobuf.Message1.class);\n+    ProtobufSchema<DynamicMessage> schema = ProtobufSchema.of(\n+\t              \"Protobuf.Message1\", descriptorSet);\n+\n+    // json\n+    JSONSchema<MyUser> schema = JSONSchema.of(MyUser.class);\n+    JSONSchema<Object> serializer = JSONSchema.of(\"MyUser\", jsonSchemaString);\n+```\n+\n+\n+### Serializer Factory\n+Serializer factory class is used to create different types of serializers. \n+For each of protobuf, avro and json, serializer factory provides serializer and deserializer implementations that can be used in pravega clients.\n+These serializers will transparently communicate with schema registry, and serialize/deserialize java objects. \n+There is support for both typed java objects and serialization system specific generic record deserialization. \n+\n+Example of avro serializers and deserializers (similar set of serializers and deserializers available for protobuf and json)\n+```\n+    /**\n+     * Creates a typed avro serializer for the Schema. The serializer implementation returned from this method is\n+     * responsible for interacting with schema registry service and ensures that only valid registered schema can be used.\n+     * \n+     * Note: the returned serializer only implements {@link Serializer#serialize(Object)}.\n+     * It does not implement {@link Serializer#deserialize(ByteBuffer)}.\n+     */\n+    public static <T> Serializer<T> avroSerializer(SerializerConfig config, AvroSchema<T> schemaData);\n+\n+    /**\n+     * Creates a typed avro deserializer for the Schema. The deserializer implementation returned from this method is\n+     * responsible for interacting with schema registry service and validate the writer schema before using it.\n+     * \n+     * Note: the returned serializer only implements {@link Serializer#deserialize(ByteBuffer)}.\n+     * It does not implement {@link Serializer#serialize(Object)}.\n+     */\n+    public static <T extends IndexedRecord> Serializer<T> avroDeserializer(SerializerConfig config,\n+                                                                           AvroSchema<T> schemaData);\n+\n+    /**\n+     * Creates a generic avro deserializer. It has the optional parameter for schema.\n+     * If the schema is not supplied, the writer schema is used for deserialization into {@link Object}. All avro record types\n+     * are deserialized as {@link GenericRecord}.\n+     * Note: the returned serializer only implements {@link Serializer#deserialize(ByteBuffer)}.\n+     * It does not implement {@link Serializer#serialize(Object)}.\n+     */\n+    public static Serializer<Object> avroGenericDeserializer(\n+                                     SerializerConfig config, @Nullable AvroSchema<Object> schemaData);\n+\n+```\n+Example writer:\n+```\n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+             .groupId(groupId)\n+             .registryConfig(config)\n+             .build();\n+\n+    AvroSchema<User> schema = AvroSchema.of(User.class);\n+    Serializer<User> serializer = SerializerFactory.avroSerializer(\n+\t          serializerConfig, schema);\n+```\n+Example reader:\n+```\n+    // Deserialize into typed java object\n+    Serializer<User> deserializer = SerializerFactory.avroDeserializer(\n+\t          serializerConfig, schema);\n+        \n+    // Use writer schema to deserialize into generic record\n+    Serializer<Object> genericDeserializer = SerializerFactory.\n+\t          avroGenericDeserializer(serializerConfig, null);\n+```\n+\n+#### Multiple Event Types within same pravega stream\n+To support scenarios where multiple types of objects could be written into same pravega stream, SerializerFactory provides `multiType serializers and deserializers`. Similar serializers and deserializers are also available for Protobuf and json. \n+This is typically beneficial for event sourcing and message bus or microservice communication scenarios. \n+``` \n+    /**\n+     * A multiplexed Avro serializer that takes a map of schemas and validates them individually.\n+     */\n+    public static <T extends IndexedRecord> Serializer<T> avroMultiTypeSerializer(SerializerConfig config,\n+                                                                                  Map<Class<? extends T>, AvroSchema<T>> schemas);\n+\n+    /**\n+     * A multiplexed Avro Deserializer that takes a map of schemas and deserializes events into those events depending\n+     * on the object type information in {@link EncodingInfo}.\n+     */\n+    public static <T extends SpecificRecordBase> Serializer<T> avroMultiTypeDeserializer(\n+            SerializerConfig config, Map<Class<? extends T>, AvroSchema<T>> schemas);\n+\n+    /**\n+     * A multiplexed Avro Deserializer that takes a map of schemas and deserializes events into those events depending\n+     * on the object type information in {@link EncodingInfo}.\n+     */\n+    public static <T extends SpecificRecordBase> Serializer<Either<T, Object>> avroTypedOrGenericDeserializer(\n+            SerializerConfig config, Map<Class<? extends T>, AvroSchema<T>> schemas);\n+```\n+\n+Example writer and reader for multi type:\n+In following code example, `User` and `Address` are avro generated java classes. \n+```\n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+                                            .groupId(groupId)\n+                                            .createGroup(serializationFormat,\n+                                                Compatibility.backward(),\n+                                                true)\n+                                            .registerSchema(true)\n+                                            .registryClient(client)\n+                                            .build();\n+\n+    // add schemas into a map or type to schema.\n+    Map<Class<? extends SpecificRecordBase>, AvroSchema<SpecificRecordBase>> map = new HashMap<>();\n+    map.put(User.class, AvroSchema.ofSpecificRecord(User.class));\n+    map.put(Address.class, AvroSchema.ofSpecificRecord(Address.class));\n+        \n+    Serializer<SpecificRecordBase> serializer = SerializerFactory.avroMultiTypeSerializer(\n+\t            serializerConfig, map);\n+    EventStreamWriter<SpecificRecordBase> writer = clientFactory.createEventWriter(\n+\t            stream, serializer, \n+\t\t\t\tEventWriterConfig.builder().build());\n+    writer.writeEvent(new User(\"username\"));\n+    writer.writeEvent(new Address(\"address\", zipCode));\n+```\n+\n+```\n+    Serializer<SpecificRecordBase> deserializer = SerializerFactory\n+\t            .avroMultiTypeDeserializer(serializerConfig, map);\n+    EventStreamReader<SpecificRecordBase> reader = clientFactory\n+\t            .createReader(\"r1\", rg, deserializer, \n+\t\t\t\tReaderConfig.builder().build());\n+\n+    EventRead<SpecificRecordBase> event1 = reader.readNextEvent(10000);\n+    assertTrue(event1.getEvent() instanceof User);\n+    EventRead<SpecificRecordBase> event2 = reader.readNextEvent(10000);\n+    assertTrue(event2.getEvent() instanceof Address);\n+```\n+\n+### Custom serializers \n+Users can also supply their custom serializers and deserializers which the serializer factory will use for serializing and deserializing the payload while taking care of all interactions with schema registry service away from the serializer. \n+```\n+    /**\n+     * A serializer that uses user supplied implementation of {@link PravegaSerializer} for serializing the objects.\n+     * It also takes user supplied schema and registers/validates it against the registry.\n+     */\n+    public static <T> Serializer<T> customSerializer(SerializerConfig config, SchemaContainer<T> schema, PravegaSerializer<T> serializer);\n+\n+    /**\n+     * A deserializer that uses user supplied implementation of {@link PravegaDeserializer} for deserializing the data into\n+     * typed java objects.\n+     */\n+    public static <T> Serializer<T> customDeserializer(SerializerConfig config, @Nullable SchemaContainer<T> schema,\n+                                                       PravegaDeserializer<T> deserializer);\n+```\n+\n+The user supplied serializer and deserializer can be used with above factory methods for custom serialization formats. The user will supply their custom schema bytes wrapped under the schemaInfo object. The registry will register the schema for the group without attempting to parse the schema. \n+Note: for custom schema formats and custom serializers registry merely serves the schemas to the deserializers. \n+Example:\n+```\n+    SchemaInfo schemaInfo = new SchemaInfo(\"User\", serializationFormat, myPojoSchemaBytes, Collections.emptyMap());\n+    MySerializer mySerializer = new MySerializer();\n+\n+    Serializer<MyPojo> serializer = SerializerFactory.customSerializer(\n+\t            config, () -> schemaInfo, mySerializer);\n+    EventStreamWriter<MyPojo> writer = clientFactory.createEventWriter(\n+\t            stream, serializer, EventWriterConfig.builder().build());\n+\n+    MyDeserializer<MyPojo> myDeserializer = new MyDeserializer();\n+    Serializer<MyPojo> deserializer = SerializerFactory.customDeserializer(\n+\t            serializerConfig, () -> null, myDeserializer);\n+    EventStreamReader<MyPojo> reader = clientFactory.createReader(\n+\t            \"r1\", rg, deserializer, ReaderConfig.builder().build());\n+```\n+\n+### Multiple format support within same pravega stream\n+There are some additional deserializers that are provided by SerializerFactory. These include multiFormatDeserializer, which can read the encoding information in the payload and based on the serialization format (one of avro protobuf and json) it deserializes the event into the serialization system specific generic java object. \n+There is another flavour which converts the deserialized object into a json string, whereby allowing reader applications to work with jsons while writers could write data into any of avro, protobuf or json. \n+\n+```\n+    /**\n+     * A deserializer that can read data where each event could be written with either of avro, protobuf or json \n+     * serialization formats.\n+     * An event serialized with avro is deserialized into {@link Object}. If its record type, it is {@link GenericRecord}.\n+     * An event serialized with protobuf is deserialized into {@link DynamicMessage}.\n+     * An event serialized with json is deserialized into {@link java.util.LinkedHashMap}.\n+     */\n+    public static Serializer<Object> genericDeserializer(SerializerConfig config);\n+\n+    /**\n+     * This is a convenience serializer shortcut that calls {@link #deserializeAsT} with a transform to \n+     * convert the object to JSON string.\n+     */\n+    public static Serializer<String> deserializeAsJsonString(SerializerConfig config);\n+\n+    /**\n+     * A deserializer that can read data where each event could be written with different serialization formats. \n+     * Formats supported are protobuf, avro and json. \n+     * An event serialized with avro is deserialized into {@link Object}. If its record type, it is {@link GenericRecord}.\n+     * An event serialized with protobuf is deserialized into {@link DynamicMessage}.\n+     * An event serialized with json is deserialized into {@link java.util.LinkedHashMap}.\n+     *\n+     * This also takes a transform function which is applied on the deserialized object and should transform the object \n+     * into the type T.  \n+     */\n+    public static <T> Serializer<T> deserializeAsT(SerializerConfig config,\n+                                                   BiFunction<SerializationFormat, Object, T> transform);\n+```\n+\n+Example: Stream could have data written using avro, protobuf or json. The deserializer hides the details and gives the deserialized\n+object back. \n+```\n+        // 1. read as a deserialized object \n+        Serializer<Object> deserializer = SerializerFactory.genericDeserializer(serializerConfig);\n+        EventStreamReader<Object> reader = clientFactory.createReader(\"r1\", rg, deserializer, ReaderConfig.builder().build());\n+        EventRead<Object> event = reader.readNextEvent(1000);\n+\n+        // 2. read as a json string\n+        Serializer<String> deserializer = SerializerFactory.deserializeAsJsonString(serializerConfig);\n+        EventStreamReader<String> reader = clientFactory.createReader(\"r1\", rg, deserializer, ReaderConfig.builder().build());\n+        EventRead<String> event = reader.readNextEvent(1000);\n+\n+        // 3. deserialize and transform it to an object of type T. \n+        Serializer<T> deserializer = SerializerFactory.deserializeAsT(serializerConfig, (x, y) -> myTransformFunction(x, y));\n+        EventStreamReader<T> reader = clientFactory.createReader(\"r1\", rg, deserializer, ReaderConfig.builder().build());\n+        EventRead<T> event = reader.readNextEvent(1000);\n+```\n+\n+#### Multi format automatically consume and produce data\n+There are two special serializers and deserializers meant to load data from one stream into another. These are namely `serializerWithSchema` and `deserializerWithSchema`. Deserializer with schema returns the object with the schema as it reads from a stream. This same data can be passed to the SerializerWithSchema and it would serialize the data with the given schema and the original format of the data. \n+\n+```\n+    /**\n+     * A multi format serializer that takes objects with schemas for the three supported formats - avro, protobuf and json.\n+     * It then serializes the object using the format specific serializer. The events are supplied using an encapsulating \n+     * object called WithSchema which has both the event and the schema. \n+     * It only serializes the events while ensuring that the corresponding schema was registered with the service. \n+     * If {@link SerializerConfig#registerSchema} is set to true, it registers the schema before using it. \n+     * This serializer contacts schema registry once for every new schema that it encounters, and it fetches the \n+     * encoding id for the schema and codec pair. \n+     */\n+    public static Serializer<WithSchema<Object>> serializerWithSchema(SerializerConfig config);\n+\n+    /**\n+     * A deserializer that can deserialize data where each event could be written with either of avro, protobuf or json \n+     * serialization formats. It deserializes them into format specific generic objects. \n+     * An event serialized with avro is deserialized into {@link GenericRecord}.\n+     * An event serialized with protobuf is deserialized into {@link DynamicMessage}.\n+     * An event serialized with json is deserialized into {@link java.util.LinkedHashMap}.\n+     */\n+    public static Serializer<WithSchema<Object>> deserializerWithSchema(SerializerConfig config);\n+```\n+\n+Example:\n+```\n+        // read from input stream\n+        Serializer<WithSchema<Object>> deserializer = SerializerFactory.deserializerWithSchema(serializerConfig);\n+        EventStreamReader<WithSchema<Object>> reader = clientFactory.createReader(\"r1\", rg, deserializer, ReaderConfig.builder().build());\n+        EventRead<WithSchema<Object>> event = reader.readNextEvent(1000);\n+        Object = event.getEvent().getObject();\n+        if (event.getEvent().hasAvroSchema()) {\n+             Schema avroSchema = event.getEvent().getAvroSchema();\n+        } \n+\n+// process the event, apply businesslogic. \n+....\n+\n+        // writing the event into destination stream\n+        Serializer<WithSchema<Object>> genericSerializer = SerializerFactory.serializerWithSchema(serializerConfig);\n+        EventStreamWriter<WithSchema<Object>> genericWriter = clientFactory\n+                .createEventWriter(outstream, genericSerializer, EventWriterConfig.builder().build());\n+        genericWriter.writeEvent(event.getEvent());\n+```\n+\n+### Codecs\n+Schema registry serializers also support codecs. CodecType is supplied with the config while instantiating a serializer. \n+Serializer library provides implementation for snappy and gzip codecs and has support for custom user defined codec types too. For serializers, users can supply the codec type. By default three decoders are included with each deserializer - decoders for `snappy`, `gzip` and `none` codec types. If no codec is supplied for serializer, CodecType.none is used. \n+```\n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+         .groupId(groupId)\n+         .codec(CodecFactory.snappy())\n+         .registryClient(client)\n+         .build();\n+```\n+\n+Custom codec type support is also supported by registry. \n+Users can create their custom codecs and use custom codecType and register the codec type with the registry service. \n+The encoding-decoding libraries for custom codec type needs to be available with writer and reader applications. \n+```\n+    Codec myCodec = new Codec() {\n+        @Override\n+        public CodecType getCodecType() {\n+            return CodecType.custom(\"MyCustomCodecType\", Collections.emptyMap());\n+        }\n+\n+        @Override\n+        public ByteBuffer encode(ByteBuffer data) {\n+            // custom encoding logic\n+        }\n+\n+        @Override\n+        public ByteBuffer decode(ByteBuffer data) {\n+            // custom decoding logic\n+        }\n+    };\n+```\n+Usage with writers and readers:\n+``` \n+    SerializerConfig serializerConfig = SerializerConfig.builder()\n+             .groupId(groupId)\n+             .codec(myCodec)\n+             .registerCodec(true)\n+             .registryClient(client)\n+             .build();\n+\n+    SerializerConfig deserializerConfig = SerializerConfig.builder()\n+             .groupId(groupId)\n+             .addDecoder(CodecFactory.GZIP, CodecFactory.gzip::decode)\n+             .addDecoder(CodecFactory.SNAPPY, CodecFactory.snappy::decode)\n+             .addDecoder(myCodec.getCodecType(), myCodec::decode)\n+             .registryClient(client)\n+             .build();\n+```"
  },
  {
    "sha": "9a0757a59260d5d06cbd9202a955684badfc0d48",
    "filename": "documentation/src/docs/rest-documentation.md",
    "status": "added",
    "additions": 709,
    "deletions": 0,
    "changes": 709,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/rest-documentation.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/rest-documentation.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/rest-documentation.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,709 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+\n+# Pravega Schema Registry APIs\n+REST APIs for Pravega Schema Registry.\n+\n+## Version: 0.0.1\n+\n+**License:** [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0)\n+\n+### /groups\n+\n+#### GET\n+##### Description:\n+\n+List all groups within the namespace. If namespace is not specified, All groups in default namespace are listed.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| namespace | query | Namespace in which to look up groups | No | string |\n+| continuationToken | query | Continuation token | No | string |\n+| limit | query | The numbers of items to return | No | integer |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | List of all groups | [ListGroupsResponse](#listgroupsresponse) |\n+| 500 | Internal server error while fetching the list of Groups |  |\n+\n+#### POST\n+##### Description:\n+\n+Create a new Group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| namespace | query | Namespace in which to create group | No | string |\n+| CreateGroupRequest | body | The Group configuration | Yes | object |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 201 | Successfully added group |\n+| 409 | Group with given name already exists |\n+| 500 | Internal server error while creating a Group |\n+\n+### /groups/{groupName}\n+\n+#### GET\n+##### Description:\n+\n+Fetch the properties of an existing Group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Found Group properties | [GroupProperties](#groupproperties) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching Group details |  |\n+\n+#### DELETE\n+##### Description:\n+\n+Delete a Group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 204 | Successfully deleted the Group |\n+| 500 | Internal server error while deleting the Group |\n+\n+### /groups/{groupName}/history\n+\n+#### GET\n+##### Description:\n+\n+Fetch the history of schema evolution of a Group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Found Group history | [GroupHistory](#grouphistory) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching Group history |  |\n+\n+### /groups/{groupName}/compatibility\n+\n+#### PUT\n+##### Description:\n+\n+update schema compatibility of an existing Group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| UpdateCompatibilityRequest | body | update group policy | Yes | object |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 200 | Updated schema compatibility policy |\n+| 404 | Group with given name not found |\n+| 409 | Write conflict |\n+| 500 | Internal server error while updating Group's schema compatibility |\n+\n+### /groups/{groupName}/schemas\n+\n+#### GET\n+##### Description:\n+\n+Fetch latest schema versions for all objects identified by SchemaInfo#type under a Group. If query param type is specified then latest schema for the type is returned.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| type | query | Type of object | No | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Latest schemas for all objects identified by SchemaInfo#type under the group | [SchemaVersionsList](#schemaversionslist) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching Group's latest schemas |  |\n+\n+#### POST\n+##### Description:\n+\n+Adds a new schema to the group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| type | query | Type of object | No | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| schemaInfo | body | Add new schema to group | Yes | [SchemaInfo](#schemainfo) |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 201 | Successfully added schema to the group | [VersionInfo](#versioninfo) |\n+| 404 | Group not found |  |\n+| 409 | Incompatible schema |  |\n+| 417 | Invalid serialization format |  |\n+| 500 | Internal server error while adding schema to group |  |\n+\n+### /groups/{groupName}/schemas/versions\n+\n+#### GET\n+##### Description:\n+\n+Get all schema versions for the group\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| type | query | Type of object the schema describes. | No | string |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Versioned history of schemas registered under the group | [SchemaVersionsList](#schemaversionslist) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching Group schema versions |  |\n+\n+### /groups/{groupName}/schemas/versions/find\n+\n+#### POST\n+##### Description:\n+\n+Get the version for the schema if it is registered. It does not automatically register the schema. To add new schema use addSchema\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| schemaInfo | body | Get schema corresponding to the version | Yes | [SchemaInfo](#schemainfo) |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Schema version | [VersionInfo](#versioninfo) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error fetching version for schema |  |\n+\n+### /groups/{groupName}/schemas/schema/{schemaId}\n+\n+#### GET\n+##### Description:\n+\n+Get schema from the schema id that uniquely identifies the schema in the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| schemaId | path | Schema Id | Yes | integer |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Schema corresponding to the version | [SchemaInfo](#schemainfo) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching schema from version |  |\n+\n+#### DELETE\n+##### Description:\n+\n+Delete schema identified by version from the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| schemaId | path | Schema Id | Yes | integer |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 204 | Schema corresponding to the version |\n+| 404 | Group with given name not found |\n+| 500 | Internal server error while deleting schema from group |\n+\n+### /groups/{groupName}/schemas/{type}/versions/{version}\n+\n+#### GET\n+##### Description:\n+\n+Get schema from the version number that uniquely identifies the schema in the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| type | path | Schema type from SchemaInfo#type or VersionInfo#type | Yes | string |\n+| version | path | Version number | Yes | integer |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Schema corresponding to the version | [SchemaInfo](#schemainfo) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while fetching schema from version |  |\n+\n+#### DELETE\n+##### Description:\n+\n+Delete schema version from the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| type | path | Schema type from SchemaInfo#type or VersionInfo#type | Yes | string |\n+| version | path | Version number | Yes | integer |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 204 | Schema corresponding to the version |\n+| 404 | Group with given name not found |\n+| 500 | Internal server error while deleting schema from group |\n+\n+### /groups/{groupName}/schemas/versions/validate\n+\n+#### POST\n+##### Description:\n+\n+Checks if given schema is compatible with schemas in the registry for current policy setting.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| ValidateRequest | body | Checks if schema is valid with respect to supplied compatibility | Yes | object |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Schema validation response | [Valid](#valid) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while trying to validate schema |  |\n+\n+### /groups/{groupName}/schemas/versions/canRead\n+\n+#### POST\n+##### Description:\n+\n+Checks if given schema can be used for reads subject to compatibility policy in the schema compatibility.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| schemaInfo | body | Checks if schema can be used to read the data in the stream based on compatibility policy. | Yes | [SchemaInfo](#schemainfo) |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Response to tell whether schema can be used to read existing schemas | [CanRead](#canread) |\n+| 404 | Group with given name not found |  |\n+| 500 | Internal server error while checking schema for readability |  |\n+\n+### /groups/{groupName}/encodings\n+\n+#### PUT\n+##### Description:\n+\n+Get an encoding id that uniquely identifies a schema version and codec type pair.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| GetEncodingIdRequest | body | Get schema corresponding to the version | Yes | object |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Found Encoding | [EncodingId](#encodingid) |\n+| 404 | Group with given name or version not found |  |\n+| 412 | Codec type not registered |  |\n+| 500 | Internal server error while getting encoding id |  |\n+\n+### /groups/{groupName}/encodings/{encodingId}\n+\n+#### GET\n+##### Description:\n+\n+Get the encoding information corresponding to the encoding id.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| encodingId | path | Encoding id that identifies a unique combination of schema and codec type | Yes | integer |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Found Encoding | [EncodingInfo](#encodinginfo) |\n+| 404 | Group or encoding id with given name not found |  |\n+| 500 | Internal server error while getting encoding info corresponding to encoding id |  |\n+\n+### /groups/{groupName}/codecTypes\n+\n+#### GET\n+##### Description:\n+\n+Get codecTypes for the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Found CodecTypes | [CodecTypesList](#codectypeslist) |\n+| 404 | Group or encoding id with given name not found |  |\n+| 500 | Internal server error while fetching codecTypes registered |  |\n+\n+#### POST\n+##### Description:\n+\n+Adds a new codecType to the group.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| groupName | path | Group name | Yes | string |\n+| namespace | query | Namespace in which to lookup group. If no namespace is specified, default namespace is used. | No | string |\n+| codecType | body | The codecType | Yes | string |\n+\n+##### Responses\n+\n+| Code | Description |\n+| ---- | ----------- |\n+| 201 | Successfully added codecType to group |\n+| 404 | Group not found |\n+| 500 | Internal server error while registering codectype to a Group |\n+\n+### /schemas/addedTo\n+\n+#### POST\n+##### Description:\n+\n+Gets a map of groups to version info where the schema if it is registered. SchemaInfo#properties is ignored while comparing the schema.\n+\n+##### Parameters\n+\n+| Name | Located in | Description | Required | Schema |\n+| ---- | ---------- | ----------- | -------- | ---- |\n+| namespace | query | Namespace in which to lookup schemas used in groups. If no namespace is specified, default namespace is used. | No | string |\n+| schemaInfo | body | Get schema references for the supplied schema | Yes | [SchemaInfo](#schemainfo) |\n+\n+##### Responses\n+\n+| Code | Description | Schema |\n+| ---- | ----------- | ------ |\n+| 200 | Schema version | [AddedTo](#addedto) |\n+| 404 | Schema not found |  |\n+| 500 | Internal server error while fetching Schema references |  |\n+\n+### Models\n+\n+\n+#### ListGroupsResponse\n+\n+Map of Group names to group properties. For partially created groups, the group properties may be null.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| groups | object |  | No |\n+| continuationToken | string | Continuation token to identify the position of last group in the response. | Yes |\n+\n+#### GroupProperties\n+\n+Metadata for a group.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| serializationFormat | [SerializationFormat](#serializationformat) | serialization format for the group. | Yes |\n+| compatibility | [Compatibility](#compatibility) | Compatibility to apply while registering new schema. | Yes |\n+| allowMultipleTypes | boolean | Flag to indicate whether to allow multiple schemas representing distinct objects to be registered in the group. | Yes |\n+| properties | object | User defined Key value strings. | No |\n+\n+#### SerializationFormat\n+\n+Serialization format enum that lists different serialization formats supported by the service. To use additional formats, use serializationFormat.Custom and supply fullTypeName.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| serializationFormat | string |  | Yes |\n+| fullTypeName | string |  | No |\n+\n+#### SchemaInfo\n+\n+Schema information object that encapsulates various properties of a schema.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| type | string | Name of the schema. This identifies the type of object the schema payload represents. | Yes |\n+| serializationFormat | [SerializationFormat](#serializationformat) | Type of schema. | Yes |\n+| schemaData | binary | Base64 encoded string for binary data for schema. | Yes |\n+| properties | object | User defined key value strings. | No |\n+\n+#### VersionInfo\n+\n+Version information object.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| type | string | Type of schema for this version. This is same value used in SchemaInfo#Type for the schema this version identifies. | Yes |\n+| version | integer | Version number that uniquely identifies the schema version among all schemas in the group that share the same Type. | Yes |\n+| id | integer | schema id that uniquely identifies schema version and describes the absolute order in which the schema was added to the group. | Yes |\n+\n+#### SchemaWithVersion\n+\n+Object that encapsulates SchemaInfo and its corresponding VersionInfo objects.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| schemaInfo | [SchemaInfo](#schemainfo) | Schema information. | Yes |\n+| versionInfo | [VersionInfo](#versioninfo) | Version information. | Yes |\n+\n+#### SchemaVersionsList\n+\n+List of schemas with their versions.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| schemas | [ [SchemaWithVersion](#schemawithversion) ] | List of schemas with their versions. | No |\n+\n+#### EncodingId\n+\n+Encoding id that uniquely identifies a schema version and codec type pair.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| encodingId | integer | encoding id generated by service. | Yes |\n+\n+#### EncodingInfo\n+\n+Encoding information object that resolves the schema version and codec type used for corresponding encoding id.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| schemaInfo | [SchemaInfo](#schemainfo) | Schema information object. | Yes |\n+| versionInfo | [VersionInfo](#versioninfo) | Version information object. | Yes |\n+| codecType | string | Codec type. | Yes |\n+\n+#### Compatibility\n+\n+Compatibility policy.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| policy | string | Compatibility policy enum. | Yes |\n+| advanced | [BackwardAndForward](#backwardandforward) | Backward and forward policy details. | No |\n+\n+#### BackwardAndForward\n+\n+BackwardPolicy and forwardPolicy policy.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| backwardPolicy | [BackwardPolicy](#backwardpolicy) | BackwardAndForward policy type that describes different types of BackwardPolicy policies like Backward, BackwardTransitive and BackwardTill. | No |\n+| forwardPolicy | [ForwardPolicy](#forwardpolicy) | BackwardAndForward policy type that describes different types of ForwardPolicy policies like Forward, ForwardTransitive and ForwardTill. | No |\n+\n+#### BackwardPolicy\n+\n+BackwardPolicy policy.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| backwardPolicy |  | BackwardAndForward type backwardPolicy. Can be one of Backward, backwardTill and backwardTransitive. | Yes |\n+\n+#### ForwardPolicy\n+\n+ForwardPolicy policy.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| forwardPolicy |  | BackwardAndForward type forwardPolicy. Can be one of forward, forwardTill and forwardTransitive. | Yes |\n+\n+#### Backward\n+\n+BackwardPolicy compatibility type which tells the service to check for backwardPolicy compatibility with latest schema.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+\n+#### Forward\n+\n+ForwardPolicy compatibility type which tells the service to check for forwardPolicy compatibilty with latest schema.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+\n+#### BackwardTransitive\n+\n+BackwardPolicy compatibility type which tells the service to check for backwardPolicy compatibility with all previous schemas.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+\n+#### ForwardTransitive\n+\n+ForwardPolicy compatibility type which tells the service to check for forwardPolicy compatibility with all previous schemas.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+\n+#### BackwardTill\n+\n+BackwardPolicy compatibility which tells the service to check for backwardPolicy compatibility with all previous schemas till specific version.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+| versionInfo | [VersionInfo](#versioninfo) | Whether given schema is valid with respect to existing group schemas against the configured compatibility. | Yes |\n+\n+#### ForwardTill\n+\n+ForwardPolicy compatibility which tells the service to check for forwardPolicy compatibility with all previous schemas till specific version.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| name | string |  | Yes |\n+| versionInfo | [VersionInfo](#versioninfo) | Whether given schema is valid with respect to existing group schemas against the configured compatibility. | Yes |\n+\n+#### CodecTypesList\n+\n+Response object for listCodecTypes.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| codecTypes | [ string ] | List of codecTypes. | No |\n+\n+#### Valid\n+\n+Response object for validateSchema api.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| valid | boolean | Whether given schema is valid with respect to existing group schemas against the configured compatibility. | Yes |\n+\n+#### CanRead\n+\n+Response object for canRead api.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| compatible | boolean | Whether given schema is compatible and can be used for reads. BackwardAndForward is checked against existing group schemas subject to group's configured compatibility policy. | Yes |\n+\n+#### GroupHistoryRecord\n+\n+Group History Record that describes each schema evolution - schema information, version generated for the schema, time and compatibility policy used for schema validation.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| schemaInfo | [SchemaInfo](#schemainfo) | Schema information object. | Yes |\n+| versionInfo | [VersionInfo](#versioninfo) | Schema version information object. | Yes |\n+| compatibility | [Compatibility](#compatibility) | Schema compatibility applied. | Yes |\n+| timestamp | long | Timestamp when the schema was added. | Yes |\n+| schemaString | string | Schema as json string for serialization formats that registry service understands. | No |\n+\n+#### GroupHistory\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| history | [ [GroupHistoryRecord](#grouphistoryrecord) ] | Chronological list of Group History records. | No |\n+\n+#### AddedTo\n+\n+Map of Group names to versionInfos in the group. This is for all the groups where the schema is registered.\n+\n+| Name | Type | Description | Required |\n+| ---- | ---- | ----------- | -------- |\n+| groups | object | Version for the schema in the group. | Yes |"
  },
  {
    "sha": "4961d103efff7000012e49f2cef67379c6820da7",
    "filename": "documentation/src/docs/rest-usage.md",
    "status": "added",
    "additions": 166,
    "deletions": 0,
    "changes": 166,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/rest-usage.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/rest-usage.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/rest-usage.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,166 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+## REST API Sample curl commands\n+Schema Registry Service provides a RESTful interface for storing and managing schemas under schema groups. Users create a named schema group under which they store and evolve the schemas according to desired compatibility policy. \n+\n+REST API documentation could be found [here](rest-documentation.md).\n+\n+Following are example usage of REST apis in schema registry:\n+\n+#### Create a new Group\n+```\n+$ cat groupProperties.json\n+{\n+   \"groupName\": \"mygroup\",\n+   \"groupProperties\": {\n+      \"serializationFormat\":{\n+         \"serializationFormat\":\"Avro\"\n+      },\n+      \"compatibility\":{\n+         \"policy\":\"BackwardTransitive\"\n+      },\n+      \"allowMultipleTypes\":true,\n+      \"properties\":{ }\n+}\n+\n+$ curl -X  POST http://SchemaRegistryIP:Port/v1/groups -H \"accept: application/json\" -H \"Content-Type: application/json\" -d @groupProperties.json\n+```\n+\n+#### List all groups\n+```\n+$ curl -X GET http://SchemaRegistryIP:Port/v1/groups?limit={limit}&continuationToken={continuationToken} \n+{\n+  \"groups\": {\n+    \"mygroup\": {\n+      \"serializationFormat\": {\n+        \"serializationFormat\": \"Avro\"\n+      },\n+      \"compatibility\": {\n+        \"policy\": \"BackwardTransitive\"\n+      },\n+      \"allowMultipleTypes\": true,\n+      \"properties\": {}\n+    }\n+  },\n+  \"continuationToken\": \"1\"\n+}\n+```\n+#### Add a new version of a schema under the group. \n+Schema binary is base64 encoded and wrapped in a schema info object\n+```\n+$ cat User.json\n+{\n+  \"type\": \"record\",\n+  \"name\": \"User\",\n+  \"fields\": [\n+    {\n+      \"name\": \"name\",\n+      \"type\": \"string\"\n+    },\n+    {\n+      \"name\": \"age\",\n+      \"type\": \"int\"\n+    }\n+  ]\n+}\n+$ cat User.json | base64\n+eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlVzZXIiLCJmaWVsZHMiOlt7Im5hbWUiOiJuYW1lIiwidHlwZSI6InN0cmluZyJ9LHsibmFtZSI6ImFnZSIsInR5cGUiOiJpbnQifV19Cg==\n+\n+$ curl -X POST \"http://SchemaRegistryOP:Port/v1/groups/mygroup/schemas\" -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"{ \\\"type\\\": \\\"User\\\", \\\"serializationFormat\\\": { \\\"serializationFormat\\\": \\\"Avro\\\" }, \\\"schemaData\\\": \\\"eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlVzZXIiLCJmaWVsZHMiOlt7Im5hbWUiOiJuYW1lIiwidHlwZSI6InN0cmluZyJ9LHsibmFtZSI6ImFnZSIsInR5cGUiOiJpbnQifV19Cg==\\\", \\\"properties\\\": { }}\"\n+\n+{\n+  \"type\": \"User\",\n+  \"version\": 0,\n+  \"id\": 0\n+}\n+```\n+\n+Add schema of different type\n+```\n+$ cat Address.json\n+{\n+  \"type\": \"record\",\n+  \"name\": \"Address\",\n+  \"fields\": [\n+    {\n+      \"name\": \"street-address\",\n+      \"type\": \"string\"\n+    },\n+    {\n+      \"name\": \"zip\",\n+      \"type\": \"int\"\n+    }\n+  ]\n+}\n+$ cat Address.json | base64\n+eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IkFkZHJlc3MiLCJmaWVsZHMiOlt7Im5hbWUiOiJzdHJlZXQtYWRkcmVzcyIsInR5cGUiOiJzdHJpbmcifSx7Im5hbWUiOiJ6aXAiLCJ0eXBlIjoiaW50In1dfQo=\n+\n+$ curl -X POST \"http://localhost:9092/v1/groups/group/schemas\" -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"{ \\\"type\\\": \\\"Address\\\", \\\"serializationFormat\\\": { \\\"serializationFormat\\\": \\\"Avro\\\" }, \\\"schemaData\\\": \\\"eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IkFkZHJlc3MiLCJmaWVsZHMiOlt7Im5hbWUiOiJhZGRyZXNzIiwidHlwZSI6InN0cmluZyJ9LHsibmFtZSI6InppcCIsInR5cGUiOiJpbnQifV19Cg==\\\", \\\"properties\\\": { }}\"\n+{\"type\":\"Address\",\"version\":0,\"id\":1}\n+```\n+\n+#### List latest schemas for type User \n+Without type query parameter the api would return latest schemas for all schema types.\n+```\n+$ curl -X GET  http://SchemaRegistryIP:Port/v1/groups/mygroup/schemas?type=User\n+{\n+  \"schemas\": [\n+    {\n+      \"schemaInfo\": {\n+        \"type\": \"User\",\n+        \"serializationFormat\": {\n+          \"serializationFormat\": \"Avro\"\n+        },\n+        \"schemaData\": \"eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlVzZXIiLCJuYW1lc3BhY2UiOiJpby5wcmF2ZWdhIiwiZmllbGRzIjpbeyJuYW1lIjoibmFtZSIsInR5cGUiOiJzdHJpbmcifSx7Im5hbWUiOiJhZ2UiLCJ0eXBlIjoiaW50In1dfQ==\",\n+        \"properties\": {}\n+      },\n+      \"versionInfo\": {\n+        \"type\": \"User\",\n+        \"version\": 0,\n+        \"id\": 0\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+#### List all schema versions for type User added under the group\n+```\n+$ curl -X GET  http://SchemaRegistryIP:Port/v1/groups/mygroup/schemas/versions?type=User \n+{\n+  \"schemas\": [\n+    {\n+      \"schemaInfo\": {\n+        \"type\": \"User\",\n+        \"serializationFormat\": {\n+          \"serializationFormat\": \"Avro\"\n+        },\n+        \"schemaData\": \"eyJ0eXBlIjoicmVjb3JkIiwibmFtZSI6IlVzZXIiLCJmaWVsZHMiOlt7Im5hbWUiOiJuYW1lIiwidHlwZSI6InN0cmluZyJ9LHsibmFtZSI6ImFnZSIsInR5cGUiOiJpbnQifV19\",\n+        \"properties\": {}\n+      },\n+      \"versionInfo\": {\n+        \"type\": \"User\",\n+        \"version\": 0,\n+        \"id\": 0\n+      }\n+    }\n+  ]\n+}\n+```\n+#### Delete schema by schema id \n+```\n+$ curl -X DELETE http://SchemaRegistryIP:Port/v1/groups/mygroup/schemas/schema/0\n+```\n+\n+#### Delete schema group \n+```\n+$ curl -X DELETE http://SchemaRegistryIP:Port/v1/groups/mygroup\n+```\n+"
  },
  {
    "sha": "5ae0d40dffbcbd0c02be2936fcbcdf26ae225669",
    "filename": "documentation/src/docs/schema-registry-concepts.md",
    "status": "added",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/schema-registry-concepts.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/schema-registry-concepts.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/schema-registry-concepts.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,64 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+\n+## Schema Registry Terminology\n+\n+### Schema\n+A schema defines the structure of your data in a formal IDL. Different serialization systems have different IDLs for describing the schema. Schema registry service stores these schema artifacts and allows their safe evolution and stores a versioned history of changes to the schema. \n+\n+### Schema Evolution\n+Schema represents the structure of your data defined for fulfilling the business needs. However, as business needs change, the structure of the data may need to be modified to reflect the changed reality. Changing of schema definition to incorporate newer requirements is called schema evolution. Schema evolution should be supported by the underlying serialization system that should allow different schemas to be used during writing and reading of data, subject to compatibility between these schemas. We will describe \n+As schema is evolved, the newer structure is referred to as new version of the schema definition. Schema registry service allows users to safely evolve their schema subject to a chosen compatibility policy.  \n+\n+### Schema Compatibility\n+Two schemas are said to be compatible if data written using one schema can be read using another schema. The compatibility can be in forward of backward directions. Backward compatibility refers to a situation where the consumers of data can use their schema to read data written with older version of the schema. Forward compatibility refers to situation where consumers can use older version of schema to read data written with newer version of schema. \n+\n+### Serialization Format\n+Serialization format refers to the serialization system used by the users to serialize and deserialize their data. For schema registry's purposes we are interested in schema based serialization systems, where the system includes an IDL which is used to describe the structure/schema. Schema registry service allows users to choose among different serialization systems and for storing and managing their schemas. Schema registry service has first class support for Avro, Protobuf and Json serialization formats where the service parses and validates these schemas to be well formed. However, the support from the service is not limited to these three formats and users can choose any other serialization system of their choice and store their schemas with the registry service too. If any other format is chosen, then schema registry service treats those schemas as an opaque blob and simply stores the schema without performing any validations or policy enforcement on it. \n+\n+### Namespace\n+A namespace is a named object which is simply an organizational construct which does not have any metadata. A namespace is optional and defaults to a `Null` name. Users of registry service can create their service entities with namespace tags of their choice and all resources created under the namespace are required to be unique within it. \n+ \n+### Schema Group\n+A schema group is the chief resource in Schema Registry under which related schemas are added and evolved. A schema group is named and its name uniquely identifies it within a namespace. Schema registry service stores a versioned history of schemas under the schema group resource and also has user defined policies which are enforced as schemas are evolved.  \n+\n+### Schema Type\n+Schema Type refers to the `name` of the object that the schema represents. Schema registry service applies compatibility policy on schema by comparing it with one or more older schemas that share the same `type`/`name` within a schema group. \n+\n+### Schema Version: \n+As schema defining a specific structure is evolved and the new structure is registered with the service, it is assigned a monotonically increasing version number for that schema type. Schema registry service stores these versions as a chronological history of schemas. Each schema version in the service is uniquely identified by the tuple schema type, schema version and serialization format.  \n+\n+### Schema Id\n+Schema registry service also assigns a unique 4 byte numerical identifier that uniquely identifies a schema in the schema group. A schema id is the id to uniquely identify the tuple - {schema type schema version and serialization format}. \n+\n+### Schema Group Properties\n+A Schema Group has an associated set of metadata configurations which users specify for serialization format and compatibility policy to be applied when evolving the schema.\n+Users have a choice to limit a schema group to only include schemas in a specific format (e.g. avro or protobuf) or choose `Any` which allows schemas from all serialization formats. Users also choose a compatibility policy that is applied on each new schema that is registered within the group.  \n+\n+### Compatibility Policy\n+Evolution of schema is the need of the business. However, this has consequence on the behaviour of consumers of data. If schema is not evolved in accordance with the expectation of consumers of the data, then it could break their functionality. Schema registry service provides a host of compatibility policy choices to safely evolve your schema. Compatibility can be defined as schema group configuration. The policy is applied at the time when new schema is added to the group. Pravega schema registry supports a range of compatibility policies that can be specified:\n+\n+    ALLOW_ANY: Allow all schema changes without any compatibility check.\n+    BACKWARD: Validate that new schema can be used to read data written using previous schema.\n+    BACKWARD_TILL(x): Validate that new schema is backward compatible till specified schema version.\n+    BACKWARD_TRANSITIVE: Validate that new schema is backward compatible with all previous schemas in the group.\n+    FORWARD: Validate that previous schema can be used to read data written using newer schema.\n+    FORWARD_TILL(x): Validate that new schema is backward compatible till specified schema version.\n+    FORWARD_TRANSITIVE: Validate that the new schema is forward compatible with all previous schemas in the group. \n+\tBACKWARD_TILL(x)_AND_FORWARD_TILL(y): Validate for backward compatibility till version identified by x and for forward compatibility till version identified by y.\n+    FULL: Validate against the latest schema that schema is compatible in both forward and backward direction with new schema. Old schema can be used to read data from new schema and new schema can be used to read data from old schema.\n+    FULL_TRANSITIVE: Validate against all previous schemas for both forward and backward compatibility.\n+    DENY_ALL: Disallow any schema evolution/modification.\n+\n+### Codec Type\n+Apart from serializing the data, applications may want to apply additional encoding on the data like compression or encryption for instance. Schema registry service allows users to record the encoding information for the data as a pair of schema and a codec type. Codec type refers to the name of additional encoding applied on the data. Users can register zero or more codec types with the service where each codec type has a unique name and an optional collection of key value strings based properties. The codec type and schema version can be used by users to request schema registry service to generate a unique id identifying each such pair. This identifier is called encoding id. Pravega applications tag the event written into schema registry service with the encoding id. Pravega reader applications, upon seeing the encoding id, resolve it to schema and codec pair to decode and deserialize the data. \n+\n+\n+"
  },
  {
    "sha": "59b41c69fd20aa8e4d284b5c741995de807ba8d5",
    "filename": "documentation/src/docs/security.md",
    "status": "added",
    "additions": 11,
    "deletions": 0,
    "changes": 11,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/security.md",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/docs/security.md",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/docs/security.md?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,11 @@\n+<!--\n+Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+-->\n+\n+Coming Soon! "
  },
  {
    "sha": "ed70485abe7a98dba1cf71e7dedeecc09cc10f9a",
    "filename": "documentation/src/mkdocs.yml",
    "status": "added",
    "additions": 51,
    "deletions": 0,
    "changes": 51,
    "blob_url": "https://github.com/pravega/schema-registry/blob/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/mkdocs.yml",
    "raw_url": "https://github.com/pravega/schema-registry/raw/80f436c92992e09231e0e685d8795bc4b3b1ac67/documentation/src/mkdocs.yml",
    "contents_url": "https://api.github.com/repos/pravega/schema-registry/contents/documentation/src/mkdocs.yml?ref=80f436c92992e09231e0e685d8795bc4b3b1ac67",
    "patch": "@@ -0,0 +1,51 @@\n+# Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+\n+site_name: 'Exploring Pravega'\n+site_url: 'https://pravega.io/'\n+site_description: 'Documentation to help you get familiar with Pravega'\n+\n+repo_url: 'https://github.com/pravega/schema-registry'\n+edit_uri: 'tree/master/documentation/src/docs'\n+\n+theme: 'material'\n+\n+\n+# Extensions\n+markdown_extensions:\n+  - admonition\n+  - codehilite(guess_lang=false)\n+  - footnotes\n+  - meta\n+  - toc(permalink=true)\n+  - pymdownx.betterem(smart_enable=all)\n+  - pymdownx.caret\n+  - pymdownx.inlinehilite\n+  - pymdownx.magiclink\n+  - pymdownx.smartsymbols\n+  - pymdownx.superfences\n+\n+pages:\n+  - Overview: 'overview.md'\n+  - Understanding Schema Registry:\n+      - 'Schema Registry Concepts': 'schema-registry-concepts.md'\n+\n+  - Using Schema Registry SDK:\n+      - 'Java API Reference': 'javadoc.md'\n+      - 'REST API': 'rest-documentation.md'\n+      - 'Using schema registry in Pravega Applications': 'pravega-applications.md'\n+\n+  - Running Schema Registry:\n+      - 'Deployment Overview': 'installation-guide.md'\n+\n+  - Security:\n+      - 'Security(TLS) and Authorization/Authentication': 'security.md'\n+extra:\n+    version: 0.1\n+\n+google_analytics: ['UA-1508605-1', 'pravega.io']"
  }
]
