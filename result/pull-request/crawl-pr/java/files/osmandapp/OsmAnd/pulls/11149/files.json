[
  {
    "sha": "0d0c54178eabef51bdcc084057f47f09b5bd4bbf",
    "filename": "OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java",
    "status": "modified",
    "additions": 35,
    "deletions": 8,
    "changes": 43,
    "blob_url": "https://github.com/osmandapp/OsmAnd/blob/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java",
    "raw_url": "https://github.com/osmandapp/OsmAnd/raw/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java",
    "contents_url": "https://api.github.com/repos/osmandapp/OsmAnd/contents/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java?ref=41610ebbc453b94adc15f4bad24e0182b91c722d",
    "patch": "@@ -38,10 +38,12 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n \n import static net.osmand.plus.measurementtool.MeasurementEditingContext.CalculationMode.WHOLE_TRACK;\n@@ -409,9 +411,7 @@ void splitSegments(int position) {\n \tprivate void preAddPoint(int position, AdditionMode additionMode, WptPt point) {\n \t\tswitch (additionMode) {\n \t\t\tcase UNDEFINED: {\n-\t\t\t\tif (appMode != MeasurementEditingContext.DEFAULT_APP_MODE) {\n-\t\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n-\t\t\t\t}\n+\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tcase ADD_AFTER: {\n@@ -420,9 +420,7 @@ private void preAddPoint(int position, AdditionMode additionMode, WptPt point) {\n \t\t\t\t\tWptPt prevPt = points.get(position - 1);\n \t\t\t\t\tif (prevPt.isGap()) {\n \t\t\t\t\t\tif (position == points.size() && getAfterPoints().size() == 0) {\n-\t\t\t\t\t\t\tif (appMode != MeasurementEditingContext.DEFAULT_APP_MODE) {\n-\t\t\t\t\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tpoint.setGap();\n \t\t\t\t\t\t\tif (position > 1) {\n@@ -437,7 +435,7 @@ private void preAddPoint(int position, AdditionMode additionMode, WptPt point) {\n \t\t\t\t\t} else if (prevPt.hasProfile()) {\n \t\t\t\t\t\tpoint.setProfileType(prevPt.getProfileType());\n \t\t\t\t\t}\n-\t\t\t\t} else if (appMode != MeasurementEditingContext.DEFAULT_APP_MODE) {\n+\t\t\t\t} else {\n \t\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n \t\t\t\t}\n \t\t\t\tbreak;\n@@ -449,7 +447,7 @@ private void preAddPoint(int position, AdditionMode additionMode, WptPt point) {\n \t\t\t\t\tif (nextPt.hasProfile()) {\n \t\t\t\t\t\tpoint.setProfileType(nextPt.getProfileType());\n \t\t\t\t\t}\n-\t\t\t\t} else if (appMode != MeasurementEditingContext.DEFAULT_APP_MODE) {\n+\t\t\t\t} else {\n \t\t\t\t\tpoint.setProfileType(appMode.getStringKey());\n \t\t\t\t}\n \t\t\t\tbreak;\n@@ -743,6 +741,12 @@ private void recreateSegments(List<TrkSegment> segments, List<TrkSegment> segmen\n \t\t\t\t\tRoadSegmentData data = this.roadSegmentData.get(pair);\n \t\t\t\t\tList<WptPt> pts = data != null ? data.getPoints() : null;\n \t\t\t\t\tif (pts != null) {\n+\t\t\t\t\t\tif (pts.size() > 0) {\n+\t\t\t\t\t\t\tpts.get(0).setProfileType(data.getStart().getProfileType());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (pts.size() > 1) {\n+\t\t\t\t\t\t\tpts.get(pts.size() - 1).setProfileType(data.getEnd().getProfileType());\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tsegmentForSnap.points.addAll(pts);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tif (calculateIfNeeded && roadSegmentIndexes.contains(segmentsForSnap.size())) {\n@@ -1111,6 +1115,29 @@ private TrkSegment getRouteSegment(int startPointIndex, int endPointIndex) {\n \t\treturn res;\n \t}\n \n+\tpublic boolean hasMultipleProfiles() {\n+\t\tList<TrkSegment> allUserSegments = new ArrayList<>();\n+\t\tif (beforeSegments != null) {\n+\t\t\tallUserSegments.addAll(beforeSegments);\n+\t\t}\n+\t\tif (afterSegments != null) {\n+\t\t\tallUserSegments.addAll(afterSegments);\n+\t\t}\n+\n+\t\tSet<String> profiles = new HashSet<>();\n+\t\tfor (TrkSegment segment : allUserSegments) {\n+\t\t\tfor (WptPt point : segment.points) {\n+\t\t\t\tif (!\"gap\".equals(point.getProfileType())) {\n+\t\t\t\t\tprofiles.add(point.getProfileType());\n+\t\t\t\t}\n+\t\t\t\tif (profiles.size() >= 2) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n \t@Override\n \tpublic void onRouteSettingsChanged(@Nullable ApplicationMode mode) {\n \t\trecalculateRouteSegments(mode);"
  },
  {
    "sha": "0de8b757935c90708a64d3385adc7728bb286c02",
    "filename": "OsmAnd/src/net/osmand/plus/measurementtool/MeasurementToolLayer.java",
    "status": "modified",
    "additions": 112,
    "deletions": 17,
    "changes": 129,
    "blob_url": "https://github.com/osmandapp/OsmAnd/blob/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementToolLayer.java",
    "raw_url": "https://github.com/osmandapp/OsmAnd/raw/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementToolLayer.java",
    "contents_url": "https://api.github.com/repos/osmandapp/OsmAnd/contents/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementToolLayer.java?ref=41610ebbc453b94adc15f4bad24e0182b91c722d",
    "patch": "@@ -1,14 +1,19 @@\n package net.osmand.plus.measurementtool;\n \n+import android.content.Context;\n import android.graphics.Bitmap;\n import android.graphics.BitmapFactory;\n import android.graphics.Canvas;\n+import android.graphics.Color;\n import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.PointF;\n+import android.graphics.drawable.Drawable;\n+import android.os.Build;\n+import android.util.DisplayMetrics;\n+import android.util.Pair;\n \n-import androidx.core.content.ContextCompat;\n-\n+import net.osmand.AndroidUtils;\n import net.osmand.GPXUtilities.TrkSegment;\n import net.osmand.GPXUtilities.WptPt;\n import net.osmand.Location;\n@@ -17,22 +22,34 @@\n import net.osmand.data.QuadRect;\n import net.osmand.data.RotatedTileBox;\n import net.osmand.plus.R;\n+import net.osmand.plus.UiUtilities;\n import net.osmand.plus.measurementtool.MeasurementEditingContext.AdditionMode;\n+import net.osmand.plus.profiles.ProfileIconColors;\n+import net.osmand.plus.settings.backend.ApplicationMode;\n import net.osmand.plus.views.OsmandMapLayer;\n import net.osmand.plus.views.OsmandMapTileView;\n import net.osmand.plus.views.Renderable;\n import net.osmand.plus.views.layers.ContextMenuLayer;\n import net.osmand.plus.views.layers.geometry.GeometryWay;\n+import net.osmand.util.Algorithms;\n import net.osmand.util.MapUtils;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+\n+import androidx.annotation.ColorInt;\n+import androidx.annotation.DrawableRes;\n+import androidx.core.content.ContextCompat;\n+import androidx.core.graphics.drawable.DrawableCompat;\n \n public class MeasurementToolLayer extends OsmandMapLayer implements ContextMenuLayer.IContextMenuProvider {\n \tprivate static final int POINTS_TO_DRAW = 50;\n \n \tprivate OsmandMapTileView view;\n \tprivate boolean inMeasurementMode;\n+\tprivate boolean multipleProfileMode = false;\n \tprivate Bitmap centerIconDay;\n \tprivate Bitmap centerIconNight;\n \tprivate Bitmap pointIcon;\n@@ -181,6 +198,7 @@ void selectPoint(int position) {\n \tpublic void onPrepareBufferImage(Canvas canvas, RotatedTileBox tb, DrawSettings settings) {\n \t\tif (inMeasurementMode) {\n \t\t\tlineAttrs.updatePaints(view.getApplication(), settings, tb);\n+\t\t\tmultipleProfileMode = editingCtx.hasMultipleProfiles();\n \n \t\t\tif (editingCtx.isInApproximationMode()) {\n \t\t\t\tList<List<WptPt>> originalPointsList = editingCtx.getOriginalSegmentPointsList();\n@@ -194,21 +212,28 @@ public void onPrepareBufferImage(Canvas canvas, RotatedTileBox tb, DrawSettings\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tList<TrkSegment> before = editingCtx.getBeforeTrkSegmentLine();\n-\t\t\tfor (TrkSegment segment : before) {\n-\t\t\t\tnew Renderable.StandardTrack(new ArrayList<>(segment.points), 17.2).\n-\t\t\t\t\t\tdrawSegment(view.getZoom(), lineAttrs.paint, canvas, tb);\n-\t\t\t}\n-\t\t\tList<TrkSegment> after = editingCtx.getAfterTrkSegmentLine();\n-\t\t\tfor (TrkSegment segment : after) {\n-\t\t\t\tnew Renderable.StandardTrack(new ArrayList<>(segment.points), 17.2).\n-\t\t\t\t\t\tdrawSegment(view.getZoom(), lineAttrs.paint, canvas, tb);\n-\t\t\t}\n-\n+\t\t\tdrawSegments(canvas, tb, settings, editingCtx.getBeforeTrkSegmentLine());\n+\t\t\tdrawSegments(canvas, tb, settings, editingCtx.getAfterTrkSegmentLine());\n \t\t\tdrawPoints(canvas, tb);\n \t\t}\n \t}\n \n+\tprivate void drawSegments(Canvas canvas, RotatedTileBox tb, DrawSettings settings, List<TrkSegment> segments) {\n+\t\tfor (int i = 0; i < segments.size(); i++) {\n+\t\t\tList<WptPt> points = segments.get(i).points;\n+\t\t\tRenderable.RenderableSegment renderable;\n+\t\t\tif (multipleProfileMode) {\n+\t\t\t\tMap<String, Pair<Integer, Bitmap>> profileValues = getProfileValues(settings.isNightMode());\n+\t\t\t\tDisplayMetrics displayMetrics = view.getContext().getResources().getDisplayMetrics();\n+\t\t\t\trenderable = new Renderable.MultiProfileTrack(new ArrayList<>(points),\n+\t\t\t\t\t\tprofileValues, displayMetrics, 17.2);\n+\t\t\t} else {\n+\t\t\t\trenderable = new Renderable.StandardTrack(new ArrayList<>(points), 17.2);\n+\t\t\t}\n+\t\t\trenderable.drawSegment(view.getZoom(), lineAttrs.paint, canvas, tb);\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic void onDraw(Canvas canvas, RotatedTileBox tb, DrawSettings settings) {\n \t\tif (inMeasurementMode) {\n@@ -290,28 +315,94 @@ private void drawPoints(Canvas canvas, RotatedTileBox tb) {\n \t\t\tif (pt != lastBeforePoint && pt != firstAfterPoint && isInTileBox(tb, pt)) {\n \t\t\t\tfloat locX = tb.getPixXFromLatLon(pt.lat, pt.lon);\n \t\t\t\tfloat locY = tb.getPixYFromLatLon(pt.lat, pt.lon);\n-\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\tif (multipleProfileMode) {\n+\t\t\t\t\tdrawMultiProfilePointIcon(canvas, locX, locY);\n+\t\t\t\t} else {\n+\t\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tpt = points.get(points.size() - 1);\n \t\t\tif (pt != lastBeforePoint && pt != firstAfterPoint && isInTileBox(tb, pt)) {\n \t\t\t\tfloat locX = tb.getPixXFromLatLon(pt.lat, pt.lon);\n \t\t\t\tfloat locY = tb.getPixYFromLatLon(pt.lat, pt.lon);\n-\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\tif (multipleProfileMode) {\n+\t\t\t\t\tdrawMultiProfilePointIcon(canvas, locX, locY);\n+\t\t\t\t} else {\n+\t\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfor (int i = 0; i < points.size(); i++) {\n \t\t\t\tWptPt pt = points.get(i);\n \t\t\t\tif (pt != lastBeforePoint && pt != firstAfterPoint && isInTileBox(tb, pt)) {\n \t\t\t\t\tfloat locX = tb.getPixXFromLatLon(pt.lat, pt.lon);\n \t\t\t\t\tfloat locY = tb.getPixYFromLatLon(pt.lat, pt.lon);\n-\t\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\t\tif (multipleProfileMode) {\n+\t\t\t\t\t\tdrawMultiProfilePointIcon(canvas, locX, locY);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n \t}\n \n+\t// Will be replaced with icon in Bitmap\n+\tprivate void drawMultiProfilePointIcon(Canvas canvas, float centerX, float centerY) {\n+\t\tContext ctx = view.getContext();\n+\t\tPath path = new Path();\n+\t\tPaint paint = new Paint();\n+\t\tpaint.setStyle(Paint.Style.FILL);\n+\t\tpath.addCircle(centerX, centerY, AndroidUtils.dpToPx(ctx, 12.5f), Path.Direction.CW);\n+\t\tpaint.setColor(Color.BLACK);\n+\t\tcanvas.drawPath(path, paint);\n+\t\tpath.reset();\n+\t\tpath.addCircle(centerX, centerY, AndroidUtils.dpToPx(ctx, 12), Path.Direction.CW);\n+\t\tpaint.setColor(Color.WHITE);\n+\t\tcanvas.drawPath(path, paint);\n+\t\tpath.reset();\n+\t\tpath.addCircle(centerX, centerY, AndroidUtils.dpToPx(ctx, 8), Path.Direction.CW);\n+\t\tpaint.setColor(Algorithms.parseColor(\"#637EFB\"));\n+\t\tcanvas.drawPath(path, paint);\n+\t}\n+\n+\tprivate Map<String, Pair<Integer, Bitmap>> getProfileValues(boolean night) {\n+\t\tMap<String, Pair<Integer, Bitmap>> profileColors = new HashMap<>();\n+\t\tint splitColor = ContextCompat.getColor(view.getContext(), ProfileIconColors.DARK_YELLOW.getColor(night));\n+\t\tprofileColors.put(ApplicationMode.DEFAULT.getStringKey(),\n+\t\t\t\tnew Pair<>(splitColor, getSizedBitmap(R.drawable.ic_action_split_interval, splitColor, 28)));\n+\t\tString[] profiles = new String[]{ApplicationMode.CAR.getStringKey(),\n+\t\t\t\tApplicationMode.BICYCLE.getStringKey(), ApplicationMode.PEDESTRIAN.getStringKey()};\n+\t\tfor (String profile : profiles) {\n+\t\t\tApplicationMode appMode = ApplicationMode.getApplicationModeByKey(profile);\n+\t\t\tif (appMode != null) {\n+\t\t\t\tint iconSize = appMode.getStringKey().equals(ApplicationMode.BICYCLE.getStringKey()) ? 24 : 28;\n+\t\t\t\tprofileColors.put(profile, new Pair<>(appMode.getProfileColor(night),\n+\t\t\t\t\t\tgetSizedBitmap(appMode.getIconRes(), appMode.getProfileColor(night), iconSize)));\n+\t\t\t}\n+\t\t}\n+\t\treturn profileColors;\n+\t}\n+\n+\tprivate Bitmap getSizedBitmap(@DrawableRes int res, @ColorInt int color, float dp) {\n+\t\tContext ctx = view.getContext();\n+\t\tDrawable drawable =  ContextCompat.getDrawable(ctx, res);\n+\t\tdrawable = UiUtilities.tintDrawable(drawable, color);\n+\t\tif (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n+\t\t\tdrawable = (DrawableCompat.wrap(drawable)).mutate();\n+\t\t}\n+\t\tBitmap src = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);\n+\t\tCanvas canvas = new Canvas(src);\n+\t\tdrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());\n+\t\tdrawable.draw(canvas);\n+\t\tint iconSize = AndroidUtils.dpToPx(ctx, dp);\n+\t\tBitmap resized = Bitmap.createScaledBitmap(src, iconSize, iconSize, false);\n+\t\tsrc.recycle();\n+\t\treturn resized;\n+\t}\n+\n \tprivate void drawBeforeAfterPath(Canvas canvas, RotatedTileBox tb) {\n \t\tList<TrkSegment> before = editingCtx.getBeforeSegments();\n \t\tList<TrkSegment> after = editingCtx.getAfterSegments();\n@@ -375,7 +466,11 @@ private void drawPointIcon(Canvas canvas, RotatedTileBox tb, WptPt pt) {\n \t\tfloat locX = tb.getPixXFromLatLon(pt.lat, pt.lon);\n \t\tfloat locY = tb.getPixYFromLatLon(pt.lat, pt.lon);\n \t\tif (tb.containsPoint(locX, locY, 0)) {\n-\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\tif (multipleProfileMode) {\n+\t\t\t\tdrawMultiProfilePointIcon(canvas, locX, locY);\n+\t\t\t} else {\n+\t\t\t\tcanvas.drawBitmap(pointIcon, locX - marginPointIconX, locY - marginPointIconY, bitmapPaint);\n+\t\t\t}\n \t\t}\n \t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n \t}"
  },
  {
    "sha": "7a3a51fecdeb9aaa7cc15b22c715c1e2b3ad3461",
    "filename": "OsmAnd/src/net/osmand/plus/measurementtool/command/ChangeRouteModeCommand.java",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/osmandapp/OsmAnd/blob/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/command/ChangeRouteModeCommand.java",
    "raw_url": "https://github.com/osmandapp/OsmAnd/raw/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/measurementtool/command/ChangeRouteModeCommand.java",
    "contents_url": "https://api.github.com/repos/osmandapp/OsmAnd/contents/OsmAnd/src/net/osmand/plus/measurementtool/command/ChangeRouteModeCommand.java?ref=41610ebbc453b94adc15f4bad24e0182b91c722d",
    "patch": "@@ -151,7 +151,7 @@ private void executeCommand() {\n \n \tprivate void updateProfileType(WptPt pt) {\n \t\tif (!pt.isGap()) {\n-\t\t\tif (newMode != null && newMode != DEFAULT_APP_MODE) {\n+\t\t\tif (newMode != null) {\n \t\t\t\tpt.setProfileType(newMode.getStringKey());\n \t\t\t} else {\n \t\t\t\tpt.removeProfileType();"
  },
  {
    "sha": "ae8e9a93d7f7be1f62179137b8a1f0cd781fb479",
    "filename": "OsmAnd/src/net/osmand/plus/settings/backend/ApplicationMode.java",
    "status": "modified",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "blob_url": "https://github.com/osmandapp/OsmAnd/blob/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/settings/backend/ApplicationMode.java",
    "raw_url": "https://github.com/osmandapp/OsmAnd/raw/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/settings/backend/ApplicationMode.java",
    "contents_url": "https://api.github.com/repos/osmandapp/OsmAnd/contents/OsmAnd/src/net/osmand/plus/settings/backend/ApplicationMode.java?ref=41610ebbc453b94adc15f4bad24e0182b91c722d",
    "patch": "@@ -726,6 +726,15 @@ public static ApplicationModeBuilder createCustomMode(ApplicationMode parent, St\n \t\treturn builder;\n \t}\n \n+\tpublic static ApplicationMode getApplicationModeByKey(String key) {\n+\t\tfor (ApplicationMode appMode : allPossibleValues()) {\n+\t\t\tif (appMode.getStringKey().equals(key)) {\n+\t\t\t\treturn appMode;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tpublic static class ApplicationModeBuilder {\n \n \t\tprivate ApplicationMode applicationMode;"
  },
  {
    "sha": "85eb85d25e776035f657f1226a9cc11f612dad3b",
    "filename": "OsmAnd/src/net/osmand/plus/views/Renderable.java",
    "status": "modified",
    "additions": 218,
    "deletions": 0,
    "changes": 218,
    "blob_url": "https://github.com/osmandapp/OsmAnd/blob/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/views/Renderable.java",
    "raw_url": "https://github.com/osmandapp/OsmAnd/raw/41610ebbc453b94adc15f4bad24e0182b91c722d/OsmAnd/src/net/osmand/plus/views/Renderable.java",
    "contents_url": "https://api.github.com/repos/osmandapp/OsmAnd/contents/OsmAnd/src/net/osmand/plus/views/Renderable.java?ref=41610ebbc453b94adc15f4bad24e0182b91c722d",
    "patch": "@@ -1,10 +1,17 @@\n package net.osmand.plus.views;\n \n+import android.graphics.Bitmap;\n import android.graphics.Canvas;\n+import android.graphics.Color;\n import android.graphics.LinearGradient;\n import android.graphics.Paint;\n import android.graphics.Path;\n+import android.graphics.PathMeasure;\n+import android.graphics.PointF;\n import android.graphics.Shader;\n+import android.util.DisplayMetrics;\n+import android.util.Pair;\n+import android.util.TypedValue;\n \n import net.osmand.GPXUtilities;\n import net.osmand.GPXUtilities.WptPt;\n@@ -15,7 +22,9 @@\n import net.osmand.util.Algorithms;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.Executor;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -26,6 +35,9 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import androidx.annotation.NonNull;\n+import androidx.core.graphics.ColorUtils;\n+\n+import static android.util.TypedValue.COMPLEX_UNIT_DIP;\n \n \n public class Renderable {\n@@ -237,6 +249,212 @@ public StandardTrack(List<WptPt> pt, double base) {\n         }\n     }\n \n+    public static class MultiProfileTrack extends StandardTrack {\n+\n+        private final Map<String, List<PointF>> profileIconsPositions = new HashMap<>();\n+        private final Map<String, Pair<Integer, Bitmap>> profileValues;\n+\n+        private final DisplayMetrics displayMetrics;\n+\n+        private Paint circlePaint;\n+        private Paint borderPaint;\n+\n+        private final float circleSize;\n+        private final float iconOffset;\n+\n+        private int userPtIdx = 0;\n+        private int leftPtIdx = 0;\n+        private int rightPtIdx = 0;\n+\n+        public MultiProfileTrack(List<WptPt> routePoints, Map<String, Pair<Integer, Bitmap>> profileValues,\n+                                 DisplayMetrics displayMetrics, double base) {\n+            super(routePoints, base);\n+            this.profileValues = profileValues;\n+            this.displayMetrics = displayMetrics;\n+            updateCirclePaint();\n+            circleSize = dpToPx(18);\n+            iconOffset = dpToPx(30) + circleSize / 2;\n+        }\n+\n+        @Override\n+        protected void drawSolid(List<WptPt> points, Paint linePaint, Canvas canvas, RotatedTileBox tileBox) {\n+            linePaint = new Paint(paint);\n+\n+            QuadRect tileBounds = tileBox.getLatLonBounds();\n+            PathMeasure pathMeasure = new PathMeasure();\n+            Path path = new Path();\n+\n+            WptPt prevPt = points.get(0);\n+            String currentProfile = getProfile(points);\n+            linePaint.setColor(profileValues.get(currentProfile).first);\n+            updateBorderPaint(linePaint.getColor(), linePaint.getStrokeWidth() + dpToPx(4));\n+\n+            float lengthRemaining = getRemainingLength(tileBox, points);\n+\n+            for (int i = 1; i < points.size(); i++) {\n+                WptPt currentPt = points.get(i);\n+                PointF start = getPointFromWpt(tileBox, prevPt);\n+                PointF end = getPointFromWpt(tileBox, currentPt);\n+\n+                path.reset();\n+                path.moveTo(start.x, start.y);\n+                path.lineTo(end.x, end.y);\n+                if (arePointsInsideTile(currentPt, prevPt, tileBounds)) {\n+                    canvas.drawPath(path, borderPaint);\n+                    canvas.drawPath(path, linePaint);\n+                }\n+\n+                if (lengthRemaining >= 0) {\n+                    pathMeasure.setPath(path, false);\n+                    float pathLength = pathMeasure.getLength();\n+                    if (lengthRemaining - pathLength <= 0) {\n+                        addIconPosition(start, end, pathLength, lengthRemaining, currentProfile);\n+                    }\n+                    lengthRemaining -= pathLength;\n+                }\n+\n+                if (currentPt.hasProfile()) {\n+                    currentProfile = getProfile(points);\n+                    linePaint.setColor(profileValues.get(currentProfile).first);\n+                    updateBorderPaint(linePaint.getColor(), linePaint.getStrokeWidth() + dpToPx(2));\n+                    lengthRemaining = getRemainingLength(tileBox, points);\n+                }\n+                prevPt = currentPt;\n+            }\n+        }\n+\n+        private void drawProfileIcons(Canvas canvas, RotatedTileBox tileBox) {\n+            for (String profile : profileIconsPositions.keySet()) {\n+                List<PointF> positions = profileIconsPositions.get(profile);\n+                if (Algorithms.isEmpty(positions)) {\n+                    continue;\n+                }\n+                for (PointF center : positions) {\n+                    if (tileBox.containsPoint(center.x, center.y, dpToPx(20)))\n+                    drawProfileCircle(canvas, center, profile);\n+                }\n+\n+            }\n+        }\n+\n+        private void drawProfileCircle(Canvas canvas, PointF center, String profile) {\n+            canvas.drawCircle(center.x, center.y, circleSize, circlePaint);\n+\n+            Path ring = new Path();\n+            ring.addCircle(center.x, center.y, circleSize, Path.Direction.CW);\n+            updateBorderPaint(profileValues.get(profile).first, dpToPx(3));\n+            canvas.drawPath(ring, borderPaint);\n+\n+            Bitmap icon = profileValues.get(profile).second;\n+            int iconX = icon.getWidth() / 2;\n+            int iconY = icon.getHeight() / 2;\n+            canvas.drawBitmap(icon, center.x - iconX, center.y - iconY, null);\n+        }\n+\n+        @Override\n+        protected void updateLocalPaint(Paint p) {\n+            super.updateLocalPaint(p);\n+            paint.setPathEffect(null);\n+            paint.setStrokeWidth(dpToPx(8));\n+        }\n+\n+        private void updateCirclePaint() {\n+            if (circlePaint == null) {\n+                circlePaint = new Paint();\n+                circlePaint.setColor(Color.WHITE);\n+                circlePaint.setStyle(Paint.Style.FILL);\n+            }\n+        }\n+\n+        private void updateBorderPaint(int color, float pixWidth) {\n+            if (borderPaint == null) {\n+                borderPaint = new Paint();\n+                borderPaint.setStyle(Paint.Style.STROKE);\n+                borderPaint.setStrokeCap(Paint.Cap.BUTT);\n+            }\n+            borderPaint.setColor(ColorUtils.blendARGB(color, Color.BLACK, 0.2f));\n+            borderPaint.setStrokeWidth(pixWidth);\n+        }\n+\n+        private void addIconPosition(PointF start, PointF end, float pathLength, float lengthRemaining, String currentProfile) {\n+            PointF iconPosition = getPointOnSection(start, end, pathLength, lengthRemaining);\n+            List<PointF> positions = profileIconsPositions.get(currentProfile);\n+            if (positions == null) {\n+                positions = new ArrayList<>();\n+                profileIconsPositions.put(currentProfile, positions);\n+            }\n+            positions.add(iconPosition);\n+        }\n+\n+        private PointF getPointOnSection(PointF start, PointF end, float sectionLength, float remainingLength) {\n+            float ratio = remainingLength / sectionLength;\n+            float diffX = ratio * (end.x - start.x);\n+            float diffY = ratio * (end.y - start.y);\n+            return new PointF(start.x + diffX, start.y + diffY);\n+        }\n+\n+        private float getRemainingLength(RotatedTileBox tileBox, List<WptPt> points) {\n+            Path path = new Path();\n+            PointF start = getPointFromWpt(tileBox, points.get(leftPtIdx));\n+            path.moveTo(start.x, start.y);\n+            for (int i = leftPtIdx + 1; i <= rightPtIdx; i++) {\n+                PointF end = getPointFromWpt(tileBox, points.get(i));\n+                path.lineTo(end.x, end.y);\n+            }\n+            float routeHalfLength = new PathMeasure(path, false).getLength() / 2;\n+            return routeHalfLength < iconOffset ? -1 : routeHalfLength;\n+        }\n+\n+        private String getProfile(List<WptPt> points) {\n+            int idx = updateLeftIdx();\n+            WptPt userWpt = idx == -1 ? null : points.get(leftPtIdx);\n+            updateRightIdx();\n+            return userWpt.getProfileType();\n+        }\n+\n+        private int updateLeftIdx() {\n+            leftPtIdx = updateUserPtIdx();\n+            return leftPtIdx;\n+        }\n+\n+        private int updateRightIdx() {\n+            userPtIdx++;\n+            rightPtIdx = updateUserPtIdx();\n+            return rightPtIdx;\n+        }\n+\n+        private int updateUserPtIdx() {\n+            for (int i = userPtIdx; i < points.size(); i++) {\n+                if (points.get(i).hasProfile()) {\n+                    userPtIdx = i;\n+                    return userPtIdx;\n+                }\n+            }\n+            userPtIdx = -1;\n+            return userPtIdx;\n+        }\n+\n+        private PointF getPointFromWpt(RotatedTileBox tileBox, WptPt pt) {\n+            float x = tileBox.getPixXFromLatLon(pt.lat, pt.lon);\n+            float y = tileBox.getPixYFromLatLon(pt.lat, pt.lon);\n+            return new PointF(x, y);\n+        }\n+\n+        private float dpToPx(float dp) {\n+            return (int) TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp, displayMetrics);\n+        }\n+\n+        @Override\n+        public void drawSingleSegment(double zoom, Paint p, Canvas canvas, RotatedTileBox tileBox) {\n+            super.drawSingleSegment(zoom, p, canvas, tileBox);\n+            drawProfileIcons(canvas, tileBox);\n+        }\n+\n+        @Override\n+        public void startCuller(double newZoom) {\n+        }\n+    }\n+\n     public static class CurrentTrack extends RenderableSegment {\n \n         public CurrentTrack(List<WptPt> pt) {"
  }
]
