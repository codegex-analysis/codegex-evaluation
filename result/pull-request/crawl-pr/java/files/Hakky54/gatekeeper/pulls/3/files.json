[
  {
    "sha": "b25d283080451cdba88d340f48d1f77b25a09626",
    "filename": "src/main/java/nl/altindag/gatekeeper/Gatekeeper.java",
    "status": "modified",
    "additions": 16,
    "deletions": 8,
    "changes": 24,
    "blob_url": "https://github.com/Hakky54/gatekeeper/blob/35799b0b76243af7b1ff77330b67a6f21a797c3c/src/main/java/nl/altindag/gatekeeper/Gatekeeper.java",
    "raw_url": "https://github.com/Hakky54/gatekeeper/raw/35799b0b76243af7b1ff77330b67a6f21a797c3c/src/main/java/nl/altindag/gatekeeper/Gatekeeper.java",
    "contents_url": "https://api.github.com/repos/Hakky54/gatekeeper/contents/src/main/java/nl/altindag/gatekeeper/Gatekeeper.java?ref=35799b0b76243af7b1ff77330b67a6f21a797c3c",
    "patch": "@@ -34,29 +34,37 @@ public static void ensureCallerIsAnyOf(Class... allowedCallerClasses) {\n             throw new IllegalArgumentException(\"At least one allowed caller class should be present\");\n         }\n \n-        StackTraceElement[] stackTrace = new Exception().getStackTrace();\n-        StackTraceElement caller = stackTrace[2];\n-        StackTraceElement target = stackTrace[1];\n-\n-        boolean isCallerAllowedToCallTarget = isCallerAllowedToCallTarget(allowedCallerClasses, caller.getClassName());\n+        Class<?> caller = internalSecurityManager.getCallerClassName(3);\n+        boolean isCallerAllowedToCallTarget = isCallerAllowedToCallTarget(allowedCallerClasses, caller);\n \n         if (!isCallerAllowedToCallTarget) {\n+            StackTraceElement[] stackTrace = new Exception().getStackTrace();\n+            StackTraceElement target = stackTrace[1];\n             throw new GatekeeperException(String.format(\n                     \"Class [%s] tried to call a restricted method. Only classes of the type [%s] are allowed to call the method [%s] from class [%s]\",\n-                    caller.getClassName(),\n+                    caller.getName(),\n                     Arrays.stream(allowedCallerClasses).map(Class::getName).collect(Collectors.joining(\", \")),\n                     target.getMethodName(),\n                     target.getClassName()));\n         }\n     }\n \n-    private static boolean isCallerAllowedToCallTarget(Class[] allowedCallerClasses, String callerClassName) {\n+    private static boolean isCallerAllowedToCallTarget(Class[] allowedCallerClasses, Class callerClass) {\n         for (Class allowedCallerClass : allowedCallerClasses) {\n-            if (allowedCallerClass.getName().equals(callerClassName)) {\n+            if (allowedCallerClass == callerClass) {\n                 return true;\n             }\n         }\n         return false;\n     }\n+    \n+    private static class InternalSecurityManager extends SecurityManager {\n+        public Class<?> getCallerClassName(int callStackDepth) {\n+            return getClassContext()[callStackDepth];\n+        }\n+    }\n+\n+    private final static InternalSecurityManager internalSecurityManager =\n+        new InternalSecurityManager();\n \n }"
  }
]
