[
  {
    "sha": "36ef49e3905504f9ac6e198fe8ab68cd9ec7a103",
    "filename": "src/main/java/baritone/utils/schematic/format/DefaultSchematicFormats.java",
    "status": "modified",
    "additions": 19,
    "deletions": 0,
    "changes": 19,
    "blob_url": "https://github.com/cabaletta/baritone/blob/5d7128ba55ef072d5a54e917f467334a1a76ee25/src/main/java/baritone/utils/schematic/format/DefaultSchematicFormats.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/5d7128ba55ef072d5a54e917f467334a1a76ee25/src/main/java/baritone/utils/schematic/format/DefaultSchematicFormats.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/main/java/baritone/utils/schematic/format/DefaultSchematicFormats.java?ref=5d7128ba55ef072d5a54e917f467334a1a76ee25",
    "patch": "@@ -21,6 +21,7 @@\n import baritone.api.schematic.format.ISchematicFormat;\n import baritone.utils.schematic.format.defaults.MCEditSchematic;\n import baritone.utils.schematic.format.defaults.SpongeSchematic;\n+import baritone.utils.schematic.format.defaults.LitematicaSchematic;\n import net.minecraft.nbt.CompressedStreamTools;\n import net.minecraft.nbt.NBTTagCompound;\n import org.apache.commons.io.FilenameUtils;\n@@ -65,6 +66,24 @@ public IStaticSchematic parse(InputStream input) throws IOException {\n                     throw new UnsupportedOperationException(\"Unsupported Version of a Sponge Schematic\");\n             }\n         }\n+    },\n+    /**\n+     * The Litematica Schematic Specification. Commonly denoted by the \".litematic\" file extension.\n+     *\n+     */\n+    LITEMATIC(\"litematic\") {\n+\n+        @Override\n+        public IStaticSchematic parse(InputStream input) throws IOException {\n+            NBTTagCompound nbt = CompressedStreamTools.readCompressed(input);\n+            int version = nbt.getInteger(\"Version\");\n+            switch (version) {\n+                case 5:\n+                    return new LitematicaSchematic(nbt);\n+                default:\n+                    throw new UnsupportedOperationException(\"Unsupported Version of a Litematica Schematic\");\n+            }\n+        }\n     };\n \n     private final String extension;"
  },
  {
    "sha": "7a4f6a03da8b4e86437f0fd105c4ff9b3f3e1388",
    "filename": "src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java",
    "status": "added",
    "additions": 217,
    "deletions": 0,
    "changes": 217,
    "blob_url": "https://github.com/cabaletta/baritone/blob/5d7128ba55ef072d5a54e917f467334a1a76ee25/src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/5d7128ba55ef072d5a54e917f467334a1a76ee25/src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/main/java/baritone/utils/schematic/format/defaults/LitematicaSchematic.java?ref=5d7128ba55ef072d5a54e917f467334a1a76ee25",
    "patch": "@@ -0,0 +1,217 @@\n+/*\n+ * This file is part of Baritone.\n+ *\n+ * Baritone is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Baritone is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package baritone.utils.schematic.format.defaults;\n+\n+import baritone.utils.schematic.StaticSchematic;\n+import net.minecraft.block.*;\n+import net.minecraft.block.properties.IProperty;\n+import net.minecraft.nbt.*;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.block.state.IBlockState;\n+\n+import org.apache.commons.lang3.Validate;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+/**\n+ * @author Emerson\n+ * @since 12/27/2020\n+ */\n+public final class LitematicaSchematic extends StaticSchematic {\n+\n+    public LitematicaSchematic(NBTTagCompound nbt) {\n+        String regionName = (String) nbt.getCompoundTag(\"Regions\").getKeySet().toArray()[0];\n+        this.x = Math.abs(nbt.getCompoundTag(\"Regions\").getCompoundTag(regionName).getCompoundTag(\"Size\").getInteger(\"x\"));\n+        this.y = Math.abs(nbt.getCompoundTag(\"Regions\").getCompoundTag(regionName).getCompoundTag(\"Size\").getInteger(\"y\"));\n+        this.z = Math.abs(nbt.getCompoundTag(\"Regions\").getCompoundTag(regionName).getCompoundTag(\"Size\").getInteger(\"z\"));\n+        this.states = new IBlockState[this.x][this.z][this.y];\n+\n+\n+        NBTTagList paletteTag = nbt.getCompoundTag(\"Regions\").getCompoundTag(regionName).getTagList(\"BlockStatePalette\",10);\n+        // ListNBT paletteTag = nbt.getCompound(\"Regions\").getCompound(regionName).getList(\"BlockStatePalette\",10);\n+\n+        // Create the block states array\n+        IBlockState[] paletteBlockStates = new IBlockState[paletteTag.tagCount()];\n+        // For every part of the array\n+        for (int i = 0; i<paletteTag.tagCount(); i++) {\n+            // Set the default state by getting block name\n+            Block block = Block.REGISTRY.getObject(new ResourceLocation((((NBTTagCompound) paletteTag.get(i)).getString(\"Name\"))));\n+            IBlockState blockState = block.getDefaultState();\n+            NBTTagCompound properties = ((NBTTagCompound) paletteTag.get(i)).getCompoundTag(\"Properties\");\n+            Object[] keys = properties.getKeySet().toArray();\n+            Map<String, String> propertiesMap = new HashMap<>();\n+            // Create a map for each state\n+            for (int j = 0; j<keys.length; j++) {\n+                propertiesMap.put((String) keys[j], (properties.getString((String) keys[j])));\n+            }\n+            for (int j = 0; j<keys.length; j++) {\n+                IProperty<?> property = block.getBlockState().getProperty(keys[j].toString());\n+                if (property != null) {\n+                    blockState = setPropertyValue(blockState, property, propertiesMap.get(keys[j]));\n+                }\n+            }\n+            paletteBlockStates[i] = blockState;\n+        }\n+\n+\n+        // BlockData is stored as an NBT long[]\n+        int paletteSize = (int) Math.floor(log2(paletteTag.tagCount()))+1;\n+        long litematicSize = (long) this.x*this.y*this.z;\n+\n+        // In 1.12, the long array isn't exposed by the libraries so parsing has to be done manually\n+        String rawBlockString = (nbt.getCompoundTag(\"Regions\").getCompoundTag(regionName)).getTag(\"BlockStates\").toString();\n+        rawBlockString = rawBlockString.substring(3,rawBlockString.length()-1);\n+        String[] rawBlockArrayString = rawBlockString.split(\",\");\n+        long[] rawBlockData = new long[rawBlockArrayString.length];\n+        for (int i = 0; i < rawBlockArrayString.length; i++) {\n+            rawBlockData[i] = Long.parseLong(rawBlockArrayString[i].substring(0,rawBlockArrayString[i].length()-1));\n+        }\n+\n+\n+        LitematicaBitArray bitArray = new LitematicaBitArray(paletteSize, litematicSize, rawBlockData);\n+        if (paletteSize > 32) {\n+            throw new IllegalStateException(\"Too many blocks in schematic to handle\");\n+        }\n+\n+        int[] serializedBlockStates = new int[(int) litematicSize];\n+        for (int i = 0; i<serializedBlockStates.length; i++) {\n+            serializedBlockStates[i] = bitArray.getAt(i);\n+        }\n+\n+        int counter = 0;\n+        for (int y = 0; y < this.y; y++) {\n+            for (int z = 0; z < this.z; z++) {\n+                for (int x = 0; x < this.x; x++) {\n+                    IBlockState state = paletteBlockStates[serializedBlockStates[counter]];\n+                    this.states[x][z][y] = state;\n+                    counter++;\n+                }\n+            }\n+        }\n+    }\n+    private static double log2(int N) {\n+        return (Math.log(N) / Math.log(2));\n+    }\n+\n+    private static <T extends Comparable<T>> IBlockState setPropertyValue(IBlockState state, IProperty<T> property, String value) {\n+        Optional<T> parsed = property.parseValue(value).toJavaUtil();\n+        if (parsed.isPresent()) {\n+            return state.withProperty(property, parsed.get());\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid value for property \" + property);\n+        }\n+    }\n+\n+    /** LitematicaBitArray class from litematica */\n+    private static class LitematicaBitArray\n+    {\n+        /** The long array that is used to store the data for this BitArray. */\n+        private final long[] longArray;\n+        /** Number of bits a single entry takes up */\n+        private final int bitsPerEntry;\n+        /**\n+         * The maximum value for a single entry. This also works as a bitmask for a single entry.\n+         * For instance, if bitsPerEntry were 5, this value would be 31 (ie, {@code 0b00011111}).\n+         */\n+        private final long maxEntryValue;\n+        /** Number of entries in this array (<b>not</b> the length of the long array that internally backs this array) */\n+        private final long arraySize;\n+\n+        public LitematicaBitArray(int bitsPerEntryIn, long arraySizeIn, @Nullable long[] longArrayIn)\n+        {\n+            Validate.inclusiveBetween(1L, 32L, (long) bitsPerEntryIn);\n+            this.arraySize = arraySizeIn;\n+            this.bitsPerEntry = bitsPerEntryIn;\n+            this.maxEntryValue = (1L << bitsPerEntryIn) - 1L;\n+\n+            if (longArrayIn != null)\n+            {\n+                this.longArray = longArrayIn;\n+            }\n+            else\n+            {\n+                this.longArray = new long[(int) (roundUp((long) arraySizeIn * (long) bitsPerEntryIn, 64L) / 64L)];\n+            }\n+        }\n+\n+        public void setAt(long index, int value)\n+        {\n+            Validate.inclusiveBetween(0L, this.arraySize - 1L, (long) index);\n+            Validate.inclusiveBetween(0L, this.maxEntryValue, (long) value);\n+            long startOffset = index * (long) this.bitsPerEntry;\n+            int startArrIndex = (int) (startOffset >> 6); // startOffset / 64\n+            int endArrIndex = (int) (((index + 1L) * (long) this.bitsPerEntry - 1L) >> 6);\n+            int startBitOffset = (int) (startOffset & 0x3F); // startOffset % 64\n+            this.longArray[startArrIndex] = this.longArray[startArrIndex] & ~(this.maxEntryValue << startBitOffset) | ((long) value & this.maxEntryValue) << startBitOffset;\n+\n+            if (startArrIndex != endArrIndex)\n+            {\n+                int endOffset = 64 - startBitOffset;\n+                int j1 = this.bitsPerEntry - endOffset;\n+                this.longArray[endArrIndex] = this.longArray[endArrIndex] >>> j1 << j1 | ((long) value & this.maxEntryValue) >> endOffset;\n+            }\n+        }\n+\n+        public int getAt(long index)\n+        {\n+            Validate.inclusiveBetween(0L, this.arraySize - 1L, (long) index);\n+            long startOffset = index * (long) this.bitsPerEntry;\n+            int startArrIndex = (int) (startOffset >> 6); // startOffset / 64\n+            int endArrIndex = (int) (((index + 1L) * (long) this.bitsPerEntry - 1L) >> 6);\n+            int startBitOffset = (int) (startOffset & 0x3F); // startOffset % 64\n+\n+            if (startArrIndex == endArrIndex)\n+            {\n+                return (int) (this.longArray[startArrIndex] >>> startBitOffset & this.maxEntryValue);\n+            }\n+            else\n+            {\n+                int endOffset = 64 - startBitOffset;\n+                return (int) ((this.longArray[startArrIndex] >>> startBitOffset | this.longArray[endArrIndex] << endOffset) & this.maxEntryValue);\n+            }\n+        }\n+\n+\n+        public long size()\n+        {\n+            return this.arraySize;\n+        }\n+\n+        public static long roundUp(long number, long interval)\n+        {\n+            if (interval == 0)\n+            {\n+                return 0;\n+            }\n+            else if (number == 0)\n+            {\n+                return interval;\n+            }\n+            else\n+            {\n+                if (number < 0)\n+                {\n+                    interval *= -1;\n+                }\n+\n+                long i = number % interval;\n+                return i == 0 ? number : number + interval - i;\n+            }\n+        }\n+    }\n+}"
  }
]
