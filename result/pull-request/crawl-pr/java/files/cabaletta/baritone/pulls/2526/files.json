[
  {
    "sha": "0641ff8ab0118e507208dc05d7167694f92e7317",
    "filename": "src/api/java/baritone/api/Settings.java",
    "status": "modified",
    "additions": 23,
    "deletions": 0,
    "changes": 23,
    "blob_url": "https://github.com/cabaletta/baritone/blob/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/Settings.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/Settings.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/api/java/baritone/api/Settings.java?ref=67d9ae881f066891128e84295a219ef7704bfadc",
    "patch": "@@ -206,6 +206,29 @@\n \n     )));\n \n+    /**\n+     * A list of blocks to be treated as correct.\n+     * <p>\n+     * If a schematic asks for any block on this list at a certain position, it will be treated as correct, regardless of what it currently is.\n+     */\n+    public final Setting<List<Block>> buildSkipBlocks = new Setting<>(new ArrayList<>(Arrays.asList(\n+\n+    )));\n+\n+    /**\n+     * A mapping of blocks to blocks treated as correct in their position\n+     * <p>\n+     * If a schematic asks for a block on this mapping, all blocks on the mapped list will be accepted at that location as well\n+     */\n+    public final Setting<Map<Block, List<Block>>> buildValidSubstitutes = new Setting<>(new HashMap<>());\n+\n+    /**\n+     * A mapping of blocks to blocks to be built instead\n+     * <p>\n+     * If a schematic asks for a block on this mapping, Baritone will place the first placeable block in the mapped list\n+     */\n+    public final Setting<Map<Block, List<Block>>> buildSubstitutes = new Setting<>(new HashMap<>());\n+\n     /**\n      * A list of blocks to become air\n      * <p>"
  },
  {
    "sha": "f2fb203cd2c485b9289e7c1fc6281aae75e2e1d0",
    "filename": "src/api/java/baritone/api/schematic/FillSchematic.java",
    "status": "modified",
    "additions": 0,
    "deletions": 3,
    "changes": 3,
    "blob_url": "https://github.com/cabaletta/baritone/blob/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/schematic/FillSchematic.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/schematic/FillSchematic.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/api/java/baritone/api/schematic/FillSchematic.java?ref=67d9ae881f066891128e84295a219ef7704bfadc",
    "patch": "@@ -19,7 +19,6 @@\n \n import baritone.api.utils.BlockOptionalMeta;\n import net.minecraft.block.state.IBlockState;\n-import net.minecraft.init.Blocks;\n \n import java.util.List;\n \n@@ -44,8 +43,6 @@ public BlockOptionalMeta getBom() {\n     public IBlockState desiredState(int x, int y, int z, IBlockState current, List<IBlockState> approxPlaceable) {\n         if (bom.matches(current)) {\n             return current;\n-        } else if (current.getBlock() != Blocks.AIR) {\n-            return Blocks.AIR.getDefaultState();\n         }\n         for (IBlockState placeable : approxPlaceable) {\n             if (bom.matches(placeable)) {"
  },
  {
    "sha": "72787c243806ba3d3c38c7abe12b02e51da8d6a9",
    "filename": "src/api/java/baritone/api/schematic/SubstituteSchematic.java",
    "status": "added",
    "additions": 89,
    "deletions": 0,
    "changes": 89,
    "blob_url": "https://github.com/cabaletta/baritone/blob/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/schematic/SubstituteSchematic.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/schematic/SubstituteSchematic.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/api/java/baritone/api/schematic/SubstituteSchematic.java?ref=67d9ae881f066891128e84295a219ef7704bfadc",
    "patch": "@@ -0,0 +1,89 @@\n+/*\n+ * This file is part of Baritone.\n+ *\n+ * Baritone is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * Baritone is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with Baritone.  If not, see <https://www.gnu.org/licenses/>.\n+ */\n+\n+package baritone.api.schematic;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockAir;\n+import net.minecraft.block.properties.IProperty;\n+import net.minecraft.block.state.IBlockState;\n+import net.minecraft.init.Blocks;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SubstituteSchematic extends AbstractSchematic {\n+\n+    private final ISchematic schematic;\n+    private final Map<Block, List<Block>> substitutions;\n+    private final Map<IBlockState, Map<Block, IBlockState>> blockStateCache = new HashMap<>();\n+\n+    public SubstituteSchematic(ISchematic schematic, Map<Block,List<Block>> substitutions) {\n+        super(schematic.widthX(), schematic.heightY(), schematic.lengthZ());\n+        this.schematic = schematic;\n+        this.substitutions = substitutions;\n+    }\n+\n+    @Override\n+    public boolean inSchematic(int x, int y, int z, IBlockState currentState) {\n+        return schematic.inSchematic(x, y, z, currentState);\n+    }\n+\n+    @Override\n+    public IBlockState desiredState(int x, int y, int z, IBlockState current, List<IBlockState> approxPlaceable) {\n+        IBlockState desired = schematic.desiredState(x, y, z, current, approxPlaceable);\n+        Block desiredBlock = desired.getBlock();\n+        if (!substitutions.containsKey(desiredBlock)) {\n+            return desired;\n+        }\n+        List<Block> substitutes = substitutions.get(desiredBlock);\n+        if (substitutes.contains(current.getBlock()) && !(current.getBlock() instanceof BlockAir)) {// don't preserve air, it's almost always there and almost never wanted\n+            return withBlock(desired, current.getBlock());\n+        }\n+        for (Block substitute : substitutes) {\n+            if (substitute instanceof BlockAir) {\n+                return current.getBlock() instanceof BlockAir ? current : Blocks.AIR.getDefaultState(); // can always \"place\" air\n+            }\n+            for (IBlockState placeable : approxPlaceable) {\n+                if (substitute.equals(placeable.getBlock())) {\n+                    return withBlock(desired, placeable.getBlock());\n+                }\n+            }\n+        }\n+        return substitutes.get(0).getDefaultState();\n+    }\n+\n+    private IBlockState withBlock(IBlockState state, Block block) {\n+        if (blockStateCache.containsKey(state) && blockStateCache.get(state).containsKey(block)) {\n+            return blockStateCache.get(state).get(block);\n+        }\n+        Collection<IProperty<?>> properties = state.getPropertyKeys();\n+        IBlockState newState = block.getDefaultState();\n+        for (IProperty<?> property : properties) {\n+            try {\n+                newState = copySingleProp(state, newState, property);\n+            } catch (IllegalArgumentException e) { //property does not exist for target block\n+            }\n+        }\n+        blockStateCache.computeIfAbsent(state, s -> new HashMap<Block,IBlockState>()).put(block, newState);\n+        return newState;\n+    }\n+    private <T extends Comparable<T>> IBlockState copySingleProp(IBlockState fromState, IBlockState toState, IProperty<T> prop) {\n+        return toState.withProperty(prop, fromState.getValue(prop));\n+    }\n+}"
  },
  {
    "sha": "48c8ee4df79b667fa550b6e734695e690c922868",
    "filename": "src/api/java/baritone/api/utils/SettingsUtil.java",
    "status": "modified",
    "additions": 31,
    "deletions": 0,
    "changes": 31,
    "blob_url": "https://github.com/cabaletta/baritone/blob/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/utils/SettingsUtil.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/67d9ae881f066891128e84295a219ef7704bfadc/src/api/java/baritone/api/utils/SettingsUtil.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/api/java/baritone/api/utils/SettingsUtil.java?ref=67d9ae881f066891128e84295a219ef7704bfadc",
    "patch": "@@ -35,6 +35,7 @@\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n import java.util.function.Consumer;\n import java.util.function.Function;\n@@ -261,6 +262,36 @@ public String toString(ParserContext context, Object value) {\n             public boolean accepts(Type type) {\n                 return List.class.isAssignableFrom(TypeUtils.resolveBaseClass(type));\n             }\n+        },\n+        MAPPING() {\n+            @Override\n+            public Object parse(ParserContext context, String raw) {\n+                Type keyType = ((ParameterizedType) context.getSetting().getType()).getActualTypeArguments()[0];\n+                Type valueType = ((ParameterizedType) context.getSetting().getType()).getActualTypeArguments()[1];\n+                Parser keyParser = Parser.getParser(keyType);\n+                Parser valueParser = Parser.getParser(valueType);\n+\n+                return Stream.of(raw.split(\",(?=[^,]*->)\"))\n+                        .map(s -> s.split(\"->\"))\n+                        .collect(Collectors.toMap(s -> keyParser.parse(context, s[0]), s -> valueParser.parse(context, s[1])));\n+            }\n+\n+            @Override\n+            public String toString(ParserContext context, Object value) {\n+                Type keyType = ((ParameterizedType) context.getSetting().getType()).getActualTypeArguments()[0];\n+                Type valueType = ((ParameterizedType) context.getSetting().getType()).getActualTypeArguments()[1];\n+                Parser keyParser = Parser.getParser(keyType);\n+                Parser valueParser = Parser.getParser(valueType);\n+\n+                return ((Map<?,?>) value).entrySet().stream()\n+                        .map(o -> keyParser.toString(context, o.getKey()) + \"->\" + valueParser.toString(context, o.getValue()))\n+                        .collect(Collectors.joining(\",\"));\n+            }\n+\n+            @Override\n+            public boolean accepts(Type type) {\n+                return Map.class.isAssignableFrom(TypeUtils.resolveBaseClass(type));\n+            }\n         };\n \n         private final Class<?> cla$$;"
  },
  {
    "sha": "08df9bad90dd8a4c4efe97fff1badce72fa42ef7",
    "filename": "src/main/java/baritone/process/BuilderProcess.java",
    "status": "modified",
    "additions": 14,
    "deletions": 3,
    "changes": 17,
    "blob_url": "https://github.com/cabaletta/baritone/blob/67d9ae881f066891128e84295a219ef7704bfadc/src/main/java/baritone/process/BuilderProcess.java",
    "raw_url": "https://github.com/cabaletta/baritone/raw/67d9ae881f066891128e84295a219ef7704bfadc/src/main/java/baritone/process/BuilderProcess.java",
    "contents_url": "https://api.github.com/repos/cabaletta/baritone/contents/src/main/java/baritone/process/BuilderProcess.java?ref=67d9ae881f066891128e84295a219ef7704bfadc",
    "patch": "@@ -26,6 +26,7 @@\n import baritone.api.process.PathingCommand;\n import baritone.api.process.PathingCommandType;\n import baritone.api.schematic.FillSchematic;\n+import baritone.api.schematic.SubstituteSchematic;\n import baritone.api.schematic.ISchematic;\n import baritone.api.schematic.IStaticSchematic;\n import baritone.api.schematic.format.ISchematicFormat;\n@@ -84,6 +85,9 @@ public void build(String name, ISchematic schematic, Vec3i origin) {\n         this.name = name;\n         this.schematic = schematic;\n         this.realSchematic = null;\n+        if (!Baritone.settings().buildSubstitutes.value.isEmpty()) {\n+            this.schematic = new SubstituteSchematic(this.schematic, Baritone.settings().buildSubstitutes.value);\n+        }\n         int x = origin.getX();\n         int y = origin.getY();\n         int z = origin.getZ();\n@@ -572,7 +576,8 @@ private void fullRecalc(BuilderCalculationContext bcc) {\n                         continue;\n                     }\n                     // this is not in render distance\n-                    if (!observedCompleted.contains(BetterBlockPos.longHash(blockX, blockY, blockZ))) {\n+                    if (!observedCompleted.contains(BetterBlockPos.longHash(blockX, blockY, blockZ))\n+                          && !Baritone.settings().buildSkipBlocks.value.contains(schematic.desiredState(x, y, z, current, this.approxPlaceable).getBlock())) {\n                         // and we've never seen this position be correct\n                         // therefore mark as incorrect\n                         incorrectPositions.add(new BetterBlockPos(blockX, blockY, blockZ));\n@@ -794,6 +799,12 @@ private boolean valid(IBlockState current, IBlockState desired, boolean itemVeri\n         if (!(current.getBlock() instanceof BlockAir) && Baritone.settings().buildIgnoreExisting.value && !itemVerify) {\n             return true;\n         }\n+        if (Baritone.settings().buildSkipBlocks.value.contains(desired.getBlock()) && !itemVerify) {\n+            return true;\n+        }\n+        if (Baritone.settings().buildValidSubstitutes.value.getOrDefault(desired.getBlock(), Collections.emptyList()).contains(current.getBlock()) && !itemVerify) {\n+            return true;\n+        }\n         return current.equals(desired);\n     }\n \n@@ -831,7 +842,7 @@ public double costOfPlacingAt(int x, int y, int z, IBlockState current) {\n                 return COST_INF;\n             }\n             IBlockState sch = getSchematic(x, y, z, current);\n-            if (sch != null) {\n+            if (sch != null && !Baritone.settings().buildSkipBlocks.value.contains(sch.getBlock())) {\n                 // TODO this can return true even when allowPlace is off.... is that an issue?\n                 if (sch.getBlock() == Blocks.AIR) {\n                     // we want this to be air, but they're asking if they can place here\n@@ -865,7 +876,7 @@ public double breakCostMultiplierAt(int x, int y, int z, IBlockState current) {\n                 return COST_INF;\n             }\n             IBlockState sch = getSchematic(x, y, z, current);\n-            if (sch != null) {\n+            if (sch != null && !Baritone.settings().buildSkipBlocks.value.contains(sch.getBlock())) {\n                 if (sch.getBlock() == Blocks.AIR) {\n                     // it should be air\n                     // regardless of current contents, we can break it"
  }
]
